<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹空间</title>
  <subtitle>时空在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-08-13T09:40:24.043Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法 —— 线性表</title>
    <link href="https://hengxing0080.github.io/2017/08/01/it/DataStructure/LinearList/"/>
    <id>https://hengxing0080.github.io/2017/08/01/it/DataStructure/LinearList/</id>
    <published>2017-08-01T01:50:23.000Z</published>
    <updated>2017-08-13T09:40:24.043Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_queue1.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>线性表：零个或多个具有相同类型的数据元素的有限序列</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>线性表是由n（ｎ＞＝０）个数据元素（结点）组成的有限序列</p>
<p>是像线一样的性质的表。<br>就是排好队伍<br>最常用最简单的一种结构。</p>
<p>一年里的星座列表，也是线性表<br>星座通常都是白羊座打头，双鱼座收尾，当中的星座都有前驱和后继，而且一共也只有12个，所以它完全符合线性表的定义。</p>
<h1 id="线性表特点"><a href="#线性表特点" class="headerlink" title="线性表特点"></a>线性表特点</h1><p>１.有且仅有一个开始结点<br>２.有且仅有一个终结结点<br>３.内部结点都有且仅有一个直接前驱结点和一个直接后继结点</p>
<h1 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ADT List</div><div class="line">Data</div><div class="line">    线性表的数据对象集合为｛a1,a2,...,an｝,每个元素的类型均为DataType.</div><div class="line">    其中，</div><div class="line">    除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</div><div class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</div><div class="line">    数据元素直接是一对一的关系。</div><div class="line">Operation</div><div class="line">    InitList(*L);//初始化操作，建立一个空的线性表</div><div class="line">    ListEmpty(L);//若线性表为空，返回true,否则返回false</div><div class="line">    ClearList(*L);//清空线性表</div><div class="line">    GetElem(L,i,*e);//查找线性表中的第i个位置的元素值，并赋值给e</div><div class="line">    LocateElem(L,e);//查找线性表L中与给定值e相等的元素，如果查找成功，则返回第一个相同的元素在L</div><div class="line">                   //中的下标；否则，返回0表示失败</div><div class="line">    ListInsert(*L,i,e);//在线性表L的第i个位置插入元素e</div><div class="line">    ListDelete(*L,i,*e);//删除线性表L中第i个位置元素，并用e返回其值</div><div class="line">    ListLength();//返回线性表L的长度</div><div class="line">end ADT</div></pre></td></tr></table></figure>
<h1 id="线性表的2种表现形式"><a href="#线性表的2种表现形式" class="headerlink" title="线性表的2种表现形式"></a>线性表的2种表现形式</h1><p>1.顺序表（顺序存储结构）<br>2.链表（链式存储结构）<br>　2.1.单链表<br>　2.2.静态链表<br>　2.3.循环链表<br>　3.4.双向链表<br>　3.5.跳跃链表</p>
<hr>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><hr>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>顺序表就是线性表的顺序存储方式。<br>也称为向量存储，可以看做是一维数组存储。<br>计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.使用连续的内存单元存放线性表的数据元素。<br>2.数据元素在内存中的物理存储次序与他们在线性表中逻辑次序相同。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>存储密度大<br>无须为表示表中元素之间的逻辑关系而增加额外的存储空间<br>可以快速地存取表中任一位置的元素</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>插入，删除等其他运算不方便。（需要移动大量元素，显然很耗费时间）<br>当线性表长度变化较大时，难以确定存储空间的容量。<br>造成存储空间的碎片</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;          <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;        <span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">	ElemType data[MAXSIZE];  <span class="comment">/* 数组，存储数据元素 */</span></div><div class="line">	<span class="keyword">int</span> length;              <span class="comment">/* 线性表当前长度 */</span></div><div class="line">&#125;SqList;</div></pre></td></tr></table></figure>
<h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>对于线性表的顺序存储结构来说，如果我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回，其实是非常简单的。<br>就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line">Typedef <span class="keyword">int</span> Status;</div><div class="line"><span class="comment">/*Status是函数的类型，其值是函数结果状态代码，如OK等*/</span></div><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></div><div class="line"><span class="comment">/*操作结果：用e返回L中第i个数据元素的值 */</span></div><div class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i, Elemtype *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span> || i&lt; <span class="number">1</span> || i &gt; L.length)</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    *e = L.data[i<span class="number">-1</span>];</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入算法的思路：<br>●如果插入位置不合理，抛出异常；<br>●如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>●从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置;<br>●将要插入元素填入位置i处；<br>●表长加1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L), */</span></div><div class="line"><span class="comment">/*操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1*/</span></div><div class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L, <span class="keyword">int</span> i ,ElemType e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">if</span>(L -&gt; length == MAXSIZE)   <span class="comment">/*顺序线性表已经满*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt;L-&gt; length+<span class="number">1</span>)   <span class="comment">/*当i不在范围内时*/</span></div><div class="line">    reuturn ERROR;</div><div class="line">    <span class="keyword">if</span>(i&lt;= L -&gt;length)  <span class="comment">/*若插入数据位置不在表尾 */</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">for</span>(k=L-&gt;length <span class="number">-1</span> ;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/*将要插入位置后数据元素向后移动一位*/</span></div><div class="line">    L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</div><div class="line">    &#125;</div><div class="line">    L-&gt;data[i<span class="number">-1</span>]=e;</div><div class="line">    L-&gt;length++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：<br>●如果删除位置不合理，抛出异常;<br>●取出删除元素;<br>●从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置;<br>●表长减1.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></div><div class="line"><span class="comment">/*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/</span></div><div class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">if</span>(L -&gt;length == <span class="number">0</span>)   <span class="comment">/*线性表为空*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)   <span class="comment">/*删除位置不正确*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    *e = L-&gt;data[i<span class="number">-1</span>];</div><div class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length)   <span class="comment">/*如果删除不是最后位置*/</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)  <span class="comment">/*将删除位置后继元素前移*/</span></div><div class="line">    L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k]l;</div><div class="line">    &#125;</div><div class="line">    L-&gt;length--；</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入和删除的时间复杂度"><a href="#插入和删除的时间复杂度" class="headerlink" title="插入和删除的时间复杂度"></a>插入和删除的时间复杂度</h3><p>最好情况：O（1）<br>最坏情况：O（n）<br>平静情况：O（n）</p>
<p>在存，读数据时，不管是1哪个位置，时间复杂度都是O（1）<br>而插入或删除时，时间复杂度都是O（n）<br>说明，线性表的顺序存储结构，比较适合元素个数不太变化，而更多是存储数据的应用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_queue1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：计数排序</title>
    <link href="https://hengxing0080.github.io/2017/07/31/it/Algorithm/SortCounting/"/>
    <id>https://hengxing0080.github.io/2017/07/31/it/Algorithm/SortCounting/</id>
    <published>2017-07-31T14:02:57.000Z</published>
    <updated>2017-08-13T08:30:46.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 计数排序<br>外文名 Counting sort<br>提出人  Harold H. Seward<br>提出时间 1954<br>定义 非基于比较的排序算法<br>类别 分配式排序<br><a id="more"></a></p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>是一种稳定的线性时间排序算法。</p>
<p>运行时间θ(n)，是稳定不是原地排序，需要占用很大的内存空间，当然这是一种牺牲空间换取时间的做法。</p>
<p>但是计数排序有个缺点，要排序的数必须是一个小范围内的数，在实践中，当k=O(n)时，常采用计数排序。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>数据结构：数组<br>最坏时间复杂度：O ( n + k )<br>最优时间复杂度：O ( n + k )<br>平均时间复杂度：O ( n + k )<br>空间复杂度：O ( n + k )<br>是否稳定：稳定</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260299.html" target="_blank" rel="external">经典排序算法 - 计数排序Counting sort</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h1&gt;&lt;p&gt;中文名 计数排序&lt;br&gt;外文名 Counting sort&lt;br&gt;提出人  Harold H. Seward&lt;br&gt;提出时间 1954&lt;br&gt;定义 非基于比较的排序算法&lt;br&gt;类别 分配式排序&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：桶排序</title>
    <link href="https://hengxing0080.github.io/2017/07/30/it/Algorithm/SortBucket/"/>
    <id>https://hengxing0080.github.io/2017/07/30/it/Algorithm/SortBucket/</id>
    <published>2017-07-30T11:01:33.000Z</published>
    <updated>2017-08-13T08:09:44.186Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbucket.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 桶排序<br>又名     箱排序<br>英文名 Bucket sort<br>类别   分配式排序 </p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>有时也称为盒子排序（Bin Sort），来源于邮局使用的盒子信件分发方法</p>
<p>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p>
<p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。<br>桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。<br>但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>桶排序以下列程序进行：<br>1.设置一个定量的数组当作空桶子。<br>2.寻访序列，并且把项目一个一个放到对应的桶子去。<br>3.对每个不是空的桶子进行排序。<br>4.从不是空的桶子里把项目再放回原来的序列中。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function bucket-sort(array, n) is</div><div class="line">    buckets ← new array of n empty lists</div><div class="line">    for i = 0 to (length(array)-1) do</div><div class="line">        insert array[i] into buckets[msbits(array[i], k)]</div><div class="line">    for i = 0 to n - 1 do</div><div class="line">        next-sort(buckets[i])</div><div class="line">    return the concatenation of buckets[0], ..., buckets[n-1]</div></pre></td></tr></table></figure></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>数据结构：数组 </p>
<p>最坏时间复杂度：O ( n 2 )<br>平均时间复杂度：O ( n + k )<br>空间复杂度：O ( n ∗ k ) </p>
<p>是否稳定：桶排序是稳定的</p>
<p>优缺点：<br>桶排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法，如果待排序的数有10亿，总不能准备10亿个桶吧？</p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * <span class="doctag">@param</span> a 待排序数组元素</div><div class="line">  * <span class="doctag">@param</span> step 步长(桶的宽度/区间),具体长度可根据情况设定</div><div class="line">  * <span class="doctag">@return</span> 桶的位置/索引</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> step)</span></span>&#123;</div><div class="line">     <span class="keyword">return</span> a/step;</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">int</span> max=arr[<span class="number">0</span>],min=arr[<span class="number">0</span>];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> a:arr) &#123;</div><div class="line">         <span class="keyword">if</span> (max&lt;a)</div><div class="line">             max=a;</div><div class="line">         <span class="keyword">if</span> (min&gt;a)</div><div class="line">             min=a;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//该值也可根据实际情况选择</span></div><div class="line">     <span class="keyword">int</span> bucketNum=max/<span class="number">10</span>-min/<span class="number">10</span>+<span class="number">1</span>;</div><div class="line">     List buckList=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">     <span class="comment">//create bucket</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bucketNum;i++)&#123;</div><div class="line">         buckList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//push into the bucket</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">         <span class="keyword">int</span> index=indexFor(arr[i],<span class="number">10</span>);</div><div class="line">         ((ArrayList&lt;Integer&gt;)buckList.get(index)).add(arr[i]);</div><div class="line">     &#125;</div><div class="line">     ArrayList&lt;Integer&gt; bucket=<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)&#123;</div><div class="line">         bucket=(ArrayList&lt;Integer&gt;)buckList.get(i);</div><div class="line">         insertSort(bucket);</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k : bucket) &#123;</div><div class="line">             arr[index++]=k;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> <span class="comment">//把桶内元素插入排序</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(List&lt;Integer&gt; bucket)</span></span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bucket.size();i++)&#123;</div><div class="line">         <span class="keyword">int</span> temp=bucket.get(i);</div><div class="line">         <span class="keyword">int</span> j=i-<span class="number">1</span>;</div><div class="line">         <span class="keyword">for</span> (; j&gt;=<span class="number">0</span> &amp;&amp; bucket.get(j)&gt;temp;j--)&#123;</div><div class="line">             bucket.set(j+<span class="number">1</span>,bucket.get(j));</div><div class="line">         &#125;</div><div class="line">         bucket.set(j+<span class="number">1</span>,temp);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbucket.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：基数排序</title>
    <link href="https://hengxing0080.github.io/2017/07/29/it/Algorithm/SortRadix/"/>
    <id>https://hengxing0080.github.io/2017/07/29/it/Algorithm/SortRadix/</id>
    <published>2017-07-29T03:52:09.000Z</published>
    <updated>2017-08-13T06:50:02.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortradix.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 基数排序<br>外文名 Radix sort<br>类别   分配式排序<br>别称   “桶子法”<br>方法   最高位优先法和最低位优先<br>发明者 赫尔曼·何乐礼 </p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，<br>顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，</p>
<p>是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。<br>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>然后，从最低位开始，依次进行一次排序。<br>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><p>第一步<br>　以LSD为例，假设原来有一串数值如下所示：<br>　73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>　首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br>　0<br>　1 81<br>　2 22<br>　3 73 93 43<br>　4 14<br>　5 55 65<br>　6<br>　7<br>　8 28<br>　9 39<br>第二步<br>　接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>　81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>　接着再进行一次分配，这次是根据十位数来分配：<br>　0<br>　1 14<br>　2 22 28<br>　3 39<br>　4 43<br>　5 55<br>　6 65<br>　7 73<br>　8 81<br>　9 93<br>第三步<br>　接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>　14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>　这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p>
<p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<p>数据结构       数组<br>最坏时间复杂度  O ( k N )<br>空间复杂度      O ( k + N )</p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> d)</span> <span class="comment">//d表示最大的数有多少位</span></span></div><div class="line">    &#123;</div><div class="line">        intk = <span class="number">0</span>;</div><div class="line">        intn = <span class="number">1</span>;</div><div class="line">        intm = <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位</span></div><div class="line">        <span class="keyword">int</span>[][]temp = newint[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9</span></div><div class="line">        <span class="keyword">int</span>[]order = newint[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数</span></div><div class="line">        <span class="keyword">while</span>(m &lt;= d)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; number.length; i++)</div><div class="line">            &#123;</div><div class="line">                intlsd = ((number[i] / n) % <span class="number">10</span>);</div><div class="line">                temp[lsd][order[lsd]] = number[i];</div><div class="line">                order[lsd]++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(order[i] != <span class="number">0</span>)</div><div class="line">                    <span class="keyword">for</span>(intj = <span class="number">0</span>; j &lt; order[i]; j++)</div><div class="line">                    &#123;</div><div class="line">                        number[k] = temp[i][j];</div><div class="line">                        k++;</div><div class="line">                    &#125;</div><div class="line">                order[i] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            n *= <span class="number">10</span>;</div><div class="line">            k = <span class="number">0</span>;</div><div class="line">            m++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span>[]data = &#123;<span class="number">73</span>, <span class="number">22</span>, <span class="number">93</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">14</span>, <span class="number">28</span>, <span class="number">65</span>, <span class="number">39</span>, <span class="number">81</span>, <span class="number">33</span>, <span class="number">100</span>&#125;;</div><div class="line">        RadixSort.sort(data, <span class="number">3</span>);</div><div class="line">        <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; data.length; i++)</div><div class="line">        &#123;</div><div class="line">            System.out.print(data[i] + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortradix.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序算法总结</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortAlgorithm/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortAlgorithm/</id>
    <published>2017-07-28T15:01:02.000Z</published>
    <updated>2017-08-13T05:49:49.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sort0.png" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="排序定义和理解"><a href="#排序定义和理解" class="headerlink" title="排序定义和理解"></a>排序定义和理解</h1><hr>
<p>常用的场景工作中，一旦建立了一个重要的数据库后，就可能根据某些需求对数据进行不同的排序，比如对姓名按字母排序，对学习按年级排序等等。<br>由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题，而且人们的确已经研究出一些非常成熟的方法。<br>如冒泡排序和选择排序。</p>
<p>排序是一种操作，将无序的序列调整为有序的序列。</p>
<p>注意我们在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p>
<p>如何排序：<br>计算机程序却不能像人这样通览所有数据。<br>它只能根据计算机的‘比较’操作原理，在同一时间内对两个队员进行比较。<br>算法的这种原理将是一个反复出现的问题。<br>在人类看来很简单的事情，计算机的算法却不能看到全景，因此只能一步一步地解决具体问题和遵循一些简单的规则。</p>
<p>按照算法的复杂度分为两大类：<br>冒泡排序，简单选择排序和直接插入排序属于简单算法。<br>希尔排序，堆排序，归并排序，快速排序属于改进算法。</p>
<p>内排序和外排序：<br>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p>内排序：<br>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。<br>内排序分为：插入排序，交换排序，选择排序和归并排序。<br>内排序算法的性能主要是受3个方面影响：<br>1.时间性能<br>2.辅助空间<br>3.算法的复杂性</p>
<p>外排序：<br>外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p>
<hr>
<h1 id="7种算法总结"><a href="#7种算法总结" class="headerlink" title="7种算法总结"></a>7种算法总结</h1><hr>
<p>根据将排序记录是否全部被放置到内存中，将排序分为内排序和外排序两种，外排序需要在内外存之间多次交换数据才能进行。<br>我们讲内排序分为：插入排序，交换排序，选择排序，归并排序4类<br>算法类文章介绍的其中7种排序法，就分别是各种分类的代表算法。<br><img src="/images/it_algorithm_sort1.png" alt="UML图"></p>
<p>7种算法的各种指标进行对比<br><img src="/images/it_algorithm_sort2.png" alt="UML图"></p>
<p>从算法的简单性来看，我们将7种算法分为两类：<br>1.简单算法：冒泡，简单选择，直接插入<br>2.改进算法：希尔，堆，归并，快速</p>
<p>从平均情况来看<br>显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。</p>
<p>从最好情况看<br>反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑后4种复杂的改进算法。<br>　　<br>从最坏情况看<br>堆排序与归并排序又强过快速排序以及其他简单排序。<br>　　<br>从这三组时间复杂度的数据对比中，我们可以得出这样一个认识。<br>堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。<br>而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。<br>但是他们如果都来比赛计算个位数的加减法，它们反而算不过成绩极普通的冒泡和直接插入。</p>
<p>从空间复杂度来说<br>归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少时，选择归并排序和快速排序就不是一个较好的决策了。</p>
<p>从稳定性来看<br>归并排序独占鳌头，我们前面也说过，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p>
<p>从待排序记录的个数上来说<br>待排序的个数n越小，采用简单排序方法越合适。反之，n越大，采用改进排序方法越合适。这也就是我们为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p>
<p>从7种算法的各种指标（上图）的数据中，似乎简单选择排序在3种简单排序中性能最差<br>其实也不完全是，比如，如果记录的关键字本身信息量比较大（例如，关键字都是数十位的数字），此时表明其占用存储空间很大，这样移动记录所花费的时间也就越多，我们给出3种简单排序算法的移动次数比较，如图所示。<br><img src="/images/it_algorithm_sort3.png" alt="UML图"><br>你会发现，此时简单选择排序就变得非常有优势，原因也就在于，它是通过大量比较后选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p>
<p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合我们也应该考虑使用不同的算法来应对它。</p>
<hr>
<h1 id="推荐排序方式"><a href="#推荐排序方式" class="headerlink" title="推荐排序方式"></a>推荐排序方式</h1><hr>
<p>开发时如果用数据量就用快速排序(递归排序)，数据量小用简单插入排序。</p>
<p>最重要还是要根据上面总结的场景来使用正确的排序方式。</p>
<hr>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><hr>
<p><a href="http://blog.csdn.net/wangwei890702/article/details/8197597" target="_blank" rel="external">7种常用排序算法总结</a><br><a href="http://blog.csdn.net/sgn132/article/details/47279511" target="_blank" rel="external">GIF演示排序算法</a><br><a href="http://www.cnblogs.com/ytb-wpq/p/6479240.html" target="_blank" rel="external">常用算法js版(冒泡/选择/插入/希尔/归并/快速/堆/计数/桶/基数)</a><br><a href="http://blog.csdn.net/litong09282039/article/details/46332127" target="_blank" rel="external">超级详细解读基本排序算法（不看后悔，带排序演示动画）</a><br><a href="http://blog.csdn.net/chivalrousman/article/details/51585639" target="_blank" rel="external">详解五大排序算法</a><br><a href="http://blog.csdn.net/cjf_iceking/article/details/7953637" target="_blank" rel="external">九种常用排序的性能分析总结</a><br><a href="http://blog.jobbole.com/11745/" target="_blank" rel="external">视觉直观感受7种常用的排序算法</a><br><a href="http://blog.sina.com.cn/s/blog_8898a00d0102whmd.html" target="_blank" rel="external">中国MOOC大学-程序设计基础-6.问题解决和算法基础3</a><br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="external">6分钟演示15种排序算法</a><br><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">可视化排序</a><br><a href="http://www.cnbeta.com/articles/tech/202221.htm" target="_blank" rel="external">[视频]程序员的艺术：排序算法舞蹈</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sort0.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：快速排序</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortQuick/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortQuick/</id>
    <published>2017-07-28T13:35:12.000Z</published>
    <updated>2017-07-29T15:32:33.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortquick1.gif" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>快速排序（Quick Sort）<br>快速排序采用“分而治之、各个击破”的观念，使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>作者为Tony Hoare，图领奖获得者，上世纪最伟大的计算机科学家之一。 在1962年提出。</p>
<p>很牛，20世纪十大算法之一。排序算法王者，要好好研究并掌握它。</p>
<p>快速排序其实就是前面认为的最慢的冒泡排序的升级，它们都属于交换排序类。<br>即它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从·后面直接移动到前面，从而减少了总的比较次数和移动交换次数。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>基本思想：<br>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对着两份记录进行排序，整个排序过程可以递归进行，以达到整个序列有序的目的。</p>
<p>步骤为：<br>1.从数列中挑出一个元素，称为”基准”（pivot），<br>2.重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>3.递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p>在简单的伪代码中，此算法可以被表示为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function quicksort(q)&#123;</div><div class="line">    var list less, pivotList, greater</div><div class="line">    if length(q) ≤ 1 &#123;</div><div class="line">        return q</div><div class="line">    &#125; else &#123;</div><div class="line">        select a pivot value pivot from q</div><div class="line">        for each x in q except the pivot element</div><div class="line">            if x &lt; pivot then add x to less</div><div class="line">            if x ≥ pivot then add x to greater</div><div class="line">        add pivot to pivotList</div><div class="line">        return concatenate(quicksort(less), pivotList, quicksort(greater))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="未优化代码"><a href="#未优化代码" class="headerlink" title="未优化代码"></a>未优化代码</h2><p>其中Partition函数是最关键的，它要做的，就是先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，将这样的关键字称为枢轴（pivot）<br>通过下面代码的模拟，可以看到Partition函数，其实就是将选取的pivotkey不断交换，将比它小的换到它的左边，比它大的换到它的右边，它也在交换中不断更改自己的位置，知道完全满足这个要求为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></div><div class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivotkey;</div><div class="line"></div><div class="line">    pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></div><div class="line">    <span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">            high--;</div><div class="line">        swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">            low++;</div><div class="line">        swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivot;</div><div class="line">    <span class="keyword">if</span>(low&lt;high)</div><div class="line">    &#123;</div><div class="line">            pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></div><div class="line">            QSort(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></div><div class="line">            QSort(L,pivot+<span class="number">1</span>,high);		<span class="comment">/*  对高子表递归排序 */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    QSort(L,<span class="number">1</span>,L-&gt;length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="优化快速排序代码"><a href="#优化快速排序代码" class="headerlink" title="优化快速排序代码"></a>优化快速排序代码</h2><p>上面的快速排序有不少可以改进的地方，来看一些优化方案。</p>
<p>1.优化选取枢轴<br>2.优化不必要的交换<br>3.优化小数组时的排序方案<br>4.优化递归操作</p>
<p>（具体优化细节描述请查看大数数据结构——422页）</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 改进后快速排序******************************** */</span></div><div class="line"><span class="comment">/* 快速排序优化算法 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivotkey;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </div><div class="line">    <span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])			</div><div class="line">        swap(L,low,high);	<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></div><div class="line">    <span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</div><div class="line">        swap(L,high,m);	<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></div><div class="line">    <span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</div><div class="line">        swap(L,m,low);		<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></div><div class="line">    </div><div class="line">    pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></div><div class="line">    L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></div><div class="line">    <span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">            high--;</div><div class="line">        L-&gt;r[low]=L-&gt;r[high];</div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">            low++;</div><div class="line">        L-&gt;r[high]=L-&gt;r[low];</div><div class="line">    &#125;</div><div class="line">    L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</div><div class="line">    <span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivot;</div><div class="line">    <span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)</div><div class="line">        &#123;</div><div class="line">            pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></div><div class="line">            QSort1(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></div><div class="line">            <span class="comment">/* QSort(L,pivot+1,high);		/*  对高子表递归排序 */</span></div><div class="line">            low=pivot+<span class="number">1</span>;	<span class="comment">/* 尾递归 */</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        InsertSort(L);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    QSort1(L,<span class="number">1</span>,L-&gt;length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏时间复杂度  O( n 2 )<br>最优时间复杂度  O( n log n )<br>平均时间复杂度  O( n log n ) </p>
<p>快速排序的时间性能取决于排序递归的深度，可以用递归树来描述递归算法的执行情况。<br>如下图所示，它是{50,10,90,30,70,40,80,60,20}在快速排序过程中递归过程。<br>由于第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。<br><img src="/images/it_algorithm_sortquick2.png" alt="UML图"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>主要是递归造成的栈空间的使用<br>最好情况：递归树的深度为log2n，其空间复杂度为O( n log n )<br>最坏情景：需要进行n-1递归调用，起空间复杂度为O（n）<br>平均情况：O ( n log n ) </p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>不稳定<br>由于关键字的比较和交换是跳跃进行的，因此它是一种不稳定的排序的排序方法。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>事实上目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越，它也存在排序不稳定，需要大量辅助空间，对少量数据排序无优势等不足。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortquick1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络 —— 协议：HTTP</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/NetworkProtocol/HTTP/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/NetworkProtocol/HTTP/</id>
    <published>2017-07-28T09:11:55.000Z</published>
    <updated>2017-07-28T10:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_http.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名 　超文本传输协议<br>外文名 　HTTP（HyperText Transfer Protocol）</p>
<hr>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><hr>
<p>定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器.<br>从层次的角度看,HTTP是面向(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件，(包括文本,声音,图像等各种多媒体文件)的重要基础。         </p>
<p>通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）来标识。<br>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。<br>就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。<br>当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。<br>浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<p>简单的理解就是：<br>基于TCP，只不过封装了一些东西。<br>Http协议用于加载以 http:// 开头的普通远程网站的HTML网页。不加密。</p>
<hr>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><hr>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<p>HTTP三点注意事项：<br>1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>2.HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>3.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
<p>HTTP协议，你只需要稍微了解一些就足够了，它的工作原理特别的简单，就是客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理就可以了。<br>是不是非常简单？<br>一个浏览器的基本工作原理也就是如此了。<br>比如Android里使用到的WebView控件，其实也就是我们向百度的服务器发起了一条HTTP请求，接着服务器分析出我们想要访问的是百度的首页，于是会把该网页的HTML代码进行返回，然后WebView再调用手机浏览器的内核对返回的HTML代码进行解析，最终将页面展示出来。</p>
<p>http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。<br>http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p>
<hr>
<h1 id="HTTP版本历史"><a href="#HTTP版本历史" class="headerlink" title="HTTP版本历史"></a>HTTP版本历史</h1><hr>
<blockquote>
<p>超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的.</p>
</blockquote>
<ul>
<li><p>HTTP/0.9　<br>已过时。<br>只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。<br>由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。</p>
</li>
<li><p>HTTP/1.0　<br>这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。</p>
</li>
<li><p>HTTP/1.1<br>当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。<br>还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。<br>版本1.0和1.1 的区别:<br>　1 缓存处理<br>　2 带宽优化及网络连接的使用<br>　　在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。<br>　　HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。<br>　3 错误通知的管理<br>　4 消息在网络中的发送<br>　5 互联网地址的维护<br>　6 安全性及完整性</p>
</li>
</ul>
<p>想要提交数据到数据器，必须和它要接口（url, method请求方式, param参数，header消息头）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_http.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：归并排序</title>
    <link href="https://hengxing0080.github.io/2017/07/27/it/Algorithm/SortMerging/"/>
    <id>https://hengxing0080.github.io/2017/07/27/it/Algorithm/SortMerging/</id>
    <published>2017-07-27T12:47:32.000Z</published>
    <updated>2017-07-29T15:20:29.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortmerging1.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortmerging2.jpg" alt="UML图"></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>归并排序（Merging Sort）是建立在归并操作上的一种有效的排序算法<br>发明者为约翰·冯·诺伊曼<br>该算法是采用分治法（Divide and Conquer）实现快速排序<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>归并的就是合并，并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。<br>就是利用归并的思想实现的排序方法。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>回想上一个讲的堆排序充分利用了完全二叉树的深度是[log2n]+1的特性，所以效率比较高。<br>不过堆结构的设计本身是比较复杂的，那么有没有更直接简单的办法利用完全二叉树来排序呢？ 有，归并排序。</p>
<p>看图所示，将无序的数组序列{16,7,13,10,9,15,3,2,5,8,12,1,11,4,6,14}，通过两两合并排序后在合并，最终获得了一个有序的数组。<br>注意它的形状，它像极了一颗导致的完全二叉树，通常涉及到完全二叉树结构的排序算法，效率一般都不低的<br><img src="/images/it_algorithm_sortmerging3.png" alt="UML图"></p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> j,k,l;</div><div class="line">     <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)	<span class="comment">/* 将SR中记录由小到大地并入TR */</span></div><div class="line">     &#123;</div><div class="line">         <span class="keyword">if</span> (SR[i]&lt;SR[j])</div><div class="line">             TR[k]=SR[i++];</div><div class="line">         <span class="keyword">else</span></div><div class="line">             TR[k]=SR[j++];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(i&lt;=m)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</div><div class="line">             TR[k+l]=SR[i+l];		<span class="comment">/* 将剩余的SR[i..m]复制到TR */</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(j&lt;=n)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=n-j;l++)</div><div class="line">             TR[k+l]=SR[j+l];		<span class="comment">/* 将剩余的SR[j..n]复制到TR */</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/* 将SR[s..t]归并排序为TR1[s..t] */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> m;</div><div class="line">     <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</div><div class="line">     <span class="keyword">if</span>(s==t)</div><div class="line">         TR1[s]=SR[s];</div><div class="line">     <span class="keyword">else</span></div><div class="line">     &#123;</div><div class="line">         m=(s+t)/<span class="number">2</span>;			<span class="comment">/* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */</span></div><div class="line">         MSort(SR,TR2,s,m);		<span class="comment">/* 递归地将SR[s..m]归并为有序的TR2[s..m] */</span></div><div class="line">         MSort(SR,TR2,m+<span class="number">1</span>,t);	<span class="comment">/* 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] */</span></div><div class="line">         Merge(TR2,TR1,s,m,t);	<span class="comment">/* 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] */</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/* 对顺序表L作归并排序 */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></div><div class="line"> &#123; </div><div class="line">     MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h2><p>因为递归的方式尽管在代码中比较清晰，容易理解，但这会造成时间和空间上的性能损耗。<br>我们排序追求的就是笑了，有没有可能将递归转化成迭代呢？ 结论当然是有的，经过改动之后，性能上进一步提高了。看看下面代码！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> j;</div><div class="line">	<span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</div><div class="line">	&#123;<span class="comment">/* 两两归并 */</span></div><div class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</div><div class="line">		i=i+<span class="number">2</span>*s;        </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></div><div class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</div><div class="line">	<span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></div><div class="line">		<span class="keyword">for</span>(j =i;j &lt;= n;j++)</div><div class="line">			TR[j] = SR[j];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代的做法更加直接了当，从最小的序列开始归并直至完成。不需要像归并的递归算法一样，需要先拆分递归，在归并退出递归。<br>迭代的做法避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O（n），并且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑用非递归方法。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好，最坏，平均的时间性能为O(nlogn)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O（n+logn）<br>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为log2n的栈空间，所以空间复杂度为O（n+logn）</p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>稳定<br>通过示例代码中的Merge函数中有if(SR[i] &lt; SR[j])语句，这就说明它需要两两比较，不存在跳跃，所以是一种稳定的稳定的算法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
<p>推荐使用迭代方式实现归并排序</p>
<p>该算法速度仅次于快速排序</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortmerging1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：堆排序</title>
    <link href="https://hengxing0080.github.io/2017/07/26/it/Algorithm/SortHeap/"/>
    <id>https://hengxing0080.github.io/2017/07/26/it/Algorithm/SortHeap/</id>
    <published>2017-07-26T11:52:08.000Z</published>
    <updated>2017-07-24T12:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortheap1.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortheap2.gif" alt="UML图"></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法。<br>它是选择排序的一种（是简单选择排序的一种改进）。</p>
<p>它利用数组的特点快速定位指定索引的元素。<br>堆分为大根堆和小根堆，是完全二叉树。<br>大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。<br>在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h1 id="算法起源"><a href="#算法起源" class="headerlink" title="算法起源"></a>算法起源</h1><p>堆排序算法是斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明的。<br>同时，他们发明了“堆”这样的数据结构。（类似叠罗汉运动）</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p>例如图所示，<br>图1是一个大顶堆，90为最大值，将90与20（末尾元素）互换，<br>如图2所示，此时90就成了整个堆序列的最后一个元素，将20经过调整，使得除90以外的节点继续满足大顶堆定义（所有结果都大于等于其子孩子），见图3，然后在考虑将30与80互换……<br><img src="/images/it_algorithm_sortheap3.png" alt="UML图"><br><img src="/images/it_algorithm_sortheap4.png" alt="UML图"></p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><p>上面明白堆排序的基本思想了，不过要实现它还需要解决两个问题：<br>1.如何由一个无需序列构建成一个堆？<br>2.如果在输出堆顶元素后，调整剩余元素成为一个新的堆？<br>先看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*  对顺序表L进行堆排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;  <span class="comment">/* 把L中的r构建成一个大根堆 */</span></div><div class="line">		 HeapAdjust(L,i,L-&gt;length);</div><div class="line">&#125;</div><div class="line">	<span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</div><div class="line">	&#123; </div><div class="line">		 swap(L,<span class="number">1</span>,i);  <span class="comment">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></div><div class="line">		 HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">/* 将L-&gt;r[1..i-1]重新调整为大根堆 */</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中能看出，整个排序过程分为两个for循环。<br>第一个循环要完成是将显著的待排序序列构建成一个大顶堆。<br>第二个循环要完成的就是逐步将每个最大值的根节点与末尾元素交换，并且要调整其成为大顶堆。</p>
<p>然后在看看关键的HeapAdjust（堆调整）函数是如何实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义， */</span></div><div class="line"><span class="comment">/* 本函数调整L-&gt;r[s]的关键字,使L-&gt;r[s..m]成为一个大顶堆 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span> temp,j;</div><div class="line">	temp=L-&gt;r[s];</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>) <span class="comment">/* 沿关键字较大的孩子结点向下筛选 */</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</div><div class="line">			++j; <span class="comment">/* j为关键字中较大的记录的下标 */</span></div><div class="line">		<span class="keyword">if</span>(temp&gt;=L-&gt;r[j])</div><div class="line">			<span class="keyword">break</span>; <span class="comment">/* rc应插入在位置s上 */</span></div><div class="line">		L-&gt;r[s]=L-&gt;r[j];</div><div class="line">		s=j;</div><div class="line">	&#125;</div><div class="line">	L-&gt;r[s]=temp; <span class="comment">/* 插入 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>过程有点复杂，多试着模拟计算机执行的方式走几遍，应该就可以理解其原理。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>最坏时间复杂度    O(n\log n)<br>最优时间复杂度    O(n\log n)[1]<br>平均时间复杂度    θ (n\log n)</p>
<p>分析下堆排序的效率<br>它的运行时间主要是消耗在初始构建堆和重建堆时的反复筛选上。<br>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构建，将它和其孩子进行比较和若有必要的交换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为0（n）</p>
<h2 id="空间复杂度-："><a href="#空间复杂度-：" class="headerlink" title="空间复杂度    ："></a>空间复杂度    ：</h2><p>O(n) total, O(1) auxiliary</p>
<h2 id="是否稳定："><a href="#是否稳定：" class="headerlink" title="是否稳定："></a>是否稳定：</h2><p>不稳定<br>它只有一个用来交换的暂存单元，也非常的不错。<br>不过由于记录的比较与交换是跳跃式进行，所以不稳定。</p>
<h2 id="其他注意："><a href="#其他注意：" class="headerlink" title="其他注意："></a>其他注意：</h2><p>因为初建堆所需的比较次数较多，因此它并不适合待排序序列个数较少的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortheap1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：臭皮匠排序（最漂亮）</title>
    <link href="https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortStooge/"/>
    <id>https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortStooge/</id>
    <published>2017-07-23T12:47:32.000Z</published>
    <updated>2017-07-30T06:17:35.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortstooge1.gif" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>Stooge排序又名臭皮匠排序<br>该算法得名于三个臭皮匠，每个臭皮匠都打其他两个。<br>在《算法导论》第二版第7章（快速排序）的思考题中被提到，是由Howard、Fine等教授提出的所谓“漂亮的”排序算法。<br>代码很漂亮但是很耗时<br>该排序是一种低效的递归排序算法，不仅慢于一般的有效排序算法（如：插入排序，合并排序，堆排序和快速排序），甚至慢于冒泡排序。<br>所以相比于经典的排序算法，STOOGE算法具有非常差的性能。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>如果最后一个值小于第一个值，则交换它们<br>如果当前子集元素数量大于等于3：<br>　1.使用Stooge排序前2/3的元素<br>　2.使用Stooge排序后2/3的元素<br>　3.再次使用Stooge排序前2/3的元素</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>O(n^log(3/2)3)<br>O（n^2.7）<br>可见此算法效率相当的低下，比选择、插入、冒泡排序更差！</p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StooGe_sort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left]&gt;<span class="built_in">array</span>[right])  </div><div class="line">    &#123;  </div><div class="line">        ExchangeAB(<span class="built_in">array</span>[left],<span class="built_in">array</span>[right]);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (left+<span class="number">1</span> &gt;= right)         <span class="comment">// 数组不多于2个元素 返回  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span> ;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">int</span> k=(right-left+<span class="number">1</span>)/<span class="number">3</span>;  </div><div class="line">    StooGe_sort(<span class="built_in">array</span>,left,right-k);  </div><div class="line">    StooGe_sort(<span class="built_in">array</span>,left+k,right);  </div><div class="line">    StooGe_sort(<span class="built_in">array</span>,left,right-k);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stooge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (a[l]&gt;a[r]) swap(a[l],a[r]);</div><div class="line">    <span class="keyword">if</span> (l+<span class="number">1</span>&gt;=r) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> k=(r-l+<span class="number">1</span>)/<span class="number">3</span>;</div><div class="line">    stooge_sort(a,l,r-k);</div><div class="line">    stooge_sort(a,l+k,r);</div><div class="line">    stooge_sort(a,l,r-k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><hr>
<p><a href="http://blog.sina.com.cn/s/blog_51cea4040100fcl6.html" target="_blank" rel="external">【OI杂记】神奇的地球之Stooge排序 </a><br><a href="http://blog.csdn.net/zhaogang1993/article/details/43601831" target="_blank" rel="external">排序算法(四)：Stooge排序</a><br><a href="http://www.cnblogs.com/cpoint/p/3367362.html" target="_blank" rel="external">Stooge 排序 </a><br><a href="http://www.bubuko.com/infodetail-201471.html" target="_blank" rel="external">排序算法之stooge排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortstooge1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：猴子排序（最慢）</title>
    <link href="https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortBogo/"/>
    <id>https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortBogo/</id>
    <published>2017-07-23T03:21:02.000Z</published>
    <updated>2017-07-30T06:17:01.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbogo1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>Bogo排序(Bogo-sort)，又被称为猴子排序，是一种恶搞排序算法。<br>其算法就是坑爹的将元素随机打乱，然后紧紧检查其是否符合排列顺序，若否，则继续进行随机打乱，继续检查结果，直到符合排列顺序。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>运气！！！！！！！！<br>Bogo排序算是一个恶搞排序，它将一切交给了上帝。Bogo排序每一趟都在检测待排序序列是否有序，如果有序，结束。如果无序，将待排序序列随机打乱（随机打乱！！！！！），重新检测。 </p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>是个既不实用又原始的排序算法，其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，否则就再抛一次。</p>
<p>“猴子排序”的名字出自“无限猴子定理”——让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。——只要时间足够，猴子排序一定能得出正确的答案</p>
<p>猴子排序结合无限猴子定理考虑的话，最终的答案就是只要你愿意等足够久的时间，最终一定能得到有序序列.</p>
<p>不过，其实猴子排序也不一定是最慢的排序，未来可以利用量子计算机的力量（当今传统计算机的几百亿倍速度来秒杀猴子排序）。<br>引入一段：<br>量子Bogo排序<br>计算机科学家之间的一个笑话说：量子计算机能够以 O(n) 的复杂度更有效地实现Bogo排序。这将使用真正的量子的随机性来随机打乱列表。根据量子物理学的多世界诠释，量子的随机性分别在无限的宇宙序列中展开，其中的一些将会提供一个排好序的列表。这个列表接着就被测试出来（需要[ i ]n-1次比较），如果顺序不对，这个宇宙就被毁灭掉。因此最后只剩下得出正确顺序的宇宙。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>平均时间复杂度是O(n·n!)<br>最坏时间复杂度为 O(∞)（所需时间是无限）<br>所以有Bogo排序的一辈子也不能输出排序结果。</p>
<h2 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h2><p>它并非一个稳定的算法。（好像是废话…..）</p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">BogoSort</span><span class="params">(datatype *<span class="built_in">array</span>, <span class="keyword">int</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">int</span> tag;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(TRUE) &#123;</div><div class="line">        tag = TRUE;</div><div class="line">        <span class="comment">//检测</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[i<span class="number">-1</span>]) &#123;</div><div class="line">                tag = FALSE;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有序，则排序完成</span></div><div class="line">        <span class="keyword">if</span>(tag) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//随机打乱</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            j = rand() % size;</div><div class="line">            Swap(<span class="built_in">array</span> + i, <span class="built_in">array</span> + j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><hr>
<p>示例来源博客：<br><a href="http://blog.csdn.net/u010647471/article/details/50171511" target="_blank" rel="external">排序算法之Bogo排序</a></p>
<p>算法效果请看以下网址：<br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="external">6分钟演示15种排序算法</a><br><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">ソートアルゴリズムを映像化してみた - jsdo.it - Share JavaScript, HTML5 and CSS</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbogo1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：希尔排序</title>
    <link href="https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShell/"/>
    <id>https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShell/</id>
    <published>2017-07-22T09:47:22.000Z</published>
    <updated>2017-07-22T10:33:40.354Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortshell2.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortshell1.gif" alt="UML图"></p>
<hr>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><hr>
<p>中文名 希尔排序<br>外文名 Shell Sort<br>别名   缩小增量排序<br>类别：插入排序的一种<br>提出者和时间：该方法因设计者希尔（DL．Shell）于1959年提出而得名</p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>首先，大家能都理解，优秀排序算法的首要条件就是速度<sup>24</sup>，但是之前提到的冒泡，选择和插入的时间复杂度都是O(n2)，似乎没法超越了<sup>25</sup>。直到终于有一天，当一位科学家发布超越了O(n<sup>2</sup>)的排序算法，并把内排序算法的时间复杂度提升到了O(nlogn)。<br>在这之前排序算法的时间复杂度基本都是O(n<sup>2</sup>)的，希望排序算法是突破这个时间复杂度的第一批算法之一。</p>
<p>之前写的直接插入排序，其实它的效率在某些时间是很高的。<br>比如，我们的记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很搞笑。<br>还有就是记录数比较少时，直接插入的优势也比较明显。<br>可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。</p>
<p>所以希尔排序可以是直接插入排序改进后的版本，可以增加效率。</p>
<p>希尔排序不同之处就是采取跳跃分割的策略：<br>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</p>
<p>基本有序：<br>就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2,1,3,5,4,7,5,8,9}这样可以成为基本有序了。<br>但像{1,5,9,3,7,8,2,4,6}这样的9在第3位，2在倒数第3位就谈不上基本有序。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>先将整个待排序序列分割成若干子序列，每个子序列由相差一定长度的数据元素组成（这个相差的长度称为增量），然后我们分别对这些子序列<br>进行直接插入排序，一轮排序再取第二个增量，以此类推，需要注意的是，对于希尔排序中增量的确定没有统一的规定，通常的做法是：第一个增量为待排序序列长度的二分之一（取整），然后逐渐减半（取整），知道等于1为止。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p>
<p>希尔排序实质上是一种分组插入的方法！​<br>希尔排序说白了就是把距离不断缩小的插入排序。<br>希尔排序是实现简单但是分析极其困难的一个算法的例子.</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>O(nlogn)<br>O(n<sup>3/2</sup>), 要好于直接排序的O（n<sup>2</sup>）.</p>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些</p>
<h2 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h2><p>另外由于记录是跳跃式的移动，希尔排序并不是一个稳定的排序算法。</p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度都O(n2)），之后。相应的更为高效的排序算法也就相继出现了。</p>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>代码来源：大话数据结构——9.6希尔排序 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> increment=L-&gt;length;</div><div class="line">	<span class="keyword">do</span></div><div class="line">	&#123;</div><div class="line">		increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></div><div class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </div><div class="line">			&#123; </div><div class="line">				L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></div><div class="line">				<span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</div><div class="line">					L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></div><div class="line">				L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"	第%d趟排序结果: "</span>,++k);</div><div class="line">		print(*L);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，增量序列的最后一个增量值必须等于1才行。</p>
<p>通过这段代码的剖析，能看到希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。<br>这里的增量的选取就非常关键了，这里用increment=increment/3+1的方式选取增量的。<br>可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><img src="/images/it_algorithm_sortshaker3.png" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="comment">//int[] data = &#123;9,2,5,15,66,4,37,3,7,55,8,0,6,21&#125;;</span></div><div class="line">     <span class="keyword">int</span>[] data = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>&#125;;</div><div class="line">     <span class="keyword">int</span> length = data.length;</div><div class="line">     System.out.print(<span class="string">"排序前："</span>);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">         System.out.print(data[i]+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     System.out.println();</div><div class="line"></div><div class="line">     shellSort(data,length);</div><div class="line">     System.out.print(<span class="string">"排序后："</span>);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</div><div class="line">         System.out.print(data[i]+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">     <span class="keyword">int</span> temp;            <span class="comment">// 临时变量</span></div><div class="line">     <span class="keyword">int</span> pointer;         <span class="comment">// 进行比较的下表位置</span></div><div class="line">     <span class="keyword">int</span> len = index / <span class="number">2</span>; <span class="comment">// 设置步长增量，分割集合的间隔长度，初始值为数组长度的一半</span></div><div class="line">     <span class="keyword">while</span> (len != <span class="number">0</span>)&#123; <span class="comment">// 1.按每次减半划分步长，直到步长为1</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;index;i++)&#123;  <span class="comment">// 2.对各个集合进行处理（根据步长，设置每轮循环次数）</span></div><div class="line">             pointer = i-len; <span class="comment">// 计算要和当前值进行比较的数的位置</span></div><div class="line">             temp = arr[i];</div><div class="line">             <span class="keyword">while</span>(temp &lt; arr[pointer])&#123; <span class="comment">// 3.将临时变量与集合内的数进行比较（按照步长距离，将临时变量里的值和集合内数值依次进行比较）</span></div><div class="line">                 arr[pointer+len] = arr[pointer];</div><div class="line">                 pointer = pointer - len;</div><div class="line">                 <span class="keyword">if</span>(pointer &lt; <span class="number">0</span>)&#123;  <span class="comment">// 如果当前下标位置大于或等于当前步长则继续循环，按步长与前面所有的数进行比较，直到遇到比当前临时变量小的数为止</span></div><div class="line">                     <span class="keyword">break</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             arr[pointer + len] = temp;<span class="comment">// 把临时变量赋值到当前下标所在位置</span></div><div class="line">         &#125;</div><div class="line">         len = len/<span class="number">2</span>;<span class="comment">//每次递减一半</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><p><a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">百度百科-希尔排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortshell2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：鸡尾酒排序</title>
    <link href="https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShaker/"/>
    <id>https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShaker/</id>
    <published>2017-07-22T04:21:30.000Z</published>
    <updated>2017-07-30T06:16:47.322Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortshaker1.gif" alt="UML图"></p>
<a id="more"></a>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这个算法有好多名称，以下就是收集的名称，这里用鸡尾酒排序来作为本篇文章的正统名称。<br>Shaker排序 (Shaker Sort)<br>鸡尾酒排序 (Cocktail Sort)<br>双向冒泡排序 (Bidirectional Bubble Sort)<br>波浪排序 (Ripple Sort)<br>摇曳排序 (Shuffle Sort)<br>飞梭排序 (Shuttle Sort)<br>欢乐时光排序 (Happy Hour Sort)</p>
<p>其实它是改良的冒泡排序的轻微变形。<br>不同的地方在于，鸡尾酒排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。<br>他可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。</p>
<p>以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。<br>但是在乱数序列状态下，鸡尾酒排序与冒泡排序的效率都很差劲，<br>优点只有原理简单这一点。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>1、 气泡排序的双向进行，先让气泡排序由左向右进行，再来让气泡排序由右往左进行，如此完成一次排序的动作<br>2、 使用left与right两个旗标来记录左右两端已排序的元素位置。</p>
<p>排序过程：<br>先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端<br>再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端<br>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O（n^2）</p>
<h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><h3 id="示例代码1（Java）"><a href="#示例代码1（Java）" class="headerlink" title="示例代码1（Java）"></a>示例代码1（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShakerSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, left = <span class="number">0</span>, </div><div class="line">               right = number.length - <span class="number">1</span>, </div><div class="line">               shift = <span class="number">0</span>; </div><div class="line"></div><div class="line">        <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">            <span class="comment">// 向右进行气泡排序 </span></div><div class="line">            <span class="keyword">for</span>(i = left; i &lt; right; i++) &#123; </div><div class="line">                <span class="keyword">if</span>(number[i] &gt; number[i+<span class="number">1</span>]) &#123; </div><div class="line">                    swap(number, i, i+<span class="number">1</span>); </div><div class="line">                    shift = i; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            right = shift; </div><div class="line"></div><div class="line">            <span class="comment">// 向左进行气泡排序 </span></div><div class="line">            <span class="keyword">for</span>(i = right; i &gt; left; i--) &#123; </div><div class="line">                <span class="keyword">if</span>(number[i] &lt; number[i-<span class="number">1</span>]) &#123; </div><div class="line">                    swap(number, i ,i-<span class="number">1</span>); </div><div class="line">                    shift = i; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            left = shift; </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t; </div><div class="line">        t = number[i]; </div><div class="line">        number[i] = number[j]; </div><div class="line">        number[j] = t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码2（JavaScript）"><a href="#示例代码2（JavaScript）" class="headerlink" title="示例代码2（JavaScript）"></a>示例代码2（JavaScript）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shakerSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = array.length,</div><div class="line">        left = <span class="number">0</span>,</div><div class="line">        right = length - <span class="number">1</span>,</div><div class="line">        lastSwappedLeft = left,</div><div class="line">        lastSwappedRight = right,</div><div class="line">        i,</div><div class="line">        j;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="comment">// 从左到右</span></div><div class="line">        lastSwappedRight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</div><div class="line">                swap(array, i, i + <span class="number">1</span>);</div><div class="line">                lastSwappedRight = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right = lastSwappedRight;</div><div class="line">        <span class="comment">// 从右到左</span></div><div class="line">        lastSwappedLeft = length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (j = right; left &lt; j; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</div><div class="line">                swap(array, j - <span class="number">1</span>, j)</div><div class="line">                lastSwappedLeft = j</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left = lastSwappedLeft;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码3（C）"><a href="#示例代码3（C）" class="headerlink" title="示例代码3（C）"></a>示例代码3（C）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(x,y) &#123;int t; t = x; x = y; y = t;&#125; </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shakersort</span><span class="params">(<span class="keyword">int</span>[])</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> number[MAX] = &#123;<span class="number">0</span>&#125;; </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line"></div><div class="line">    srand(time(<span class="literal">NULL</span>)); </div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"排序前："</span>); </div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) &#123; </div><div class="line">        number[i] = rand() % <span class="number">100</span>; </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    shakersort(number); </div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shakersort</span><span class="params">(<span class="keyword">int</span> number[])</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> i, left = <span class="number">0</span>, right = MAX - <span class="number">1</span>, shift = <span class="number">0</span>; </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">        <span class="comment">// 向右进行气泡排序 </span></div><div class="line">        <span class="keyword">for</span>(i = left; i &lt; right; i++) &#123; </div><div class="line">            <span class="keyword">if</span>(number[i] &gt; number[i+<span class="number">1</span>]) &#123; </div><div class="line">                SWAP(number[i], number[i+<span class="number">1</span>]); </div><div class="line">                shift = i; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        right = shift; </div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n往右排序："</span>); </div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line"></div><div class="line">        <span class="comment">// 向左进行气泡排序 </span></div><div class="line">        <span class="keyword">for</span>(i = right; i &gt; left; i--) &#123; </div><div class="line">            <span class="keyword">if</span>(number[i] &lt; number[i<span class="number">-1</span>]) &#123; </div><div class="line">                SWAP(number[i], number[i<span class="number">-1</span>]); </div><div class="line">                shift = i; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        left = shift; </div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n向左排序："</span>); </div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h2><p><a href="http://blog.csdn.net/xushuaic/article/details/8615253" target="_blank" rel="external">算法 Shaker排序法 - 改良的气泡排序</a><br><a href="https://www.kancloud.cn/kancloud/sort-algorithm/46565" target="_blank" rel="external">鸡尾酒排序 (Cocktail Sort/Shaker Sort)</a><br><a href="http://blog.csdn.net/vivitue/article/details/38716575" target="_blank" rel="external">算法之路 - 双向冒泡排序之Shaker</a><br><a href="http://www.cnblogs.com/wuweiblog/archive/2011/07/11/2103325.html" target="_blank" rel="external">冒泡排序与鸡尾酒排序</a><br><a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Shaker/Shaker.php" target="_blank" rel="external">[演算法] 搖晃排序法(Shaker Sort)</a><br><a href="https://www.codingunit.com/cocktail-sort-algorithm-or-shaker-sort-algorithm" target="_blank" rel="external">Cocktail Sort Algorithm or Shaker Sort Algorithm</a><br><a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" target="_blank" rel="external">SORTING ALGORITHMS: THE COCKTAIL SORT</a><br><a href="http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科-鸡尾酒排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortshaker1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：插入排序</title>
    <link href="https://hengxing0080.github.io/2017/07/21/it/Algorithm/SortInsert/"/>
    <id>https://hengxing0080.github.io/2017/07/21/it/Algorithm/SortInsert/</id>
    <published>2017-07-21T09:47:22.000Z</published>
    <updated>2017-07-21T10:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortInsert4.gif" alt="UML图"><br>过程类似插入扑克牌的过程（一边摸牌，一边理牌）<br><a id="more"></a></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>插入排序（Insertion Sorting）</p>
<p>简单定义就是直接插入排序过程需要将带插入的元素和当前有序序列中所有数据进行比较</p>
<p>每次将一个待排序的数据元素，按照其关键字大小插入到前面已排好序的有序序列的适当位置，使插入以后的数据序列仍然为一个有序序列，直到整个序列成为有序的序列为止。</p>
<p>它是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>从第一个元素开始，该元素可以认为已经被排序.<br>取出下一个元素，在已经排序的元素序列中从后向前扫描.<br>如果该元素（已排序）大于新元素，将该元素移到下一位置.<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置.<br>将新元素插入到该位置中.<br>重复步骤2.</p>
<p>下面是各种插入排序图示流程↓<br><img src="/images/it_algorithm_sortInsert1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortInsert3.gif" alt="UML图"><br><img src="/images/it_algorithm_sortInsert2.gif" alt="UML图"></p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n^2）<br>不过能看出来，同样的复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。</p>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>稳定</p>
<hr>
<h1 id="算法的2种分类"><a href="#算法的2种分类" class="headerlink" title="算法的2种分类"></a>算法的2种分类</h1><hr>
<blockquote>
<p>它有两个形式：直接插入排序，二分插入排序</p>
</blockquote>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>Straight Insertion Sort<br>基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。<br><img src="/images/it_algorithm_sortInsert5.png" alt="UML图"></p>
<h3 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">int</span> currentData = arr[i]; <span class="comment">// 用for循环在数组中提取数据并赋值给currentData</span></div><div class="line">        <span class="keyword">int</span> temp = i;</div><div class="line">        <span class="comment">// 用while循环盘点数组第一个元素是否大于取出的第二个元素，如果大于数组向右移动</span></div><div class="line">        <span class="keyword">while</span> ((temp &gt; <span class="number">0</span>) &amp;&amp; (arr[temp - <span class="number">1</span>] &gt; currentData)) &#123;  </div><div class="line">            arr[temp] = arr[temp - <span class="number">1</span>]; <span class="comment">// 实现了数组的向右移动</span></div><div class="line">            temp--; <span class="comment">// temp为0，while循环结束</span></div><div class="line">        &#125;</div><div class="line">        arr[temp] = currentData; <span class="comment">// 交换数据（将取出的第二个元素赋值给数组中第一个元素）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] data = &#123;<span class="number">23</span>, <span class="number">45</span>, <span class="number">16</span>, <span class="number">7</span>, <span class="number">42</span>&#125;; <span class="comment">// 定义无序数组data</span></div><div class="line">    insertSort(data);</div><div class="line">    <span class="comment">// 页面打印</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:data)&#123;</div><div class="line">        System.out.print(x+<span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码-2（C）"><a href="#示例代码-2（C）" class="headerlink" title="示例代码 2（C）"></a>示例代码 2（C）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];	<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></div><div class="line">	<span class="keyword">int</span> length;			<span class="comment">/* 用于记录顺序表的长度 */</span></div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span> i,j;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></div><div class="line">		&#123;</div><div class="line">			L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></div><div class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</div><div class="line">				L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></div><div class="line">			L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>又称 折半插入排序</p>
<p>折半插入排序算法是对直接插入排序算法的一种改进。<br>在直接插入排序算法中，向有序序列中插入一个元素1，插入位置是把待插入元素关键字与有序序列中元素的关键字逐个比较得到的。</p>
<p>它是将待插入数据与当前有序序列中的平分位置的关键字数据进行比较，从而确定了下一步要平分的子序列，以此类推直到找到合适的插入位置为止。<br><img src="/images/it_algorithm_sortInsert6.png" alt="UML图"></p>
<p>折半插入排序算法的基本思想是：<br>向有序序列中插入元素，那么插入位置可以不断地平分有序序列，并把带插入的元素的关键字与平分有序序列得到的关键字比较，以确定下一步要平分的子序列，直到找到合适的插入位置为止。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] data = &#123;<span class="number">7</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">1</span>&#125;;    <span class="comment">//排序后：1, 7, 16, 23, 42, 45</span></div><div class="line">    <span class="comment">//int[] data2 = &#123;7, 16, 23, 42, 45, 45&#125;;//排序后：7, 16, 23, 42, 45, 45</span></div><div class="line">    BInsertSort(data);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:data)&#123;</div><div class="line">        System.out.print(x+<span class="string">"  "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;  <span class="comment">// 获取数组长度</span></div><div class="line">    <span class="keyword">int</span> insertData = arr[len - <span class="number">1</span>]; <span class="comment">// 待插入元素</span></div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> hign = len - <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt;= hign) &#123;</div><div class="line">        <span class="keyword">int</span> middle = (low + hign) / <span class="number">2</span>; <span class="comment">// 获取数组中间元素下标</span></div><div class="line">        <span class="keyword">if</span>(insertData &lt; arr[middle])&#123;</div><div class="line">            hign = middle - <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            low = middle +<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span>;j&gt;hign+<span class="number">1</span>;j--)&#123;</div><div class="line">        arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    arr[hign+<span class="number">1</span>] = insertData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortInsert4.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;过程类似插入扑克牌的过程（一边摸牌，一边理牌）&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：串</title>
    <link href="https://hengxing0080.github.io/2017/07/20/it/DataStructure/String/"/>
    <id>https://hengxing0080.github.io/2017/07/20/it/DataStructure/String/</id>
    <published>2017-07-20T11:31:51.000Z</published>
    <updated>2017-07-20T11:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_string0.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名 串/字符串<br>英文名 String</p>
<p>串是由零个或多个字符组成的有限序列，又名叫字符串。它也是一种数据结构。<br>（所谓的序列，说明串的相邻字符之间具有前驱和后继的关系）</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>&nbsp;<br>本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找，替换等操作。</p>
<p>一般记为s=”a1a2…….an”(n≥0)，其中s是串的名称，用双引号（有些书里是单引号）括起来的字符序列是串的值，注意单引号不属于串的内容。</p>
<h1 id="各种关键词"><a href="#各种关键词" class="headerlink" title="各种关键词"></a>各种关键词</h1><ul>
<li><p>空串：<br>零个字符串的串称为空串（null string），它的长度为零，可以直接用两双引号””表示，也可以用希腊字母Φ来表示。</p>
</li>
<li><p>空格串：<br>是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</p>
</li>
<li><p>子串与主串：<br>串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。<br>子串在主串中的位置就是子串的第一个字符在主串中的序号。<br>“over”,”end”,”lie”其实可以认为是”lover”,”friend”,”believe”这些单词字符串的子串</p>
</li>
</ul>
<h1 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h1><ul>
<li><p>比较两个串相等<br>必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。<br>即给定两个串：s=”a1a2….an”, t=”b2b2….bm”, 当且仅当n=m, 且a1=b1,a2=b2,……,an=bm时，我们认为s=t.</p>
</li>
<li><p>比较两个串不相等<br>给定两个串：s=”a1a2……an”, t=”b2b2…..bm”, 当满足以下条件之一时，s&lt;t<br>1.n&lt;m，且a1=b1(i=1,2,…..,n) .<br>例如如s=”hap”,t=”happy”,就有s&lt;t。因此t比s多出了两个字母。<br>2.存在某个k≤min(m,n)，使得ai=bi (i=1,2,…..,k-1),ak&lt;bk .<br>例如当s=”happen”,t=”happy”,因为两串的前4个字母均相同，而两串第5个字母（k值），字母e的ASCII码是101，而字母y的ASCII码是121，显然e&lt;y,所以s&lt;t.</p>
</li>
<li><p>例子<br>纸质英语词典：通常都是上万个单词的有序排列。就大小而言，前面的单词比后面的要小，你在查找单词的过程，其实就是在比较字符串大小的过程。<br>电子词典：查找单词实现的原理，其实就是字符串这种数据结构的典型应用。</p>
</li>
</ul>
<hr>
<h1 id="串的存储结构（顺序和链式）"><a href="#串的存储结构（顺序和链式）" class="headerlink" title="串的存储结构（顺序和链式）"></a>串的存储结构（顺序和链式）</h1><hr>
<blockquote>
<p>串的存储结构与线性表相同，分为两种。</p>
</blockquote>
<h2 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h2><p>是用一组地址连续的存储单元来存储串中的字符序列的。<br>按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。<br>一般是定长数组来定义。</p>
<p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。</p>
<p>但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\o”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间。</p>
<p><img src="/images/it_datastructure_string1.png" alt="UML图"></p>
<p>刚才讲的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接Concat、新串的插入Strlnsert、以及字符串的替换Replace，都有可能使得串序列的长度超过了数组的长度MaxSize。</p>
<p>也就是说，串的顺序存储结构的缺点是字符串的截断，截断就是超过预定义长度的串值被舍去。<br>于是对于串的顺序存储，有一些变化，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做“堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理。</p>
<h2 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h2><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用’#”或其他串值字符补全，如图↓<br><img src="/images/it_datastructure_string2.png" alt="UML图"></p>
<p>当然，这里一个结点存多少字符才合适就变得很重要，这回直接影响着处理的效率，需要根据实际情况作出选择。</p>
<p>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_string0.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 算法：递归</title>
    <link href="https://hengxing0080.github.io/2017/07/19/it/Algorithm/Recursion/"/>
    <id>https://hengxing0080.github.io/2017/07/19/it/Algorithm/Recursion/</id>
    <published>2017-07-19T03:26:49.000Z</published>
    <updated>2017-07-19T10:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_recursion1.jpg" alt="UML图"></p>
<blockquote>
<p>递归属于<a href="http://www.hengxing.me/2017/07/18/it/DataStructure/Stack/" target="_blank" rel="external">栈</a>的经典应用方式之一。</p>
</blockquote>
<a id="more"></a>
<h1 id="递归的解释和定义"><a href="#递归的解释和定义" class="headerlink" title="递归的解释和定义"></a>递归的解释和定义</h1><p>&nbsp;<br>递归作为一种算法在程序设计语言中广泛应用。<br>是指函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象。<br>递归是计算机科学的一个重要概念，递归的方法是程序设计中有效的方法，采用递归编写程序能使程序变得简洁和清晰。</p>
<p>简单理解其实就是函数自己调用自己。<br>是指在定义自身的过程中又直接或间接调用自身的一种算法。</p>
<p>在高级语言中，调用自己和其他函数并没有本质的不同。<br>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</p>
<p>递归算法所有解决的问题都是一个问题可以分割为使用相同算法结局的若干子问题。</p>
<h1 id="递归的特点"><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h1><p>&nbsp;<br>一个问题可以被分解成若按简单的子问题<br>子问题和其上层的解决方案一致<br>外层问题的解决依赖于子问题的解决</p>
<h1 id="递归的工作方式"><a href="#递归的工作方式" class="headerlink" title="递归的工作方式"></a>递归的工作方式</h1><p>&nbsp;<br>一个对象函数调用自己的复制品，复制品函数在执行的过程再次复制出一个复制品继续调用，一直继续下去，知道遇到某个条件停止循环递归调用，然后逐层返回，这个过程就是递归的工作方式。</p>
<h1 id="使用递归算法有2个要素注意"><a href="#使用递归算法有2个要素注意" class="headerlink" title="使用递归算法有2个要素注意"></a>使用递归算法有2个要素注意</h1><p>&nbsp;<br>1.至少有一个停止条件，不能无限递归下去，那就是死循环。<br>2.要计算递归方法的当前值，需要重复调用自身，直至达到停止条件。</p>
<h1 id="递归的视觉"><a href="#递归的视觉" class="headerlink" title="递归的视觉"></a>递归的视觉</h1><p>&nbsp;<br><a href="http://baike.baidu.com/link?url=i5jUc80R_n8xl63Hc8pMTNuRRyE_3VNEndFj-CqlT-LpFfRNK_RhLcZhTkhnx6cDYZPC-ORWKKi8aX1_s8uKw4iICH_WW13Kp8VQ7tLwsqCTM6mh6azLIZ9Cr-7WWSNuqV9TBTvaGAaYVq7sQj9EZ_" target="_blank" rel="external">德罗斯特效应</a>是递归的一种视觉形式，它能在视觉上描述递归算法。 效果类似如下↓<br><img src="/images/it_algorithm_recursion2.jpg" alt="UML图"><br>想看更多德罗斯特效应，请<a href="http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94" target="_blank" rel="external">搜索图片</a></p>
<hr>
<h1 id="递归示例1：兔子繁殖问题"><a href="#递归示例1：兔子繁殖问题" class="headerlink" title="递归示例1：兔子繁殖问题"></a>递归示例1：兔子繁殖问题</h1><hr>
<blockquote>
<p>兔子繁殖问题也称兔子数列，属于斐波那契数列，是个很经典的递归例子。</p>
</blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>先说下 斐波那契数列（Fibonacci）</p>
<p>用递归和非递归算法列出Fibonacci数列的前n项几乎是所有程序员都经历过的过程。</p>
<p>特点是数列中的每一项都是前两项的（最前两项都是1）和，即F（n）=F（n-1）+F（n-2）。</p>
<p>斐波那契数列又因意大利数学家列昂纳多·斐波那契（Fibonacci leonardo，约1170-1250）以兔子繁殖为例子而引入，故又称为“兔子数列”。<br>这个数列是意大利中世纪数学家斐波那契在&lt;算盘全书&gt;中提出的。</p>
<p>他在1202年提出了下面的问题描述如下：<br>兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p>
<h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><p>我们不妨拿新出生的一对小兔子分析一下：</p>
<p>第一个月小兔子没有繁殖能力，所以还是一对<br>两个月后，生下一对小兔对数共有两对<br>三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对</p>
<p>依次类推可以列出下表：<br><img src="/images/it_algorithm_recursion3.jpg" alt="UML图"></p>
<p>幼仔对数=前月成兔对数<br>成兔对数=前月成兔对数+前月幼仔对数<br>总体对数=本月成兔对数+本月幼仔对数</p>
<p>如果1到12个月的个数，那么结果为<br>1　1　2　3　5　8　13　21　34　55　89　144</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">月份      不成熟兔子       成熟兔子        数量</div><div class="line">1         1                              1</div><div class="line">2                         1              1</div><div class="line">3         1               1              2</div><div class="line">4         1               2              3</div><div class="line">5         2               3              5  </div><div class="line">6         3               5              8</div><div class="line">7         5               8              13</div><div class="line">8         8               13             21    </div><div class="line">9         13              21             34</div><div class="line">10        21              34             55</div><div class="line">11        34              55             89</div><div class="line">12        55              89             144</div></pre></td></tr></table></figure>
<p>可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。</p>
<p>这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。</p>
<h2 id="图示效果"><a href="#图示效果" class="headerlink" title="图示效果"></a>图示效果</h2><p><img src="/images/it_algorithm_recursion4.png" alt="UML图"><br><img src="/images/it_algorithm_recursion5.png" alt="UML图"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 迭代方式（For循环）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            res = x + y;</div><div class="line">            x = y;</div><div class="line">            y = res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 递归方式</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fRecur</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n== <span class="number">1</span> || n == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> fRecur(n-<span class="number">2</span>)+fRecur(n-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(fFor(<span class="number">6</span>));</div><div class="line">        System.out.println(fRecur(<span class="number">6</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123; </div><div class="line">            System.out.println(fRecur(i)+<span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">迭代和递归的区别是：</div><div class="line">迭代使用的是循环结构，递归使用的是选择结构。</div><div class="line">但是大量的递归调用会简历函数的副本，会耗费大量的时间和内存。</div><div class="line">迭代则不需要反复调用函数和占用额外的内存。</div><div class="line">因此应该视不同情况选择不同的代码实现方式。</div><div class="line">*/</div></pre></td></tr></table></figure>
<hr>
<h1 id="递归示例2：猴子吃桃问题"><a href="#递归示例2：猴子吃桃问题" class="headerlink" title="递归示例2：猴子吃桃问题"></a>递归示例2：猴子吃桃问题</h1><hr>
<p>猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。<br>第二天早上又将剩下的桃子吃掉一半，又多吃了一个。<br>以后每天早上都吃了前一天剩下的一半零一个。<br>到第10天早上想再吃时，见只剩下一个桃子了。<br>求第一天共摘了多少？或者说第1天到10天每天桃子的数量是多少？</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>第10天~第1天的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1       // 第10天：因为上面说了第10天就剩1个了</div><div class="line">4       // 第9天：1*2+1=3+1=4</div><div class="line">10      // 第8天：4*2+1=9+1=10</div><div class="line">22      // 第7天：10*2+1=21+1=22</div><div class="line">46      // 第6天：22*2+1=45+1=46</div><div class="line">94      // 第5天：46*2+1=93+1=94</div><div class="line">190     // 第4天：94*2+1=189+1=190</div><div class="line">382     // 第3天：190*2+1=381+1=382</div><div class="line">766     // 第2天：382*2+1=765+1=766</div><div class="line">1534    // 第1天：766*2+1=1533+1=1534</div></pre></td></tr></table></figure>
<h2 id="示例代码1（迭代算法）"><a href="#示例代码1（迭代算法）" class="headerlink" title="示例代码1（迭代算法）"></a>示例代码1（迭代算法）</h2><p>当然，do while和if都是类似的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> day=<span class="number">10</span>,x1=<span class="number">0</span>,x2=<span class="number">1</span>,eatNum;</div><div class="line">    <span class="keyword">for</span>(;day&gt;<span class="number">0</span>;day--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(day==<span class="number">10</span>)&#123;</div><div class="line">           x1 = <span class="number">1</span>;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"猴子在第 %d 天有 %d 个桃子。\n"</span>,day, x1);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">           x1=(x2+<span class="number">1</span>)*<span class="number">2</span>;  <span class="comment">// 每前一天的桃子数都等一现在剩余的桃子数加一在乘以二  </span></div><div class="line">           x2=x1;</div><div class="line">           eatNum = x1/<span class="number">2</span>+<span class="number">1</span>;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"猴子在第 %d 天有 %d 个桃子，当天吃了 %d 个桃子。\n"</span>,day,x1, eatNum);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果<br><img src="/images/it_algorithm_recursion6.jpg" alt="UML图"></p>
<h2 id="示例代码2-1（递归算法：C）"><a href="#示例代码2-1（递归算法：C）" class="headerlink" title="示例代码2.1（递归算法：C）"></a>示例代码2.1（递归算法：C）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span> (d == <span class="number">10</span>)        </div><div class="line">        sum = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;<span class="number">10</span>)   </div><div class="line">        sum = <span class="number">2</span> * (num(d + <span class="number">1</span>) + <span class="number">1</span>);  </div><div class="line">    <span class="keyword">return</span> sum;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">main() &#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> day = <span class="number">10</span>;</div><div class="line">    <span class="keyword">while</span>(day&gt;<span class="number">0</span>)&#123;</div><div class="line">         sum = num(day);  </div><div class="line">         day--;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"猴子一共摘了 %d 个桃子。\n"</span>, sum);  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码2-2（递归算法：Java）"><a href="#示例代码2-2（递归算法：Java）" class="headerlink" title="示例代码2.2（递归算法：Java）"></a>示例代码2.2（递归算法：Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> day = <span class="number">10</span>;</div><div class="line">        <span class="keyword">while</span>(day &gt; <span class="number">0</span>)&#123;</div><div class="line">            System.out.println(<span class="string">"猴子第"</span>+day+<span class="string">"天的桃子数量："</span>+getTotalNum(day));</div><div class="line">            day--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">10</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (getTotalNum(n + <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_recursion1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归属于&lt;a href=&quot;http://www.hengxing.me/2017/07/18/it/DataStructure/Stack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;栈&lt;/a&gt;的经典应用方式之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 各种" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%90%84%E7%A7%8D/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：栈和队列的总结</title>
    <link href="https://hengxing0080.github.io/2017/07/18/it/DataStructure/StackAndQueue/"/>
    <id>https://hengxing0080.github.io/2017/07/18/it/DataStructure/StackAndQueue/</id>
    <published>2017-07-18T12:50:39.000Z</published>
    <updated>2017-07-18T12:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_stackandqueue1.png" alt="UML图"></p>
<a id="more"></a>
<p>1.它们都是特殊的线性表，只不过对插入和删除操作做了限制：<br>栈：限定仅在表尾进行插入和删除操作的线性表。<br>队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>2.栈和队列的顺序存储结构：<br>它们都可以用线性表的顺序存储结构实现，但都存在着顺序存储的一些弊端，因此它们各自有一些技巧解决这个问题。<br>对于栈来说，如果两个相同数据类型的栈，则可以用数组的两端作栈底的方法让两个栈共享数据，最大化利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，引入循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
<p>3.栈和队列的链式存储结构：<br>栈和队列的链式存储结构的实现原理和线性表的实现原理基本上相同。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_stackandqueue1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：栈</title>
    <link href="https://hengxing0080.github.io/2017/07/18/it/DataStructure/Stack/"/>
    <id>https://hengxing0080.github.io/2017/07/18/it/DataStructure/Stack/</id>
    <published>2017-07-18T09:28:23.000Z</published>
    <updated>2017-07-18T12:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_stack1.png" alt="UML图"></p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;<br>中文名 栈<br>英文名 Stack<br>又名   堆栈</p>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>&nbsp;<br>栈是限定仅在表尾进行插入和删除操作的线性表</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>&nbsp;<br>它是一种运算受限的线性表。<br>其限制是仅允许在表的一端进行插入和删除运算。<br>访问栈中的元素时，遵守后进先出的运算规则。<br>因此，栈也成为后进先出表（Last In First Out的线性表），简称LIFO。</p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。<br>这也就使得：栈底是固定的，最先进栈的只能在栈底。<br><img src="/images/it_datastructure_stack2.png" alt="UML图"></p>
<h1 id="情景比喻"><a href="#情景比喻" class="headerlink" title="情景比喻"></a>情景比喻</h1><p>&nbsp;<br>中文解释是存储货物或供旅客住宿的房屋。</p>
<p>如同一个杯子，水桶。<br>水桶相当于栈，往水桶里倒水就是进栈，相反，把水桶里的水导出来就是出栈。<br>水桶的底部就是栈底，水桶的顶部就是栈顶。<br>由于后进先出规则，先导入水桶的水当我们倒出的时间肯定是最后才倒出来。</p>
<h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p>&nbsp;<br>空栈：不包含任何数据元素的栈称为空栈。　<br>栈顶和栈底：我们把允许插入和删除的一段称为栈顶（top），另一端称为栈底（botton）<br>栈顶元素和栈底元素：存储在栈底位置的数据元素称为栈底元素，反之，在栈顶的叫栈顶元素。<br>进栈入栈/压栈：push（压），插入的操作，类似子弹压入（入弹夹）<br>出栈/退栈：pop（弹），删除的操作，类似弹夹的子弹弹出（出夹）</p>
<h1 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h1><p>&nbsp;<br>由于栈本身就是一个线性表，那么线性表的顺序存储和链式存储，对于栈也是同样适用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ADT 栈(stack)  </div><div class="line">Data  </div><div class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后堆关系。  </div><div class="line">Operation  </div><div class="line">    InitStack ( *S )：初始化操作.建立一个空栈S。  </div><div class="line">    DestroyStack ( *S )：若栈存在，則销毁它。  </div><div class="line">    ClearStack (*S)：将栈清空。  </div><div class="line">    StackEmpty ( S ):若栈为空，返回true,否則返回 false。  </div><div class="line">    GetTop (S,*e)：若栈存在且非空，用e返回S的栈顶元素。  </div><div class="line">    Push (*S,e)：若栈S存在，插入新元素e到栈S中并成为栈頂元素。  </div><div class="line">    Pop (*S,*e)：删除栈S中栈顶元素，并用e返回其值。  </div><div class="line">    StackLength (S)：返回回栈S的元素个数。  </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h1 id="栈的两种存储方式"><a href="#栈的两种存储方式" class="headerlink" title="栈的两种存储方式"></a>栈的两种存储方式</h1><p>&nbsp;<br>栈的种类分为顺序栈和链栈</p>
<hr>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><hr>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>栈的顺序存储结构简称顺序栈。<br>顺序栈用一组连续的存储单元依次存放从栈底到栈顶的数据元素。同时用一个指针top指示栈顶元素在顺序栈中的位置。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.数据元素存放在连续的存储地址中。<br>2.栈底位置固定不变。<br>3.栈顶位置随进栈，出栈操作而变化。 </p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>很方便，因为它只准栈顶进出元素，所以不存在线性表插入和删除时移动元素的问题。</p>
<h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><p>必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。</p>
<h3 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h3><p>空栈：top == -1<br>满栈：top == MAXSIZE -1</p>
<h3 id="栈的结构定义"><a href="#栈的结构定义" class="headerlink" title="栈的结构定义"></a>栈的结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType; <span class="comment">/* SElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="comment">/* 顺序栈结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">        SElemType data[MAXSIZE];</div><div class="line">        <span class="keyword">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></div><div class="line">&#125;SqStack;</div></pre></td></tr></table></figure>
<p>若现在有一个栈，StackSize是5，则栈普通情况，空栈和栈满的情况示意图</p>
<p><img src="/images/it_datastructure_stack3.png" alt="UML图"></p>
<h3 id="进出栈操作"><a href="#进出栈操作" class="headerlink" title="进出栈操作"></a>进出栈操作</h3><p>两者没有涉及任何循环语句，因此时间复杂度是O(1)<br>进栈图示<br><img src="/images/it_datastructure_stack4.png" alt="UML图"></p>
<p>进栈代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S,SElemType e)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>) <span class="comment">/* 栈满 */</span></div><div class="line">        &#123;</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        S-&gt;top++;		   <span class="comment">/* 栈顶指针增加一 */</span></div><div class="line">        S-&gt;data[S-&gt;top]=e; <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出栈代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S,SElemType *e)</span></span></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        *e=S-&gt;data[S-&gt;top];	<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></div><div class="line">        S-&gt;top--;			<span class="comment">/* 栈顶指针减一 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>对于与一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于与两个相同类似的栈，我们可以做到最大限度的利用其事先开辟的存储空间来进行操作。</p>
<p>比如数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标0处，另一个栈为栈的末端，即下标为数组长度n-1处。<br>这样，两个栈如果增加元素，就是两端点向中间延伸.</p>
<p>关键思路：它们是数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈可以一直使用。</p>
<p>这里可以分析出来<br>栈1为空时：top1 == -1<br>栈2为空时：top2 == n<br>栈满情况1：若栈2是空栈，栈1的top1 == n -1，就是栈1满了<br>栈满情况2：反之，栈1为空栈时，top2 == 0，为栈2满<br>栈满情况3：两个栈见面之时，就是指针之间相差1时，即top1+1 == top2为栈满</p>
<h4 id="两栈共享空间的结构"><a href="#两栈共享空间的结构" class="headerlink" title="两栈共享空间的结构"></a>两栈共享空间的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 两栈共享空间结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></div><div class="line">&#123;</div><div class="line">        SElemType data[MAXSIZE];</div><div class="line">        <span class="keyword">int</span> top1;	<span class="comment">/* 栈1栈顶指针 */</span></div><div class="line">        <span class="keyword">int</span> top2;	<span class="comment">/* 栈2栈顶指针 */</span></div><div class="line">&#125;SqDoubleStack;</div></pre></td></tr></table></figure>
<h4 id="两栈共享空间的push方法"><a href="#两栈共享空间的push方法" class="headerlink" title="两栈共享空间的push方法"></a>两栈共享空间的push方法</h4><p>除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="keyword">int</span> stackNumber)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)	<span class="comment">/* 栈已满，不能再push新元素了 */</span></div><div class="line">                <span class="keyword">return</span> ERROR;	</div><div class="line">        <span class="keyword">if</span> (stackNumber==<span class="number">1</span>)			<span class="comment">/* 栈1有元素进栈 */</span></div><div class="line">                S-&gt;data[++S-&gt;top1]=e; <span class="comment">/* 若是栈1则先top1+1后给数组元素赋值。 */</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)	<span class="comment">/* 栈2有元素进栈 */</span></div><div class="line">                S-&gt;data[--S-&gt;top2]=e; <span class="comment">/* 若是栈2则先top2-1后给数组元素赋值。 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不用担心溢出问题的</p>
<h4 id="两栈共享空间的pop方法"><a href="#两栈共享空间的pop方法" class="headerlink" title="两栈共享空间的pop方法"></a>两栈共享空间的pop方法</h4><p>参数就只是判断栈1栈2的参数stackNumber</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="keyword">int</span> stackNumber)</span></span></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span> (stackNumber==<span class="number">1</span>) </div><div class="line">        &#123;</div><div class="line">                <span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>) </div><div class="line">                        <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈1已经是空栈，溢出 */</span></div><div class="line">                *e=S-&gt;data[S-&gt;top1--]; <span class="comment">/* 将栈1的栈顶元素出栈 */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)</div><div class="line">        &#123; </div><div class="line">                <span class="keyword">if</span> (S-&gt;top2==MAXSIZE) </div><div class="line">                        <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈2已经是空栈，溢出 */</span></div><div class="line">                *e=S-&gt;data[S-&gt;top2++]; <span class="comment">/* 将栈2的栈顶元素出栈 */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是针对两个具有数据类型的栈的一个设计上的技巧，如果是不同数据类型的栈，这种办法不但不能更好处理问题，反而使问题变得更复杂，所以要注意这个前提。</p>
<hr>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><hr>
<p>栈的链式存储结构</p>
<p><img src="/images/it_datastructure_stack5.png" alt="UML图"></p>
<h3 id="链栈的栈满"><a href="#链栈的栈满" class="headerlink" title="链栈的栈满"></a>链栈的栈满</h3><p>不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统面临死机崩溃的情况，而不是这个链栈是否溢出的问题。</p>
<h3 id="链栈的空栈"><a href="#链栈的空栈" class="headerlink" title="链栈的空栈"></a>链栈的空栈</h3><p>因链表定义是头指针指向空，那么链栈的空其实就是top=NULL </p>
<h3 id="链栈的结构代码"><a href="#链栈的结构代码" class="headerlink" title="链栈的结构代码"></a>链栈的结构代码</h3><p>链栈的操作绝大部分和单链表类似，只是在插入和删除上特殊一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 链栈结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></div><div class="line">&#123;</div><div class="line">        SElemType data;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;StackNode,*LinkStackPtr;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">        LinkStackPtr top;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">&#125;LinkStack;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">visit</span><span class="params">(SElemType c)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,c);</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链栈的进栈操作"><a href="#链栈的进栈操作" class="headerlink" title="链栈的进栈操作"></a>链栈的进栈操作</h3><p>假设元素值为e的新结点是s，top为栈顶指针。<br>图示↓<br><img src="/images/it_datastructure_stack6.png" alt="UML图"></p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span></div><div class="line">&#123;</div><div class="line">        LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); </div><div class="line">        s-&gt;data=e; </div><div class="line">        s-&gt;next=S-&gt;top;	<span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */</span></div><div class="line">        S-&gt;top=s;         <span class="comment">/* 将新的结点s赋值给栈顶指针，见图中② */</span></div><div class="line">        S-&gt;count++;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="链栈的出栈操作"><a href="#链栈的出栈操作" class="headerlink" title="链栈的出栈操作"></a>链栈的出栈操作</h3><p>假设变量p用来存储要删除的栈顶节点，将栈顶指针下移一位，最后释放p即可。<br>图示↓<br><img src="/images/it_datastructure_stack7.png" alt="UML图"></p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span></div><div class="line">&#123; </div><div class="line">        LinkStackPtr p;</div><div class="line">        <span class="keyword">if</span>(StackEmpty(*S))</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        *e=S-&gt;top-&gt;data;</div><div class="line">        p=S-&gt;top;	      <span class="comment">/* 将栈顶结点赋值给p，见图中③ */</span></div><div class="line">        S-&gt;top=S-&gt;top-&gt;next;  <span class="comment">/* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span></div><div class="line">        <span class="built_in">free</span>(p);              <span class="comment">/* 释放结点p */</span>        </div><div class="line">        S-&gt;count--;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="顺序栈与链栈的对比"><a href="#顺序栈与链栈的对比" class="headerlink" title="顺序栈与链栈的对比"></a>顺序栈与链栈的对比</h3><p>进出栈都很简单，没有任何循环操作，时间复杂度均为0(1)<br>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。<br>所以他没的区别和线性表讨论的一样，如果栈的使用过程元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果变化在可控范围内，建议使用顺序栈会更好一些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_stack1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络 —— 网络参考模型：OSI</title>
    <link href="https://hengxing0080.github.io/2017/07/17/it/NetworkProtocol/OSI/"/>
    <id>https://hengxing0080.github.io/2017/07/17/it/NetworkProtocol/OSI/</id>
    <published>2017-07-17T12:17:29.000Z</published>
    <updated>2017-07-18T11:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_osi1.png" alt="UML图"></p>
<p>中文名 　开放式系统互联<br>外文名 　OSI（Open System Interconnection）</p>
<a id="more"></a>
<h1 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h1><p>&nbsp;<br>OSI参考模型（开放式系统互联参考模型（Open System Interconnect Reference Model）<br>国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。</p>
<h1 id="设计目的和用途"><a href="#设计目的和用途" class="headerlink" title="设计目的和用途"></a>设计目的和用途</h1><p>&nbsp;<br>最早的时候网络刚刚出现的时候，很多大型的公司都拥有了网络技术，公司内部计算机可以相互连接，可以却不能与其它公司连接。<br>因为没有一个统一的规范。计算机之间相互传输的信息对方不能理解。所以不能互联。<br>ISO为了更好的使网络应用更为普及，就推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。 </p>
<p>OSI参考模型是ISO（国际标准化组织）ISO的建议，和国际电报电话咨询委员会(CCITT)这个组织在1985年研究联合制定的的开放系统互连网络互联模型，为开放式互连信息系统提供了一种功能结构的框架。<br>它是为了使各层上的协议国际标准化而发展起来的。</p>
<p>OSI模型用途相当广泛。<br>比如交换机、集线器、路由器等很多网络设备的设计都是参照OSI模型设计的。</p>
<h1 id="七层结构"><a href="#七层结构" class="headerlink" title="七层结构"></a>七层结构</h1><p>&nbsp;<br>OSI它把网络协议从逻辑上分为了7层。<br>它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<ul>
<li><p><strong>应用层（Appication layer）</strong><br>功能：文件传输、电子邮件、文件服务、虚拟终端、浏览器、Web开发、我们面对机器也在这层。<br>TCP/IP网络协议：HTTP、FTP、DNS、Telnet、TFTP、SMTP、RIP、NFS。</p>
</li>
<li><p><strong>表示层（Presentation layer）</strong><br>功能：数据格式化，代码转换，数据加密。<br>没有协议</p>
</li>
<li><p><strong>会话层（Session layer）</strong><br>功能：解除或建立与别的接点的联系。<br>没有协议</p>
</li>
<li><p><strong>传输层（Transport layer）</strong><br>功能：提供端对端的接口。<br>TCP/IP网络协议：：TCP、UDP。<br>PS:网络编程在这2个层：传输层、网际层。</p>
</li>
<li><p><strong>网络层/网际层（Network layer）</strong><br>功能：为数据包选择路由。<br>TCP/IP网络协议：IP、ICMP、ARP、RARP、RIP、OSPF、BGP、IGMP。</p>
</li>
<li><p><strong>数据链路层（Data link layer）</strong><br>功能：传输有地址的帧以及错误检测功能。<br>TCP/IP网络协议：SLIP、CSLIP、PPP、ARP、RARP、MTU。</p>
</li>
<li><p><strong>物理层（Physical layer）</strong><br>功能：以二进制数据形式在物理媒体上传输数据、网线、光纤、无线（红外、蓝牙）。<br>TCP/IP网络协议：ISO2110、IEEE802、IEEE802.2。</p>
</li>
</ul>
<h1 id="分层传输过程和单位"><a href="#分层传输过程和单位" class="headerlink" title="分层传输过程和单位"></a>分层传输过程和单位</h1><p>&nbsp;<br>数据发送时，从第七层传到第一层，接受方则相反。（流程如最上面的图示）</p>
<p>上三层总称应用层，用来控制软件方面。<br>下四层总称数据流层，用来管理硬件。 </p>
<p>数据在发至数据流层的时候将被拆分。 </p>
<h2 id="协议数据单元PDU"><a href="#协议数据单元PDU" class="headerlink" title="协议数据单元PDU"></a>协议数据单元PDU</h2><p>OSI参考模型中，对等层协议之间交换的信息单元统称为协议数据单元(PDU，Protocol Data Unit)。<br>而传输层及以下各层的PDU另外还有各自特定的名称：<br>　传输层——数据段（Segment）<br>　网络层——分组（数据包）（Packet）<br>　数据链路层——数据帧（Frame）<br>　物理层——比特（Bit）</p>
<h1 id="TCP-IP模型和OSI模型的关系和区别"><a href="#TCP-IP模型和OSI模型的关系和区别" class="headerlink" title="TCP/IP模型和OSI模型的关系和区别"></a>TCP/IP模型和OSI模型的关系和区别</h1><p>&nbsp;<br><img src="/images/it_network_osi2.png" alt="UML图"></p>
<p>TCP/IP模型实际上是OSI模型的一个浓缩版本，它只有四个层次：<br>　1.应用层，对应着OSI的应用层、表示层、会话层<br>　2.传输层，对应着OSI的传输层<br>　3.网络层，对应着OSI的网络层<br>　4.网络接口层，对应着OSI的数据链路层和物理层</p>
<p>OSI模型的网络层同时支持面向连接和无连接的通信，但是传输层只支持面向连接的通信；<br>TCP/IP模型的网络层只提供无连接的服务，但是传输层上同时提供两种通信模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_osi1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;中文名 　开放式系统互联&lt;br&gt;外文名 　OSI（Open System Interconnection）&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 网络参考模型" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 各种：取模运算</title>
    <link href="https://hengxing0080.github.io/2017/07/16/it/Algorithm/ModuloOperation/"/>
    <id>https://hengxing0080.github.io/2017/07/16/it/Algorithm/ModuloOperation/</id>
    <published>2017-07-16T12:26:32.000Z</published>
    <updated>2017-07-22T04:27:23.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_modulo1.jpg" alt="UML图"></p>
<p>有些刚毕业刚入职的程序猿同学因为上学时数学学的不好且有些算法好久不用而遗忘，<br>因为模运算在编程算法设计中属于高频使用，<br>而且负数，0,1，小数模于大数等等的模运算当时自己也弄的很迷茫，<br>所以工作多年后用自己白话的方式做了下整理以为遗忘时参考！</p>
<a id="more"></a>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>就是求余数</p>
<h1 id="根据排列组合得出运算规律"><a href="#根据排列组合得出运算规律" class="headerlink" title="根据排列组合得出运算规律"></a>根据排列组合得出运算规律</h1><ul>
<li>1.如果出现负数，只看被模数（左边的数），不看右边，例1%-5=1，-1%5=-1</li>
<li>2.左边是1，结果是1</li>
<li>3.右边是1，结果是0</li>
<li>4.左边小于右边，结果是左边</li>
<li>5.左边等于右边，结果是0</li>
<li>6.左边大于右边，这个就是简单最常用的情况了，直接看有没有余数</li>
</ul>
<h1 id="简单运算示例"><a href="#简单运算示例" class="headerlink" title="简单运算示例"></a>简单运算示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">0%0     NaN     // 除数不能为零，所以无意义，如果是Java编译的就报异常了（ArithmeticException / by zero)</div><div class="line">0%1     0       // 0模于什么都等于0，这组以下以此类推</div><div class="line">0%2     0</div><div class="line">0%100   0</div><div class="line"></div><div class="line">-1%-1   0   </div><div class="line">-1%1    0   </div><div class="line">1%1     0       </div><div class="line">1%2     1       // 那不就是1除以2，余数当然是1</div><div class="line">1%3     1       // 这组得1的都参考运算规律2</div><div class="line">1%4     1     </div><div class="line">-1%5    -1      // 参考运算规律1   </div><div class="line">1%5     1</div><div class="line">1%-5    1     </div><div class="line">1%100   1</div><div class="line"></div><div class="line">2%1     1      </div><div class="line">-2%3    -2</div><div class="line">2%      2</div><div class="line">2/5=?   0       // 如果不做类型转换的话结果去整数部分 所以是0</div><div class="line">2%5=?   2       // 0*5+2=2 所以是2</div><div class="line">2%-100  2       // 参考运算规律1  </div><div class="line"></div><div class="line">-3 % 3  0</div><div class="line">3 % 4   3       // 商0余3，结果为3</div><div class="line"></div><div class="line">-4%5    4       // 4除以5等于0余4，因此结果是4</div><div class="line">4%5     4       </div><div class="line">4%-5    4       // 正负跟第一个数有关，跟第二个无关，正如：-4%5=-4</div><div class="line"></div><div class="line">5 % 6   5</div><div class="line">5 % 9   5</div><div class="line"></div><div class="line">9 % 5   5</div></pre></td></tr></table></figure>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="判别奇偶数"><a href="#判别奇偶数" class="headerlink" title="判别奇偶数"></a>判别奇偶数</h2><p>奇偶数的判别是模运算最基本的应用，也非常简单。<br>已知一个整数n对2取模，如果余数为0，则表示n为偶数，否则n为奇数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"请输入您要判断的数字:"</span>);</div><div class="line">    <span class="keyword">int</span> num=sc.nextInt();</div><div class="line">    <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">        System.out.println(<span class="string">"您输入的是一个偶数"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        System.out.println(<span class="string">"您输入的是一个奇数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><p>质数又称素数,是指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数</p>
<p>一个数，如果只有1和它本身两个因数，这样的数叫做质数（或素数）。<br>例如 2，3，5，7 是质数，而 4，6，8，9 则不是，后者称为合成数或合数。</p>
<p>判断某个自然数是否是素数最常用的方法就是试除法：用比该自然数的平方根小的正整数去除这个自然数，若该自然数能被整除，则说明其非素数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 扫描器，接收控制台输入信息</span></div><div class="line">        System.out.print(<span class="string">"请输入一个整数："</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> num = scan.nextInt();          <span class="comment">// 取出控制台输入的信息</span></div><div class="line">            <span class="keyword">if</span> (isPrime(num)) &#123;     </div><div class="line">                System.out.println(num + <span class="string">"是素数！"</span>);   </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(num + <span class="string">"不是素数！"</span>); </div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"请输入整数"</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于判断一个数是否为素数，若为素数，返回true,否则返回false</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> a 输入的值</div><div class="line">     * <span class="doctag">@return</span> true、false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a &lt; <span class="number">2</span>) &#123; <span class="comment">// 素数不能小于2</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(a); i++) &#123;  <span class="comment">// 巧用开平方函数提高效率</span></div><div class="line">                <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;  <span class="comment">// 若能被整除，则说明不是素数，返回false</span></div><div class="line">                    flag = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="取模运算符在Java和C的不同之处"><a href="#取模运算符在Java和C的不同之处" class="headerlink" title="取模运算符在Java和C的不同之处"></a>取模运算符在Java和C的不同之处</h1><p>Java中：如果两个操作数均是整数，结果也是整数； 如果两个操作数中有一个是浮点数，结果也是浮点数，保留小数部分。这一点和C语言不同。<br>C语言中：%运算符的两个操作数只能是整数，不允许是浮点数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_modulo1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;有些刚毕业刚入职的程序猿同学因为上学时数学学的不好且有些算法好久不用而遗忘，&lt;br&gt;因为模运算在编程算法设计中属于高频使用，&lt;br&gt;而且负数，0,1，小数模于大数等等的模运算当时自己也弄的很迷茫，&lt;br&gt;所以工作多年后用自己白话的方式做了下整理以为遗忘时参考！&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 各种" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%90%84%E7%A7%8D/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
