<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹空间</title>
  <subtitle>时空在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-07-22T10:27:34.645Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：希尔排序</title>
    <link href="https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShell/"/>
    <id>https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShell/</id>
    <published>2017-07-22T09:47:22.000Z</published>
    <updated>2017-07-22T10:27:34.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortshell2.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortshell1.gif" alt="UML图"></p>
<hr>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><hr>
<p>中文名 希尔排序<br>外文名 Shell Sort<br>别名   缩小增量排序<br>类别：插入排序的一种<br>提出者和时间：该方法因设计者希尔（DL．Shell）于1959年提出而得名</p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>首先，大家能都理解，优秀排序算法的首要条件就是速度<sup>24</sup>，但是之前提到的冒泡，选择和插入的时间复杂度都是O(n2)，似乎没法超越了<sup>25</sup>。直到终于有一天，当一位科学家发布超越了O(n<sup>2</sup>)的排序算法，并把内排序算法的时间复杂度提升到了O(nlogn)。<br>在这之前排序算法的时间复杂度基本都是O(n<sup>2</sup>)的，希望排序算法是突破这个时间复杂度的第一批算法之一。</p>
<p>之前写的直接插入排序，其实它的效率在某些时间是很高的。<br>比如，我们的记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很搞笑。<br>还有就是记录数比较少时，直接插入的优势也比较明显。<br>可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。</p>
<p>所以希尔排序可以是直接插入排序改进后的版本，可以增加效率。</p>
<p>希尔排序不同之处就是采取跳跃分割的策略：<br>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</p>
<p>基本有序：<br>就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2,1,3,5,4,7,5,8,9}这样可以成为基本有序了。<br>但像{1,5,9,3,7,8,2,4,6}这样的9在第3位，2在倒数第3位就谈不上基本有序。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>先将整个待排序序列分割成若干子序列，每个子序列由相差一定长度的数据元素组成（这个相差的长度称为增量），然后我们分别对这些子序列<br>进行直接插入排序，一轮排序再取第二个增量，以此类推，需要注意的是，对于希尔排序中增量的确定没有统一的规定，通常的做法是：第一个增量为待排序序列长度的二分之一（取整），然后逐渐减半（取整），知道等于1为止。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p>
<p>希尔排序实质上是一种分组插入的方法！​<br>希尔排序说白了就是把距离不断缩小的插入排序。<br>希尔排序是实现简单但是分析极其困难的一个算法的例子.</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>O(nlogn)<br>O(n<sup>3/2</sup>), 要好于直接排序的O（n<sup>2</sup>）.</p>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些</p>
<h2 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h2><p>另外由于记录是跳跃式的移动，希尔排序并不是一个稳定的排序算法。</p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度都O(n2)），之后。相应的更为高效的排序算法也就相继出现了。</p>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>代码来源：大话数据结构——9.6希尔排序 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> increment=L-&gt;length;</div><div class="line">	<span class="keyword">do</span></div><div class="line">	&#123;</div><div class="line">		increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></div><div class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </div><div class="line">			&#123; </div><div class="line">				L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></div><div class="line">				<span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</div><div class="line">					L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></div><div class="line">				L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"	第%d趟排序结果: "</span>,++k);</div><div class="line">		print(*L);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，增量序列的最后一个增量值必须等于1才行。</p>
<p>通过这段代码的剖析，能看到希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。<br>这里的增量的选取就非常关键了，这里用increment=increment/3+1的方式选取增量的。<br>可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="comment">//int[] data = &#123;9,2,5,15,66,4,37,3,7,55,8,0,6,21&#125;;</span></div><div class="line">     <span class="keyword">int</span>[] data = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>&#125;;</div><div class="line">     <span class="keyword">int</span> length = data.length;</div><div class="line">     System.out.print(<span class="string">"排序前："</span>);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">         System.out.print(data[i]+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     System.out.println();</div><div class="line"></div><div class="line">     shellSort(data,length);</div><div class="line">     System.out.print(<span class="string">"排序后："</span>);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</div><div class="line">         System.out.print(data[i]+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">     <span class="keyword">int</span> temp;            <span class="comment">// 临时变量</span></div><div class="line">     <span class="keyword">int</span> pointer;         <span class="comment">// 进行比较的下表位置</span></div><div class="line">     <span class="keyword">int</span> len = index / <span class="number">2</span>; <span class="comment">// 设置步长增量，分割集合的间隔长度，初始值为数组长度的一半</span></div><div class="line">     <span class="keyword">while</span> (len != <span class="number">0</span>)&#123; <span class="comment">// 1.按每次减半划分步长，直到步长为1</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;index;i++)&#123;  <span class="comment">// 2.对各个集合进行处理（根据步长，设置每轮循环次数）</span></div><div class="line">             pointer = i-len; <span class="comment">// 计算要和当前值进行比较的数的位置</span></div><div class="line">             temp = arr[i];</div><div class="line">             <span class="keyword">while</span>(temp &lt; arr[pointer])&#123; <span class="comment">// 3.将临时变量与集合内的数进行比较（按照步长距离，将临时变量里的值和集合内数值依次进行比较）</span></div><div class="line">                 arr[pointer+len] = arr[pointer];</div><div class="line">                 pointer = pointer - len;</div><div class="line">                 <span class="keyword">if</span>(pointer &lt; <span class="number">0</span>)&#123;  <span class="comment">// 如果当前下标位置大于或等于当前步长则继续循环，按步长与前面所有的数进行比较，直到遇到比当前临时变量小的数为止</span></div><div class="line">                     <span class="keyword">break</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             arr[pointer + len] = temp;<span class="comment">// 把临时变量赋值到当前下标所在位置</span></div><div class="line">         &#125;</div><div class="line">         len = len/<span class="number">2</span>;<span class="comment">//每次递减一半</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><p><a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">百度百科-希尔排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortshell2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：Shaker排序</title>
    <link href="https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShaker/"/>
    <id>https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShaker/</id>
    <published>2017-07-22T04:21:30.000Z</published>
    <updated>2017-07-22T07:33:01.396Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortshaker1.gif" alt="UML图"></p>
<a id="more"></a>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这个算法有好多名称，以下就是收集的名称，这里用Shaker排序来作为本篇文章的正统名称。<br>Shaker排序 (Shaker Sort)<br>双向冒泡排序 (Bidirectional Bubble Sort)<br>鸡尾酒排序 (Cocktail Sort)<br>波浪排序 (Ripple Sort)<br>摇曳排序 (Shuffle Sort)<br>飞梭排序 (Shuttle Sort)<br>欢乐时光排序 (Happy Hour Sort)</p>
<p>其实它是改良的冒泡排序的轻微变形。<br>不同的地方在于，Shaker排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。<br>他可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。</p>
<p>以序列(2,3,4,5,1)为例，Shaker排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。<br>但是在乱数序列状态下，Shaker排序与冒泡排序的效率都很差劲，<br>优点只有原理简单这一点。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>1、 气泡排序的双向进行，先让气泡排序由左向右进行，再来让气泡排序由右往左进行，如此完成一次排序的动作<br>2、 使用left与right两个旗标来记录左右两端已排序的元素位置。</p>
<p>排序过程：<br>先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端<br>再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端<br>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O（n^2）</p>
<h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><h3 id="示例代码1（Java）"><a href="#示例代码1（Java）" class="headerlink" title="示例代码1（Java）"></a>示例代码1（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShakerSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, left = <span class="number">0</span>, </div><div class="line">               right = number.length - <span class="number">1</span>, </div><div class="line">               shift = <span class="number">0</span>; </div><div class="line"></div><div class="line">        <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">            <span class="comment">// 向右进行气泡排序 </span></div><div class="line">            <span class="keyword">for</span>(i = left; i &lt; right; i++) &#123; </div><div class="line">                <span class="keyword">if</span>(number[i] &gt; number[i+<span class="number">1</span>]) &#123; </div><div class="line">                    swap(number, i, i+<span class="number">1</span>); </div><div class="line">                    shift = i; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            right = shift; </div><div class="line"></div><div class="line">            <span class="comment">// 向左进行气泡排序 </span></div><div class="line">            <span class="keyword">for</span>(i = right; i &gt; left; i--) &#123; </div><div class="line">                <span class="keyword">if</span>(number[i] &lt; number[i-<span class="number">1</span>]) &#123; </div><div class="line">                    swap(number, i ,i-<span class="number">1</span>); </div><div class="line">                    shift = i; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            left = shift; </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t; </div><div class="line">        t = number[i]; </div><div class="line">        number[i] = number[j]; </div><div class="line">        number[j] = t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码2（JavaScript）"><a href="#示例代码2（JavaScript）" class="headerlink" title="示例代码2（JavaScript）"></a>示例代码2（JavaScript）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shakerSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = array.length,</div><div class="line">        left = <span class="number">0</span>,</div><div class="line">        right = length - <span class="number">1</span>,</div><div class="line">        lastSwappedLeft = left,</div><div class="line">        lastSwappedRight = right,</div><div class="line">        i,</div><div class="line">        j;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="comment">// 从左到右</span></div><div class="line">        lastSwappedRight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</div><div class="line">                swap(array, i, i + <span class="number">1</span>);</div><div class="line">                lastSwappedRight = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right = lastSwappedRight;</div><div class="line">        <span class="comment">// 从右到左</span></div><div class="line">        lastSwappedLeft = length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (j = right; left &lt; j; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</div><div class="line">                swap(array, j - <span class="number">1</span>, j)</div><div class="line">                lastSwappedLeft = j</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left = lastSwappedLeft;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码3（C）"><a href="#示例代码3（C）" class="headerlink" title="示例代码3（C）"></a>示例代码3（C）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(x,y) &#123;int t; t = x; x = y; y = t;&#125; </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shakersort</span><span class="params">(<span class="keyword">int</span>[])</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> number[MAX] = &#123;<span class="number">0</span>&#125;; </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line"></div><div class="line">    srand(time(<span class="literal">NULL</span>)); </div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"排序前："</span>); </div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) &#123; </div><div class="line">        number[i] = rand() % <span class="number">100</span>; </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    shakersort(number); </div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shakersort</span><span class="params">(<span class="keyword">int</span> number[])</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> i, left = <span class="number">0</span>, right = MAX - <span class="number">1</span>, shift = <span class="number">0</span>; </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">        <span class="comment">// 向右进行气泡排序 </span></div><div class="line">        <span class="keyword">for</span>(i = left; i &lt; right; i++) &#123; </div><div class="line">            <span class="keyword">if</span>(number[i] &gt; number[i+<span class="number">1</span>]) &#123; </div><div class="line">                SWAP(number[i], number[i+<span class="number">1</span>]); </div><div class="line">                shift = i; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        right = shift; </div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n往右排序："</span>); </div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line"></div><div class="line">        <span class="comment">// 向左进行气泡排序 </span></div><div class="line">        <span class="keyword">for</span>(i = right; i &gt; left; i--) &#123; </div><div class="line">            <span class="keyword">if</span>(number[i] &lt; number[i<span class="number">-1</span>]) &#123; </div><div class="line">                SWAP(number[i], number[i<span class="number">-1</span>]); </div><div class="line">                shift = i; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        left = shift; </div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n向左排序："</span>); </div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h2><p><a href="http://blog.csdn.net/xushuaic/article/details/8615253" target="_blank" rel="external">算法 Shaker排序法 - 改良的气泡排序</a><br><a href="https://www.kancloud.cn/kancloud/sort-algorithm/46565" target="_blank" rel="external">鸡尾酒排序 (Cocktail Sort/Shaker Sort)</a><br><a href="http://blog.csdn.net/vivitue/article/details/38716575" target="_blank" rel="external">算法之路 - 双向冒泡排序之Shaker</a><br><a href="http://www.cnblogs.com/wuweiblog/archive/2011/07/11/2103325.html" target="_blank" rel="external">冒泡排序与鸡尾酒排序</a><br><a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Shaker/Shaker.php" target="_blank" rel="external">[演算法] 搖晃排序法(Shaker Sort)</a><br><a href="https://www.codingunit.com/cocktail-sort-algorithm-or-shaker-sort-algorithm" target="_blank" rel="external">Cocktail Sort Algorithm or Shaker Sort Algorithm</a><br><a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" target="_blank" rel="external">SORTING ALGORITHMS: THE COCKTAIL SORT</a><br><a href="http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科-鸡尾酒排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortshaker1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：插入排序</title>
    <link href="https://hengxing0080.github.io/2017/07/21/it/Algorithm/SortInsert/"/>
    <id>https://hengxing0080.github.io/2017/07/21/it/Algorithm/SortInsert/</id>
    <published>2017-07-21T09:47:22.000Z</published>
    <updated>2017-07-21T10:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortInsert4.gif" alt="UML图"><br>过程类似插入扑克牌的过程（一边摸牌，一边理牌）<br><a id="more"></a></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>插入排序（Insertion Sorting）</p>
<p>简单定义就是直接插入排序过程需要将带插入的元素和当前有序序列中所有数据进行比较</p>
<p>每次将一个待排序的数据元素，按照其关键字大小插入到前面已排好序的有序序列的适当位置，使插入以后的数据序列仍然为一个有序序列，直到整个序列成为有序的序列为止。</p>
<p>它是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>从第一个元素开始，该元素可以认为已经被排序.<br>取出下一个元素，在已经排序的元素序列中从后向前扫描.<br>如果该元素（已排序）大于新元素，将该元素移到下一位置.<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置.<br>将新元素插入到该位置中.<br>重复步骤2.</p>
<p>下面是各种插入排序图示流程↓<br><img src="/images/it_algorithm_sortInsert1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortInsert3.gif" alt="UML图"><br><img src="/images/it_algorithm_sortInsert2.gif" alt="UML图"></p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n^2）<br>不过能看出来，同样的复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。</p>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>稳定</p>
<hr>
<h1 id="算法的2种分类"><a href="#算法的2种分类" class="headerlink" title="算法的2种分类"></a>算法的2种分类</h1><hr>
<blockquote>
<p>它有两个形式：直接插入排序，二分插入排序</p>
</blockquote>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>Straight Insertion Sort<br>基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。<br><img src="/images/it_algorithm_sortInsert5.png" alt="UML图"></p>
<h3 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">int</span> currentData = arr[i]; <span class="comment">// 用for循环在数组中提取数据并赋值给currentData</span></div><div class="line">        <span class="keyword">int</span> temp = i;</div><div class="line">        <span class="comment">// 用while循环盘点数组第一个元素是否大于取出的第二个元素，如果大于数组向右移动</span></div><div class="line">        <span class="keyword">while</span> ((temp &gt; <span class="number">0</span>) &amp;&amp; (arr[temp - <span class="number">1</span>] &gt; currentData)) &#123;  </div><div class="line">            arr[temp] = arr[temp - <span class="number">1</span>]; <span class="comment">// 实现了数组的向右移动</span></div><div class="line">            temp--; <span class="comment">// temp为0，while循环结束</span></div><div class="line">        &#125;</div><div class="line">        arr[temp] = currentData; <span class="comment">// 交换数据（将取出的第二个元素赋值给数组中第一个元素）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] data = &#123;<span class="number">23</span>, <span class="number">45</span>, <span class="number">16</span>, <span class="number">7</span>, <span class="number">42</span>&#125;; <span class="comment">// 定义无序数组data</span></div><div class="line">    insertSort(data);</div><div class="line">    <span class="comment">// 页面打印</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:data)&#123;</div><div class="line">        System.out.print(x+<span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码-2（C）"><a href="#示例代码-2（C）" class="headerlink" title="示例代码 2（C）"></a>示例代码 2（C）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];	<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></div><div class="line">	<span class="keyword">int</span> length;			<span class="comment">/* 用于记录顺序表的长度 */</span></div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span> i,j;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></div><div class="line">		&#123;</div><div class="line">			L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></div><div class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</div><div class="line">				L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></div><div class="line">			L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>又称 折半插入排序</p>
<p>折半插入排序算法是对直接插入排序算法的一种改进。<br>在直接插入排序算法中，向有序序列中插入一个元素1，插入位置是把待插入元素关键字与有序序列中元素的关键字逐个比较得到的。</p>
<p>它是将待插入数据与当前有序序列中的平分位置的关键字数据进行比较，从而确定了下一步要平分的子序列，以此类推直到找到合适的插入位置为止。<br><img src="/images/it_algorithm_sortInsert6.png" alt="UML图"></p>
<p>折半插入排序算法的基本思想是：<br>向有序序列中插入元素，那么插入位置可以不断地平分有序序列，并把带插入的元素的关键字与平分有序序列得到的关键字比较，以确定下一步要平分的子序列，直到找到合适的插入位置为止。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] data = &#123;<span class="number">7</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">1</span>&#125;;    <span class="comment">//排序后：1, 7, 16, 23, 42, 45</span></div><div class="line">    <span class="comment">//int[] data2 = &#123;7, 16, 23, 42, 45, 45&#125;;//排序后：7, 16, 23, 42, 45, 45</span></div><div class="line">    BInsertSort(data);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:data)&#123;</div><div class="line">        System.out.print(x+<span class="string">"  "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;  <span class="comment">// 获取数组长度</span></div><div class="line">    <span class="keyword">int</span> insertData = arr[len - <span class="number">1</span>]; <span class="comment">// 待插入元素</span></div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> hign = len - <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt;= hign) &#123;</div><div class="line">        <span class="keyword">int</span> middle = (low + hign) / <span class="number">2</span>; <span class="comment">// 获取数组中间元素下标</span></div><div class="line">        <span class="keyword">if</span>(insertData &lt; arr[middle])&#123;</div><div class="line">            hign = middle - <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            low = middle +<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span>;j&gt;hign+<span class="number">1</span>;j--)&#123;</div><div class="line">        arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    arr[hign+<span class="number">1</span>] = insertData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortInsert4.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;过程类似插入扑克牌的过程（一边摸牌，一边理牌）&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：串</title>
    <link href="https://hengxing0080.github.io/2017/07/20/it/DataStructure/String/"/>
    <id>https://hengxing0080.github.io/2017/07/20/it/DataStructure/String/</id>
    <published>2017-07-20T11:31:51.000Z</published>
    <updated>2017-07-20T11:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_string0.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名 串/字符串<br>英文名 String</p>
<p>串是由零个或多个字符组成的有限序列，又名叫字符串。它也是一种数据结构。<br>（所谓的序列，说明串的相邻字符之间具有前驱和后继的关系）</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>&nbsp;<br>本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找，替换等操作。</p>
<p>一般记为s=”a1a2…….an”(n≥0)，其中s是串的名称，用双引号（有些书里是单引号）括起来的字符序列是串的值，注意单引号不属于串的内容。</p>
<h1 id="各种关键词"><a href="#各种关键词" class="headerlink" title="各种关键词"></a>各种关键词</h1><ul>
<li><p>空串：<br>零个字符串的串称为空串（null string），它的长度为零，可以直接用两双引号””表示，也可以用希腊字母Φ来表示。</p>
</li>
<li><p>空格串：<br>是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</p>
</li>
<li><p>子串与主串：<br>串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。<br>子串在主串中的位置就是子串的第一个字符在主串中的序号。<br>“over”,”end”,”lie”其实可以认为是”lover”,”friend”,”believe”这些单词字符串的子串</p>
</li>
</ul>
<h1 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h1><ul>
<li><p>比较两个串相等<br>必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。<br>即给定两个串：s=”a1a2….an”, t=”b2b2….bm”, 当且仅当n=m, 且a1=b1,a2=b2,……,an=bm时，我们认为s=t.</p>
</li>
<li><p>比较两个串不相等<br>给定两个串：s=”a1a2……an”, t=”b2b2…..bm”, 当满足以下条件之一时，s&lt;t<br>1.n&lt;m，且a1=b1(i=1,2,…..,n) .<br>例如如s=”hap”,t=”happy”,就有s&lt;t。因此t比s多出了两个字母。<br>2.存在某个k≤min(m,n)，使得ai=bi (i=1,2,…..,k-1),ak&lt;bk .<br>例如当s=”happen”,t=”happy”,因为两串的前4个字母均相同，而两串第5个字母（k值），字母e的ASCII码是101，而字母y的ASCII码是121，显然e&lt;y,所以s&lt;t.</p>
</li>
<li><p>例子<br>纸质英语词典：通常都是上万个单词的有序排列。就大小而言，前面的单词比后面的要小，你在查找单词的过程，其实就是在比较字符串大小的过程。<br>电子词典：查找单词实现的原理，其实就是字符串这种数据结构的典型应用。</p>
</li>
</ul>
<hr>
<h1 id="串的存储结构（顺序和链式）"><a href="#串的存储结构（顺序和链式）" class="headerlink" title="串的存储结构（顺序和链式）"></a>串的存储结构（顺序和链式）</h1><hr>
<blockquote>
<p>串的存储结构与线性表相同，分为两种。</p>
</blockquote>
<h2 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h2><p>是用一组地址连续的存储单元来存储串中的字符序列的。<br>按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。<br>一般是定长数组来定义。</p>
<p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。</p>
<p>但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\o”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间。</p>
<p><img src="/images/it_datastructure_string1.png" alt="UML图"></p>
<p>刚才讲的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接Concat、新串的插入Strlnsert、以及字符串的替换Replace，都有可能使得串序列的长度超过了数组的长度MaxSize。</p>
<p>也就是说，串的顺序存储结构的缺点是字符串的截断，截断就是超过预定义长度的串值被舍去。<br>于是对于串的顺序存储，有一些变化，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做“堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理。</p>
<h2 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h2><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用’#”或其他串值字符补全，如图↓<br><img src="/images/it_datastructure_string2.png" alt="UML图"></p>
<p>当然，这里一个结点存多少字符才合适就变得很重要，这回直接影响着处理的效率，需要根据实际情况作出选择。</p>
<p>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_string0.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 算法：递归</title>
    <link href="https://hengxing0080.github.io/2017/07/19/it/Algorithm/Recursion/"/>
    <id>https://hengxing0080.github.io/2017/07/19/it/Algorithm/Recursion/</id>
    <published>2017-07-19T03:26:49.000Z</published>
    <updated>2017-07-19T10:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_recursion1.jpg" alt="UML图"></p>
<blockquote>
<p>递归属于<a href="http://www.hengxing.me/2017/07/18/it/DataStructure/Stack/" target="_blank" rel="external">栈</a>的经典应用方式之一。</p>
</blockquote>
<a id="more"></a>
<h1 id="递归的解释和定义"><a href="#递归的解释和定义" class="headerlink" title="递归的解释和定义"></a>递归的解释和定义</h1><p>&nbsp;<br>递归作为一种算法在程序设计语言中广泛应用。<br>是指函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象。<br>递归是计算机科学的一个重要概念，递归的方法是程序设计中有效的方法，采用递归编写程序能使程序变得简洁和清晰。</p>
<p>简单理解其实就是函数自己调用自己。<br>是指在定义自身的过程中又直接或间接调用自身的一种算法。</p>
<p>在高级语言中，调用自己和其他函数并没有本质的不同。<br>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</p>
<p>递归算法所有解决的问题都是一个问题可以分割为使用相同算法结局的若干子问题。</p>
<h1 id="递归的特点"><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h1><p>&nbsp;<br>一个问题可以被分解成若按简单的子问题<br>子问题和其上层的解决方案一致<br>外层问题的解决依赖于子问题的解决</p>
<h1 id="递归的工作方式"><a href="#递归的工作方式" class="headerlink" title="递归的工作方式"></a>递归的工作方式</h1><p>&nbsp;<br>一个对象函数调用自己的复制品，复制品函数在执行的过程再次复制出一个复制品继续调用，一直继续下去，知道遇到某个条件停止循环递归调用，然后逐层返回，这个过程就是递归的工作方式。</p>
<h1 id="使用递归算法有2个要素注意"><a href="#使用递归算法有2个要素注意" class="headerlink" title="使用递归算法有2个要素注意"></a>使用递归算法有2个要素注意</h1><p>&nbsp;<br>1.至少有一个停止条件，不能无限递归下去，那就是死循环。<br>2.要计算递归方法的当前值，需要重复调用自身，直至达到停止条件。</p>
<h1 id="递归的视觉"><a href="#递归的视觉" class="headerlink" title="递归的视觉"></a>递归的视觉</h1><p>&nbsp;<br><a href="http://baike.baidu.com/link?url=i5jUc80R_n8xl63Hc8pMTNuRRyE_3VNEndFj-CqlT-LpFfRNK_RhLcZhTkhnx6cDYZPC-ORWKKi8aX1_s8uKw4iICH_WW13Kp8VQ7tLwsqCTM6mh6azLIZ9Cr-7WWSNuqV9TBTvaGAaYVq7sQj9EZ_" target="_blank" rel="external">德罗斯特效应</a>是递归的一种视觉形式，它能在视觉上描述递归算法。 效果类似如下↓<br><img src="/images/it_algorithm_recursion2.jpg" alt="UML图"><br>想看更多德罗斯特效应，请<a href="http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94" target="_blank" rel="external">搜索图片</a></p>
<hr>
<h1 id="递归示例1：兔子繁殖问题"><a href="#递归示例1：兔子繁殖问题" class="headerlink" title="递归示例1：兔子繁殖问题"></a>递归示例1：兔子繁殖问题</h1><hr>
<blockquote>
<p>兔子繁殖问题也称兔子数列，属于斐波那契数列，是个很经典的递归例子。</p>
</blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>先说下 斐波那契数列（Fibonacci）</p>
<p>用递归和非递归算法列出Fibonacci数列的前n项几乎是所有程序员都经历过的过程。</p>
<p>特点是数列中的每一项都是前两项的（最前两项都是1）和，即F（n）=F（n-1）+F（n-2）。</p>
<p>斐波那契数列又因意大利数学家列昂纳多·斐波那契（Fibonacci leonardo，约1170-1250）以兔子繁殖为例子而引入，故又称为“兔子数列”。<br>这个数列是意大利中世纪数学家斐波那契在&lt;算盘全书&gt;中提出的。</p>
<p>他在1202年提出了下面的问题描述如下：<br>兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p>
<h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><p>我们不妨拿新出生的一对小兔子分析一下：</p>
<p>第一个月小兔子没有繁殖能力，所以还是一对<br>两个月后，生下一对小兔对数共有两对<br>三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对</p>
<p>依次类推可以列出下表：<br><img src="/images/it_algorithm_recursion3.jpg" alt="UML图"></p>
<p>幼仔对数=前月成兔对数<br>成兔对数=前月成兔对数+前月幼仔对数<br>总体对数=本月成兔对数+本月幼仔对数</p>
<p>如果1到12个月的个数，那么结果为<br>1　1　2　3　5　8　13　21　34　55　89　144</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">月份      不成熟兔子       成熟兔子        数量</div><div class="line">1         1                              1</div><div class="line">2                         1              1</div><div class="line">3         1               1              2</div><div class="line">4         1               2              3</div><div class="line">5         2               3              5  </div><div class="line">6         3               5              8</div><div class="line">7         5               8              13</div><div class="line">8         8               13             21    </div><div class="line">9         13              21             34</div><div class="line">10        21              34             55</div><div class="line">11        34              55             89</div><div class="line">12        55              89             144</div></pre></td></tr></table></figure>
<p>可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。</p>
<p>这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。</p>
<h2 id="图示效果"><a href="#图示效果" class="headerlink" title="图示效果"></a>图示效果</h2><p><img src="/images/it_algorithm_recursion4.png" alt="UML图"><br><img src="/images/it_algorithm_recursion5.png" alt="UML图"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 迭代方式（For循环）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            res = x + y;</div><div class="line">            x = y;</div><div class="line">            y = res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 递归方式</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fRecur</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n== <span class="number">1</span> || n == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> fRecur(n-<span class="number">2</span>)+fRecur(n-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(fFor(<span class="number">6</span>));</div><div class="line">        System.out.println(fRecur(<span class="number">6</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123; </div><div class="line">            System.out.println(fRecur(i)+<span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">迭代和递归的区别是：</div><div class="line">迭代使用的是循环结构，递归使用的是选择结构。</div><div class="line">但是大量的递归调用会简历函数的副本，会耗费大量的时间和内存。</div><div class="line">迭代则不需要反复调用函数和占用额外的内存。</div><div class="line">因此应该视不同情况选择不同的代码实现方式。</div><div class="line">*/</div></pre></td></tr></table></figure>
<hr>
<h1 id="递归示例2：猴子吃桃问题"><a href="#递归示例2：猴子吃桃问题" class="headerlink" title="递归示例2：猴子吃桃问题"></a>递归示例2：猴子吃桃问题</h1><hr>
<p>猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。<br>第二天早上又将剩下的桃子吃掉一半，又多吃了一个。<br>以后每天早上都吃了前一天剩下的一半零一个。<br>到第10天早上想再吃时，见只剩下一个桃子了。<br>求第一天共摘了多少？或者说第1天到10天每天桃子的数量是多少？</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>第10天~第1天的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1       // 第10天：因为上面说了第10天就剩1个了</div><div class="line">4       // 第9天：1*2+1=3+1=4</div><div class="line">10      // 第8天：4*2+1=9+1=10</div><div class="line">22      // 第7天：10*2+1=21+1=22</div><div class="line">46      // 第6天：22*2+1=45+1=46</div><div class="line">94      // 第5天：46*2+1=93+1=94</div><div class="line">190     // 第4天：94*2+1=189+1=190</div><div class="line">382     // 第3天：190*2+1=381+1=382</div><div class="line">766     // 第2天：382*2+1=765+1=766</div><div class="line">1534    // 第1天：766*2+1=1533+1=1534</div></pre></td></tr></table></figure>
<h2 id="示例代码1（迭代算法）"><a href="#示例代码1（迭代算法）" class="headerlink" title="示例代码1（迭代算法）"></a>示例代码1（迭代算法）</h2><p>当然，do while和if都是类似的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> day=<span class="number">10</span>,x1=<span class="number">0</span>,x2=<span class="number">1</span>,eatNum;</div><div class="line">    <span class="keyword">for</span>(;day&gt;<span class="number">0</span>;day--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(day==<span class="number">10</span>)&#123;</div><div class="line">           x1 = <span class="number">1</span>;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"猴子在第 %d 天有 %d 个桃子。\n"</span>,day, x1);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">           x1=(x2+<span class="number">1</span>)*<span class="number">2</span>;  <span class="comment">// 每前一天的桃子数都等一现在剩余的桃子数加一在乘以二  </span></div><div class="line">           x2=x1;</div><div class="line">           eatNum = x1/<span class="number">2</span>+<span class="number">1</span>;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"猴子在第 %d 天有 %d 个桃子，当天吃了 %d 个桃子。\n"</span>,day,x1, eatNum);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果<br><img src="/images/it_algorithm_recursion6.jpg" alt="UML图"></p>
<h2 id="示例代码2-1（递归算法：C）"><a href="#示例代码2-1（递归算法：C）" class="headerlink" title="示例代码2.1（递归算法：C）"></a>示例代码2.1（递归算法：C）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span> (d == <span class="number">10</span>)        </div><div class="line">        sum = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;<span class="number">10</span>)   </div><div class="line">        sum = <span class="number">2</span> * (num(d + <span class="number">1</span>) + <span class="number">1</span>);  </div><div class="line">    <span class="keyword">return</span> sum;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">main() &#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> day = <span class="number">10</span>;</div><div class="line">    <span class="keyword">while</span>(day&gt;<span class="number">0</span>)&#123;</div><div class="line">         sum = num(day);  </div><div class="line">         day--;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"猴子一共摘了 %d 个桃子。\n"</span>, sum);  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码2-2（递归算法：Java）"><a href="#示例代码2-2（递归算法：Java）" class="headerlink" title="示例代码2.2（递归算法：Java）"></a>示例代码2.2（递归算法：Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> day = <span class="number">10</span>;</div><div class="line">        <span class="keyword">while</span>(day &gt; <span class="number">0</span>)&#123;</div><div class="line">            System.out.println(<span class="string">"猴子第"</span>+day+<span class="string">"天的桃子数量："</span>+getTotalNum(day));</div><div class="line">            day--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">10</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (getTotalNum(n + <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_recursion1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归属于&lt;a href=&quot;http://www.hengxing.me/2017/07/18/it/DataStructure/Stack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;栈&lt;/a&gt;的经典应用方式之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 各种" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%90%84%E7%A7%8D/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：栈和队列的总结</title>
    <link href="https://hengxing0080.github.io/2017/07/18/it/DataStructure/StackAndQueue/"/>
    <id>https://hengxing0080.github.io/2017/07/18/it/DataStructure/StackAndQueue/</id>
    <published>2017-07-18T12:50:39.000Z</published>
    <updated>2017-07-18T12:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_stackandqueue1.png" alt="UML图"></p>
<a id="more"></a>
<p>1.它们都是特殊的线性表，只不过对插入和删除操作做了限制：<br>栈：限定仅在表尾进行插入和删除操作的线性表。<br>队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>2.栈和队列的顺序存储结构：<br>它们都可以用线性表的顺序存储结构实现，但都存在着顺序存储的一些弊端，因此它们各自有一些技巧解决这个问题。<br>对于栈来说，如果两个相同数据类型的栈，则可以用数组的两端作栈底的方法让两个栈共享数据，最大化利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，引入循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
<p>3.栈和队列的链式存储结构：<br>栈和队列的链式存储结构的实现原理和线性表的实现原理基本上相同。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_stackandqueue1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：栈</title>
    <link href="https://hengxing0080.github.io/2017/07/18/it/DataStructure/Stack/"/>
    <id>https://hengxing0080.github.io/2017/07/18/it/DataStructure/Stack/</id>
    <published>2017-07-18T09:28:23.000Z</published>
    <updated>2017-07-18T12:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_stack1.png" alt="UML图"></p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;<br>中文名 栈<br>英文名 Stack<br>又名   堆栈</p>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>&nbsp;<br>栈是限定仅在表尾进行插入和删除操作的线性表</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>&nbsp;<br>它是一种运算受限的线性表。<br>其限制是仅允许在表的一端进行插入和删除运算。<br>访问栈中的元素时，遵守后进先出的运算规则。<br>因此，栈也成为后进先出表（Last In First Out的线性表），简称LIFO。</p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。<br>这也就使得：栈底是固定的，最先进栈的只能在栈底。<br><img src="/images/it_datastructure_stack2.png" alt="UML图"></p>
<h1 id="情景比喻"><a href="#情景比喻" class="headerlink" title="情景比喻"></a>情景比喻</h1><p>&nbsp;<br>中文解释是存储货物或供旅客住宿的房屋。</p>
<p>如同一个杯子，水桶。<br>水桶相当于栈，往水桶里倒水就是进栈，相反，把水桶里的水导出来就是出栈。<br>水桶的底部就是栈底，水桶的顶部就是栈顶。<br>由于后进先出规则，先导入水桶的水当我们倒出的时间肯定是最后才倒出来。</p>
<h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p>&nbsp;<br>空栈：不包含任何数据元素的栈称为空栈。　<br>栈顶和栈底：我们把允许插入和删除的一段称为栈顶（top），另一端称为栈底（botton）<br>栈顶元素和栈底元素：存储在栈底位置的数据元素称为栈底元素，反之，在栈顶的叫栈顶元素。<br>进栈入栈/压栈：push（压），插入的操作，类似子弹压入（入弹夹）<br>出栈/退栈：pop（弹），删除的操作，类似弹夹的子弹弹出（出夹）</p>
<h1 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h1><p>&nbsp;<br>由于栈本身就是一个线性表，那么线性表的顺序存储和链式存储，对于栈也是同样适用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ADT 栈(stack)  </div><div class="line">Data  </div><div class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后堆关系。  </div><div class="line">Operation  </div><div class="line">    InitStack ( *S )：初始化操作.建立一个空栈S。  </div><div class="line">    DestroyStack ( *S )：若栈存在，則销毁它。  </div><div class="line">    ClearStack (*S)：将栈清空。  </div><div class="line">    StackEmpty ( S ):若栈为空，返回true,否則返回 false。  </div><div class="line">    GetTop (S,*e)：若栈存在且非空，用e返回S的栈顶元素。  </div><div class="line">    Push (*S,e)：若栈S存在，插入新元素e到栈S中并成为栈頂元素。  </div><div class="line">    Pop (*S,*e)：删除栈S中栈顶元素，并用e返回其值。  </div><div class="line">    StackLength (S)：返回回栈S的元素个数。  </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h1 id="栈的两种存储方式"><a href="#栈的两种存储方式" class="headerlink" title="栈的两种存储方式"></a>栈的两种存储方式</h1><p>&nbsp;<br>栈的种类分为顺序栈和链栈</p>
<hr>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><hr>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>栈的顺序存储结构简称顺序栈。<br>顺序栈用一组连续的存储单元依次存放从栈底到栈顶的数据元素。同时用一个指针top指示栈顶元素在顺序栈中的位置。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.数据元素存放在连续的存储地址中。<br>2.栈底位置固定不变。<br>3.栈顶位置随进栈，出栈操作而变化。 </p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>很方便，因为它只准栈顶进出元素，所以不存在线性表插入和删除时移动元素的问题。</p>
<h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><p>必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。</p>
<h3 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h3><p>空栈：top == -1<br>满栈：top == MAXSIZE -1</p>
<h3 id="栈的结构定义"><a href="#栈的结构定义" class="headerlink" title="栈的结构定义"></a>栈的结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType; <span class="comment">/* SElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="comment">/* 顺序栈结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">        SElemType data[MAXSIZE];</div><div class="line">        <span class="keyword">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></div><div class="line">&#125;SqStack;</div></pre></td></tr></table></figure>
<p>若现在有一个栈，StackSize是5，则栈普通情况，空栈和栈满的情况示意图</p>
<p><img src="/images/it_datastructure_stack3.png" alt="UML图"></p>
<h3 id="进出栈操作"><a href="#进出栈操作" class="headerlink" title="进出栈操作"></a>进出栈操作</h3><p>两者没有涉及任何循环语句，因此时间复杂度是O(1)<br>进栈图示<br><img src="/images/it_datastructure_stack4.png" alt="UML图"></p>
<p>进栈代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S,SElemType e)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>) <span class="comment">/* 栈满 */</span></div><div class="line">        &#123;</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        S-&gt;top++;		   <span class="comment">/* 栈顶指针增加一 */</span></div><div class="line">        S-&gt;data[S-&gt;top]=e; <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出栈代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S,SElemType *e)</span></span></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        *e=S-&gt;data[S-&gt;top];	<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></div><div class="line">        S-&gt;top--;			<span class="comment">/* 栈顶指针减一 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>对于与一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于与两个相同类似的栈，我们可以做到最大限度的利用其事先开辟的存储空间来进行操作。</p>
<p>比如数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标0处，另一个栈为栈的末端，即下标为数组长度n-1处。<br>这样，两个栈如果增加元素，就是两端点向中间延伸.</p>
<p>关键思路：它们是数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈可以一直使用。</p>
<p>这里可以分析出来<br>栈1为空时：top1 == -1<br>栈2为空时：top2 == n<br>栈满情况1：若栈2是空栈，栈1的top1 == n -1，就是栈1满了<br>栈满情况2：反之，栈1为空栈时，top2 == 0，为栈2满<br>栈满情况3：两个栈见面之时，就是指针之间相差1时，即top1+1 == top2为栈满</p>
<h4 id="两栈共享空间的结构"><a href="#两栈共享空间的结构" class="headerlink" title="两栈共享空间的结构"></a>两栈共享空间的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 两栈共享空间结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></div><div class="line">&#123;</div><div class="line">        SElemType data[MAXSIZE];</div><div class="line">        <span class="keyword">int</span> top1;	<span class="comment">/* 栈1栈顶指针 */</span></div><div class="line">        <span class="keyword">int</span> top2;	<span class="comment">/* 栈2栈顶指针 */</span></div><div class="line">&#125;SqDoubleStack;</div></pre></td></tr></table></figure>
<h4 id="两栈共享空间的push方法"><a href="#两栈共享空间的push方法" class="headerlink" title="两栈共享空间的push方法"></a>两栈共享空间的push方法</h4><p>除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="keyword">int</span> stackNumber)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)	<span class="comment">/* 栈已满，不能再push新元素了 */</span></div><div class="line">                <span class="keyword">return</span> ERROR;	</div><div class="line">        <span class="keyword">if</span> (stackNumber==<span class="number">1</span>)			<span class="comment">/* 栈1有元素进栈 */</span></div><div class="line">                S-&gt;data[++S-&gt;top1]=e; <span class="comment">/* 若是栈1则先top1+1后给数组元素赋值。 */</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)	<span class="comment">/* 栈2有元素进栈 */</span></div><div class="line">                S-&gt;data[--S-&gt;top2]=e; <span class="comment">/* 若是栈2则先top2-1后给数组元素赋值。 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不用担心溢出问题的</p>
<h4 id="两栈共享空间的pop方法"><a href="#两栈共享空间的pop方法" class="headerlink" title="两栈共享空间的pop方法"></a>两栈共享空间的pop方法</h4><p>参数就只是判断栈1栈2的参数stackNumber</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="keyword">int</span> stackNumber)</span></span></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span> (stackNumber==<span class="number">1</span>) </div><div class="line">        &#123;</div><div class="line">                <span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>) </div><div class="line">                        <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈1已经是空栈，溢出 */</span></div><div class="line">                *e=S-&gt;data[S-&gt;top1--]; <span class="comment">/* 将栈1的栈顶元素出栈 */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)</div><div class="line">        &#123; </div><div class="line">                <span class="keyword">if</span> (S-&gt;top2==MAXSIZE) </div><div class="line">                        <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈2已经是空栈，溢出 */</span></div><div class="line">                *e=S-&gt;data[S-&gt;top2++]; <span class="comment">/* 将栈2的栈顶元素出栈 */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是针对两个具有数据类型的栈的一个设计上的技巧，如果是不同数据类型的栈，这种办法不但不能更好处理问题，反而使问题变得更复杂，所以要注意这个前提。</p>
<hr>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><hr>
<p>栈的链式存储结构</p>
<p><img src="/images/it_datastructure_stack5.png" alt="UML图"></p>
<h3 id="链栈的栈满"><a href="#链栈的栈满" class="headerlink" title="链栈的栈满"></a>链栈的栈满</h3><p>不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统面临死机崩溃的情况，而不是这个链栈是否溢出的问题。</p>
<h3 id="链栈的空栈"><a href="#链栈的空栈" class="headerlink" title="链栈的空栈"></a>链栈的空栈</h3><p>因链表定义是头指针指向空，那么链栈的空其实就是top=NULL </p>
<h3 id="链栈的结构代码"><a href="#链栈的结构代码" class="headerlink" title="链栈的结构代码"></a>链栈的结构代码</h3><p>链栈的操作绝大部分和单链表类似，只是在插入和删除上特殊一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 链栈结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></div><div class="line">&#123;</div><div class="line">        SElemType data;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;StackNode,*LinkStackPtr;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">        LinkStackPtr top;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">&#125;LinkStack;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">visit</span><span class="params">(SElemType c)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,c);</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链栈的进栈操作"><a href="#链栈的进栈操作" class="headerlink" title="链栈的进栈操作"></a>链栈的进栈操作</h3><p>假设元素值为e的新结点是s，top为栈顶指针。<br>图示↓<br><img src="/images/it_datastructure_stack6.png" alt="UML图"></p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span></div><div class="line">&#123;</div><div class="line">        LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); </div><div class="line">        s-&gt;data=e; </div><div class="line">        s-&gt;next=S-&gt;top;	<span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */</span></div><div class="line">        S-&gt;top=s;         <span class="comment">/* 将新的结点s赋值给栈顶指针，见图中② */</span></div><div class="line">        S-&gt;count++;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="链栈的出栈操作"><a href="#链栈的出栈操作" class="headerlink" title="链栈的出栈操作"></a>链栈的出栈操作</h3><p>假设变量p用来存储要删除的栈顶节点，将栈顶指针下移一位，最后释放p即可。<br>图示↓<br><img src="/images/it_datastructure_stack7.png" alt="UML图"></p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span></div><div class="line">&#123; </div><div class="line">        LinkStackPtr p;</div><div class="line">        <span class="keyword">if</span>(StackEmpty(*S))</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        *e=S-&gt;top-&gt;data;</div><div class="line">        p=S-&gt;top;	      <span class="comment">/* 将栈顶结点赋值给p，见图中③ */</span></div><div class="line">        S-&gt;top=S-&gt;top-&gt;next;  <span class="comment">/* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span></div><div class="line">        <span class="built_in">free</span>(p);              <span class="comment">/* 释放结点p */</span>        </div><div class="line">        S-&gt;count--;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="顺序栈与链栈的对比"><a href="#顺序栈与链栈的对比" class="headerlink" title="顺序栈与链栈的对比"></a>顺序栈与链栈的对比</h3><p>进出栈都很简单，没有任何循环操作，时间复杂度均为0(1)<br>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。<br>所以他没的区别和线性表讨论的一样，如果栈的使用过程元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果变化在可控范围内，建议使用顺序栈会更好一些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_stack1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络 —— 网络参考模型：OSI</title>
    <link href="https://hengxing0080.github.io/2017/07/17/it/NetworkProtocol/OSI/"/>
    <id>https://hengxing0080.github.io/2017/07/17/it/NetworkProtocol/OSI/</id>
    <published>2017-07-17T12:17:29.000Z</published>
    <updated>2017-07-18T11:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_osi1.png" alt="UML图"></p>
<p>中文名 　开放式系统互联<br>外文名 　OSI（Open System Interconnection）</p>
<a id="more"></a>
<h1 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h1><p>&nbsp;<br>OSI参考模型（开放式系统互联参考模型（Open System Interconnect Reference Model）<br>国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。</p>
<h1 id="设计目的和用途"><a href="#设计目的和用途" class="headerlink" title="设计目的和用途"></a>设计目的和用途</h1><p>&nbsp;<br>最早的时候网络刚刚出现的时候，很多大型的公司都拥有了网络技术，公司内部计算机可以相互连接，可以却不能与其它公司连接。<br>因为没有一个统一的规范。计算机之间相互传输的信息对方不能理解。所以不能互联。<br>ISO为了更好的使网络应用更为普及，就推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。 </p>
<p>OSI参考模型是ISO（国际标准化组织）ISO的建议，和国际电报电话咨询委员会(CCITT)这个组织在1985年研究联合制定的的开放系统互连网络互联模型，为开放式互连信息系统提供了一种功能结构的框架。<br>它是为了使各层上的协议国际标准化而发展起来的。</p>
<p>OSI模型用途相当广泛。<br>比如交换机、集线器、路由器等很多网络设备的设计都是参照OSI模型设计的。</p>
<h1 id="七层结构"><a href="#七层结构" class="headerlink" title="七层结构"></a>七层结构</h1><p>&nbsp;<br>OSI它把网络协议从逻辑上分为了7层。<br>它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<ul>
<li><p><strong>应用层（Appication layer）</strong><br>功能：文件传输、电子邮件、文件服务、虚拟终端、浏览器、Web开发、我们面对机器也在这层。<br>TCP/IP网络协议：HTTP、FTP、DNS、Telnet、TFTP、SMTP、RIP、NFS。</p>
</li>
<li><p><strong>表示层（Presentation layer）</strong><br>功能：数据格式化，代码转换，数据加密。<br>没有协议</p>
</li>
<li><p><strong>会话层（Session layer）</strong><br>功能：解除或建立与别的接点的联系。<br>没有协议</p>
</li>
<li><p><strong>传输层（Transport layer）</strong><br>功能：提供端对端的接口。<br>TCP/IP网络协议：：TCP、UDP。<br>PS:网络编程在这2个层：传输层、网际层。</p>
</li>
<li><p><strong>网络层/网际层（Network layer）</strong><br>功能：为数据包选择路由。<br>TCP/IP网络协议：IP、ICMP、ARP、RARP、RIP、OSPF、BGP、IGMP。</p>
</li>
<li><p><strong>数据链路层（Data link layer）</strong><br>功能：传输有地址的帧以及错误检测功能。<br>TCP/IP网络协议：SLIP、CSLIP、PPP、ARP、RARP、MTU。</p>
</li>
<li><p><strong>物理层（Physical layer）</strong><br>功能：以二进制数据形式在物理媒体上传输数据、网线、光纤、无线（红外、蓝牙）。<br>TCP/IP网络协议：ISO2110、IEEE802、IEEE802.2。</p>
</li>
</ul>
<h1 id="分层传输过程和单位"><a href="#分层传输过程和单位" class="headerlink" title="分层传输过程和单位"></a>分层传输过程和单位</h1><p>&nbsp;<br>数据发送时，从第七层传到第一层，接受方则相反。（流程如最上面的图示）</p>
<p>上三层总称应用层，用来控制软件方面。<br>下四层总称数据流层，用来管理硬件。 </p>
<p>数据在发至数据流层的时候将被拆分。 </p>
<h2 id="协议数据单元PDU"><a href="#协议数据单元PDU" class="headerlink" title="协议数据单元PDU"></a>协议数据单元PDU</h2><p>OSI参考模型中，对等层协议之间交换的信息单元统称为协议数据单元(PDU，Protocol Data Unit)。<br>而传输层及以下各层的PDU另外还有各自特定的名称：<br>　传输层——数据段（Segment）<br>　网络层——分组（数据包）（Packet）<br>　数据链路层——数据帧（Frame）<br>　物理层——比特（Bit）</p>
<h1 id="TCP-IP模型和OSI模型的关系和区别"><a href="#TCP-IP模型和OSI模型的关系和区别" class="headerlink" title="TCP/IP模型和OSI模型的关系和区别"></a>TCP/IP模型和OSI模型的关系和区别</h1><p>&nbsp;<br><img src="/images/it_network_osi2.png" alt="UML图"></p>
<p>TCP/IP模型实际上是OSI模型的一个浓缩版本，它只有四个层次：<br>　1.应用层，对应着OSI的应用层、表示层、会话层<br>　2.传输层，对应着OSI的传输层<br>　3.网络层，对应着OSI的网络层<br>　4.网络接口层，对应着OSI的数据链路层和物理层</p>
<p>OSI模型的网络层同时支持面向连接和无连接的通信，但是传输层只支持面向连接的通信；<br>TCP/IP模型的网络层只提供无连接的服务，但是传输层上同时提供两种通信模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_osi1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;中文名 　开放式系统互联&lt;br&gt;外文名 　OSI（Open System Interconnection）&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 网络参考模型" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 各种：取模运算</title>
    <link href="https://hengxing0080.github.io/2017/07/16/it/Algorithm/ModuloOperation/"/>
    <id>https://hengxing0080.github.io/2017/07/16/it/Algorithm/ModuloOperation/</id>
    <published>2017-07-16T12:26:32.000Z</published>
    <updated>2017-07-22T04:27:23.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_modulo1.jpg" alt="UML图"></p>
<p>有些刚毕业刚入职的程序猿同学因为上学时数学学的不好且有些算法好久不用而遗忘，<br>因为模运算在编程算法设计中属于高频使用，<br>而且负数，0,1，小数模于大数等等的模运算当时自己也弄的很迷茫，<br>所以工作多年后用自己白话的方式做了下整理以为遗忘时参考！</p>
<a id="more"></a>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>就是求余数</p>
<h1 id="根据排列组合得出运算规律"><a href="#根据排列组合得出运算规律" class="headerlink" title="根据排列组合得出运算规律"></a>根据排列组合得出运算规律</h1><ul>
<li>1.如果出现负数，只看被模数（左边的数），不看右边，例1%-5=1，-1%5=-1</li>
<li>2.左边是1，结果是1</li>
<li>3.右边是1，结果是0</li>
<li>4.左边小于右边，结果是左边</li>
<li>5.左边等于右边，结果是0</li>
<li>6.左边大于右边，这个就是简单最常用的情况了，直接看有没有余数</li>
</ul>
<h1 id="简单运算示例"><a href="#简单运算示例" class="headerlink" title="简单运算示例"></a>简单运算示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">0%0     NaN     // 除数不能为零，所以无意义，如果是Java编译的就报异常了（ArithmeticException / by zero)</div><div class="line">0%1     0       // 0模于什么都等于0，这组以下以此类推</div><div class="line">0%2     0</div><div class="line">0%100   0</div><div class="line"></div><div class="line">-1%-1   0   </div><div class="line">-1%1    0   </div><div class="line">1%1     0       </div><div class="line">1%2     1       // 那不就是1除以2，余数当然是1</div><div class="line">1%3     1       // 这组得1的都参考运算规律2</div><div class="line">1%4     1     </div><div class="line">-1%5    -1      // 参考运算规律1   </div><div class="line">1%5     1</div><div class="line">1%-5    1     </div><div class="line">1%100   1</div><div class="line"></div><div class="line">2%1     1      </div><div class="line">-2%3    -2</div><div class="line">2%      2</div><div class="line">2/5=?   0       // 如果不做类型转换的话结果去整数部分 所以是0</div><div class="line">2%5=?   2       // 0*5+2=2 所以是2</div><div class="line">2%-100  2       // 参考运算规律1  </div><div class="line"></div><div class="line">-3 % 3  0</div><div class="line">3 % 4   3       // 商0余3，结果为3</div><div class="line"></div><div class="line">-4%5    4       // 4除以5等于0余4，因此结果是4</div><div class="line">4%5     4       </div><div class="line">4%-5    4       // 正负跟第一个数有关，跟第二个无关，正如：-4%5=-4</div><div class="line"></div><div class="line">5 % 6   5</div><div class="line">5 % 9   5</div><div class="line"></div><div class="line">9 % 5   5</div></pre></td></tr></table></figure>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="判别奇偶数"><a href="#判别奇偶数" class="headerlink" title="判别奇偶数"></a>判别奇偶数</h2><p>奇偶数的判别是模运算最基本的应用，也非常简单。<br>已知一个整数n对2取模，如果余数为0，则表示n为偶数，否则n为奇数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"请输入您要判断的数字:"</span>);</div><div class="line">    <span class="keyword">int</span> num=sc.nextInt();</div><div class="line">    <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">        System.out.println(<span class="string">"您输入的是一个偶数"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        System.out.println(<span class="string">"您输入的是一个奇数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><p>质数又称素数,是指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数</p>
<p>一个数，如果只有1和它本身两个因数，这样的数叫做质数（或素数）。<br>例如 2，3，5，7 是质数，而 4，6，8，9 则不是，后者称为合成数或合数。</p>
<p>判断某个自然数是否是素数最常用的方法就是试除法：用比该自然数的平方根小的正整数去除这个自然数，若该自然数能被整除，则说明其非素数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 扫描器，接收控制台输入信息</span></div><div class="line">        System.out.print(<span class="string">"请输入一个整数："</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> num = scan.nextInt();          <span class="comment">// 取出控制台输入的信息</span></div><div class="line">            <span class="keyword">if</span> (isPrime(num)) &#123;     </div><div class="line">                System.out.println(num + <span class="string">"是素数！"</span>);   </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(num + <span class="string">"不是素数！"</span>); </div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"请输入整数"</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于判断一个数是否为素数，若为素数，返回true,否则返回false</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> a 输入的值</div><div class="line">     * <span class="doctag">@return</span> true、false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a &lt; <span class="number">2</span>) &#123; <span class="comment">// 素数不能小于2</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(a); i++) &#123;  <span class="comment">// 巧用开平方函数提高效率</span></div><div class="line">                <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;  <span class="comment">// 若能被整除，则说明不是素数，返回false</span></div><div class="line">                    flag = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="取模运算符在Java和C的不同之处"><a href="#取模运算符在Java和C的不同之处" class="headerlink" title="取模运算符在Java和C的不同之处"></a>取模运算符在Java和C的不同之处</h1><p>Java中：如果两个操作数均是整数，结果也是整数； 如果两个操作数中有一个是浮点数，结果也是浮点数，保留小数部分。这一点和C语言不同。<br>C语言中：%运算符的两个操作数只能是整数，不允许是浮点数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_modulo1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;有些刚毕业刚入职的程序猿同学因为上学时数学学的不好且有些算法好久不用而遗忘，&lt;br&gt;因为模运算在编程算法设计中属于高频使用，&lt;br&gt;而且负数，0,1，小数模于大数等等的模运算当时自己也弄的很迷茫，&lt;br&gt;所以工作多年后用自己白话的方式做了下整理以为遗忘时参考！&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 各种" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%90%84%E7%A7%8D/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：队列</title>
    <link href="https://hengxing0080.github.io/2017/07/15/it/DataStructure/Queue/"/>
    <id>https://hengxing0080.github.io/2017/07/15/it/DataStructure/Queue/</id>
    <published>2017-07-15T09:50:32.000Z</published>
    <updated>2017-07-18T12:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_queue1.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 队列<br>英文名 Queue</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>队列是一种先进先出（First in First out（缩写FIFO））一种特殊的线性表<br>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，<br>和栈一样，队列是一种操作受限制的线性表。<br>进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<h1 id="情景比喻"><a href="#情景比喻" class="headerlink" title="情景比喻"></a>情景比喻</h1><p>队列非常好理解<br>如同一个水管<br>或者就像电影院前人们站成的排一样，第一个进入队列的人最先买票（出列），最后面的人不断紧跟队伍排队（入列）。<br><img src="/images/it_datastructure_queue2.png" alt="UML图"></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>队列在程序设计中用得非常频繁<br>如操作系统和客服系统<br>键盘进行各种字母数字的输入，到显示器上如记事本软件上的输出，其实就是队列的典型应用。</p>
<h1 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h1><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT 队列（Queue）</div><div class="line">Data</div><div class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</div><div class="line">Operatoion</div><div class="line">    InitQueue( *Q )</div><div class="line">        初始化操作，构造一个空队列Q。</div><div class="line">    DestroyQueue ( *Q )</div><div class="line">      	若队列Q已存在，则销毁它。</div><div class="line">    ClearQueue ( *Q )</div><div class="line">      	将Q清为空队列。</div><div class="line">    QueueEmpty( Q )</div><div class="line">     	若Q为空队列，则返回TRUE，否则返回FALSE。</div><div class="line">    QueueLength( Q )</div><div class="line">      	返回Q的数据元素个数，即队列的长度。</div><div class="line">    GetHead( Q, *e )</div><div class="line">     	队列Q已存在且非空，用e返回Q的队头元素。</div><div class="line">    EnQueue( *Q, e )</div><div class="line">      	队列Q已存在，插入元素e为Q的新的队尾元素。</div><div class="line">    DeQueue( *Q, *e )</div><div class="line">      	队列Q已存在且非空，删除Q的队头元素，并用e返回其值。</div><div class="line">endADT</div></pre></td></tr></table></figure>
<hr>
<h1 id="队列的两种存储方式"><a href="#队列的两种存储方式" class="headerlink" title="队列的两种存储方式"></a>队列的两种存储方式</h1><hr>
<p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。<br>先看下队列的顺序存储结构。</p>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>队列的顺序储存结构称为顺序队列，就是用一组地址连续的存储空间来存放队列中的数据元素的。<br>顺序队列是队列的一种，它具有队列的特征。<br>顺序队列使用front和rear两个指针分别指示队头元素和队尾元素的位置。<br>顺序队列只能从队头（front端）删除元素，向队尾（rear端）添加新元素。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.静态分配存储空间。<br>2.入队操作只能在队尾，出队操作只能在队首<br>3.队列为空时，front = rear<br>4.队列为满时， rear = 队列长度 -1<br>5.队列非空非满时，Front &lt; rear &lt; 队列长度 -1</p>
<h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。</p>
<p>假设长度为5的数组，front与rear指针均指向下标为0的的位置，然后入队a1,a2,a3,a3,a4,front指针依然指向下标为0位置，而rear指针指向下标为4的位置<br><img src="/images/it_datastructure_queue3.png" alt="UML图"></p>
<p>出队a1,a2,则dfront指针指向下标为2的位置，rear不变，再入队a5,此时front指针不变，rear指针移动到数组之外？（问题来了）<br><img src="/images/it_datastructure_queue4.png" alt="UML图"></p>
<p>问题还不止于此。假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的，这种现象叫做’假溢出’.</p>
<p>解决假溢出的方法就是后面满了，就再从头开始，也就是头尾相接的循环，<br>把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>对于队列来说，为了避免数组插入和删除时需要移动数据，引入循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
<h4 id="判断公式"><a href="#判断公式" class="headerlink" title="判断公式"></a>判断公式</h4><ul>
<li><p><strong>1.判断空队列条件</strong><br>front == rear</p>
<p>  不过下列图中有个问题<br>  <img src="/images/it_datastructure_queue5.png" alt="UML图"><br>  正常通用的情况是空队列时，front等于rear，不过上述图中当队列满时也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>
<p>  办法1：设置一个标志遍历flag，当front == rear，且flag = 0时为队列空，当front==rear，且flag = 1时为队列满。</p>
<p>  办法2：当队列空时，条件就是front = rear当队列满时，我们修改其条件，数组中保留一个空闲元素空间。如上图左，我们就认为此队列已经满了，也就是说，不允许右图情况出现。</p>
</li>
<li><p><strong>2.判断满队列条件</strong><br>(rear+1)%QueueSize == front</p>
</li>
<li><p><strong>3.获取通用计算队列长度公式</strong><br>(rear-front+QueueSize)%QueueSize</p>
</li>
</ul>
<hr>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">    QElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> front;      <span class="comment">/* 头指针 */</span></div><div class="line">    <span class="keyword">int</span> rear;       <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></div><div class="line">&#125;SqQueue;</div><div class="line"></div><div class="line"><span class="comment">/* 初始化一个空队列Q */</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></div><div class="line">&#123;</div><div class="line">    Q-&gt;front=<span class="number">0</span>;</div><div class="line">    Q-&gt;rear=<span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span>  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span>  (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 循环队列的入队操作*/</span></div><div class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)    <span class="comment">/* 队列满的判断 */</span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    Q-&gt;data[Q-&gt;rear]=e;         <span class="comment">/* 将元素e赋值给队尾 */</span></div><div class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></div><div class="line">                                <span class="comment">/* 若到最后则转到数组头部 */</span></div><div class="line">    <span class="keyword">return</span>  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 循环队列的出队操作*/</span></div><div class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)        <span class="comment">/* 队列空的判断 */</span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    *e=Q-&gt;data[Q-&gt;front];           <span class="comment">/* 将队头元素赋值给e */</span></div><div class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;  <span class="comment">/* front指针向后移一位置， */</span></div><div class="line">                                    <span class="comment">/* 若到最后则转到数组头部 */</span></div><div class="line">    <span class="keyword">return</span>  OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h4><p>顺序存储，若不是循环队列，算法的实践性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还要研究一下不需要担心队列长度的链式存储结构。</p>
<hr>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出，简称链队列。</p>
<p>队头指针指向链队列的头结点<br>队尾指针指向终端结点<br><img src="/images/it_datastructure_queue6.png" alt="UML图"></p>
<p>空队列时，front和rear都指向头结点。<br><img src="/images/it_datastructure_queue7.png" alt="UML图"></p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>1.动态分配存储空间<br>2.入队操作在队尾进行，出队操作在队头进行。<br>3.链式队列在入队时无队满情况问题<br>4.链式队列为空队列的条件：front = rear</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType; 	<span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>	/* 结点结构 */</span></div><div class="line">&#123;</div><div class="line">   QElemType data;</div><div class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;QNode,*QueuePtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>			/* 队列的链表结构 */</span></div><div class="line">&#123;</div><div class="line">   QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></div><div class="line">&#125;LinkQueue;</div></pre></td></tr></table></figure>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><p>其实就是在链表尾部插入结点<br><img src="/images/it_datastructure_queue8.png" alt="UML图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,QElemType e)</span></span></div><div class="line">&#123; </div><div class="line">    QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">    <span class="keyword">if</span>(!s) <span class="comment">/* 存储分配失败 */</span></div><div class="line">        <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">    s-&gt;data=e;</div><div class="line">    s-&gt;next=<span class="literal">NULL</span>;</div><div class="line">    Q-&gt;rear-&gt;next=s; <span class="comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span></div><div class="line">    Q-&gt;rear=s;       <span class="comment">/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span></div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><p>就是头结点的后继结点出队，将头结点的后继改为它后面的结点<br>若链表除头结点外只剩一个元素时，则需将rear指向头结点<br><img src="/images/it_datastructure_queue9.png" alt="UML图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span></div><div class="line">&#123;</div><div class="line">    QueuePtr p;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    p=Q-&gt;front-&gt;next;    <span class="comment">/* 将欲删除的队头结点暂存给p，见图中① */</span></div><div class="line">    *e=p-&gt;data;          <span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></div><div class="line">    Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span></div><div class="line">    <span class="keyword">if</span>(Q-&gt;rear==p)       <span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span></div><div class="line">        Q-&gt;rear=Q-&gt;front;</div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链式队列和循环队列的比较"><a href="#链式队列和循环队列的比较" class="headerlink" title="链式队列和循环队列的比较"></a>链式队列和循环队列的比较</h3><ul>
<li>1.从时间上<br>它们的基本操作都是常数时间O（1）<br>不过循环队列是事先申请好空间，使用期间不释放<br>而对于链队列，每次申请和释放节点也会存在一些时间开销<br>如果入队出队频繁，则两者还是有细微差异。</li>
<li>2.从空间上<br>循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。<br>而连队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。<br>所以在空间上，连队列更加灵活。<br>总的来说，在可以确定队列长度的情况下，建议用循环队列，如果无法预估队列长度时，用链队列。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_queue1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：选择排序</title>
    <link href="https://hengxing0080.github.io/2017/07/09/it/Algorithm/SortSelection/"/>
    <id>https://hengxing0080.github.io/2017/07/09/it/Algorithm/SortSelection/</id>
    <published>2017-07-09T08:26:32.000Z</published>
    <updated>2017-07-15T11:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortselection1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortselection2.gif" alt="UML图"></p>
<a id="more"></a>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>选择排序（Selection sort）<br>是一种简单直观的排序算法。<br>它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 </p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n2)<br>尽管与冒泡排序同为O（n2），但选择排序的性能上还是要略优于冒泡排序。<br>因为交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)  (用于交换和记录索引)</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>不稳定的排序方法。</p>
<p>举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>破坏顺序有什么关系？ 如果以节约时间为目的，选择排序似乎肯定要比冒泡排序好些，是这样吧？</p>
<p>他们两个的效率要根据具体的数据有不同的结论。主要是特殊的数据是递增还是递减，不过通常情况下选择排序的效率还是比较高的！<br>我们现在所做的拿数据简单的做测试对破坏顺序当然没什么关系。但是如果是那结构体来排序呢？比如一个结构体里面包含一个人的学号和分数，要求在分数相等的情况下再按照学号排序，这个时候顺序就有关系了。</p>
<hr>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><hr>
<h2 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[]a)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> minIndex=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>((a==<span class="keyword">null</span>)||(a.length==<span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)</div><div class="line">    &#123;</div><div class="line">        minIndex=i;<span class="comment">//无序区的最小数据数组下标</span></div><div class="line">        <span class="keyword">for</span>(intj=i+<span class="number">1</span>;j&lt;a.length;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在无序区中找到最小数据并保存其数组下标</span></div><div class="line">            <span class="keyword">if</span>(a[j]&lt;a[minIndex])</div><div class="line">            &#123;</div><div class="line">                minIndex=j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minIndex!=i)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//如果不是无序区的最小值位置不是默认的第一个数据，则交换之。</span></div><div class="line">            temp=a[i];</div><div class="line">            a[i]=a[minIndex];</div><div class="line">            a[minIndex]=temp;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-2（C）"><a href="#示例代码-2（C）" class="headerlink" title="示例代码 2（C）"></a>示例代码 2（C）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">        <span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> length;</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> temp = L-&gt;r[i];</div><div class="line">     L-&gt;r[i]=L-&gt;r[j];</div><div class="line">     L-&gt;r[j]=temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span>&#123;</div><div class="line">     <span class="keyword">int</span> i,j,min;</div><div class="line">     <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;L-&gt;length;i++)&#123;</div><div class="line">           min = i;</div><div class="line">           <span class="keyword">for</span>(j = i+<span class="number">1</span>; j&lt;=L-&gt;length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(L-&gt;r[min]&gt;L-&gt;r[j])&#123;</div><div class="line">                      min = j;                                </div><div class="line">                &#125;                      </div><div class="line">           &#125; </div><div class="line">           <span class="keyword">if</span>(i!=min)</div><div class="line">              swap(L,i,min);</div><div class="line">     &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-3（C-）"><a href="#示例代码-3（C-）" class="headerlink" title="示例代码 3（C#）"></a>示例代码 3（C#）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void(int[]group)</div><div class="line">&#123;</div><div class="line">    int temp;</div><div class="line">    int pos=0;</div><div class="line">    for(int i=0;i&lt; group.Length-1;i++)</div><div class="line">    &#123;</div><div class="line">        pos=i;</div><div class="line">        for(intj=i+1;j&lt;group.Length;j++)</div><div class="line">        &#123;</div><div class="line">            if(group[j]&lt;group[pos])</div><div class="line">            &#123;</div><div class="line">                pos=j;</div><div class="line">            &#125;</div><div class="line">        &#125;//第i个数与最小的数group[pos]交换</div><div class="line">        temp=group[i];</div><div class="line">        group[i]=group[pos];</div><div class="line">        group[pos]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortselection1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/it_algorithm_sortselection2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：冒泡排序</title>
    <link href="https://hengxing0080.github.io/2017/07/08/it/Algorithm/SortBubble/"/>
    <id>https://hengxing0080.github.io/2017/07/08/it/Algorithm/SortBubble/</id>
    <published>2017-07-08T11:12:32.000Z</published>
    <updated>2017-07-22T04:27:23.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbubble1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortbubble2.gif" alt="UML图"><br><img src="/images/it_algorithm_sortbubble3.gif" alt="UML图"><br><!-- http://www.oschina.net/code/snippet_103482_14730 --></p>
<a id="more"></a>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>冒泡排序（Bubble Sort）<br>也称气泡排序。<br>是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p>
<p>它是一种交换排序。<br>利用交换数据元素的位置进行排序的方法称为交换排序。<br>常用的交换排序算法主要有冒泡排序和快速排序。</p>
<p>基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>
<p>这是最原始，也是众所周知的最慢的算法了。他的名字的由来因为它的工作看来象是冒泡.</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>冒泡排序算法的运作如下：（从后往前）<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n^2）</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)  (用于交换)</p>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>稳定</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.“编程复杂度”很低，很容易写出代码；<br>2.具有稳定性，这里的稳定性是指原序列中相同元素的相对顺序仍然保持到排序后的序列，</p>
<h2 id="冒泡排序和选择排序的特点"><a href="#冒泡排序和选择排序的特点" class="headerlink" title="冒泡排序和选择排序的特点"></a>冒泡排序和选择排序的特点</h2><p>比较两个数据项<br>交换两个数据项或复制其中一项。<br>就是每种算法的具体实现细节有所不同。</p>
<hr>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><hr>
<h2 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span></div><div class="line"> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j])</div><div class="line">                &#123;</div><div class="line">                    temp = a[j];</div><div class="line">                    a[j] = a[j + <span class="number">1</span>];</div><div class="line">                    a[j + <span class="number">1</span>] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-2（JavaScript）"><a href="#示例代码-2（JavaScript）" class="headerlink" title="示例代码 2（JavaScript）"></a>示例代码 2（JavaScript）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = arr.length, j;</div><div class="line">    <span class="keyword">var</span> tempExchangVal;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                tempExchangVal = arr[j];</div><div class="line">                arr[j] = arr[j + <span class="number">1</span>];</div><div class="line">                arr[j + <span class="number">1</span>] = tempExchangVal;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        i--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">var</span> arrSorted = bubbleSort(arr);</div><div class="line"><span class="built_in">console</span>.log(arrSorted);</div><div class="line">alert(arrSorted);</div></pre></td></tr></table></figure>
<h2 id="示例代码-3（C-）"><a href="#示例代码-3（C-）" class="headerlink" title="示例代码 3（C#）"></a>示例代码 3（C#）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">namespace 数组排序</div><div class="line">&#123;</div><div class="line">    class Program</div><div class="line">    &#123;</div><div class="line">        static void Main(string[] args)</div><div class="line">        &#123;</div><div class="line">            int temp = 0;</div><div class="line">            int[] arr = &#123;23, 44, 66, 76, 98, 11, 3, 9, 7&#125;;</div><div class="line">            #region该段与排序无关</div><div class="line">            Console.WriteLine(&quot;排序前的数组：&quot;);</div><div class="line">            foreach (intiteminarr)</div><div class="line">            &#123;</div><div class="line">                Console.Write(item + &quot;&quot;);</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine();</div><div class="line">            #endregion</div><div class="line">            for (int i = 0; i &lt; arr.Length - 1; i++)</div><div class="line">            &#123;</div><div class="line">                #region将大的数字移到数组的arr.Length-1-i</div><div class="line">                for (int j = 0; j &lt; arr.Length - 1 - i; j++)</div><div class="line">                &#123;</div><div class="line">                    if (arr[j] &gt; arr[j + 1])</div><div class="line">                    &#123;</div><div class="line">                        temp = arr[j + 1];</div><div class="line">                        arr[j + 1] = arr[j];</div><div class="line">                        arr[j] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            #endregion</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine(&quot;排序后的数组：&quot;);</div><div class="line">            foreach (int item in arr)</div><div class="line">            &#123;</div><div class="line">                Console.Write(item+&quot;&quot;);</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine();</div><div class="line">            Console.ReadKey();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-4（C）"><a href="#示例代码-4（C）" class="headerlink" title="示例代码 4（C）"></a>示例代码 4（C）</h2><h3 id="示例代码1"><a href="#示例代码1" class="headerlink" title="示例代码1"></a>示例代码1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 8</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j, temp;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - j; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                temp = a[i];</div><div class="line">                a[i] = a[i + <span class="number">1</span>];</div><div class="line">                a[i + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> number[SIZE] = &#123;<span class="number">95</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">12</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    bubble_sort(number, SIZE);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, number[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码2（算法优化）"><a href="#示例代码2（算法优化）" class="headerlink" title="示例代码2（算法优化）"></a>示例代码2（算法优化）</h3><p>对冒泡排序算法进行简单的优化，用一个标记来记录在一趟的比较过程中是否存在交换，如果不存在交换则整个数组已经有序退出排序过程，反之则继续进行下一趟的比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];   <span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></div><div class="line">    <span class="keyword">int</span> length;         <span class="comment">/* 用于记录顺序表的长度 */</span></div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> temp=L-&gt;r[i]; </div><div class="line">    L-&gt;r[i]=L-&gt;r[j]; </div><div class="line">    L-&gt;r[j]=temp; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 用于打印结果 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SqList L)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L.length;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,L.r[i]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,L.r[i]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作改进优化冒泡算法 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    Status flag=TRUE;                <span class="comment">/* flag用来作为标记 */</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++) <span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></div><div class="line">    &#123;</div><div class="line">        flag=FALSE;                  <span class="comment">/* 初始为False */</span></div><div class="line">        <span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                 swap(L,j,j+<span class="number">1</span>); <span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></div><div class="line">                 flag=TRUE;     <span class="comment">/* 如果有数据交换，则flag为true */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="其他博文推荐"><a href="#其他博文推荐" class="headerlink" title="其他博文推荐"></a>其他博文推荐</h1><hr>
<p><a href="http://blog.csdn.net/cjf_iceking/article/details/7911027" target="_blank" rel="external">太阳落雨–冒泡排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbubble1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/it_algorithm_sortbubble2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/it_algorithm_sortbubble3.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;!-- http://www.oschina.net/code/snippet_103482_14730 --&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>全球开发者调查统计报告（StackOverflow)</title>
    <link href="https://hengxing0080.github.io/2017/06/22/it/Statistics/RankingsDeveloper/"/>
    <id>https://hengxing0080.github.io/2017/06/22/it/Statistics/RankingsDeveloper/</id>
    <published>2017-06-22T02:35:15.000Z</published>
    <updated>2017-06-22T03:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/statistics_stackoverflow_logo.jpg" alt="LOGO"></p>
<p>信息来源官网：<a href="https://stackoverflow.com/" target="_blank" rel="external">StackOverflow</a><br>国外原地址传送门：<a href="https://insights.stackoverflow.com/survey/2017" target="_blank" rel="external">https://insights.stackoverflow.com/survey/2017</a><br>国内转载地址传送门：<a href="https://www.suilengea.com/show/xaimhemhxa.html" target="_blank" rel="external">StackOverflow 2017开发者调查报告（全译文）</a></p>
<p>Stack Overflow 发布了 2017 开发者调查报告，此次有超过 64,000 名开发人员参与调查，分别对其技能、工具、学习趋势等数据进行了统计！<br>详情请查看上面的地址！</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/statistics_stackoverflow_logo.jpg&quot; alt=&quot;LOGO&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息来源官网：&lt;a href=&quot;https://stackoverflow.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow&lt;/a&gt;&lt;br&gt;国外原地址传送门：&lt;a href=&quot;https://insights.stackoverflow.com/survey/2017&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://insights.stackoverflow.com/survey/2017&lt;/a&gt;&lt;br&gt;国内转载地址传送门：&lt;a href=&quot;https://www.suilengea.com/show/xaimhemhxa.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow 2017开发者调查报告（全译文）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stack Overflow 发布了 2017 开发者调查报告，此次有超过 64,000 名开发人员参与调查，分别对其技能、工具、学习趋势等数据进行了统计！&lt;br&gt;详情请查看上面的地址！&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 统计调查" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式GOF之5 —— 原型模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/15/it/DesignPattern/5.Prototype/"/>
    <id>https://hengxing0080.github.io/2017/06/15/it/DesignPattern/5.Prototype/</id>
    <published>2017-06-15T05:21:32.000Z</published>
    <updated>2017-06-22T02:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：原型模式<br>英文名：Prototype<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_prototype1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍<br> ● Client：客户端用户。<br> ● Prototype：抽象类或者接口，声明具备clone能力。<br> ● ConcretePrototype：具体的原型类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p>
<h1 id="各种解释"><a href="#各种解释" class="headerlink" title="各种解释"></a>各种解释</h1><p>其实就是从一个对象在创建另外一个可定制的对象，而且不需知道任何创建的细节。</p>
<p>在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。</p>
<p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这即隐藏了对象创建的细节。又对性能是大大的提高。<br>是不用重新初始化对象，而是动态地获得对象运行时的状态。</p>
<p>通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。</p>
<p>原型模式本质上就是对象拷贝，与C++中的拷贝构造函数有些类似，他们之间容易出现的问题也都是深拷贝，浅拷贝。使用原型模式可以解决构造复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。<br>还有一个重要的用途就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个只读对象修改，通常可以返回一个对象拷贝的形式实现只读的限制。</p>
<p>原型二字表明了该模式应用有一个样板示例，用户从这个样板对象中复制出一个内部属性一直的对象，这个过程也就是我们俗称的“克隆”。<br>被复制的实例就是我们锁称的“原型”，这个原型是可定制的。<br>原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经负载的实例可使程序运动更高效。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体验其优点。<br>new对象之所以效率低，是因为每New一次，都需要执行一次构造函数，如果构造函数的执行时间很长，那么多次的执行这个初始化操作就实在太低效了。<br>所以一般在初始化的信息不发生变化的情况下，克隆是最好的方法。<br>这即隐藏了对象创建的细节，又对性能是大大的提高，何乐而不为。</p>
<p>缺点：<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要在实际应用时考虑。<br>缺点是每一个类都必须配备一个克隆方法。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>1.类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗。<br>2.用过new产生一个对象需要非常繁琐的数据准备或访问权限，这是可以使用原型模式。<br>3.一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。<br>　需要注意的是，通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者成本较高时，通过clone方法才能够获得效率上的提升。<br>　因此，在使用Cloneable时需要考虑构建对象的成本以及做一些效率上的测试。<br>　当然，实现原型模式也不一定非要实现Cloneable接口，也有其他的实现方式，本章将会一一说明。</p>
<h1 id="使用方式和注意事项："><a href="#使用方式和注意事项：" class="headerlink" title="使用方式和注意事项："></a>使用方式和注意事项：</h1><h2 id="浅拷贝-影子拷贝-浅复制"><a href="#浅拷贝-影子拷贝-浅复制" class="headerlink" title="浅拷贝/影子拷贝/浅复制"></a>浅拷贝/影子拷贝/浅复制</h2><p>Object.clone方法是这样，<br>如果字段是值类型，则对字段执行逐位复制，<br>如果字段是引用类型，则复制引用但不复制引用对象，因此，原始对象及其复本引用同一对象。就是说如果有对象引用，那么引用的对象数据是不会被克隆过来的。<br>被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的应用都仍然指向原来的对象。</p>
<h2 id="深拷贝-深复制"><a href="#深拷贝-深复制" class="headerlink" title="深拷贝/深复制"></a>深拷贝/深复制</h2><p>把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。<br>就是把要复制的对象所引用的对象都复制一遍。</p>
<h1 id="2种使用方式"><a href="#2种使用方式" class="headerlink" title="2种使用方式"></a>2种使用方式</h1><p>1.Director<br>通过具有的Builder来构建产品对象，而Director封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<p>2.链式调用<br>值得注意点是，在现实开发过程中，Director角色经常会被忽略，而直接使用一个Builder来进行对象的组装，这个Builder通常为链式调用，<br>它的关键点是每个setter方法都返回自身，也就是retrun this，这样使得setter方法可以链式调用，代码大致如下：<br>New TestBuilder.setA(“A”).setB(“B”).create();<br>这样使得代码更简洁，易懂，例如下文示例代码中说到的ImageLoader就是通过ImageLoaderConfig进行配置，这就避免了目标类中被过多的接口污染。</p>
<h1 id="Android涉及到的抽象工厂设计模式"><a href="#Android涉及到的抽象工厂设计模式" class="headerlink" title="Android涉及到的抽象工厂设计模式"></a>Android涉及到的抽象工厂设计模式</h1><p>1.原型模式：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。<br>另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了</p>
<p>2.Intent</p>
<p>3.ArrayList的clone</p>
<h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><p>模式的简单实现</p>
<p>下面以简单的文档拷贝为例来演示一下简单的原型模式模式。<br>这个例子中首先创建了一个文档悐，即WorderdOCUMENT，这个文档中含有文字和图片。用户经过了长时间的内容编辑后，打算对该问的做进一步的编辑，但是，这个编辑后的当问是否会被才欧勇还不确定，因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 文档类型, 扮演的是ConcretePrototype角色，而cloneable是代表prototype角色</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文本</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String mText;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 图片名列表</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt;&lt;string&gt; mImages = <span class="keyword">new</span> ArrayList&lt;String&gt;&lt;string&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"----------- WordDocument构造函数 -----------"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 克隆对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</div><div class="line">            doc.mText = <span class="keyword">this</span>.mText;</div><div class="line">            doc.mImages = <span class="keyword">this</span>.mImages;</div><div class="line">            <span class="keyword">return</span> doc;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mText;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String mText)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mText = mText;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;string&gt; <span class="title">getImages</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mImages;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(String img)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mImages.add(img);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 打印文档内容</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"----------- Word Content Start -----------"</span>);</div><div class="line">        System.out.println(<span class="string">"Text : "</span> + mText);</div><div class="line">        System.out.println(<span class="string">"Images List: "</span>);</div><div class="line">        <span class="keyword">for</span> (String imgName : mImages) &#123;</div><div class="line">            System.out.println(<span class="string">"image name : "</span> + imgName);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"----------- Word Content End -----------"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过WordDocument类模拟了word文档中的基本元素，即文字和图片。<br>WordDocument的在该原型模式示例中扮演的角色为ConcretePrototype， 而Cloneable的角色则为Prototype。<br>WordDocument实现了clone方法以实现对象克隆。<br>注意，这个方法并不是Cloneable接口中的，而是Object中的方法。Cloneable也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现Cloneable接口却调用了clone()函数将抛出异常。<br>上面的代码中通过实现Clonable接口和覆写CLONE方法实现原型模式。<br>下面我们看看Client端的使用 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        WordDocument originDoc = <span class="keyword">new</span> WordDocument(); <span class="comment">//构造文档对象</span></div><div class="line">        originDoc.setText(<span class="string">"这是一篇文档"</span>);</div><div class="line">        originDoc.addImage(<span class="string">"图片1"</span>);</div><div class="line">        originDoc.addImage(<span class="string">"图片2"</span>);</div><div class="line">        originDoc.addImage(<span class="string">"图片3"</span>);</div><div class="line">        originDoc.showDocument();</div><div class="line"></div><div class="line">        WordDocument doc2 = originDoc.clone(); <span class="comment">//以原始文档为原型，拷贝一份副本</span></div><div class="line">        doc2.showDocument();</div><div class="line"></div><div class="line">        doc2.setText(<span class="string">"这是修改过的Doc2文本"</span>); <span class="comment">//修改文档副本，不会影响原始文档</span></div><div class="line">        doc2.showDocument();</div><div class="line">         </div><div class="line">        originDoc.showDocument();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/it_pattern_prototype2.jpg" alt="结果图"></p>
<p>可以看到，doc2是通过originDoc.clone()创建的，并且doc2第一次输出的时候和originDoc输出是一样的。即doc2是originDoc的一份拷贝，他们的内容是一样的，而doc2修改了文本内容以后并不会影响originDoc的文本内容。需要注意的是通过clone拷贝对象的时候并不会执行构造函数！</p>
<p>不过上述原型模式的实现实际上只是一个浅拷贝，这份拷贝实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段！</p>
<p>我们直接看下面的例子会出现的问题，将main函数的内容修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造文档对象（源）</span></div><div class="line">    WordDocument originDoc = <span class="keyword">new</span> WordDocument();</div><div class="line">    originDoc.setText(<span class="string">"这是一篇文档"</span>);</div><div class="line">    originDoc.addImage(<span class="string">"图片1"</span>);</div><div class="line">    originDoc.addImage(<span class="string">"图片2"</span>);</div><div class="line">    originDoc.addImage(<span class="string">"图片3"</span>);</div><div class="line">    originDoc.showDocument();</div><div class="line">    </div><div class="line">    <span class="comment">// 拷贝文档（副本）</span></div><div class="line">    WordDocument doc2 = originDoc.clone();</div><div class="line">    doc2.showDocument();</div><div class="line">    doc2.setText(<span class="string">"这是修改过的Doc2文本"</span>);</div><div class="line">    doc2.addImage(<span class="string">"哈哈.jpg"</span>);</div><div class="line">    doc2.showDocument();</div><div class="line">    </div><div class="line">    originDoc.showDocument();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/it_pattern_prototype3.jpg" alt="结果图"></p>
<p>细心的朋友可能发现了，最后两个文档信息输出是一致的。<br>我们在doc2添加了一张名为”哈哈.jpg”的照片，但是却也显示在originDoc中？这是怎么回事呢？<br>其实学习过C++的朋友都知道，这是因为上文中WordDocument的clone方法中只是简单的进行浅拷贝，引用类型的新对象doc2的mImages只是单纯的指向了this.mImages引用，而并没有进行拷贝。<br>doc2的mImages添加了新的图片，实际上也就是往originDoc里添加了新的图片，所以originDoc里面也有”哈哈.jpg” 。<br>那如何解决这个问题呢？ 那就是采用深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用的形式。clone方法修改如下 :</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 克隆对象</div><div class="line">  */</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</div><div class="line">         doc.mText = <span class="keyword">this</span>.mText;</div><div class="line">         <span class="comment">// doc.mImages = this.mImages;</span></div><div class="line">         doc.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</div><div class="line">         <span class="keyword">return</span> doc;</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         </div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>如上代码所示，将doc.mImages指向this.mImages的一份拷贝， 而不是this.mImages本身，这样在doc2添加图片时并不会影响originDoc，如图所示 :</p>
<p><img src="/images/it_pattern_prototype4.jpg" alt="结果图"></p>
<p>原型模式是非常简单的一个模式，它的核心问题就是对原始对象进行拷贝，在这个模式的使用过程中需要注意的多一点就是：深、浅拷贝的问题。<br>在开发过程中，建议使用该模式时尽量使用深拷贝，避免操作副本时影响原始对象的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：原型模式&lt;br&gt;英文名：Prototype&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_prototype1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之4 —— 建造者模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/08/it/DesignPattern/4.Builder/"/>
    <id>https://hengxing0080.github.io/2017/06/08/it/DesignPattern/4.Builder/</id>
    <published>2017-06-08T07:21:33.000Z</published>
    <updated>2017-06-22T02:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：建造者模式<br>别称：生成器模式<br>英文名：Builder<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_builder1.jpg" alt="UML图"><br><a id="more"></a><br>重要角色：<br>Build：为创建一个Product对象的各个部件指定的抽象接口。<br>ConcreteBuilder：具体建造者，实现Builder接口，构造和装配各个部件。<br>Product：具体的产品角色。<br>Director：指挥者，用它来控制统一组装建造过程，也用它来隔离用户与建造过程的关联。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>建造者模式是当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式.</p>
<p>将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。<br>建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>遵循单一职责、开闭原则</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。<br>建造者独立，容易扩展。</p>
<p>缺点：<br>会产生多余的Builder对象以及Director对象，消耗内存。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>它主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。<br>相同的方法，不同的执行顺序，产生不同的事件结果时。<br>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。<br>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。</p>
<h1 id="2种使用方式"><a href="#2种使用方式" class="headerlink" title="2种使用方式"></a>2种使用方式</h1><p>1.Director<br>通过具有的Builder来构建产品对象，而Director封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<p>2.链式调用<br>值得注意点是，在现实开发过程中，Director角色经常会被忽略，而直接使用一个Builder来进行对象的组装，这个Builder通常为链式调用，<br>它的关键点是每个setter方法都返回自身，也就是retrun this，这样使得setter方法可以链式调用，代码大致如下：<br>New TestBuilder.setA(“A”).setB(“B”).create();<br>这样使得代码更简洁，易懂，例如下文示例代码中说到的ImageLoader就是通过ImageLoaderConfig进行配置，这就避免了目标类中被过多的接口污染。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="1-组装电脑（Director方式）"><a href="#1-组装电脑（Director方式）" class="headerlink" title="1. 组装电脑（Director方式）"></a>1. 组装电脑（Director方式）</h2><p>计算机的组装过程较为复杂，并且组装顺序是不固定的，为了易于理解，我们把计算机组装的过程简化为构建主机、设置操作系统、设置显示器3个部分，然后通过Director和具体的Builder够构建计算机对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象产品类 - 计算机</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主板</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String mBoard;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 显示器</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String mDisplay;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 操作系统</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String mOS;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置主板</div><div class="line">     * <span class="doctag">@param</span> board 主板类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoard</span><span class="params">(String board)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mBoard = board;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置显示器</div><div class="line">     * <span class="doctag">@param</span> display 显示器类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmDisplay</span><span class="params">(String display)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mDisplay = display;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置操作系统</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Computer&#123;"</span> +</div><div class="line">                <span class="string">"mBoard='"</span> + mBoard + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", mDisplay='"</span> + mDisplay + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", mOS='"</span> + mOS + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体产品类 - Macbook</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        mOS = <span class="string">"Mac OS X 10.10"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象Builder类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置主机</div><div class="line">     * <span class="doctag">@param</span> board 主机类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置显示器</div><div class="line">     * <span class="doctag">@param</span> display 显示器类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置操作系统</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建Computer</div><div class="line">     * <span class="doctag">@return</span> 返回一个完整的电脑</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体的Builder类，MacbookBuilder</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacbookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> Macbook();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span> </span>&#123;</div><div class="line">        mComputer.setBoard(board);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</div><div class="line">        mComputer.setDisplay(display);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        mComputer.setOS();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mComputer;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 导演类，负责构造Computer</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line"></div><div class="line">    Builder mBuilder = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mBuilder = builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构建对象</div><div class="line">     * <span class="doctag">@param</span> board</div><div class="line">     * <span class="doctag">@param</span> display</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String board, String display)</span> </span>&#123;</div><div class="line">        mBuilder.buildBoard(board);</div><div class="line">        mBuilder.buildDisplay(display);</div><div class="line">        mBuilder.buildOS();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 构建器</span></div><div class="line">        Builder builder = <span class="keyword">new</span> MacbookBuilder();</div><div class="line">        <span class="comment">// Director</span></div><div class="line">        Director pcDirector = <span class="keyword">new</span> Director(builder);</div><div class="line">        <span class="comment">// 封装构建过程，4核、内存2GB、Mac系统</span></div><div class="line">        pcDirector.construct(<span class="string">"英特尔主板"</span>, <span class="string">"Retina显示器"</span>);</div><div class="line">        <span class="comment">// 构建计算机，输出相关信息</span></div><div class="line">        System.out.println(<span class="string">"Computer Info: "</span> + builder.create().toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出结果</span></div><div class="line">Computer Info: Computer&#123;mBoard=<span class="string">'英特尔主板'</span>, mDisplay=<span class="string">'Retina显示器'</span>, mOS=<span class="string">'Mac OS X 10.10'</span>&#125;</div></pre></td></tr></table></figure>
<p>上述实例中，通过具体的MacbookBuilder来构建Macbook对象，而Director封装了构建复杂产品对象的过程，对外隐藏构建细节。<br>Builder与Director一起将一个复杂对象的构建过程与他的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<h2 id="2-配置ImageLoader（链式调用方式）"><a href="#2-配置ImageLoader（链式调用方式）" class="headerlink" title="2.配置ImageLoader（链式调用方式）"></a>2.配置ImageLoader（链式调用方式）</h2><p>还拿之前文章面向对象几大原则的中ImageLoader为例，随着不断的演进，这个库的可扩展性、灵活性越来越高，在带来用户关注的同时也需要开发一些新特性来满足用户的需求，比较典型的问题就是配置ImageLoader，<br>如设置图片再加载时ImageView显示的图片、加载失败后显示的图片、图片加载引擎线程数等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span></span>&#123;</div><div class="line">    <span class="comment">// 图片加载配置对象</span></div><div class="line">    <span class="keyword">private</span> ImageLoaderConfig mConfig;</div><div class="line"></div><div class="line">    <span class="comment">// 省略单例模式的代码</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化ImageLoader</div><div class="line">     * <span class="doctag">@param</span> config</div><div class="line">     */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ImageLoaderConfig config)</span></span>&#123;</div><div class="line">         mConfig = config;</div><div class="line">         <span class="comment">// 检测配置的合法性，内部会根据配置做一些初始化操作</span></div><div class="line">         checkConfig();</div><div class="line">         <span class="comment">// 代码省略</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// 加载图片的函数</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String imageUrl, ImageView imageView)</span></span>&#123;</div><div class="line">         Bitmap bitmap = mImageCache.get(imageUrl);</div><div class="line">         <span class="keyword">if</span>(bitmap != <span class="keyword">null</span>)&#123;</div><div class="line">             imageView.setImageBitmap(bitmap);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 添加加载请求</span></div><div class="line">         submitLoadRequest(imageUrl,imageView);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitLoadRequest</span><span class="params">(<span class="keyword">final</span> String imageUrl, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">         <span class="comment">// 代码省略</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 把配置的代码基本上都封装到了ImageLoaderConfig和Builder对象中</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">public</span> class <span class="title">ImageLoaderConfig</span><span class="params">()</span></span>&#123;</div><div class="line">     </div><div class="line">     <span class="comment">// 图片缓存配置对象</span></div><div class="line">     BitmapCache bitmapCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">     <span class="comment">// 加载图片时的loading和加载失败的图片配置对象</span></div><div class="line">     DisplayConfig displayConfig = <span class="keyword">new</span> DisplayConfig();</div><div class="line">     <span class="comment">// 加载策略</span></div><div class="line">     LoadPlicy loadPolicy = <span class="keyword">new</span> SerialPolicy();</div><div class="line">     <span class="comment">// 线程数量，默认为CPU数量+1</span></div><div class="line">     <span class="keyword">int</span> threadCount = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</div><div class="line">     </div><div class="line">     <span class="comment">// 构造函数私有化</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="title">ImageLoaderConfig</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * 配置类的Builder</div><div class="line">      */</div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 图片缓存配置对象</div><div class="line">          */</div><div class="line">         BitmapCache bitmapCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 加载图片时的loading和加载失败的图片配置对象</div><div class="line">          */</div><div class="line">         DisplayConfig displayConfig = <span class="keyword">new</span> DisplayConfig();</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 加载策略</div><div class="line">          */</div><div class="line">         LoadPolicy loadPolicy = <span class="keyword">new</span> SerialPolicy();</div><div class="line">         <span class="comment">// 线程数量</span></div><div class="line">         <span class="keyword">int</span> threadCound = Runtime.getRuntime().availableProcessors()+<span class="number">1</span>;</div><div class="line">         <span class="comment">// 设置线程数量</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setThreadCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">             threadCount = Math.max(<span class="number">1</span>,count);</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置缓存</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setCache</span><span class="params">(BitmapCache cache)</span></span>&#123;</div><div class="line">             bitmapCache = cache;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置图片加载中显示的图片</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setLoadingPlacehoder</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">             displayConfig.loadingResId = resId;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置要加载的图片加载失败时显示的图片</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setNotFoundPlacehoder</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">             displayConfig.failedResId = resId;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置加载策略</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setLoadPolicy</span><span class="params">(LoadPolicy policy)</span></span>&#123;</div><div class="line">             <span class="keyword">if</span>(policy != <span class="keyword">null</span>)&#123;</div><div class="line">                 loadPolicy = policy;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="function"><span class="keyword">void</span> <span class="title">applyConfig</span><span class="params">(ImageLoaderConfig config)</span></span>&#123;</div><div class="line">             config.bitmapCache = <span class="keyword">this</span>.bitmapCache;</div><div class="line">             config.displayConfig = <span class="keyword">this</span>.displayConfig;</div><div class="line">             config.loadPolicy = <span class="keyword">this</span>.loadPolicy;</div><div class="line">             config.threadCount = <span class="keyword">this</span>.threadCount;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 根据已经设置好的属性创建配置对象</div><div class="line">          *</div><div class="line">          * <span class="doctag">@return</span> ImageLoaderConfig对象</div><div class="line">          */</div><div class="line">         <span class="function"><span class="keyword">public</span> ImageLoaderConfig <span class="title">create</span><span class="params">()</span></span>&#123;</div><div class="line">             ImageLoaderConfig config = <span class="keyword">new</span> ImageLoaderConfig();</div><div class="line">             <span class="comment">// 应用配置</span></div><div class="line">             applyConfig(config);</div><div class="line">             <span class="keyword">return</span> config;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>通过将ImageLoaderConfig的构造函数、字段私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过Builder对象了，也就是说用户只能通过Builder对象构造ImageLoaderConfig对象，这就是构建和表示相分离。</p>
<p>但是“使得相同的构造过程可以创建不用的表示”又是如何理解呢？在经典的Builder模式中海油一个Director和ConcreteBuilder角色，不同的ConcreteBuilder是可以创建不用的Product子类的，因此，也就是可以创建不用的表示。<br>我们这里并没有使用景点实现，以你，不做过多的描述。</p>
<p>下面看下客户端的使用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageLoader</span><span class="params">()</span></span>&#123;</div><div class="line">    ImageLoaderConfig config = <span class="keyword">new</span> ImageLoaderConfig.Builder()</div><div class="line">     .setLoadingPlaceholder(R.drawable.loading)</div><div class="line">     .setNotFoundPlacehoder(R.drawable.not_found)</div><div class="line">     .setCache(<span class="keyword">new</span> DoubleCache(<span class="keyword">this</span>))</div><div class="line">     .setThreadCound(<span class="number">4</span>)</div><div class="line">     .setLoadPolicy(<span class="keyword">new</span> ReversePolicy()</div><div class="line">     .create());</div><div class="line">    <span class="comment">// 将配置初始化到ImageLoader中</span></div><div class="line">    ImageLoader.getInstance().init(config);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用init函数之后，ImageLoader就可以正常使用了，各种setter函数不会再用户调用ImageLoader方法时出现在视野中，他们已经被隔离到了Builder模式中。<br>API很清晰，简单！</p>
<h1 id="Android涉及到的抽象工厂设计模式"><a href="#Android涉及到的抽象工厂设计模式" class="headerlink" title="Android涉及到的抽象工厂设计模式"></a>Android涉及到的抽象工厂设计模式</h1><p>Builder模式在Anroid开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同事也是将配置从目标中隔离出来，避免过多的setter方法。</p>
<p>　1.Notification配置和创建过程如下：　<br>　　Notification noti = new Notification.Builder(this)<br>　　.setContentTitle(“标题”)<br>　　.setContentText(“文本内容”)<br>　　.setSmallIcon(R.drawable.ic_launcher_table)<br>　　.setLargeIcon(BitmapFactory.decodeResource<br>　　　　(getResources(), R.drawable.ic_launcher_table))　　<br>　　.build();<br>　　mNotificationManager.notify(0, noti);</p>
<p>　2.AlertDialog.Builder（可以分步地构造每一部分）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：建造者模式&lt;br&gt;别称：生成器模式&lt;br&gt;英文名：Builder&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_builder1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之3 —— 抽象工厂模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/04/it/DesignPattern/3.Abstract/"/>
    <id>https://hengxing0080.github.io/2017/06/04/it/DesignPattern/3.Abstract/</id>
    <published>2017-06-04T11:01:45.000Z</published>
    <updated>2017-06-22T02:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：抽象工厂模式<br>英文名：Abstract Factory Pattern<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_abstract1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>虽然抽象工厂方法模式的类繁多，但是，主要还是分为4类：<br>　　AbstractFactory：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上述类图中的AbstractFactory中就定了两个方法，分别创建产品A和产品B。</p>
<p>　　ConcreteFactory：具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的ConcreteFactory1和CocreteFactory2.</p>
<p>　　AbstractProduct：抽象产品角色，它为每种产品声明接口，比如上述类中的AbstractProductA和AbstractProductB.</p>
<p>　　ConcreteProduct：具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象接口中声明的业务方法，如上述类图中的ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2.</p>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h1 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h1><p>工厂模式是对具体产品进行扩展，有的项目可能需要更多的扩展性，要对这个“工厂”也进行扩展，那就成了“抽象工厂模式”。</p>
<p>可以联想一下现实生活中的工厂肯定都是具体的，也就说每个工厂都会生产某一种具体的产品，那么抽象工厂意味着生产出来的产品是不确定的！<br>抽象工厂模式起源于以前对不用操作系统的图形化解决方案，如不同操作系统的按钮和文本框空间其实现不同，展示效果也不一样，对于每一个操作系统，其本身就构成一个产品类，而按钮与文本框空间也构成一个产品类，两种产品类两种变化，各自有自己的特性，如Android中的Button和TextView，Window Phone中的Button和TextView等。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>遵循单一职责、依赖倒置、开闭原则</p>
<h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><p>优点：<br>一个显著的优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活，容易。</p>
<p>缺点：<br>一是类文件的徒增（爆炸性增加），如果工厂类过多，势必导致类文件非常多，因此，在实际开发中一定要权衡慎用。<br>二是不太容易扩展新的产品类，因为每当我们增加一个产品类就需要修改抽象工厂，那么所有的具体工厂类均会被要做相应的修改。 </p>
<h1 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h1><p>一个对象族有相同的约束时可以使用抽象工厂模式。</p>
<p>举个例子，Android,IOS,Window Phone下都有短信软件和拨号软件，两者都属于Software软件的范畴，但是，它们所在的操作系统平台不一样，即便是同一家公司出品的软件，其代码的实现逻辑也是不同的，这时候可以考虑使用抽象工厂方法模式来产生android,ios,Window Phone下的短信软件和拨号软件。</p>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="示例1：车工厂造不同型号的车"><a href="#示例1：车工厂造不同型号的车" class="headerlink" title="示例1：车工厂造不同型号的车"></a>示例1：车工厂造不同型号的车</h2><blockquote>
<p>来源：《android源码设计模式解析与实战》————6.5</p>
</blockquote>
<p>语言：Java</p>
<p>案例描述：<br>以奥迪车工厂造奥迪车举例，虽然用到了之前的工厂方法模式，但是，后来发现一个问题，虽然Q3、Q5、Q7都是一个车系，但是三者之间的零部件差别确实很大，就拿Q3和Q7来说，Q3使用的发动机是国产的，而Q7的发动机是进口的；Q3的轮胎是普通的，Q7的轮胎是越野轮胎;还有Q3使用的是比较普通的制动系统，而Q7使用的是会自动性能极好的制动系统。<br>Q3、Q7对应的是一系列车，而发动机、轮胎、制动系统则对应的是一系列零部件，两者是两种不同的产品类型，这时候就可以将抽象工厂模式应用到其中，首先，骑车工厂需要生产轮胎、发动机、制动系统这3种部件。</p>
<p>抽象车厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</div><div class="line">    <span class="comment">// 生产轮胎  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ITire <span class="title">createTire</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// 生产发动机  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEngine <span class="title">createEngine</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// 生产制动系统  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBrake <span class="title">createBrake</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为每一种零部件产品定义一个接口，并分别创建两个不同的实现类表示不同的零部件产品。<br>轮胎相关类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITire</span> </span>&#123;  </div><div class="line">    <span class="comment">// 轮胎  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"普通轮胎"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUVTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"越野轮胎"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发动机相关类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEngine</span> </span>&#123;  </div><div class="line">    <span class="comment">// 发动机  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomesticEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"国产发动机"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"进口发动机"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>制动系统相关类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrake</span> </span>&#123;  </div><div class="line">    <span class="comment">// 发制动系统  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"普通制动"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"高级制动"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于生产Q3的工厂，其使用的零部件不同，而生产Q7的工厂呢，其零部件也不同。<br>Q3工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalTire();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DomesticEngine();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createBrate</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Q7工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q7Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SUVTire();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImportEngine();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createBrate</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SeniorBrake();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端类模拟<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 生产一个Q3的工厂类  </span></div><div class="line">        CarFactory q3Factory3 = <span class="keyword">new</span> Q3Factory();  </div><div class="line">        carFactory3.createTire().tire();  </div><div class="line">        carFactory3.createEngine().engine();  </div><div class="line">        carFactory3.createBrake().brake();  </div><div class="line"></div><div class="line">        System.out.println(<span class="string">"================================="</span>);  </div><div class="line"></div><div class="line">        <span class="comment">// 生产一个Q7的工厂类  </span></div><div class="line">        CarFactory carFactory7 = <span class="keyword">new</span> Q7Factory();  </div><div class="line">        carFactory7.createTire().tire();  </div><div class="line">        carFactory7.createBrake().brake();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">普通轮胎</div><div class="line">国产发动机</div><div class="line">普通制动</div><div class="line">-----------------------------------------</div><div class="line">越野轮胎</div><div class="line">进口发动机</div><div class="line">高级制动</div></pre></td></tr></table></figure></p>
<h2 id="示例2：切换不同的数据库和使用不用的数据库表"><a href="#示例2：切换不同的数据库和使用不用的数据库表" class="headerlink" title="示例2：切换不同的数据库和使用不用的数据库表"></a>示例2：切换不同的数据库和使用不用的数据库表</h2><blockquote>
<p>来源：《大话设计模式》————15章</p>
</blockquote>
<p>语言：Java</p>
<p>案例描述：<br>有一个公司，是给一家去也做的电子商务网站，是用SQL Server作为数据库的。后来，这家公司接到另外一家公司类似需求的项目，但这家公司想省钱，租用一个空间，只能用Access，不能用SQL Server，于是乎，就需要程序员来改造原来那个项目的代码，但是发现数据库被写死了…</p>
<p>原客户端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">        SqlServerUser su = <span class="keyword">new</span> SqlServerUser(); <span class="comment">// 与SQL Server耦合</span></div><div class="line">        su.insert(user);  </div><div class="line">        su.getUser(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以不能换数据库，原因就是在于SqlserverUser sql = new SqlserverUser()使得sql这个对象被锁死在SQL Server上了。<br>如果这里是灵活的，专业点的说法就是多态，<br>那么在执行sql.Insert(user);和sql.GetUser(1);时就不用考虑是在用SQL Server还是Access.</p>
<p>开始改造<br>先看下工厂方法模式实现（温习巩固一下）</p>
<h3 id="工厂方法模式实现"><a href="#工厂方法模式实现" class="headerlink" title="工厂方法模式实现"></a>工厂方法模式实现</h3><p>UML图例<br><img src="/images/it_pattern_abstract3.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IUser接口，用于客户端访问，解除与具体数据库访问的耦合</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;  </div><div class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// SqlserverUser类，用于访问SQL Server的User</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerUser</span> <span class="keyword">implements</span> <span class="title">IUser</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>&#123; </div><div class="line">        System.out.println(<span class="string">"在SQL Server中给User表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在SQL Server中根据ID得到User表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">// AccessUser类，用于访问Access的User  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessUser</span> <span class="keyword">implements</span> <span class="title">IUser</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中给User表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中根据ID得到User表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// IFactory接口，定义一个创建访问User表对象的抽象的工厂接口  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span>  </span>&#123;  </div><div class="line">    <span class="function">IUser <span class="title">createUser</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// SqlServerFactory类，实现IFactory接口，实例化SqlServerUser  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlServerUser();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// AccessFactory类，实现IFactory接口，实例化AccessUser  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessUser();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 客户端代码  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">  </div><div class="line">        <span class="comment">// IFactory factory = new AccessFactory();  </span></div><div class="line">        IFactory factory = <span class="keyword">new</span> SqlServerFactory();  </div><div class="line">  </div><div class="line">        IUser iu = factory.createUser();  </div><div class="line">  </div><div class="line">        iu.insert(user);  </div><div class="line">        iu.getUser(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若要改成Access数据库，只需要改为IFactory factory = new AccessFactory();<br>由于多态的关系，使得声明IUser接口的对象iu事先根本不知道是在访问哪个数据库，缺可以在运行时很好地完成工作，这就是所谓的业务逻辑与数据访问的解耦。</p>
<p>但是确定依然还在，<br>客户端代码还是有修改的地方（new SqlServerFactory())<br>还有数据库里不可能只有一个User表，很可能有其他表，比如增加部门表（Department表）<br>此时就需要用到抽象工厂模式了！</p>
<h3 id="抽象工厂模式实现"><a href="#抽象工厂模式实现" class="headerlink" title="抽象工厂模式实现"></a>抽象工厂模式实现</h3><p>UML图例<br><img src="/images/it_pattern_abstract2.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Department类  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     id;  </div><div class="line">    <span class="keyword">private</span> String  name;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> id;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.id = id;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// IDepartment接口，用于客户端访问，解除与具体数据库访问的耦合  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDepartment</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Department department)</span></span>;  </div><div class="line">    <span class="function">Department <span class="title">getDepartment</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// SqlServerDepartment类，用于访问SQL Server的Department  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerDepartment</span> <span class="keyword">implements</span> <span class="title">IDepartment</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Department department)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在SQL Server中给Deaprtment表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在SQL Server中根据ID得到Deaprtment表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// AccessDepartment类，用于访问Access的Department  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessDepartment</span> <span class="keyword">implements</span> <span class="title">IDepartment</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Department department)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中给Deaprtment表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中根据ID得到Deaprtment表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// IFactory接口，定义一个创建访问User表对象的抽象工厂接口  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span>  </span>&#123;  </div><div class="line">    <span class="function">IUser <span class="title">createUser</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// SqlServerFactory类，实现IFactory接口，实例化SqlServerUser和SqlServerDepartment  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlServerUser();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlServerDepartment();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// AccessFactory类，实现IFactory接口，实例化AccessUser和AccessDepartment  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessUser();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessDepartment();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 客户端代码  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></div><div class="line">    &#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">        Department department = <span class="keyword">new</span> Department();  </div><div class="line">  </div><div class="line">        <span class="comment">// 只需确定实例化哪一个数据库访问对象给factory</span></div><div class="line">        <span class="comment">// IFactory factory = new SqlServerFactory();  </span></div><div class="line">        IFactory factory = <span class="keyword">new</span> AccessFactory();  </div><div class="line">  </div><div class="line">        <span class="comment">// 则此时已与具体的数据库访问解除了依赖</span></div><div class="line">        IUser iu = factory.createUser();  </div><div class="line">        iu.insert(user);  </div><div class="line">        iu.getUser(<span class="number">1</span>);  </div><div class="line">  </div><div class="line">        <span class="comment">// 同上（解决了依赖）</span></div><div class="line">        IDepartment id = factory.createDepartment();</div><div class="line">        id.insert(department);  </div><div class="line">        id.getDepartment(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果显示如下：</span></div><div class="line">在Access中给User表增加一条记录  </div><div class="line">在Access中根据ID得到User表一条记录  </div><div class="line">在Access中给Deaprtment表增加一条记录  </div><div class="line">在Access中根据ID得到Deaprtment表一条记录</div></pre></td></tr></table></figure>
<p>不过是个模式就会有缺点的，都有不适用的时候，要辩证地看待问题啊。抽象工厂模式可以很方便地切换两个数据库访问的代码，但是如果你的需求来自增加功能，比如我们现在要增加项目表Project，你要改动哪些地方？”<br>那就要至少增加三个类，Iproject、SqlServerProject、AccessProject，还需要更改IFactory、SqlServerFactory和AccessFactory才可以完全实现。一改就是三个类，有点糟糕。<br>还有啊，客户端程序类显然不会只有一啊，有很多地方都在使用IUser或IDepartment，而这样的设计，其实在每一个类的开始都需要声明IFactory factory = new SqlServerFactory()，如果我有100个调用数据库访问的类，是不是就要更改100次IFactory factory = new AccessFactory()这样的代码才行？</p>
<p>所以继续改造！</p>
<h3 id="用简单工厂改进抽象工厂"><a href="#用简单工厂改进抽象工厂" class="headerlink" title="用简单工厂改进抽象工厂"></a>用简单工厂改进抽象工厂</h3><p>去除IFactory、SqlServerFactory和AccessFactory三个工厂类，取而代之的是一个DataAccess类，用一个简单工厂模式来实现。</p>
<p>UML图例<br><img src="/images/it_pattern_abstract4.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DataAccess类  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String db  = <span class="string">"Sqlserver"</span>; <span class="comment">// 数据库名称，可替换成Acess</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        IUser result = <span class="keyword">null</span>;  </div><div class="line">        <span class="comment">// 由于db的实现设置，所以此处可以根据选择实例化出相应的对象</span></div><div class="line">        <span class="keyword">switch</span>(db)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Sqlserver"</span>:</div><div class="line">                result = <span class="keyword">new</span> SqlServerUser();  </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Access"</span>:</div><div class="line">                result = <span class="keyword">new</span> AccessUser();  </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>&#123;  </div><div class="line">        IDepartment result = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (<span class="string">"Sqlserver"</span>.equals(db))&#123;  </div><div class="line">            result = <span class="keyword">new</span> SqlServerDepartment();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Access"</span>.equals(db))  &#123;  </div><div class="line">            result = <span class="keyword">new</span> AccessDepartment();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 客户端代码  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">        Department department = <span class="keyword">new</span> Department();  </div><div class="line">        </div><div class="line">        <span class="comment">// 直接得到实际的数据库访问实例，而不存在任何依赖 </span></div><div class="line">        IUser iu = DataAccess.createUser(); </div><div class="line">        iu.insert(user);  </div><div class="line">        iu.getUser(<span class="number">1</span>);  </div><div class="line">        </div><div class="line">        <span class="comment">// 同上</span></div><div class="line">        IDepartment id = DataAccess.createDepartment();  </div><div class="line">        id.insert(department);  </div><div class="line">        id.getDepartment(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个设计表现在，与其用那么多的工厂类，不如直接用一个简单工厂来实现，直接抛弃了IFactory、SqlServerFactory和AccessFactory三个工厂类，取而代之的是DataAccess类，由于事先设置了db的值（Sqlserver或Access），所以简单工厂的方法都不需要输入参数，这样在客户端就只需要DataAccess.createUser()和DataAccess.createDepartment()来生成具体的数据库访问类实例，客户端没有出现任何一个SQL Server或Access的字样，达到了解耦合的目的。</p>
<p>不过还是不能得满分，原因是如果我需要增加Oracle数据库的访问，本来抽象工厂只增加一个OracleFactory工厂类就可以了，现在就比较麻烦了。<br>因为需在DataAccess类中每个方法的if分支语句里面增加了。</p>
<p>还是还得继续优化</p>
<h3 id="用反射-抽象工厂的数据访问程序"><a href="#用反射-抽象工厂的数据访问程序" class="headerlink" title="用反射+抽象工厂的数据访问程序"></a>用反射+抽象工厂的数据访问程序</h3><p>我们要考虑的就是可不可以不在程序里写明‘如果是Sqlserver就去实例化SQL Server数据库相关的类，如果是Access就去实例化Access相关的类’这样的语句，而是根据字符串db的值去某个地方找应该要实例化的类是哪一个。<br>这样，我们的if就可以对它说再见了。”</p>
<p>UML图例<br><img src="/images/it_pattern_abstract6.jpg" alt="UML图"></p>
<p>DataAccess类，用反射技术，取代IFactory、SqlserverFactory、AccessFactory．</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常规的写法  </span></div><div class="line">Iuser result = <span class="keyword">new</span> SqlServerUser();  </div><div class="line"></div><div class="line"><span class="comment">// 反射写法  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String db   = <span class="string">"SqlServer"</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String className  = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        className = db + <span class="string">"User"</span>;  </div><div class="line">        <span class="keyword">try</span>  &#123;  </div><div class="line">            <span class="keyword">return</span> (IUser) Class.forName(className).newInstance();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (InstantiationException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IllegalAccessException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>&#123;  </div><div class="line">        className = db + <span class="string">"Department"</span>;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            <span class="keyword">return</span> (IDepartment) Class.forName(className).newInstance();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (InstantiationException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IllegalAccessException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在如果我们增加了Oracle数据访问，相关的类的增加是不可避免的，这点无论我们用任何办法都解决不了，不过这叫扩展，<br>开放-封闭原则告诉我们，对于扩展，我们开放。但对于修改，我们应该要尽量关闭，<br>就目前而言，我们只需要更改private static final String  db  = “SqlServer”;为private static final String  db  = “Oracle”;<br>也就意味着(IUser) Class.forName(className).newInstance();这一句话发生了变化。<br>这样的结果就是DataAccess.createUser()本来得到的是SqlServerUser的实例，而现在变成了OracleUser的实例了。<br>那么如果我们需要增加Project产品时，如何做呢？<br>只需要增加三个与Project相关的类，再修改DataAccess，在其中增加一个public static IProject createProject()方法就可以了。</p>
<p>虽然比以前代码漂亮多了。<br>但总体感觉还是有缺憾，因为在更改数据库访问时，还是需要去改程序啊，改db这个字符串的值重编译，如果可以不改程序，那才是真正地符合开放-封闭原则。而且createUser()和createDepartment()的内部实现代码几乎是完全一致的。”</p>
<h3 id="用反射-配置文件实现数据访问程序（终极实现）"><a href="#用反射-配置文件实现数据访问程序（终极实现）" class="headerlink" title="用反射+配置文件实现数据访问程序（终极实现）"></a>用反射+配置文件实现数据访问程序（终极实现）</h3><p>我们可以复用配置文件来解决更改DataAccess的问题。<br>就是在配置文件中写明是SqlServer还是Access，这样就连DataAccess类也不用更改了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 添加一个app.properties文件。内容如下：</span></div><div class="line">DB = SqlServer</div><div class="line"></div><div class="line"><span class="comment">// 回到DataAccess</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String       DB          = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String       className   = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties   properties  = <span class="keyword">new</span> Properties();  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            properties.load(DataAccess.class.getClassLoader()  </div><div class="line">                    .getResourceAsStream(<span class="string">"config/app.properties"</span>));  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IOException e)  &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        DB = properties.getProperty(<span class="string">"DB"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">create</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        className = DB + name;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            <span class="keyword">return</span> Class.forName(className).newInstance();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (InstantiationException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IllegalAccessException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> (IUser) create(<span class="string">"User"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> (IDepartment) create(<span class="string">"Department"</span>);  </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本上可以得个满分木有啥问题了。现在我们应用了反射+抽象工厂模式解决了数据库访问时的可维护、可扩展问题。<br>从这个角度上说，所有的用简单工厂的地方，都可以考虑用反射技术消除if或switch，解除分支判断带来的耦合。</p>
<h1 id="Android涉及到的抽象工厂设计模式"><a href="#Android涉及到的抽象工厂设计模式" class="headerlink" title="Android涉及到的抽象工厂设计模式"></a>Android涉及到的抽象工厂设计模式</h1><p>抽象工厂方法模式在Android开发中使用得并不多，大家看到源码中的应用其实也是极少的，主要是在开发过程中很多会出现多个产品种类的情况，大部分情况我们使用工厂模式即可解决。</p>
<p>1.DAO与Service的使用</p>
<p>2.Activity的onCreate，Service的onBind，如果从Framework的角度来看Activity和Service都可以看做是一个具体的工厂，这样看相当于一个丑熊工厂方法模式的雏形也没错。</p>
<p>3.Activity底层对MediaPlayer的创建</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：抽象工厂模式&lt;br&gt;英文名：Abstract Factory Pattern&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_abstract1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之2 —— 工厂模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/02/it/DesignPattern/2.Factory/"/>
    <id>https://hengxing0080.github.io/2017/06/02/it/DesignPattern/2.Factory/</id>
    <published>2017-06-02T03:31:55.000Z</published>
    <updated>2017-06-22T02:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>英文名：    Factory Pattern<br>所属类型：  创建型模式<br>2种用法：  简单工厂模式和工厂方法模式<br>俗称：     实例化对象模式<br>本质：     工厂方法代替new操作<br>类别：     管理模式</p>
<a id="more"></a>
<hr>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><hr>
<p>英文名：Simple Factory Pattern<br>别称：静态工厂方法模式（Static Factory Method）</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p>
<h2 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h2><p>它是工厂方法模式的一个弱化版本<br>不属于23种GOF设计模式之一<br>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。<br>简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<h2 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h2><p><img src="/images/it_pattern_factory1.jpg" alt="UML图"></p>
<h2 id="该模式中包含的角色及其职责"><a href="#该模式中包含的角色及其职责" class="headerlink" title="该模式中包含的角色及其职责"></a>该模式中包含的角色及其职责</h2><p>工厂（Creator）角色<br>　　简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</p>
<p>抽象产品（Product）角色<br>　　简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</p>
<p>具体产品（Concrete Product）角色<br>　　是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点<br>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的，对于客户端来说，去除了与具体产品的依赖。保持了封装对象创建过程的优点。明确了各自的职责和权利，有利于整个软件体系结构的优化。</p>
<p>缺点<br>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的克服。<br>就拿计算器Demo来说，如果要加一个求M数的N次方功能，是一定需要给运算工厂类的方法里加’case’的分支条件，就是说需要修改原有的类，不过这等于说，不但对扩展开放了，对修改也开放了，这样就违背了开闭原则。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂类负责创建的对象比较少；<br>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；<br>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。</p>
<h2 id="示例代码（C-）"><a href="#示例代码（C-）" class="headerlink" title="示例代码（C#）"></a>示例代码（C#）</h2><blockquote>
<p>来源：大话设计模式（书籍）——第8章 工厂方法模式</p>
</blockquote>
<p>具有加减乘除的计算器的代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class OperationFactory&#123;</div><div class="line">    public static Operation createOperate(string operate)&#123;</div><div class="line">        Operation oper = null;</div><div class="line">        switch(operate)&#123;</div><div class="line">            case &quot;+&quot;:</div><div class="line">                oper = new OperationAdd();</div><div class="line">                break;</div><div class="line">            case &quot;-&quot;:</div><div class="line">                oper = new OperationSub();</div><div class="line">                break;</div><div class="line">            case &quot;*&quot;:</div><div class="line">                oper = new OperationMul();</div><div class="line">                break;</div><div class="line">            case &quot;/&quot;:</div><div class="line">                oper = new OperationDiv();</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return oper;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端的应用</div><div class="line">Operation oper;</div><div class="line">oper = OperationFactory.createOperate(&quot;+&quot;);</div><div class="line">oper.NumberA = 1;</div><div class="line">oper.NumberB = 2;</div><div class="line">double result = oper.GetResult();</div></pre></td></tr></table></figure>
<hr>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>中文名:工厂方法模式<br>英文名:Factory Method Pattern</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</p>
<h2 id="各种解释"><a href="#各种解释" class="headerlink" title="各种解释"></a>各种解释</h2><p>工厂方法模式是完全符合设计原则的，其降低了对象之间的耦合度，而且，工厂方法模式依赖于抽象的架构，其将实例化的任务交由子类去完成，有非常好的扩展性。</p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>和简单工厂一样都是集中分装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与产品对象的耦合。<br>工厂方法模式是简单工厂模式的进一步抽象和推广，由于使用了多态性。工厂方法模式保持了简单工厂模式的有点，而且克服了它的缺点。<br>还有工厂方法克服了简单工厂违背开闭原则的缺点，又保持了封装对象创建过程的优点。</p>
<p>缺点：<br>是由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。<br>每次为工厂方法模式添加新的产品时就要编写一个新的产品类，同时还要引入抽象层，这必然会导致类结构的复杂化，所以，在某些情况比较简单时，是否要使用工厂模式，需要设计者权衡利弊了。</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂模式。</p>
<h2 id="UML结构图例"><a href="#UML结构图例" class="headerlink" title="UML结构图例"></a>UML结构图例</h2><p><img src="/images/it_pattern_factory3.jpg" alt="UML图"></p>
<h2 id="示例代码1（C-）"><a href="#示例代码1（C-）" class="headerlink" title="示例代码1（C#）"></a>示例代码1（C#）</h2><blockquote>
<p>来源：大话设计模式（书籍）——第8章 工厂方法模式</p>
</blockquote>
<p>还是拿计算器举例</p>
<p>UML结构图例<br><img src="/images/it_pattern_factory2.jpg" alt="UML图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// 先构建一个工厂接口</div><div class="line">interface IFactory&#123;</div><div class="line">    Operation CreateOperation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后加减乘除各建一个具体工厂去实现这个接口</div><div class="line">// 加法类工厂</div><div class="line">class AddFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationAdd();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 减法类工厂</div><div class="line">class SubFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationSub();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 乘法类工厂</div><div class="line">class MulFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationMul();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 除法类工厂</div><div class="line">class DivFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationDiv();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端实现效果</div><div class="line">IFactory operFactory = new AddFactory();</div><div class="line">Operation oper = operFactory.CreateOperation();</div><div class="line">oper.NumberA = 1;</div><div class="line">oper.NumberB = 2;</div><div class="line">double result = oper.GetResult();</div></pre></td></tr></table></figure>
<h2 id="示例代码2（Java）"><a href="#示例代码2（Java）" class="headerlink" title="示例代码2（Java）"></a>示例代码2（Java）</h2><blockquote>
<p>来源：Android源码设计模式解析与实战（书籍）——第5章 应用最广泛的模式——工厂方法模式</p>
</blockquote>
<p>UML结构图例<br><img src="/images/it_pattern_factory4.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象产品类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 具体的产品类 继承 产品抽象类，实现方法</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体产品A"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体产品B"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象工厂类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象工厂方法</div><div class="line">     * 具体生产什么由子类去实现</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 具体的产品对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</div><div class="line">        <span class="comment">//  return new ConcreteProductB(); // 如果想得到ConcreteProductB的实例，直接替换注释即可</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Factory factory = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product p = factory.createProduct();</div><div class="line">        p.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的几个角色都很简单，主要分为四大模块，<br>一是抽象工厂，其为工厂方法模式的核心;<br>二是具体工厂，其实现了具体的业务逻辑;<br>三是抽象产品，是工厂方法模式所创建的产品的父类;<br>四是具体产品，为实现抽象产品的某个具体产品的对象。</p>
<p>利用反射的方式更简洁地来生产具体产品对象，<br>此时，需要在工厂方法的参数列表中传入一个Class类来决定是哪一个产品类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象工厂方法</div><div class="line">     * 具体生产什么由子类去实现</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> clz 产品对象类型</div><div class="line">     * <span class="doctag">@return</span> 具体的产品对象</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于具体的工厂类，则通过反射获取类的示例即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T extends Product&gt;<span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span></span>&#123;</div><div class="line">        Product p = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            p = (Product)Class.forName(clz.getName().newInstance());</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T)p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端中的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Factory factory = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product p = factory.createProduct(ConcreteProductB.class);</div><div class="line">        p.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要哪一个类的对象就传入哪一个类的类型即可，这种方法比较简洁、动态！<br>如果你不喜欢这种方法，也可以尝试为每一个产品都定义一个具体的工厂，各司其职：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Factory factoryA = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product productA = factoryA.createProduct();</div><div class="line">        productA.method();</div><div class="line"></div><div class="line">        Factory factoryB = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product productB = factoryB.createProduct();</div><div class="line">        productB.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这样拥有多个工厂的方式我们成为多工厂方法模式</p>
<p>回到最初的那个工厂方法模式，当我们的工厂只有一个的时候，我们还是为工厂提供了一个抽象类，那么，我们是否可以将其简化，然后将对应的工厂方法改为静态方法即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpmcreteProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像这样的方法其实就是简单工厂模式（静态工厂模式），它是工厂方法模式的一个弱化版本。</p>
<h1 id="Android涉及到的工厂模式"><a href="#Android涉及到的工厂模式" class="headerlink" title="Android涉及到的工厂模式"></a>Android涉及到的工厂模式</h1><p>1.各个生命周期方法，以onCreate，它就可以看做是一个工厂方法，我们在其中可以构造我们的view并通过setContentView返回给framework处理等。</p>
<p>2.List和Set，他们都继承于Collection接口，而Collection接口继承于Iterable接口，Iterable接口很简单，就一个iterator方法<br>public interface Iterable<t>{<br>Iterator<t> iterator();<br>}<br>这意味着List和Set接口也会继承该方法，平时比较常用的两个间接实现类ArrayList和HashSet中iterator方法的实现就是构造并返回一个迭代器对象，其实就相当于一个工厂方法，专为new对象而生，这里iterator方法是构造并返回一个具体的迭代器。</t></t></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单工厂模式和工厂方法模式都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与产品对象的耦合。</p>
<p>简单工厂模式和工厂方法模式都有个最佳用法就是都可以避免修改客户端——考虑用反射技能来去除switch或if解除分支判断带来的耦合。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;英文名：    Factory Pattern&lt;br&gt;所属类型：  创建型模式&lt;br&gt;2种用法：  简单工厂模式和工厂方法模式&lt;br&gt;俗称：     实例化对象模式&lt;br&gt;本质：     工厂方法代替new操作&lt;br&gt;类别：     管理模式&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之1 —— 单例模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/01/it/DesignPattern/1.Singleton/"/>
    <id>https://hengxing0080.github.io/2017/06/01/it/DesignPattern/1.Singleton/</id>
    <published>2017-06-01T01:41:25.000Z</published>
    <updated>2017-06-22T02:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名:单例模式<br>中文别名：单实例模式 / 单态模式<br>英文名:Singleton pattern<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_singleton.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h1 id="各种解释"><a href="#各种解释" class="headerlink" title="各种解释"></a>各种解释</h1><p>单例模式确保某一个类在内存中只能有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。</p>
<p>解决一个类在内存只存在一个对象（正常情况下，一个类在内存中能new很多对象）。</p>
<p>想要保证对象唯一<br>1.为了避免其他程序过多建立该类对象，先禁止其他程序建立该类对象<br>2.还为了让其他程序可以访问到该类对象，只好在本类中自定义一个对象。<br>3.为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。<br>这三部怎么用代码体现呢？<br>1.将构造函数私有化。<br>2.在类中创建一个本类对象。<br>3.提供一个方法可以获取到该对象。<br>了解思想！对于事物该怎么描述，还怎么描述。<br>当需要将该事物的对象保证在内存中唯一时，就将以上的三步加上即可。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点<br>1.由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建，销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。<br>2.由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如肚脐配置，产生其他依赖对象时，则可以用过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。<br>3.单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对用一个资源文件的同时写操作。<br>4.单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例累，负者所有数据表的映射处理，</p>
<p>缺点<br>1.单例模式一般没有接口，扩展很苦难，若要扩展，除了修改代码基本上没有第二种途径可以实现。<br>2.单例对如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context.（android开发的朋友要注意）<br>3.单例模式上手容易，但是需要注意很多问题，最重要的就是多线程并发的情况下保证单例的唯一性。<br>4.单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。<br>对于创建开销较大的类可使用此方法，保证全局一个实例，在程序运行过程中该类不会因新建额外对象产生开销。<br>例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这是就要考虑使用单例模式。</p>
<p>单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<p>公共接口一定要考虑到代码重入的情况，能设计为单例就尽量用单例。</p>
<h1 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h1><p>1.Context类的getSystemService(String key)<br>2.LayoutInflater<br>3.Universal-Image-ImageLoader</p>
<blockquote>
<p>参考书籍：Android源码设计模式解析与实战——第2章 应用最广的模式——单例模式</p>
</blockquote>
<hr>
<h1 id="四种单例写法"><a href="#四种单例写法" class="headerlink" title="四种单例写法"></a>四种单例写法</h1><hr>
<p>由于在客户端通常没有高并发的情况，因此，选择哪些实现方式并不会有太大的区别。<br>即便如此，出于效率考虑，推荐用DoubleCheckLock(DCL)实现单例和静态内部类单例模式</p>
<h2 id="1-饿汉式-和-懒汉式"><a href="#1-饿汉式-和-懒汉式" class="headerlink" title="1.饿汉式 和 懒汉式"></a>1.饿汉式 和 懒汉式</h2><p>懒汉式和饿汉式的区别：（可用于面试题）<br>　1.懒汉式的特点：<br>　　　实例的延迟加载<br>　2.懒汉式实例的延迟加载有没有问题？：<br>　　　有，如果多线程访问时会出现安全隐患问题<br>　3.如果多线程访问时会出现安全问题怎么解决？：<br>　　　可以加同步解决：加同步的方式用同步代码块或者同步函数都行，但是稍微有些低效，不过可以用双从判断（double-check）的方式可以稍微解决低效！<br>　4.加同步的时候使用的锁是哪一个：<br>  　　该类所属的字节码文件对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 单例设计模式——饿汉式（特点：先创建对象）</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single instance = <span class="keyword">new</span> Single();   </div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125; </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 单例设计模式——懒汉式（特点：后创建对象）</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;   <span class="comment">// 注意，没有final</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">                s = <span class="keyword">new</span> Single(); <span class="comment">// 对象被延迟加载</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>getInstance方法添加了synchronized关键字，也就是getInstance是一个同步方法，这就是上面所说的在多线程情况下保证单例对象唯一性的手段。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>细想一下，大家可能会发现一个问题，即使instance已经被初始化（第一次调用时就会被初始化instance），每次调用getInatance方法都会进行同步，<br>这样会消耗不必要的资源，这就是懒汉单例模式存在的最大问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点是只有在使用时才被会被实例化，在一定程序上节约了资源<br>缺点是第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。<br>这种模式一般不建议使用。</p>
<h2 id="2-Double-Check-Lock-DCL-实现单例"><a href="#2-Double-Check-Lock-DCL-实现单例" class="headerlink" title="2.Double Check Lock(DCL)实现单例"></a>2.Double Check Lock(DCL)实现单例</h2><blockquote>
<p>来源：Android源码设计模式解析与实战——2.6.2 Double Check Lock（DCL）实现单例</p>
</blockquote>
<p>DCL方式实现单例模式的优点是既能够在需要时才初始化单例，又能够保证线程安全，且单例对象初始化后调用getInstance不进行同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="comment">// 同步代码块 </span></div><div class="line">            <span class="comment">// 注意：静态里不能写this，所以写字节码所属对象</span></div><div class="line">            <span class="keyword">synchronized</span>(Single.class)&#123;</div><div class="line">                <span class="comment">// 用双从判断的形式来解决低效的问题，稍微提高了懒汉式的效率</span></div><div class="line">                <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">                    s = <span class="keyword">new</span> Single(); <span class="comment">// 对象此时被延迟加载</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DCL失效问题"><a href="#DCL失效问题" class="headerlink" title="DCL失效问题"></a>DCL失效问题</h3><p>本程序的亮点自然都在getInstance方法上，可以看到getInstance方法中对instance进行了两次判空：<br>第一层判断主要是为了避免不必要的同步，<br>第二层的判断则是为了在null的情况下创建实例。</p>
<p>这是什么意思呢？是不是有点摸不着头脑，下面就一起来分析一下。</p>
<p>假设线程A执行到instance= new Singleton()语句，这里看起来是一句代码，但实际上它并不是一个原子操作，这句代码最终会被编译成多条汇编指令，它大致做了3件事情：<br>（1）给Singleton的实例分配内存；<br>（2）调用Singleton()的构造函数，初始化成员字段；<br>（3）将instance对象指向分配的内存空间(此时instance就不是null了)。</p>
<p>但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM（JavaMemory Model，即Java内存模型）中Cache、寄存器到主存回写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序可能是1-2-3也可能是1-3-2.如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行过了第三点，instance已经是非空了，所以，线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的错误很可能会隐藏很久。</p>
<p>在JDK1.5之后，SUN官方已经注意到这种问题，调整了JMM、具体化volatile关键字，因此，如果JDK是1.5或之后的版本，只需要将instance的定义改成private volatile static Singleton instance = null就可以保证instance对象每次都是从主存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile或多或少也会影响到性能，但考虑到程序的正确性，牺牲这点性能还是值得的。</p>
<h3 id="DCL优点"><a href="#DCL优点" class="headerlink" title="DCL优点"></a>DCL优点</h3><p>资源利用率高，第一个执行getInstance时单例对象才会被实例化，效率高。</p>
<h3 id="DCL缺点"><a href="#DCL缺点" class="headerlink" title="DCL缺点"></a>DCL缺点</h3><p>第一次加载时反应稍慢。<br>也由于Java内存模型的原因偶尔会失效，在高并发环境下也有一定的缺陷，虽然发生概率很小。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>DCL模式是使用最多的单例实现方式，它能够在需要时才实例化单例对象，并且能够在绝大多数场景下保证单例对象的唯一性，<br>除非你的代码在并发场景比较复杂或者低于JDK6版本下使用，否则，这种方式一般能够满足需求。</p>
<h2 id="3-静态内部类单例模式"><a href="#3-静态内部类单例模式" class="headerlink" title="3.静态内部类单例模式"></a>3.静态内部类单例模式</h2><blockquote>
<p>来源：<br>　<a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">如何在Android中避免创建不必要的对象</a><br>　Android源码设计模式解析与实战——2.6.3 静态内部类单例模式</p>
</blockquote>
<p>所以DCL虽然在一定程序上解决了资源消耗、多余的同步、线程安全等问题，<br>但是，它还是在某些情况下出现失效的问题。这个问题被称为双重检查锁定（DCL）失效，<br>在《Java兵法编程实践》一书的最后谈到了这个问题，并指出这种“优化”是丑陋的，不赞成使用。而建议使用如下的代码替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在Java中，类的静态初始化会在类被加载时触发，我们利用这个原理，可以实现利用这一特性，结合内部类，可以实现下面的代码，进行懒汉式创建实例。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceHolder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一次加载Singleton类时并不会初始化sInstance，只有在第一次调用Singleton的getInstance方法时才会导致sInstance被初始化。<br>因为，第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，<br>所以这是推荐使用的单例模式实现方式。</p>
<h2 id="4：枚举单例"><a href="#4：枚举单例" class="headerlink" title="4：枚举单例"></a>4：枚举单例</h2><blockquote>
<p>来源书籍——Android源码设计模式解析与实战——2.6.4 枚举单例</p>
</blockquote>
<p>更简单的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SimpleSingleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"doSomething"</span>);</div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// Call the method from Singleton:  </span></div><div class="line">SimpleSingleton.INSTANCE.doSomething();</div></pre></td></tr></table></figure>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.写法简单是枚举单例最大的有点，枚举在Java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法。</p>
<p>2.最重要是默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。</p>
<p>  为什么这么说呢？<br>  因为上述的集中单例模式实现中，在一个情况下它们会出现重新创建对象的情况，那就是<font color="#FF0000"><strong>反序列化</strong></font>。<br>  通过序列化可以将一个单例的实例对象写到磁盘，然后在读回来，从而有效地活得一个实例。<br>  即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该累的构造函数。<br>  反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的、被实例化的方法readResolve(),这个方法可以让开发人员控制对象的反序列化。<br>  例如：上述几个示例中如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入如下方法：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readReslove</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  例而在单例中，并不存在这个问题，因为即使反序列化它也不会重新生成新的实例。<br>  也就是在readResolve方法中将sInstance对象返回，而不是默认的重新生成一个新的对象。</p>
<h2 id="5：使用容器实现单例模式"><a href="#5：使用容器实现单例模式" class="headerlink" title="5：使用容器实现单例模式"></a>5：使用容器实现单例模式</h2><blockquote>
<p>参考书籍——Android源码设计模式解析与实战——2.6.5 使用容器实现单例模式</p>
</blockquote>
<p>一种另类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))&#123;</div><div class="line">            objMap.put(key,instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> objMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理工具类中，在使用根据key获取对象对应类型的对象。<br>这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名:单例模式&lt;br&gt;中文别名：单实例模式 / 单态模式&lt;br&gt;英文名:Singleton pattern&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_singleton.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>世界编程语言排行榜（Tiobe)</title>
    <link href="https://hengxing0080.github.io/2017/05/31/it/Statistics/RankingsProgrammingLanguage/"/>
    <id>https://hengxing0080.github.io/2017/05/31/it/Statistics/RankingsProgrammingLanguage/</id>
    <published>2017-05-31T08:35:15.000Z</published>
    <updated>2017-06-22T03:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/statistics_programminglanguage_logo.jpg" alt="LOGO"></p>
<p>信息来源官网：TIOBE<br>Tiobe实时编程排行榜传送门：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="external">https://www.tiobe.com/tiobe-index/</a></p>
<p>下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据</p>
<p>TIOBE Index for May 2017<br><img src="/images/Rankings.jpg" alt="UML图"></p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/statistics_programminglanguage_logo.jpg&quot; alt=&quot;LOGO&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息来源官网：TIOBE&lt;br&gt;Tiobe实时编程排行榜传送门：&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据&lt;/p&gt;
&lt;p&gt;TIOBE Index for May 2017&lt;br&gt;&lt;img src=&quot;/images/Rankings.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 统计调查" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>世界编程语言排行榜（Tiobe官网实时排名)</title>
    <link href="https://hengxing0080.github.io/2017/05/31/it/Statistics/Rankings/"/>
    <id>https://hengxing0080.github.io/2017/05/31/it/Statistics/Rankings/</id>
    <published>2017-05-31T08:35:15.000Z</published>
    <updated>2017-07-16T05:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>信息来源：TIOBE<br>Tiobe实时编程排行榜传送门：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="external">https://www.tiobe.com/tiobe-index/</a></p>
<p>下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据</p>
<p>TIOBE Index for May 2017<br><img src="/images/Rankings.jpg" alt="UML图"></p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信息来源：TIOBE&lt;br&gt;Tiobe实时编程排行榜传送门：&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据&lt;/p&gt;
&lt;p&gt;TIOBE Index for May 2017&lt;br&gt;&lt;img src=&quot;/images/Rankings.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 统计调查" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%9F%A5/"/>
    
    
  </entry>
  
</feed>
