<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹空间</title>
  <subtitle>时间在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-09-19T10:13:49.306Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运算符系列：位运算符</title>
    <link href="https://hengxing0080.github.io/2017/08/25/it/Algorithm/BitwiseOperation/"/>
    <id>https://hengxing0080.github.io/2017/08/25/it/Algorithm/BitwiseOperation/</id>
    <published>2017-08-25T03:54:12.000Z</published>
    <updated>2017-09-19T10:13:49.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_bitwise.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>位运算符：位是二进制位的位，也就是说位运算符是直接对二进制进行运算的符号<br> 它是做所有运算中最快的<br> 有局限性，以2的倍数增长<br>（左移右移）</p>
<hr>
<h1 id="各个分析"><a href="#各个分析" class="headerlink" title="各个分析"></a>各个分析</h1><hr>
<h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>越往左移，数越大</p>
<h3 id="运算规律"><a href="#运算规律" class="headerlink" title="运算规律"></a>运算规律</h3><p>就是2的倍数或者2的几次幂 </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>3&lt;&lt;2 = 12<br>　3左移2位 等于12，实际上就是 3<em>4 =12　或者 3</em>22(3<em>(2</em>2)<br>　3的二进制表示形式：0000-0000-0000-0000-0000-0000-0000-0011<br>　12的二进制表示形式：0000-0000-0000-0000-0000-0000-0000-1100<br>　左移2位（舍弃），右边缺2个拿0补<br>3&lt;&lt;1 = 6<br>　实际上就是 3<em>2=6或3</em>21(3<em>(2</em>1)<br>　00000011 3&lt;&lt;1(左移1位) 之后：00000110 就是6<br>3&lt;&lt;3 =24<br>　实际上就是 3<em>8=24或3</em>23（3<em>(2</em>2*2)</p>
<h2 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移&gt;&gt;"></a>有符号右移&gt;&gt;</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>右移位运算就是将左操作数的比特位向右移动第二个操作数指定的位数，在二进制中，首位是用来表示正负的，若右移运算符的第一个操作数是正数，就填充0，是负数就填充1；</p>
<p>最高位补什么由原有数据的最高位值而定（最高位：如1111-1111）<br>如果最高位0，右移后，用0补空位<br>如果最高位1，右移后，用1补空位</p>
<p>就是将那个数转为2进制然后在前面补0或1<br>如果是正数就补0<br>负数补1</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>越往右移，数越小</p>
<h3 id="运算规律-1"><a href="#运算规律-1" class="headerlink" title="运算规律"></a>运算规律</h3><p>就是除以2的几次幂</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>6&gt;&gt;2 = 1<br>　6右移2位是1，实际上就是 6/2(2)=1 或者 6/(2<em>2)<br>　等于6除以4，都是整数，所以小数点舍弃得1<br>　右移2位（舍弃），左边补2个0<br>6&gt;&gt;1 = 3<br>　实际上就是 6/2 = 3<br>6&gt;&gt;3 = 0<br>　实际上就是 3</em>2 = 6<br>11 &gt;&gt; 2<br>　则是将数字11右移2位<br>　11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011，然后把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。<br>　则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。<br>　转换为十进制是2。
　</p>
<h2 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义</p>
<h3 id="运算规律-2"><a href="#运算规律-2" class="headerlink" title="运算规律"></a>运算规律</h3><p>物理最高位是什么，右移后，都用0补</p>
<h3 id="无符号右移与有符号右移的区别"><a href="#无符号右移与有符号右移的区别" class="headerlink" title="无符号右移与有符号右移的区别"></a>无符号右移与有符号右移的区别</h3><p>无符号始终补0</p>
<h2 id="与运算-amp"><a href="#与运算-amp" class="headerlink" title="与运算&amp;"></a>与运算&amp;</h2><p>概述：&amp;符号也可以做位运算符存在<br>运算技巧：0是假，1是真<br>示例：6 &amp; 3 = 2<br>示例代码： System.out.println(6 &amp; 3);<br><img src="/images/it_algorithm_bitwise2.png" alt="UML图"></p>
<h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算|"></a>或运算|</h2><p>示例：6 | 5 = 7<br><img src="/images/it_algorithm_bitwise3.png" alt="UML图"></p>
<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算^"></a>异或运算^</h2><p>示例：6 ^ 5 = 3<br>示例代码： System.out.println(6 ^ 5);<br><img src="/images/it_algorithm_bitwise4.png" alt="UML图"></p>
<h3 id="异或技巧"><a href="#异或技巧" class="headerlink" title="异或技巧"></a>异或技巧</h3><p>范例：7 ^ 4 = 3<br>范例：7 ^ 4 ^ 4 = 7<br>范例：7 ^ 5 ^ 5 = 7<br>结论：一个数异或同一个数2次，结果还是那个数。  （这个规律要记住）<br><img src="/images/it_algorithm_bitwise5.png" alt="UML图"></p>
<h3 id="异或用途"><a href="#异或用途" class="headerlink" title="异或用途"></a>异或用途</h3><p>用于加密算法，异或一次变反了，在异或一次就变回来了</p>
<p>数据加密（把某个数如4异或一次）<br>数据解密（和4在异或一次）</p>
<p>还有更复杂的加密方式，如又与又或有很多种运算，这就叫加密算法</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码~"></a>反码~</h2><p>理解：就是取反</p>
<p>示例代码： System.out.println(~7);</p>
<p>范例：<br>~6 = -7  (正6的取反)<br><img src="/images/it_algorithm_bitwise6.png" alt="UML图"></p>
<p>~-6 = -7+1  （负6的取反）<br><img src="/images/it_algorithm_bitwise7.png" alt="UML图"></p>
<hr>
<h1 id="面试题和使用场景"><a href="#面试题和使用场景" class="headerlink" title="面试题和使用场景"></a>面试题和使用场景</h1><hr>
<h2 id="1-最有效率的方式算出2乘以8等于几？"><a href="#1-最有效率的方式算出2乘以8等于几？" class="headerlink" title="1.最有效率的方式算出2乘以8等于几？"></a>1.最有效率的方式算出2乘以8等于几？</h2><p>最有效率的方式不是2*8，它的底层还是二进制运算<br>二进制是10000<br>十进制是16<br><img src="/images/it_algorithm_bitwise8.png" alt="UML图"></p>
<p>最高效的运算是位运算：2&lt;&lt;3<br>2乘以8：8是2的三次方，也就是将2左移3位（这3位去掉），右边补位（3个0），等于16<br><img src="/images/it_algorithm_bitwise9.png" alt="UML图"></p>
<h2 id="2-对两个整数变量的值进行互换"><a href="#2-对两个整数变量的值进行互换" class="headerlink" title="2.对两个整数变量的值进行互换"></a>2.对两个整数变量的值进行互换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperateDemo2</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = <span class="number">3</span>,m = <span class="number">8</span>;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"n="</span>+n+<span class="string">",m="</span>+m);  <span class="comment">// 打印互换之前的变量</span></div><div class="line"></div><div class="line">        <span class="comment">// 1.通过定义第三方变量（推荐这种最简单的方式，开发常用，阅读性强）</span></div><div class="line">        <span class="comment">//  11 = 3 + 8;</span></div><div class="line">        <span class="comment">//  3 = 11 - 8;</span></div><div class="line">        <span class="comment">//  8 = 11 - 3;</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        temp = n;</div><div class="line">        n = m;</div><div class="line">        m = temp;</div><div class="line"></div><div class="line">        <span class="comment">// 2.不用第三方变量</span></div><div class="line">        <span class="comment">// 2.1.第一种方式：(但是有局限性，如果n和m的值非常大，容易超出int范围，容易损失精度)</span></div><div class="line">        n = n + m;  <span class="comment">// 3+8=11，此时n=11</span></div><div class="line">        m = n - m;  <span class="comment">// 11-8=3，此时m=3</span></div><div class="line">        n = n - m;  <span class="comment">// 11-3=8，此时n=8</span></div><div class="line"></div><div class="line">        <span class="comment">// 2.2.第二种方式：(技巧型方式，记这个有规则，左边是nmn，右边是nnn和mmm)</span></div><div class="line">        n = n ^ m;</div><div class="line">        m = n ^ m;  <span class="comment">// 过程：(n^m)^m  （m异或一个数2次所以还是n）</span></div><div class="line">        n = n ^ m;  <span class="comment">// 过程：n^(n^m)                                      */</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"n="</span>+n+<span class="string">",m="</span>+m);   <span class="comment">// 打印互换之后的变量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_bitwise.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 各种" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%90%84%E7%A7%8D/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之12 —— 享元模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/23/it/DesignPattern/12.Flyweight/"/>
    <id>https://hengxing0080.github.io/2017/08/23/it/DesignPattern/12.Flyweight/</id>
    <published>2017-08-23T13:10:30.000Z</published>
    <updated>2017-09-18T16:34:13.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：享元模式<br>英文名：Flyweight<br>又名：共享模式<br>所属类型：结构型模式</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_flyweight1.png" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍：<br>(1) Flyweight(抽象享元角色)：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。在Java中可以由抽象类、接口来担当。</p>
<p>(2) ConcreteFlyweight(具体享元角色)：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。</p>
<p>(3) UnsharedConcreteFlyweight(具体不共享享元角色)：指那些不需要共享的Flyweight子类，因为Flyweight接口共享成为可能，但它并不强制共享.</p>
<p>(4) FlyweightFactory(享元工厂角色)：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键！</p>
<p>(5) Client(客户端角色)：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>使用共享对象可有效地支持大量的细颗度的对象。<br>运用共享技术有效的支持大量细粒度的对象。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对象共享，避免创建多对象</p>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<p>可以避免大量非常相似类的开销。</p>
<p>它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。</p>
<p>享元模式是对象池的一种实现，代表轻量级的意思。<br>用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享，避免创建过多对象的效果，这样一来就可以提升性能，避免内存移出等。<br>享元对象中的部分状态是可以共享，可以共享的状态称为内部状态，内存状态不会随着环境变化，不可共享的状态则称为外部状态，它们会随着环境的改变而改变。在享元模式中会简历一个对象容器，在景点的享元模式中该容器为一个Map，它的健是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免了创建过多对象的问题。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>1.系统中存在大量的相似对象。<br>2.细颗度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>3.需要缓冲池的场景。<br>4.一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p>总之就是如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用，还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p>
<h1 id="两个状态（内部状态和外部状态）"><a href="#两个状态（内部状态和外部状态）" class="headerlink" title="两个状态（内部状态和外部状态）"></a>两个状态（内部状态和外部状态）</h1><p>内蕴状态存储在享元内部，不会随环境的改变而有所不同，是可以共享的<br>外蕴状态是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。</p>
<hr>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><hr>
<p>针对上述的UML结构图的代码示例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">// Flyweight类，它是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态</div><div class="line">abstract class Flyweight&#123;</div><div class="line">    public abstract void Operation(int extrinsicstate);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteFlyweight是继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间</div><div class="line">class ConcreteFlyweight : Flyweight&#123;</div><div class="line">    public overridevoid Operation(int extrinsicstate)&#123;</div><div class="line">        Console.WriteLine(“具体Flyweight：” extrinsicstate);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// UnsharedConcreteFlyweight是指那些不需要共享的Flyweight子类。</div><div class="line">// 不过为什么有UnsharedConcreteFlyweight的存在呢？</div><div class="line">// 因为Flyweight接口共享称为可能，但它并不强制共享.</div><div class="line">// 说白了就是因为个别时候也有可能不需要共享的，它的存在解决那么不需要共享对象的问题.</div><div class="line">class UnsharedConcreteFlyweight: Flyweight&#123;</div><div class="line">    public overridevoid Operation(int extrinsicstate)&#123;</div><div class="line">        Console.WriteLine(“不共享的具体Flyweight：” extrinsicstate);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// FlyweightFactory，是一个享元工厂，用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）</div><div class="line">class FlyweightFactory&#123;</div><div class="line">    private Hashtable flyweights = new Hashtable();</div><div class="line">    public FlyweightFactory()&#123;</div><div class="line">        // 初始化工厂时，先生成三个实例</div><div class="line">        flyweights.Add(“X”,new ConcreteFlyweight());</div><div class="line">        flyweights.Add(“Y”,new ConcreteFlyweight());</div><div class="line">        flyweights.Add(“Z”,new ConcreteFlyweight());</div><div class="line">        // FlyweightFactory根据客户需求返回早已生成好的对象，但一定要事先生成对象实例吗？</div><div class="line">        // 不一定需要，完全可以初始化时什么也不做，到需要时，再去判断对象是否为null来决定是否实例化</div><div class="line">&#125;</div><div class="line">public Flyweight GetFlyweight(string key)&#123;</div><div class="line">        return ((Flyweight)flyweight[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码</div><div class="line">public class Client&#123;</div><div class="line">    static void Main(string[] args)&#123;</div><div class="line">        int extrinsicstate = 22; // 代码外部状态</div><div class="line"></div><div class="line">        FlyweightFactory f = new FlyweightFactory();</div><div class="line"></div><div class="line">        Flyweight fx = f.GetFlyweight(“X”);</div><div class="line">        fx.Operation(--extrinsicstate);</div><div class="line"></div><div class="line"></div><div class="line">        Flyweight fy = f.GetFlyweight(“Y”);</div><div class="line">        fy.Operation(--extrinsicstate);</div><div class="line"></div><div class="line"></div><div class="line">        Flyweight fz = f.GetFlyweight(“Z”);</div><div class="line">        fz.Operation(--extrinsicstate);</div><div class="line"></div><div class="line">        UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();</div><div class="line">        uf.Operation(--extrinsicstate );</div><div class="line"></div><div class="line">        Console.Read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 结果显示</div><div class="line">具体Flyweight:21</div><div class="line">具体Flyweight:20</div><div class="line">具体Flyweight:19</div><div class="line">不共享的具体Flyweight:18</div></pre></td></tr></table></figure>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>1.买火车票（Android源码设计模式解析与实战——22.5）</p>
<p>2.String（Android源码设计模式解析与实战——22.5）<br>在JDK中String也是类似消息池，Java中String是存在于常量池中。也就是一个String被定义之后它就被缓存到了常量池中，当其他地方要使用同样的字符串时，则直接使用的是缓存，而不会重复创建。</p>
<p>3.围棋和五子棋（Android源码设计模式解析与实战——26.5）</p>
<p>4.在word经常输入英文字符<br>如输出ABCDEFD很多很多的字符，每一个字符都是一个对象，最后导致会有很多的小对象，浪费！<br>所以，只要定义26个对象，分别代表26个字母，然后表示不同位置出现的对象<br>例：itegrity<br>其中有2个位置出现了i，所以定义i为一个对象，<br>这个对象有个叫显示的方法（display），<br>这个方法然后接收参数（在哪个地方显示），传入x位置和y位置（外部的状态）<br>例：i.display(int x,int y)<br>这样对象的数量大大的减少了</p>
<p>5.电脑桌面图标<br>桌面上的图标，比如文件夹，如果每一个文件夹图标都要建立一个对象那是很多很多的对象，<br>因为文件夹都是一样的外表，就定义成一个对象，叫做图标，有显示的位置和标题</p>
<p>6.缓存<br>把那些基本整数很小的，把它们缓存起来，在哪个地方出现整数就把这个缓存整数弄出来，而不是该定义一个新的整数对象</p>
<h1 id="Android源码中的桥接模式实现"><a href="#Android源码中的桥接模式实现" class="headerlink" title="Android源码中的桥接模式实现"></a>Android源码中的桥接模式实现</h1><p>1.Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。<br>2.定义成员变量，都是享元模式。<br>    示例：<br>    /**</p>
<pre><code> * 享元设计模式(只声明一次,为下面所有操作共享这些成员变量)
 */
private AlertDialog dialog;
private AlertDialog.Builder builder;
private View view;
private EditText et_password;
private Button bt_ok;
private Button bt_cancel;
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>享元模式实现比较简单，但是它的作用在某些场景确实极其重要的。它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>大幅度降低内存中对象的数量</p>
<p>缺点：<br>1.使系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使程序的逻辑复杂化。<br>2.享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。<br>3.使用享元模式需要维护一个记录了系统已有的所有享元的列表，而这本身需要耗费资源。<br>所以应当在有足够多的对象实例可供共享时才值得使用享元模式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：享元模式&lt;br&gt;英文名：Flyweight&lt;br&gt;又名：共享模式&lt;br&gt;所属类型：结构型模式&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_flyweight1.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之11 —— 桥接模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/22/it/DesignPattern/11.Bridge/"/>
    <id>https://hengxing0080.github.io/2017/08/22/it/DesignPattern/11.Bridge/</id>
    <published>2017-08-22T12:05:31.000Z</published>
    <updated>2017-09-14T08:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：桥接模式<br>英文名：Bridge<br>又名：桥梁模式<br>所属类型：结构型模式</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_bridge1.png" alt="UML图"><br><a id="more"></a><br>角色介绍：</p>
<ul>
<li><p>Abstraction：抽象部分<br>该类保持一个对实现对象的引用，抽象部分中的方法需要调用实现部分的对象来实现，该类一般都抽象类。</p>
</li>
<li><p>RefinedAbstraction：优化的抽象部分<br>抽象部分的具体实现，该类一般是对抽象部分的方法进行完善和扩展。</p>
</li>
<li><p>Implementor：实现部分<br>可以为接口或抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分这些基本操作的业务方法。</p>
</li>
<li><p>ConcreteImplementorA/ConcreteImplementorB：实现部分的具体实现<br>完善实现部分中方法定义的具体逻辑</p>
</li>
<li><p>Client：客户类，客户端程序</p>
</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>什么叫抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>连接两地的交通枢纽</p>
<p>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</p>
<p>将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化‘’</p>
<hr>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><hr>
<p>针对上述的UML结构图的代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现部分的抽象接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span>&#123;</div><div class="line">    <span class="comment">// 实现抽象部分的具体方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现部分具体的实现一</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImple</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">// 具体的实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现部分具体的实现二</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementrorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImple</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//具体的实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象部分的实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Implementor mImplementor; <span class="comment">//声明一个私有成员变量引用实现部分的对象</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 通过实现部分对象的引用构造抽象部分的对象</div><div class="line">    * <span class="doctag">@param</span> implementor 实现部分对象的引用</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span></span>&#123;</div><div class="line">        mImplementor = implementor;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 通过调用实现部分具体的方法实现具体的功能</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</div><div class="line">        mImplementor.operationImpl();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 抽象部分的子类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(implementor);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 对父类抽象部分中的方法进行扩展</div><div class="line">    */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refinedOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 对Abstraction中的方法进行扩展</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户端实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 客户调用逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>多角度去分类实现对象，而只用继承会造成大量的类增加，不能满足开放-封闭原则时，就应该要考虑用桥接模式了。</p>
<p>桥梁的作用其实就是连接“抽象部分”与“实现部分”,但是事实上，任何多维度变化或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。<br>如果一个系统需要在构建的抽象画和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，可以通过桥接模式使它们在抽象层建立一个关联关系。<br>对象那么不希望使用继承或因为多层次几层导致系统类的个数急剧增加的系统，也可以考虑使用桥接模式。</p>
<p>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>1.手机品牌和手机软件（大话设计模式——22章）</p>
<p>2.咖啡厅喝咖啡（Android源码设计模式解析与实战——24.5）</p>
<p>3.实现不同样式的ProgressBar（Android源码设计模式解析与实战——24.8）</p>
<p>4.进行数据库dao类设计也会使用到桥接模式</p>
<p>5.开关与具体的电器<br>开关的类型有多种，而电器也是各式各样，这两者是独立变化的且又有耦合</p>
<p>6.显示屏<br>显示屏的尺寸与生厂商之间也是一种二维关系，具体的尺寸与具体的厂商独立变化</p>
<h1 id="Android源码中的桥接模式实现"><a href="#Android源码中的桥接模式实现" class="headerlink" title="Android源码中的桥接模式实现"></a>Android源码中的桥接模式实现</h1><p>1.Window与WindowManager</p>
<p>2.WindowManagerService</p>
<p>3.Adapter与AdapterView</p>
<p>4.View的视图曾觌与执行真正的硬件绘制相关功能实现类（DisplayList, HadrdwareLayer和Canvas负责）之间的关系是可以看做是一种桥接模式</p>
<p>5.对于Android来说，应用层与Native层之间的交互就是一个最好的例子<br>需要操纵Android设备硬件时就需要使用一个连接应用层与Native的桥梁，这个桥梁通常是一个具体的类，比如提供操作相机的Camera，播放音视频的MediaPlayer，提供图形绘制接口的OpenCV等，这些API类为我们操作底层硬件提供了可能。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>桥接模式可以应用到许多开发中，但是它应用得却不多，一个很重要的原因是对于抽象与实现的分离的把握，是不是需要分离，如何分离？<br>所以对设计者来说要有一个恰到好处的分寸。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>分离抽象与实现，灵活的扩展以及对客户来说透明的实现</p>
<p>缺点：<br>不容易设计，对开发者来说要有一定的经验要求。理解很容易，设计却不容易。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：桥接模式&lt;br&gt;英文名：Bridge&lt;br&gt;又名：桥梁模式&lt;br&gt;所属类型：结构型模式&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_bridge1.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之10 —— 组合模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/21/it/DesignPattern/10.Composite/"/>
    <id>https://hengxing0080.github.io/2017/08/21/it/DesignPattern/10.Composite/</id>
    <published>2017-08-21T13:21:51.000Z</published>
    <updated>2017-09-14T08:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：组合模式(CompositePatterm)<br>又名：合成模式 | 部分整体模式(Part-whole Patterm)<br>所属类型：结构型模式</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_composite1.png" alt="UML图"><br><a id="more"></a><br>外观模式接口比较简单，就是通过一个统一的接口对外提供服务，使得外层程序只通过一个雷就可以实现系统内部的多种功能，而这些实现功能的内部子系统之间可能也有交互，或者说完成一个功能需要几个子系统之间进行协作，如果没有封装，那么用户就需要操作几个子系统的交互逻辑，容易出现错误。而通过外观类类对外屏蔽这些复杂的交互，降低拥护的使用成本。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将对象组合成树形结构以表示‘部分-整体’的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>树状嵌套结构</p>
<p>组合模式比较简单，它将一组相似的对象看做一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略对象与对象集合之间的拆别。生活中一个比较典型的例子就是组织结构的树状图。</p>
<h1 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h1><p>当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。<br>部分与整体的关系。</p>
<p>表示对象的部分-整体层次结构时。<br>从一个整体中能够独立出部分模块或功能的场景。</p>
<h1 id="使用场合示例"><a href="#使用场合示例" class="headerlink" title="使用场合示例"></a>使用场合示例</h1><p>1.Windows系统的文件系统（文件和文件夹）就是一种典型的组合模式例子。<br>—详情查看 Android源码设计模式解析与实战 —— 19.5 组合模式的简单实现</p>
<p>2.Android的目录选择器DirScelector</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">// Component为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件。</div><div class="line">abstract class Component&#123;</div><div class="line">    protected string name;</div><div class="line"></div><div class="line">    public Component(string name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 通常都用Add和Remove方法来提供增加或移出树叶或树枝的功能</div><div class="line">    public abstract void Add(Component c);</div><div class="line">        public abstract void Remove(Component c); </div><div class="line">        public abstract void Display(int depth);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// Left在组合中表示叶节点对象，叶节点没有子节点。</div><div class="line">class Leaf : Component&#123;</div><div class="line">    public Leaf(string name) ： base(name)&#123;&#125;</div><div class="line"></div><div class="line">    public override void Add(Component c)&#123;</div><div class="line">        Comsole.writeLine(“Cannot add to a leaf”);</div><div class="line">    &#125;</div><div class="line">    public override void Remove(Component c)&#123;</div><div class="line">        Console.WriteLine(“Cannot removee from a leaf”);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Display(int depth)&#123;</div><div class="line">        // 叶节点的具体方法，此处是显示其名称和级别</div><div class="line">        Console.WriteLine(new String(‘-’,depth)+name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Composite定义有枝结点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove.</div><div class="line">class Composite : Component&#123;</div><div class="line">    private List&lt;Component&gt; children = new List&lt;Component&gt;();</div><div class="line"></div><div class="line">    public Composite(string name):base(name)&#123;&#125;</div><div class="line"></div><div class="line">    public override void Add(Component c)&#123;</div><div class="line">        children.Add(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Remove(Component c)&#123;</div><div class="line">        children.Remove(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Display(int depth)&#123;</div><div class="line">        Console.WriteLine(new String(‘-’,depth) + name);</div><div class="line">        foreach(Component component in children)&#123;</div><div class="line">            component.Display(depth + 2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码，能通过Component接口操作组合部件的对象。</div><div class="line">static void Main(strin[] args)&#123;</div><div class="line">    // 生成树根root，根上长出两叶LeafA和LeafB</div><div class="line">    Composite root = new Composite(“root”);</div><div class="line">    root.Add(new Leaf(“Leaf A”));</div><div class="line">    root.Add(new Leaf(“Leaf B”));</div><div class="line"></div><div class="line">    // 根上长出分枝CompositeX,分枝上也有两叶LeafXA和LeafXB</div><div class="line">    Composite comp = new Composite(“Composite X”);</div><div class="line">    comp.Add(new Leaf(“leaf XA”));</div><div class="line">    comp.Add(new Leaf(“leaf XB”));</div><div class="line">    root.Add(comp);</div><div class="line"></div><div class="line">    // 在Composite X上在长出分枝CompositeXY,分枝上也有两叶LeafXYA和LeafXYB</div><div class="line">    Composite comp2 = new Composite(“Composite XY”);</div><div class="line">    comp2.Add(new Leaf(“leaf XYA”));</div><div class="line">    comp2.add(new Leaf(“leaf XYB”));</div><div class="line">    comp.Add(comp2);</div><div class="line"></div><div class="line">    // 根部又长出两叶LeafC和LeafD，可惜LeafD没长牢，被风吹走了</div><div class="line">    root.Add(new Leaf(“Leaf C”));</div><div class="line">    Leaf leaf = new Leaf(“Leaf D”);</div><div class="line">    root.Add(leaf);</div><div class="line">    root.Remove(leaf);</div><div class="line"></div><div class="line">    // 显示大树的样子</div><div class="line">    root.Display(1);</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">结果显示</div><div class="line">    -root</div><div class="line">    ---Leaf A</div><div class="line">    ---Leaf B</div><div class="line">    ---Composite X</div><div class="line">    -----Leaf XA</div><div class="line">    -----Leaf XB</div><div class="line">    -----Composite XY</div><div class="line">    -------Leaf XYA</div><div class="line">    -------Leaf XYB</div><div class="line">    ---Leaf C</div></pre></td></tr></table></figure>
<h1 id="透明方式与安全方式"><a href="#透明方式与安全方式" class="headerlink" title="透明方式与安全方式"></a>透明方式与安全方式</h1><p>接上述代码示例。<br>为什么Leaf类也有Add和Remove，树叶不是不可以在长分枝吗？<br>这种方式叫透明方式，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add,Remove等。<br>这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，<br>它们具备完全一致的行为接口。<br>但问题也很明显，因为Leaf类本身不具备Add(),Remove()方法的功能，所以实现它是没有意义的。<br>Leaf类当中不用Add和Remove方法就是所谓的安全方式，也就是在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，这样做旧不会出现刚才提到的问题，<br>不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。<br>虽透明方式不用判断省事，但是两者各有好处，视情况而定！</p>
<h1 id="Android源码中模式实现"><a href="#Android源码中模式实现" class="headerlink" title="Android源码中模式实现"></a>Android源码中模式实现</h1><p>View和ViewGroup的嵌套组合</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们平时在Android开发的过程中组合模式的应用并不算多，组合模式更适用于对一些界面UI的架构设计上，当然，绝大多数情况下，这部分代码都会由相应的程序语言提供，比如Java的AWT，Android和iOS的UI框架等，真正需要开发者去实现的不多。<br>组合模式和解释器模式有一定的类同，两者在迭代对象时都涉及递归的调用，但是组合模式所提供的属性层次结构使得我们能够一视同仁地对待单个对象和对象集合，不过，这是牺牲类的单一原则换来的，而且组合模式是通过继承来实现的，这样的缺乏缺少弹性。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>组合模式可以一致地使用组合结构和单个对象。</p>
<p>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让高层模块忽略了层次的差异，方便对整个层次结构进行控制。<br>高层模块可以一致地使用一个组合结构或其中单个对象，不必关系处理的是单个对象还是整个组合结构，简化了高层模块的代码。<br>组合模式中增加新的枝干构件和叶子狗子都很方便，无须对现有类库进行任何修改，符合“开闭原则”。<br>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和枝干对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制缺非常简单。</p>
<p>缺点：<br>在新增构件时不好对枝干中的构件类型进行限制，不然依赖类型系统来增加这些约束，因为在大多数情况下，它们都来自于相同的抽象层，此时，必须进行蕾西检查来实现，这个实现过程较为复杂。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：组合模式(CompositePatterm)&lt;br&gt;又名：合成模式 | 部分整体模式(Part-whole Patterm)&lt;br&gt;所属类型：结构型模式&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_composite1.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之9 —— 外观模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/20/it/DesignPattern/9.State/"/>
    <id>https://hengxing0080.github.io/2017/08/20/it/DesignPattern/9.State/</id>
    <published>2017-08-20T12:00:02.000Z</published>
    <updated>2017-09-14T04:32:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：外观模式<br>英文名：Facade<br>又名：门面模式<br>所属类型：结构型模式</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_facade2.png" alt="UML图"><br><a id="more"></a><br>外观模式接口比较简单，就是通过一个统一的接口对外提供服务，使得外层程序只通过一个雷就可以实现系统内部的多种功能，而这些实现功能的内部子系统之间可能也有交互，或者说完成一个功能需要几个子系统之间进行协作，如果没有封装，那么用户就需要操作几个子系统的交互逻辑，容易出现错误。而通过外观类类对外屏蔽这些复杂的交互，降低拥护的使用成本。</p>
<p>角色介绍<br>Facade：系统对外的统一接口，系统内部系统地工作。简单的说就是这个外观类为子系统提供一个共同的对外接口<br>SystemA，SystemB，SystemC：子系统接口<br>Clients：客户对象通过一个外观接口读写子系统中各接口的数据资源。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。<br>外观模式提供一个高层次的接口，使得子系统更易于使用。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>外部与一个子系统的通信必须通过一个统一的门面对象进行。<br>门面模式提供一个高层次的接口，使得子系统更易于使用。<br>每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类<br>很常用，因为它完美体现了依赖倒转原则和迪米特法则的思想，所以是非常常用的模式之一。</p>
<p>在开发过程中的运用频率非常高，尤其是在现结点各种第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式。<br>通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低拥护的使用成本，也对拥护屏蔽了很多实现细节。<br>当然，在开发过程中，外观模式也是封装API的常用手段，例如网络模块，ImageLoader模块等。<br>可能你在开发中运用无数次外观模式，只是没有在理论层面认识它。</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>在以下情况下可以考虑使用外观模式：<br>(1) 设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。<br>(2) 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。<br>(3) 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点<br>1.对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。<br>2.外观类对子系统的接口封装，使得系统更易于使用。</p>
<p>缺点：<br>1.外观类接口膨胀<br>　　由于子系统的接口都有外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了拥护使用成本。<br>2.外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>外观模式一个高频率使用的设计模式，它的精髓就在于封装二字。<br>通过一个高层次结构为拥护提供统一的API入口，使得拥护通过一个类型就基本能够操作整个系统，这样减少了用户的使用成本，也能够提升系统的灵活性。</p>
<h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><p>生活中使用外观模式的例子非常多，任何一个类似中央调度结构的组织都类似外观模式。举个简单的例子，手机就是一个外观模式的例子，它集合了电话功能，短信功能，GPS，拍照等于一身，通过手机你就可以完成各种功能。而不是当你打电话时准备一个诺基亚1100，要拍照时非常用一个相机，如果是这样每使用一个功能你就必须操作特定的设备，会使得整个过程很繁琐。而手机给了你一个统一的入口，集电话，上网，拍照等功能于一身。使用方便，操作简单。</p>
<p>下面模拟手机的外观模式<br><img src="/images/it_pattern_facade3.png" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">MobilePhone</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Phone mPhone = <span class="keyword">new</span> PhoneImpl();</div><div class="line">    <span class="keyword">private</span> Camera mCamera = <span class="keyword">new</span> SamsungCamera();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>&#123;</div><div class="line">        mPhone.dail();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">videoChat</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“--&gt; 视频聊天接通中”);</div><div class="line">        mCamera.open();</div><div class="line">        mPhone.dail();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>&#123;</div><div class="line">        mPhone.hangup();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>&#123;</div><div class="line">        mCamera.open();</div><div class="line">        mCamera.takePicture();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeCamera</span><span class="params">()</span></span>&#123;</div><div class="line">        mCamera.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span></span>&#123;</div><div class="line">    <span class="comment">//打电话</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 挂断</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneImpl</span> <span class="keyword">implements</span> <span class="title">Phont</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“打电话”);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“打电话”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Camera</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamsungCamera</span> <span class="keyword">implements</span> <span class="title">Camera</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“打开相机”);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“拍照”);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“关闭相机”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        MobilePhone nexus6 = <span class="keyword">new</span> MobilePhone();</div><div class="line">        <span class="comment">// 拍照</span></div><div class="line">        nexus6.takePicture();</div><div class="line">        <span class="comment">// 视频聊天</span></div><div class="line">        nexus6.videoChat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">    打开相机</div><div class="line">    拍照</div><div class="line">    打开相机</div><div class="line">    打电话</div></pre></td></tr></table></figure>
<p>从上述代码中可以看到，外观模式就是统一接口封装。<br>将子系统的逻辑，交互隐藏起来，为拥护提供一个高层次的接口，使得系统更加易用，同事也对外隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会感知到，<br>因为用户使用的是Facade高层接口，内部的变化对于用户来说并不可见。<br>这样一来就将变化隔离开来，使得系统也更加灵活。</p>
<h1 id="Android源码中的外观模式"><a href="#Android源码中的外观模式" class="headerlink" title="Android源码中的外观模式"></a>Android源码中的外观模式</h1><p>1.ContextImpl<br>Context对开发者来说是最重要的高层接口。不过它只是一个抽象类，它的真正实现在ContextImpl（外观）类中</p>
<p>2.SDK和开源库<br>外观模式在这里是使用率最高的模式，这些库通过外观类为拥护提供统一的高层接口，使得用户不必了解一些更细节的实现。<br>例如在使用ImageLoader时我们通常只操作一个ImageLoader类就可以完成，而不要了解网络请求类，缓存类以及它们的交互细节。<br>又比如在使用友盟统计SDK时，通过MobclickAgent这个相当于是外观类就可以完成我们所需的功能，至于MobclickAgent类内部有其他的什么类型，它们的具体交互是什么我们都不需要关系。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：外观模式&lt;br&gt;英文名：Facade&lt;br&gt;又名：门面模式&lt;br&gt;所属类型：结构型模式&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_facade2.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之8 —— 适配器模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/19/it/DesignPattern/8.adapter/"/>
    <id>https://hengxing0080.github.io/2017/08/19/it/DesignPattern/8.adapter/</id>
    <published>2017-08-19T14:12:59.000Z</published>
    <updated>2017-09-13T16:37:00.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 适配器模式<br>外文名 Adapter  Pattern<br>又名 变压器模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_adapter1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h1><p>Target：目标角色，也就是所期待得到的接口。注意，由于这里讨论的是类适配器模式，因此目标不可以是类。<br>Adaptee：现在需要适配的接口。<br>Adapter：适配器角色，也是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。<br>适配类可以根据参数返还一个合适的实例给客户端。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。<br>一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p>
<p>在软件开发中，也就是系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个缘由对象与某个接口匹配。<br>适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，如何在需要和早期代码复用一些功能等应用上很有实际价值。</p>
<p>简单理解就是将2个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种解决方案使得它们能够协作起来进行很好的合作。<br>例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是没有如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时往往会使用一个Adapter，在这两种接口之间创建一个混血儿接口，这个Adapter会将两个接口进行兼容，在不修改原有代码的情况下满足需求。</p>
<p>所以Apdater模式在开发中运用非常广泛，因此，掌握Adapter模式是非常必要的。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>更好的复用性<br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>更好的扩展性<br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体把握。<br>例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。<br>因此，如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
</ul>
<h1 id="适配器模式和代理模式的区别"><a href="#适配器模式和代理模式的区别" class="headerlink" title="适配器模式和代理模式的区别"></a>适配器模式和代理模式的区别</h1><p>代理模式和适配器模式应该说很相像，但是他们的区别也很明显，代理模式和被代理者的接口是同一个，只是使用中客户访问不到被代理者，所以利用代理间接的访问，而适配器模式，是因为接口不同，为了让用户使用到统一的接口，把原先的对象通过适配器让用户统一的使用，大多数运用在代码维护的后期，或者借用第三方库的情况下 ，</p>
<h1 id="适配器模式的两种写法"><a href="#适配器模式的两种写法" class="headerlink" title="适配器模式的两种写法"></a>适配器模式的两种写法</h1><ul>
<li><p>对象适配器模式<br>– 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p>
</li>
<li><p>类适配器模式<br>– 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。<br>– 由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而C#，VB.NET，Java等语言都不支持多重继承（C++支持），<br>也就是一个类只有一个父类。</p>
</li>
</ul>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>用电源接口做例子，笔记本电脑的电源一般都是用5V电压，但是我们生活中的癫痫电压一般都是200V。这个时候就出现了不匹配的状况，在软件开发中我们称之为接口不兼容，此时就需要适配器来进行一个接口转换。在软件开发中有一句话正好体现了这点：任何问题都可以加一个中间层来解决。这个层我们可以理解为这里的Adapter层，通过这层来进行一个接口转换就达到了兼容的目的。<br>下列代码中，5V电压就是Target接口，220V电压就是Adaptee类，而将电压从220V转换到5V就是Adapter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Target角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FiveVolt</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adaptee角色，需要被转换的对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volt220</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span></span>&#123;</div><div class="line">        Return <span class="number">220</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adapter角色，将220V的电压转换成5V的电压</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">FiveVolt</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    VoltAdapter adapter = <span class="keyword">new</span> VoltAdapter();</div><div class="line">        System.out.println(“输出电压：”+adapter.getVolt5());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用代理关系连接到Adaptee类，UML图如下</p>
<p>从下列代码可以看到，Adaptee类（Volt220）并没有getVolt5()方法，而客户端则期待这个方法。为使客户端使用Adapter类，需要提供一个包装类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// Target角色</div><div class="line">public interface FiveVolt&#123;</div><div class="line">    Public int getVolt5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Adaptee角色，需要被转换的对象</div><div class="line">public classs Volt220&#123;</div><div class="line">    public int getVolt220()&#123;</div><div class="line">        return 220;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 对象适配器模式</div><div class="line">public class VoltAdapter implements FiveVolt&#123;</div><div class="line">    Volt229 mVolt220;</div><div class="line">    public VoltAdapter(Volt220 adaptee)&#123;</div><div class="line">        mVolt220 = adaptee;</div><div class="line">    &#125;</div><div class="line">    public int getVolt220()&#123;</div><div class="line">        return mVolt220.getVolt220();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getVolt5()&#123;</div><div class="line">        return 5;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Client</div><div class="line">public classs Test&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        VoltAdapter adapter = new VoltAdapter(new Volt220());</div><div class="line">        System.out.println(“输出电压：”+adapter.getVolt5());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现方式直接将要适配的对象传递到Adapter中，使用组合的形式实现接口兼容的效果。这比类适配器方式更为灵活，它的另一个好处是被适配对象的方法不会暴露出来，<br>而类适配器由于继承了被适配对象，因此，被适配对象类的函数在Adapter类中也都含有，这使得Adapter类出现一些奇怪的接口，用户使用成本较高。因此，对象适配器模式更加灵活、实用。</p>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>在Android的开发使用率极高，从代码中随处可见的Adapter就可以判断出来。从最早的ListView，GriwView到现在最新的RecyclerView都需要使用Adapter.<br>所以Adapter模式的是非常灵活的实现，如ListView中的隔离变化，使得整个UI架构变得更灵活，能够拥抱变化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名 适配器模式&lt;br&gt;外文名 Adapter  Pattern&lt;br&gt;又名 变压器模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_adapter1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>框架模式 —— MVC &amp; MVP &amp; MVVM &amp; MVPVM</title>
    <link href="https://hengxing0080.github.io/2017/08/17/it/DesignPattern/MVC/"/>
    <id>https://hengxing0080.github.io/2017/08/17/it/DesignPattern/MVC/</id>
    <published>2017-08-17T13:11:01.000Z</published>
    <updated>2017-09-13T10:38:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_pattern_mvc1.png" alt="图"><br><a id="more"></a></p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li><p>架构<br>有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。<br>简单的说架构就是一个蓝图，是一种设计方案，将客户的不同需求抽象成为抽象组件，并且能够描述这些抽象组件之间的通信和调用。<br>总结一下，就是一整个软件工程项目中的骨架，是一种宏观的规划。</p>
</li>
<li><p>框架<br>软件框架是项目软件开发过程中提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型。<br>框架不是现成可用的应用系统，而是一个半成品，提供了诸多服务，开发人员进行二次开发，实现具体功能的应用系统。<br>框架则是一个半成品的应用，直接给出一个骨架。写框架能提升自己的架构能力。剖析别人框架的特点，写出属于自己的框架。</p>
</li>
<li><p>库<br>库是解决某个问题而拼凑出来的一大堆函数与类的集合。</p>
</li>
<li><p>设计模式<br>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，它强调的是一个设计问题的解决方法。</p>
</li>
</ul>
<hr>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MVC英文：Model-View-Controller<br>中文含义：模型——视图——控制器<br>提出时间：1970年由TrygveReenskaug在Smalltalk-80系统上·首次提出<br>产生时间：1982年</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/it_pattern_mvc2.png" alt="图"><br>MVC中View接受事件,并调用Controller来操作Model,同时,当Model实例的数据发生变化后，Controller再更新界面(当然View也可以直接更新Model)。</p>
<h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>将数据模型和视图分离开来，并以控制器作为连接两者的桥梁以实现解耦</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MVC是一种框架模式而非设计模式<br>GOF把MVC看作是3种设计模式：观察者模式，策略模式与组合模式的合体，而且核心在观察者模式，也就是一个基于发布/订阅者模型的框架，很多时间在实际开发过程中我们常常还会在MVC框架中使用到其他的设计模式。</p>
<p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<h2 id="框架模式与设计模式的区别"><a href="#框架模式与设计模式的区别" class="headerlink" title="框架模式与设计模式的区别"></a>框架模式与设计模式的区别</h2><p>做开发的经常会听到这样活那样的框架，比如注解框架，通信框架，数据存储框架等通用性较强的框架，还有一些面向后端开发的，如Structs,Spring等框架，在这些框架中你常常会见到很多设计模式的应用。<br>对框架来说，通常是代码的重用，而对设计来说通常是对设计的重用，<br>简单理解就是框架面向于一系列相同行为代码的重用，而设计则面向的是一系列相同结构代码的重用，<br>我们平常所说的架构则介于框架与设计之间。<br>在软件开发领域有3种级别的重用：<br>内部重用，即在同一应用中能公共使用的抽象块;<br>代码重用，即将通用模块组合成库或工具集，以便在多一个应用和领域都能使用。<br>应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。<br>开发过程中场景的框架模式有MCV，MVP，MVVC ,MTV，CBD，ORM<br>框架是大智慧，用来对软件设计进行分工<br>设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>理解很容易，技术含量并不高，对开发和维护来说成本较低也易于维护和修改。<br>耦合性不高，表示层与业务层分离实现各司其职，对开发来说也是很有利，前端工程师专注于界面的研发，后端工程师则致力于业务逻辑的完善等。</p>
<p>缺点：<br>没有明确的定义，所以完全理解MVC模式并不是很容易。<br>使用MVC模式需要精心计划，由于它的内部原理比较复杂，需要花时间去思考。<br>开发一个MVC模式架构的工程，讲不得不花费相当可观的时间去考虑如何将MVC模式运用到应用程序中，同时由于Model和View要严格分离，这样也是调试应用程序带来了一定的困难。<br>由于MVC模式将一个应用程序分成了3个部件，所以，这意味着同一个工程将包含比以前更多的文件。因此，对于一些小规模的项目，MVC反而会更来更大的工作量以及复杂性。</p>
<h2 id="MVC在Android中的实现"><a href="#MVC在Android中的实现" class="headerlink" title="MVC在Android中的实现"></a>MVC在Android中的实现</h2><p>在传统的开发中Activity俨然既充当了Controller又充当了View的作用.既需要接受用户响应操作Model,又要更新界面.<br>这样做有一个好处就是数据的更新变得很简单,但是缺点也十分明显,Activity是非臃肿,后期不好维护.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Android的UI系统中，控制器Activity主要起到的作用就是解耦，将试图View和模型Model进行分离，两者在Activity中进行绑定或完成其他逻辑。<br>MVC更适合于大规模项目，比如Android的UI系统框架，但是android的健康非我们自己完成的，而是由framework给我们搭建好并提供给我们的，在平时的开发中，特别是用Android开发，我们并不常用到MVC模式去脱离Android UI系统构建自己的框架结构。</p>
<hr>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Model-View-Presenter<br>模型-视图-主导器</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>是传统MVC(Model-View-Controller)在Android开发上的一种变种演化版本、进化模式。<br>主要用来隔离UI、UI逻辑和业务逻辑、数据,创建松散耦合并可重用的对象。<br>我们知道View层是容易变化且多种多样的,业务逻辑也是多种多样的,与传统的MVC相比,P充当了C的作用.<br>Model存储数据，View表示Model的表现，Presenter协调两者之间的通信.</p>
<p>能有效地降低View复杂性，避免业务逻辑被塞进View中。<br>解除View与Model的耦合，同时也带来了良好的可扩展性，可测试性，保证了系统的整洁性，灵活性。<br>对于简单的应用来说MVP稍显麻烦，各种各样的接口与概念，使得整个应用充斥着零散的接口，但是对于比较复杂的应用来说，MVP模式是一种良好的架构模式，它能够非常好地组织应用结构，使得应用变得灵活，拥抱变化。</p>
<h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/it_pattern_mvc3.png" alt="图"><br>MVP中将业务逻辑单独抽出Presenter,View层变成一个被动的东西,Presenter负责完成View层与Model层的交互.<br>View 不可以直接和Model交互(MVC中允许Model和View交互),只有Presenter告知其更新，它才会去更新.<br>而且Presenter和View的交互是通过接口来完成.</p>
<h2 id="MVP模式的三个角色"><a href="#MVP模式的三个角色" class="headerlink" title="MVP模式的三个角色"></a>MVP模式的三个角色</h2><p>1.Presenter——交互中间人（中介）<br>主要作为沟通View和Model的桥梁，它从Model层检索数据后，返回给View层，使得View和Model之间没有耦合，也将业务逻辑从View角色上抽离出来。<br>2.View——用户界面<br>View通常是指Activity，Fragment或者某个View控件，它含有一个Presenter成员变量。通常View需要实现一个逻辑接口，将View上的操作通过会转交给Presenter进行实现，最后，Presenter调用View逻辑接口将结果返回给View元素。<br>3.Model——数据的存取<br>对于一个结构化的App来说，Model角色主要是提供数据的存取功能。Presenter需要通过Model层存储，获取数据，Model就像一个数据仓库。更直白的说，Model是封装了数据库DAO或者网络获取数据的角色，或者两种数据获取方式的集合。</p>
<h2 id="MVP与MVC-MVVM的区别"><a href="#MVP与MVC-MVVM的区别" class="headerlink" title="MVP与MVC,MVVM的区别"></a>MVP与MVC,MVVM的区别</h2><p>1.MVC特点<br>1.用户可以向View发送指令，再由View直接要求Model改变状态。<br>2.用户也可以直接向Controller发送指令，再由Controller发送给View<br>3.Controller起到事件路由的作用，同时业务逻辑都部署在Controller中。<br>可以看到，MVC的耦合性还是相对较高，View可以直接访问Model，导致3者之间构成回路。<br>因为,MVP与MVC的主要区别是，MVP中的View不能直接访问Model，需要通过Presenter发出请求，View与Model不直接通信。</p>
<p>2.MVVM特点<br>MVVM与MVP很相似，唯一的区别是View和Model进行双向绑定（data-binding），两者之间有一方发送变化则会反应到另一方上。<br>而MVP与MVVM的主要区别则是，MVP中的View更新需要通过Presenter，而MVVM不需要，因为View与Model进行了双向绑定，数据的修改会直接反应到View角色上，而View的修改也会导致数据的变更。此时，ViewModel角色需要做的只是业务逻辑的处理，以及修改View或者Model的状态。<br>MVVM模式有点像ListView与Adapter，数据集的关系，这个Adapter就是ViewModel角色，它与View进行了绑定，又与数据集进行了绑定，当数据集合发送变化时，调用Adapter的notifyDataSetChanged之后就直接更新，他们之间没有直接的耦合，使得ListView变的更为灵活。</p>
<h2 id="MVP与Activity-Fragment的生命周期"><a href="#MVP与Activity-Fragment的生命周期" class="headerlink" title="MVP与Activity,Fragment的生命周期"></a>MVP与Activity,Fragment的生命周期</h2><p>优点：<br>易维护，易测试，松耦合，复用性高，健壮稳定，易扩展。</p>
<p>缺点：<br>由于Presenter经常性需要执行一些耗时操作，例如网络请求数据，Presenter持有了Activity的强引用，如果在请求结束之前Activity被销毁了，那么由于网络请求还买有返回，导致Presenter一直持有Activity对象，使得Activity对象无法被回收，此时就发生了内存泄漏。</p>
<p>解决方案：<br>通过弱引用和Acitivyt,Fragment的生命周期来解决这个问题。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>MVP是开发过程中非常值得推荐的架构模式，它能够将各组件进行解耦，并且带来良好的可扩展性，可测试性，稳定性，可维护性，<br>同时使得每个类似的职责相对单一，简单，避免了大量代码的程序存在，例如数千行的Activity类。<br>有效的将业务逻辑，数据处理等工作从Activity等View元素中抽离出来，使得每个类尽可能简单，同时每个模块能够独立进行演化。<br>它的思维也体现了面向对象的设计原则，即抽象，单一职责，最小化，低耦合。</p>
<hr>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><hr>
<p><img src="/images/it_pattern_mvc4.png" alt="图"></p>
<p>MVVM (Model-View-ViewModel)<br>在MVP基础上的变种,相比较MVP而言,MVVM使数据绑定变得更加简单.</p>
<p>即ViewModel到View的映射，不需要再去自己找到view，然后更新字段，而是在映射建立后直接更新ViewModel然后反映到View上。<br>值得一提的是，MVP和MVVM都是微软提出的理念，最早都是在WPF里面被应用的，只是时至今日才在Android上被真正用起来。</p>
<p>MVVM最先使用在WPF中,通过ViewModel和View的映射,完成了View和Model的双向绑定.<br>View的事件直接传递到ViewModel，ViewModel去对Model进行操作并接受更新.进而反馈到View上.</p>
<h2 id="MVVM在Android中的实现"><a href="#MVVM在Android中的实现" class="headerlink" title="MVVM在Android中的实现"></a>MVVM在Android中的实现</h2><p>在Android上对应Data Binding</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>因为ViewModel与View的耦合,MVVM有一个缺点就是View的复用问题,<br>因为去掉了Presenter,View层依然过重.</p>
<hr>
<h1 id="MVPVM"><a href="#MVPVM" class="headerlink" title="MVPVM"></a>MVPVM</h1><hr>
<p><img src="/images/it_pattern_mvc5.png" alt="图"></p>
<p>MVPVM (Model-View-Presenter-ViewModel)</p>
<p>MVPVM是MVP和MVVM的演化变种版本,MVPVM在MVVM中加入引入Presenter层，降低了ViewModel与View的耦合,View只需要实现ViewModel的观察者接口实现更新.ViewModel不再对Model直接进行操作,而是交给了Presenter.Presenter操作Model并反馈到ViewModel上<br>Model,View,ViewModel之间通过Presenter联系了起来.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_pattern_mvc1.png&quot; alt=&quot;图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 —— IOC（控制反转）</title>
    <link href="https://hengxing0080.github.io/2017/08/15/it/DesignPattern/IOC/"/>
    <id>https://hengxing0080.github.io/2017/08/15/it/DesignPattern/IOC/</id>
    <published>2017-08-15T07:21:32.000Z</published>
    <updated>2017-09-13T10:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_pattern_ioc1.jpg" alt="图"><br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名：控制反转<br>英文：IoC（Inversion of Control）<br>目的：描述框架的重要特征<br>起源时间：1988年</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IoC是框架的重要特征，并非面向对象编程的专用术语。<br>它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。</p>
<p>IoC是一个重要的面向对象编程的法则来削减计算机程序的耦合问题，也是轻量级的Spring框架的核心。 </p>
<p>IoC体现了<a href="https://baike.baidu.com/item/%E5%A5%BD%E8%8E%B1%E5%9D%9E%E5%8E%9F%E5%88%99/16019700?fr=aladdin" target="_blank" rel="external">好莱坞原则</a>，即“不要打电话过来，我们会打给你”。</p>
<p>IoC是Spring的核心，贯穿始终。所谓IOC就是有Spring来控制对象的生命周期和对象间的关系。<br>传统开发模式：对象之间相互依赖<br>IOC开发模式：IOC控制对象之间的依赖</p>
<p>IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。</p>
<p>也可以把IoC模式看做是工厂模式的升华，可以把IoC看作是一个大工厂，只不过这个大工厂里要生成的对象都是在XML文件中给出定义的，然后利用Java 的“反射”编程，根据XML中给出的类名生成相应的对象。从实现来看，IoC是把以前在工厂方法里写死的对象生成代码，改变为由XML文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。<br>IoC中最基本的Java技术就是“反射”编程。反射又是一个生涩的名词，通俗的说反射就是根据给出的类名（字符串）来生成对象。这种编程方式可以让对象在生成时才决定要生成哪一种对象。反射的应用是很广泛的，像Hibernate、Spring中都是用“反射”做为最基本的技术手段。<br>在过去，反射编程方式相对于正常的对象生成方式要慢10几倍，这也许也是当时为什么反射技术没有普遍应用开来的原因。但经SUN改良优化后，反射方式生成对象和通常对象生成方式，速度已经相差不大了（但依然有一倍以上的差距）。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>IoC最大的好处是什么？<br>因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是实现于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拔（有点像USB接口和SCSI硬盘了）。</p>
<p>IoC最大的缺点是什么？<br>（1）生成一个对象的步骤变复杂了（事实上操作上还是挺简单的），对于不习惯这种方式的人，会觉得有些别扭和不直观。<br>（2）对象生成因为是使用反射编程，在效率上有些损耗。但相对于IoC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。<br>（3）缺少IDE重构操作的支持，如果在Eclipse要对类改名，那么你还需要去XML文件里手工去改了，这似乎是所有XML方式的缺陷所在。</p>
<h1 id="实现策略类型"><a href="#实现策略类型" class="headerlink" title="实现策略类型"></a>实现策略类型</h1><p>IoC是一个很大的概念,可以用不同的方式实现。其主要形式有两种类型：依赖注入和依赖查找。<br>依赖注入应用比较广泛。</p>
<p>1.依赖注入（Dependency Injection，简称DI）<br>容器提供回调接口和上下文条件给组件。EJB和Apache Avalon 都使用这种方式。这样一来，组件就必须使用容器提供的API来查找资源和协作对象，仅有的控制反转只体现在那些回调方法上（也就是上面所说的 类型1）：容器将调用这些回调方法，从而让应用代码获得相关资源。</p>
<p>其又有三种方式：<br>接口注入（Interface Injection）<br>设置注入（Setter Injection）<br>构造注入（Constructor Injection）</p>
<p>2.依赖查找（Dependency Lookup，简称DL）<br>组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。容器全权负责的组件的装配，它会把符合依赖关系的对象通过JavaBean属性或者构造函数传递给需要的对象。通过JavaBean属性注射依赖关系的做法称为设值方法注入(Setter Injection)；将依赖关系作为构造函数参数传入的做法称为构造器注入（Constructor Injection）</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="http://stamen.iteye.com/blog/1489223/" target="_blank" rel="external">透透彻彻IoC（你没有理由不懂！）</a><br><a href="http://blog.csdn.net/bestcxx/article/details/77931436" target="_blank" rel="external">依赖注入和控制反转的理解，写的太好了</a><br><a href="http://blog.csdn.net/u013320868/article/details/54926578" target="_blank" rel="external">浅析android中的依赖注入</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_pattern_ioc1.jpg&quot; alt=&quot;图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之7 —— 代理模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/12/it/DesignPattern/7.Proxy/"/>
    <id>https://hengxing0080.github.io/2017/08/12/it/DesignPattern/7.Proxy/</id>
    <published>2017-08-12T03:22:47.000Z</published>
    <updated>2017-08-30T10:41:01.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 代理模式<br>外文名 Proxy Pattern<br>又名 委托模式 | 第三方模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_proxy1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为其他对象提供一种代理以控制对这个对象的访问。<br>在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>跟MM在网上聊天，一开头总是“hi，你好”，“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 </p>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。  </p>
<p>代理模式一个非常重要的模式，而且学起来很简单！</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象实现相同的接口。</p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>（1）抽象角色：通过接口或抽象类声明真实角色实现的业务方法。<br>（2）代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>（3）真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>（1）装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2）装饰对象包含一个真实对象的引用（reference）<br>（3）装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4）装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>（1）职责清晰<br>真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。<br>（2）代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。<br>（3）高扩展性</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>几乎没有什么缺点而言，它是细分化至很小的一种模式，要真找缺点，那么就是所有涉及模式的通病：对类的增加，不过在这种孰优孰劣的局势下，就算对类的稍微增加又何妨呢？</p>
<h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理<br>对象实现同一个接口,先访问代理类再访问真正要访问的对象。</p>
<p>代理模式分为静态代理、动态代理。</p>
<p>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</p>
<h1 id="代理模式的2种方式"><a href="#代理模式的2种方式" class="headerlink" title="代理模式的2种方式"></a>代理模式的2种方式</h1><h2 id="从Code方面"><a href="#从Code方面" class="headerlink" title="从Code方面"></a>从Code方面</h2><p>1.1.静态代理<br>如下述示例那样，代理者的代理又程序员自己或通过一些自动化工具生成固定的代理在对其进行编译。也就是说在我们的代理运行前代理类的class编译文件就已存在。</p>
<p>需求：小明以前在公司上班时，就遇到过被老板拖欠工资甚至克扣工资的情况，这种情况下小明还是通过法律途径来解决问题，一旦小明选择了走法律途径解决该纠纷，那么不可避免地就需要请一个律师来作为自己的诉讼代理人，我们将诉讼的流程抽象在一个接口类中。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 诉讼接口类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="comment">// 提交申请</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 进行举证</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 开始辩护</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 诉讼完成</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体诉讼人</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMin</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“老板·拖欠工资！特此申请仲裁！”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“这是合同书和过去一年的银行工资流水”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“证据确凿！不需要说什么了！”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“诉讼成功！判决老板即日起七天内结算工资”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代理律师类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lawyer</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> ILawsuit mLawsuit;  <span class="comment">// 持有一个具体被代理者的引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lawyer</span><span class="params">(ILawsult lawsuit)</span></span>&#123;</div><div class="line">        mLawsuit = lawsit;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.submit();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.burden();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.defend();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造一个小明</span></div><div class="line">        ILawsuit xiaoming = <span class="keyword">new</span> XiaoMin();</div><div class="line">        <span class="comment">// 构造一个代理律师并将小明作为构造参数传递进去</span></div><div class="line">        ILawsuit lawyer = <span class="keyword">new</span> Lawyer(xiaoming);</div><div class="line">        <span class="comment">// 律师提交诉讼申请</span></div><div class="line">        lawyer.submit();</div><div class="line">        <span class="comment">// 律师进行举证</span></div><div class="line">        lawyer.burden();</div><div class="line">        <span class="comment">// 完成诉讼</span></div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.2.动态代理<br>动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们在code阶段压根就不需要知道代理谁，代理谁我们将会在执行阶段决定。<br>而Java也给我们提供了一个便捷的动态代理接口InvocationHandler，实现该接口需要重写其调用方法invoke<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0,Method args1, Object[] args2)</span><span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过invoke方法来调用具体的被代理方法，也就是真实的方法。<br>动态代理可以使我们的代理逻辑更简洁</p>
<p>优化代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHander</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 被代理的类引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line">    &#125; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 调用被代理类对象的方法</span></div><div class="line">        Object result = method.invoke(obj, args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造一个小明</span></div><div class="line">        ILawsuit xiaoming = <span class="keyword">new</span> XiaoMin();</div><div class="line">        <span class="comment">// 构造一个动态代理</span></div><div class="line">        DynamicProxy proxy = <span class="keyword">new</span> DynamicProxy(xiaomin);</div><div class="line">        <span class="comment">// 获取被代理类小明的ClassLoader</span></div><div class="line">        ClassLoader loader = xiaoming.getClass().getClassLoader();</div><div class="line">        <span class="comment">// 动态构造一个代理者律师</span></div><div class="line">        ILawsuit lawyer = (ILawsuit)Proxy.newProxyInstance(loader,<span class="keyword">new</span> Class[] &#123; ILawsuit.class&#125;,proxy);</div><div class="line">        <span class="comment">// 律师提交诉讼申请</span></div><div class="line">        lawyer.submit();</div><div class="line">        <span class="comment">// 律师进行举证</span></div><div class="line">        lawyer.burden();</div><div class="line">        <span class="comment">// 律师代替小明进行辩护</span></div><div class="line">        lawyer.defend();</div><div class="line">        <span class="comment">// 完成诉讼</span></div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果和以前一致。<br>由此可见动态代理通过一个代理类来代理N多被代理类，其实质是对代理者与被代理者进行解耦，使两者直接没有直接的耦合关系。<br>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么久需要重新定义不同代理类，较为复杂，但是静态代理更符合面向对象原则。<br>在开发时具体使用哪种方式来实现代理，就看自己的偏好了。</p>
<h2 id="从适用范围区别几种不同类型的代理实现"><a href="#从适用范围区别几种不同类型的代理实现" class="headerlink" title="从适用范围区别几种不同类型的代理实现"></a>从适用范围区别几种不同类型的代理实现</h2><p>1.远程代理（Remote Proxy）：为某个对象在不同的内存地址空间提供局部代理。使系统可以将Server部分的实现隐藏，以便Client可以不必考虑Server的存在。<br>2.虚拟代理（Virtual Proxy）：使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。<br>3.保护代理（Protection Proxy）：使用代理控制对原始对象的访问。该类型的代理常被用于原始对象又不同访问权限的情况。<br>4.智能引用（Smart Reference）：在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数。<br>这里要注意的是，静态和动态代理都可以应用于上述4种情形，两者是各自独立的变化。</p>
<h1 id="代理模式实战场景"><a href="#代理模式实战场景" class="headerlink" title="代理模式实战场景"></a>代理模式实战场景</h1><p>1.NotificationManager的notify方法发送通知（详情看android源码设计模式解析与实战—18.8代理模式实战）</p>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>1.Binder跨进程通信机制与AIDL<br>代理模式：类似于ios开发的delegate委托模式，所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。<br>简介：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>2.子线程委托主线程的handler调用它的handlemessage来更新UI，类似代理设计模式</p>
<p>3.ActivityManagerProxy代理类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名 代理模式&lt;br&gt;外文名 Proxy Pattern&lt;br&gt;又名 委托模式 | 第三方模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_proxy1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之6 —— 装饰模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/10/it/DesignPattern/6.Decorator/"/>
    <id>https://hengxing0080.github.io/2017/08/10/it/DesignPattern/6.Decorator/</id>
    <published>2017-08-10T00:11:22.000Z</published>
    <updated>2017-08-30T10:27:33.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 装饰模式<br>外文名 Decorator Pattern<br>又名 装饰者模式 | 包装模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_decorator1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍<br> ● Client：客户端用户。<br> ● Prototype：抽象类或者接口，声明具备clone能力。<br> ● ConcretePrototype：具体的原型类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态地给一个对象添加一些额外的职责。<br>就增加功能来说，装饰模式相比生成子类更加灵活。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。</p>
<p>装饰模式是为已有功能动态地添加更多功能的一种方式。<br>这个模式还是算很好理解！</p>
<h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>Java IO 流是典型的装饰模式。</p>
<h1 id="现实中使用"><a href="#现实中使用" class="headerlink" title="现实中使用"></a>现实中使用</h1><p>人需要各式各样的衣着，不管你穿着怎么样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式，装饰物也各不相同但是装饰的对象本质是不变的。</p>
<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><p>以下情况使用Decorator模式<br>（1） 需要扩展一个类的功能，或给一个类添加附加职责。<br>（2） 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>（3） 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>（4） 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2） 装饰对象包含一个真实对象的引用（reference）<br>（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>（1）Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。<br>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>（3）把类中的装饰功能从类中搬移去除，这样可以简化原有的类。 有效的把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复装饰逻辑。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>（1）这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。<br>（2）装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。<br>（3）装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>多用组合，少用继承。<ul>
<li>利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。</li>
<li>然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</li>
</ul>
</li>
<li>类应设计的对扩展开放，对修改关闭。 </li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>需要透明且动态地扩展类的功能时。</p>
<h1 id="装饰模式和代理模式的区别"><a href="#装饰模式和代理模式的区别" class="headerlink" title="装饰模式和代理模式的区别"></a>装饰模式和代理模式的区别</h1><p>装饰模式和代理模式有点类型，有时甚至容易混淆，倒不是把代码当成装饰，而容易将装饰看成代理，所以要注意！<br>装饰模式是亿对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，儿代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用。<br>装饰模式应该为所装饰的对象增强·功能，代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>
<h1 id="装饰模式与适配者模式的区别"><a href="#装饰模式与适配者模式的区别" class="headerlink" title="装饰模式与适配者模式的区别"></a>装饰模式与适配者模式的区别</h1><p>1.关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。<br>2.关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种–“半透明”装饰者）<br>3.关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。</p>
<h1 id="模式简化的2种方式"><a href="#模式简化的2种方式" class="headerlink" title="模式简化的2种方式"></a>模式简化的2种方式</h1><ol>
<li>如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。</li>
<li>如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。</li>
</ol>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">// Conponent类</div><div class="line">abstract class Compnent&#123;</div><div class="line">    public abstract void Operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteComponent类</div><div class="line">class ConcreteComponent : Component&#123;</div><div class="line">    public override void Operation()&#123;</div><div class="line">        Console.WriteLine(“具体对象的操作”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Decorator类</div><div class="line">abstract class Decorator :Conponent&#123;</div><div class="line">    protected Conponent component;</div><div class="line">    public void SetComponent(Component component)&#123;</div><div class="line">        this.component = component;	</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Operation()&#123;</div><div class="line">        if(component != null_&#123;</div><div class="line">            component.Operation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteDecoratorA类</div><div class="line">class ConcreteDecoratorA : Decorator&#123;</div><div class="line">    private string addedState; // 本类的独有功能，以区别于ConcreteDecoratorB</div><div class="line">    public override void Operation()&#123;</div><div class="line">        base.Operation();</div><div class="line">        addedState = “New State”;</div><div class="line">        Conscole.WriteLine(“具体装饰对象A的操作”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteDecoratorB类</div><div class="line">class ConcreteDecoratorB : Decorator&#123;</div><div class="line">    public override void Operation()&#123;</div><div class="line">        base.Operation();</div><div class="line">        AddedBehavior();</div><div class="line">        Conscole.WriteLine(“具体装饰对象A的操作”);</div><div class="line">    &#125;</div><div class="line">    private void AddedBehavior()&#123;  // 本类独有的方法，以区别于ConcreteDecoratorB</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码</div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    ConcreteConponent c = new ConcrtetComponent();</div><div class="line">    ConcreteDecoratorA d1 = new ConcreteDecoratorA();</div><div class="line">    ConcreteDecoratorB d2 = new ConcreteDecoratorB();;</div><div class="line"></div><div class="line">    // 装饰的方法是：首先用ConcreteComponent实例化对象c，然后用ConcreteDecoratorA的实例化对象d1来包装c，再用ConcreteDecoratorB的对象d2包装d1，最终执行d2的Operation();</div><div class="line">    d1.SetComponent(c);</div><div class="line">    d2.SetComponent(d1);</div><div class="line">    d2.Operation();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰模式就是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就喝如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p>
<p>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。<br>同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</p>
<p>优化代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">// Person类（ConcreteComponent）</div><div class="line">class Person&#123;</div><div class="line">    public Person()&#123;&#125;</div><div class="line">    public Person(string name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public virtual void Show()&#123;</div><div class="line">        Console.WriteLine(“装扮的&#123;0&#125;”,name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 服饰类（Decorator）</div><div class="line">class Finery : Person&#123;</div><div class="line">    protected Person component;</div><div class="line"></div><div class="line">    // 打扮</div><div class="line">    public void Decorate(Person component)&#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Show()&#123;</div><div class="line">        if(component != null)&#123;</div><div class="line">            component.Show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体服饰类（ConcreteDecorator）</div><div class="line">class TShirts : Finery&#123;</div><div class="line">    public override void Show()&#123;</div><div class="line">        Console.Write(“大T血”);</div><div class="line">        Base.Show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BigTrouser: Finery&#123;</div><div class="line">    public override void Show()&#123;</div><div class="line">        Console.Write(“大裤子”);</div><div class="line">        Base.Show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 其余类类似，省略......</div><div class="line"></div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    Person xc = new Person(“小明”);</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第一种装扮:“);</div><div class="line">    Sneakers pqx = new Sneakers();</div><div class="line">    BigTrouser kk = new BigTrouser();</div><div class="line">    TShirts dtx = new TShirts();</div><div class="line">    pqx.Decorate(xc);</div><div class="line">    kk.Decorate(pqx);</div><div class="line">    dtx.Decorate(kk);</div><div class="line">    dtx.Show();</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第二种装扮:“);</div><div class="line">    LeatherShoes px= new LeatherShoes ();</div><div class="line">    Tie ld = new Tie ();</div><div class="line">    Suit xz= new Suit ();</div><div class="line">    px.Decorate(xc);</div><div class="line">    kk.Decorate(pqx);</div><div class="line">    xz.Decorate(kk);</div><div class="line">    xz.Show();</div><div class="line"></div><div class="line"></div><div class="line">    Console.WriteLine(“\n第三种装扮:“);</div><div class="line">    Sneakers pqx2= new Sneakers();</div><div class="line">    LeatherShoes px2= new LeatherShoes ();</div><div class="line">    BigTrouser kk2= new BigTrouser();</div><div class="line">    Tie ld2 = new Tie ();</div><div class="line">    pqx2.Decorate(xc);</div><div class="line">    px2.Decorate(pqx2);</div><div class="line">    kk2.Decorate(px2);</div><div class="line">    ld2 .Decorate(kk2);</div><div class="line">    ld2 .Show();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>1.Context与ContextImpl<br>2.Activity的onCreate方法中一些相关的初始化操作。<br>装饰模式其实并不负责，就是一种类间的封装。在平时的开发过程中也经常会不经意地使用类似的概念，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> classs DecoratorActivity extends Activity&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">// 初始化数据</span></div><div class="line">        initData();</div><div class="line">        <span class="comment">// 初始化控件</span></div><div class="line">        initViews();</div><div class="line">        <span class="comment">// 初始化事件</span></div><div class="line">        initEvent();</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 初始化数据</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 初始化控件</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span></span>&#123;</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        *初始化事件</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实如上的一些新增方法的调用就类似装饰模式中的装饰者的职责，只不过这里没有保持对组件累的引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名 装饰模式&lt;br&gt;外文名 Decorator Pattern&lt;br&gt;又名 装饰者模式 | 包装模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_decorator1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>IQ题 —— 面试系列（持续更新）</title>
    <link href="https://hengxing0080.github.io/2017/08/01/it/IQ/1.interview/"/>
    <id>https://hengxing0080.github.io/2017/08/01/it/IQ/1.interview/</id>
    <published>2017-08-01T15:58:10.000Z</published>
    <updated>2017-09-19T12:05:59.406Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_iq_interview.jpg" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="8个试剂，其中一个有毒，最少多少只小白鼠能检测出有毒试剂"><a href="#8个试剂，其中一个有毒，最少多少只小白鼠能检测出有毒试剂" class="headerlink" title="8个试剂，其中一个有毒，最少多少只小白鼠能检测出有毒试剂"></a>8个试剂，其中一个有毒，最少多少只小白鼠能检测出有毒试剂</h1><hr>
<h2 id="方法1：位"><a href="#方法1：位" class="headerlink" title="方法1：位"></a>方法1：位</h2><p>运用了位的思想<br>8瓶酒，可以由对应的8个状态来对应。<br>2^3=8<br>所以三只小白鼠足够了，即三个小白鼠喝出八中状态。<br>可以把二进制对应的八位写出来，从低到高，每种情况对应一种试剂有毒，然后根据为1的死了，为0的活着，来判断哪个小白鼠喝了哪瓶试剂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># [3、2、1]</div><div class="line">0 0 1 = 1  # 2、3没死，1死了，说明第1支试剂有毒</div><div class="line">0 1 0 = 2  # 1、3没死，2死了，说明第2支试剂有毒</div><div class="line">0 1 1 = 3  # 3没死，1、2死了，说明第3支试剂有毒</div><div class="line">1 0 0 = 4  # 1、2没死，3死了，说明第4支试剂有毒</div><div class="line">1 0 1 = 5  # 2没死，1、3死了，说明第5值试剂有毒</div><div class="line">1 1 0 = 6  # 1没死，2、3死了，说明第6值试剂有毒</div><div class="line">1 1 1 = 7  # 三只都死了，说明第7值试剂有毒</div><div class="line">0 0 0 = 0  # 三只都没死，说明第8值试剂有毒</div></pre></td></tr></table></figure>
<p>这样就方便写出每只小白鼠应该喝哪几瓶了。<br>下面一步一步分析，哪环有小白鼠挂了就类似数组记录一下，依次类推，就能推导出答案了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"># 2、3没死，1死了，说明第1支试剂有毒。即第一只老鼠喝了1，二三没喝1</div><div class="line">1:[1]</div><div class="line">2:[]</div><div class="line">3:[]</div><div class="line"></div><div class="line"># 1、3没死，2死了，说明第2支试剂有毒。同上</div><div class="line">1:[1]</div><div class="line">2:[2]</div><div class="line">3:[]</div><div class="line"></div><div class="line"># 3没死，1、2死了，说明第3支试剂有毒。即一二喝了第3支试剂，三没有</div><div class="line">1:[1,3]</div><div class="line">2:[2,3]</div><div class="line">3:[]</div><div class="line"></div><div class="line"># 1、2没死，3死了，说明第4支试剂有毒。同上面情况1，2</div><div class="line">1:[1,3]</div><div class="line">2:[2,3]</div><div class="line">3:[4]</div><div class="line"></div><div class="line"># 2没死，1、3死了，说明第5值试剂有毒。说明1,3和了第5试剂，1没有</div><div class="line">1:[1,3,5]</div><div class="line">2:[2,3]</div><div class="line">3:[4,5]</div><div class="line"></div><div class="line"># 1没死，2、3死了，说明第6值试剂有毒</div><div class="line">1:[1,3,5]</div><div class="line">2:[2,3,6]</div><div class="line">3:[4,5,6]</div><div class="line"></div><div class="line"># 三只都死了，说明第7值试剂有毒</div><div class="line">1:[1,3,5,7]</div><div class="line">2:[2,3,6,7]</div><div class="line">3:[4,5,6,7]</div><div class="line"></div><div class="line"># 三只都没死，说明第8值试剂有毒</div><div class="line">1:[1,3,5,7]</div><div class="line">2:[2,3,6,7]</div><div class="line">3:[4,5,6,7]</div></pre></td></tr></table></figure>
<p>简而言之，看竖列，数列为1的，就是需要喝的。<br>比如第一只小白鼠的数列为10101010，就是需要1，3，5，7<br>第二只小白鼠的数列为0110 0110 ，就是需要2，3，6，7<br>第三只小白鼠的数列为00011110，就是需要4，5，6，7<br><img src="/images/it_iq_interview1.jpg" alt="UML图"></p>
<p>所以最终答案就是：<br>用3只小白鼠，能组合成8种状态。<br>第一只喂食【1、3、5、7】四只试剂<br>第二只喂食【2、3、6、7】四只试剂<br>第三只喂食【4、5、6、7】四只试剂</p>
<h2 id="方法2：二分"><a href="#方法2：二分" class="headerlink" title="方法2：二分"></a>方法2：二分</h2><p>每次把试剂分成两堆，然后用两只小白鼠测试，如果一只死掉了，那么就能确定哪一堆有毒。<br>然后继续分。因此，小白鼠的数量就是试剂能被二分的次数。<br>8只试剂能被二分3次，所以就需要3只小白鼠。</p>
<p>步骤：<br>第一次二分：8 → 4 (此时用到的小白鼠数量：1)<br>第二次二分：4 → 2 (此时用到的小白鼠数量：2)<br>第三次二分：2 → 1 (此时用到的小白鼠数量：3) </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>参考文章<br>　<a href="http://blog.csdn.net/u010429424/article/details/77856133" target="_blank" rel="external">面试题：8个试剂，其中一个有毒，最少多少只小白鼠能检测出有毒试剂</a><br>　<a href="http://blog.csdn.net/qq_33277870/article/details/78006116" target="_blank" rel="external">位的巧妙应用</a></p>
<p>类似题目<br>　<a href="http://blog.csdn.net/sinat_28028941/article/details/53815587" target="_blank" rel="external">1000瓶试剂，其中一瓶有毒，最少需要多少只小白鼠能找出有毒的试剂</a><br>　PS:原理差不多，知道解题思路便通杀其他类似的题</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_iq_interview.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - IQ题 - 面试题" scheme="https://hengxing0080.github.io/categories/IT-IQ%E9%A2%98-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="IQ题" scheme="https://hengxing0080.github.io/tags/IQ%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表</title>
    <link href="https://hengxing0080.github.io/2017/08/01/it/DataStructure/LinearList/"/>
    <id>https://hengxing0080.github.io/2017/08/01/it/DataStructure/LinearList/</id>
    <published>2017-08-01T01:50:23.000Z</published>
    <updated>2017-08-26T06:10:47.364Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_linearlist1.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>线性表：零个或多个具有相同类型的数据元素的有限序列</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>线性表是由n（ｎ＞＝０）个数据元素（结点）组成的有限序列</p>
<p>是像线一样的性质的表。<br>就是排好队伍<br>最常用最简单的一种结构。</p>
<p>一年里的星座列表，也是线性表<br>星座通常都是白羊座打头，双鱼座收尾，当中的星座都有前驱和后继，而且一共也只有12个，所以它完全符合线性表的定义。</p>
<h1 id="线性表特点"><a href="#线性表特点" class="headerlink" title="线性表特点"></a>线性表特点</h1><p>１.有且仅有一个开始结点<br>２.有且仅有一个终结结点<br>３.内部结点都有且仅有一个直接前驱结点和一个直接后继结点</p>
<h1 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ADT List</div><div class="line">Data</div><div class="line">    线性表的数据对象集合为｛a1,a2,...,an｝,每个元素的类型均为DataType.</div><div class="line">    其中，</div><div class="line">    除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</div><div class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</div><div class="line">    数据元素直接是一对一的关系。</div><div class="line">Operation</div><div class="line">    InitList(*L);//初始化操作，建立一个空的线性表</div><div class="line">    ListEmpty(L);//若线性表为空，返回true,否则返回false</div><div class="line">    ClearList(*L);//清空线性表</div><div class="line">    GetElem(L,i,*e);//查找线性表中的第i个位置的元素值，并赋值给e</div><div class="line">    LocateElem(L,e);//查找线性表L中与给定值e相等的元素，如果查找成功，则返回第一个相同的元素在L</div><div class="line">                   //中的下标；否则，返回0表示失败</div><div class="line">    ListInsert(*L,i,e);//在线性表L的第i个位置插入元素e</div><div class="line">    ListDelete(*L,i,*e);//删除线性表L中第i个位置元素，并用e返回其值</div><div class="line">    ListLength();//返回线性表L的长度</div><div class="line">end ADT</div></pre></td></tr></table></figure>
<h1 id="线性表的2种表现形式"><a href="#线性表的2种表现形式" class="headerlink" title="线性表的2种表现形式"></a>线性表的2种表现形式</h1><p>1.顺序表（顺序存储结构）<br>2.链表（链式存储结构）<br>　2.1.单链表<br>　2.2.静态链表<br>　2.3.循环链表<br>　3.4.双向链表<br>　3.5.跳跃链表</p>
<hr>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><hr>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>顺序表就是线性表的顺序存储方式。<br>也称为向量存储，可以看做是一维数组存储。<br>计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.使用连续的内存单元存放线性表的数据元素。<br>2.数据元素在内存中的物理存储次序与他们在线性表中逻辑次序相同。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>存储密度大<br>无须为表示表中元素之间的逻辑关系而增加额外的存储空间<br>可以快速地存取表中任一位置的元素</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>插入，删除等其他运算不方便。（需要移动大量元素，显然很耗费时间）<br>当线性表长度变化较大时，难以确定存储空间的容量。<br>造成存储空间的碎片</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;          <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;        <span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">	ElemType data[MAXSIZE];  <span class="comment">/* 数组，存储数据元素 */</span></div><div class="line">	<span class="keyword">int</span> length;              <span class="comment">/* 线性表当前长度 */</span></div><div class="line">&#125;SqList;</div></pre></td></tr></table></figure>
<h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>对于线性表的顺序存储结构来说，如果我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回，其实是非常简单的。<br>就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line">Typedef <span class="keyword">int</span> Status;</div><div class="line"><span class="comment">/*Status是函数的类型，其值是函数结果状态代码，如OK等*/</span></div><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></div><div class="line"><span class="comment">/*操作结果：用e返回L中第i个数据元素的值 */</span></div><div class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i, Elemtype *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span> || i&lt; <span class="number">1</span> || i &gt; L.length)</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    *e = L.data[i<span class="number">-1</span>];</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入算法的思路：<br>●如果插入位置不合理，抛出异常；<br>●如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>●从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置;<br>●将要插入元素填入位置i处；<br>●表长加1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L), */</span></div><div class="line"><span class="comment">/*操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1*/</span></div><div class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L, <span class="keyword">int</span> i ,ElemType e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">if</span>(L -&gt; length == MAXSIZE)   <span class="comment">/*顺序线性表已经满*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt;L-&gt; length+<span class="number">1</span>)   <span class="comment">/*当i不在范围内时*/</span></div><div class="line">    reuturn ERROR;</div><div class="line">    <span class="keyword">if</span>(i&lt;= L -&gt;length)  <span class="comment">/*若插入数据位置不在表尾 */</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">for</span>(k=L-&gt;length <span class="number">-1</span> ;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/*将要插入位置后数据元素向后移动一位*/</span></div><div class="line">    L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</div><div class="line">    &#125;</div><div class="line">    L-&gt;data[i<span class="number">-1</span>]=e;</div><div class="line">    L-&gt;length++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：<br>●如果删除位置不合理，抛出异常;<br>●取出删除元素;<br>●从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置;<br>●表长减1.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></div><div class="line"><span class="comment">/*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/</span></div><div class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">if</span>(L -&gt;length == <span class="number">0</span>)   <span class="comment">/*线性表为空*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)   <span class="comment">/*删除位置不正确*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    *e = L-&gt;data[i<span class="number">-1</span>];</div><div class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length)   <span class="comment">/*如果删除不是最后位置*/</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)  <span class="comment">/*将删除位置后继元素前移*/</span></div><div class="line">    L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k]l;</div><div class="line">    &#125;</div><div class="line">    L-&gt;length--；</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入和删除的时间复杂度"><a href="#插入和删除的时间复杂度" class="headerlink" title="插入和删除的时间复杂度"></a>插入和删除的时间复杂度</h3><p>最好情况：O（1）<br>最坏情况：O（n）<br>平静情况：O（n）</p>
<p>在存，读数据时，不管是1哪个位置，时间复杂度都是O（1）<br>而插入或删除时，时间复杂度都是O（n）<br>说明，线性表的顺序存储结构，比较适合元素个数不太变化，而更多是存储数据的应用。</p>
<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><hr>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>由于顺序存储结构的插入和删除操作不方便，引出了链式存储结构。<br>它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。</p>
<p>之前在顺序结构中，每个数据元素只需要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p>
<p>链式存储用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置上不一定相邻，必须采用附加信息表示数据元素之间的关系，即用指针体现结点之间的逻辑关系。</p>
<p>单线索，无分支。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。</p>
<h2 id="数据域和指针域"><a href="#数据域和指针域" class="headerlink" title="数据域和指针域"></a>数据域和指针域</h2><p>一般是在链表中的结点，数据域存放数据，指针域存放指向下一个结点的指针，以实现链表彻底线型结构。</p>
<h2 id="线性表类型——1-单链表"><a href="#线性表类型——1-单链表" class="headerlink" title="线性表类型——1.单链表"></a>线性表类型——1.单链表</h2><p>链式存储的线性表又分为几种，常见常用的是单链表，循环链表和双链表链表！<br>先看看单链表！</p>
<h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>并且它不是闭环的，是一条链状结构，因此才被称为单链表。<br>单链表是最简单的链式存储的线性表，他就像一条链子。<br>它的每个结点都可以分为两部分，一个是数据域（nodeValue），一个是指针域（next）<br>数据域存储结点的数据，指针域向下一个结点的内存存储地址</p>
<h3 id="头指针和尾-空指针"><a href="#头指针和尾-空指针" class="headerlink" title="头指针和尾/空指针"></a>头指针和尾/空指针</h3><p>对于单链表，我们还需要知道2个概念，头指针和尾/空指针。<br><img src="/images/it_datastructure_linearlist3.png" alt="UML图"></p>
<p>头指针：<br>是一个指针，它指向单链表第一结点存储的位置。整个单链表的存储必须从头指针开始，常用head表示，<br>链表中第一个结点的存储位置叫做头指针。</p>
<p>尾指针：<br>线性链表的最后一个结点指针为‘空’（通常用NULL或“^”符号表示）</p>
<h3 id="头指针和头结点的异同点"><a href="#头指针和头结点的异同点" class="headerlink" title="头指针和头结点的异同点"></a>头指针和头结点的异同点</h3><p>头指针<br>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。<br>头指针具有标识作用，所以常用头指针冠以链表的名字。<br>无论链表是否为空，头指针均不为空。尾指针是链表的必要元素。</p>
<p>头结点<br>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）、<br>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了。<br>头结点不一定是链表。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。</p>
<h3 id="单链表结构-与-顺序存储结构-优缺点"><a href="#单链表结构-与-顺序存储结构-优缺点" class="headerlink" title="单链表结构 与 顺序存储结构 优缺点"></a>单链表结构 与 顺序存储结构 优缺点</h3><p><img src="/images/it_datastructure_linearlist2.jpg" alt="UML图"></p>
<p>通过上面对比，得出一些经验性结论：<br>1.若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。<br>若需要频繁插入和删除时，宜采用单链表结构。比如说游戏开发中，用于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时采用顺序存储就不太合适了，单链表结构就可以大展拳脚。<br>当然，这是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。<br>2.当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。<br>而如果事先知道线性表的大致长度，如何一年12个月，一周就是星期一至星期日共七天，这样用顺序存储结构效率会高很多。</p>
<p>总之，线性表的顺序存储结构和单链表结构各有优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪个数据结构更能满足和达到需求和性能。</p>
<h3 id="如何将一个单向链表反转？"><a href="#如何将一个单向链表反转？" class="headerlink" title="如何将一个单向链表反转？"></a>如何将一个单向链表反转？</h3><p>递归</p>
<h2 id="线性表类型——2-静态链表"><a href="#线性表类型——2-静态链表" class="headerlink" title="线性表类型——2.静态链表"></a>线性表类型——2.静态链表</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><p>C语言是个好东西，它具有的指针能力，使得它可以非常容易地操作内存中的地址和数据，这比其他高级语言更加灵活方便。<br>后来的面向对象语言，如Java，C#等，虽不使用指针，但因为启用了对象引用机制，从某种角度也间接实现了指针的某些作用，但对于一些语言，如Basic，Fortran等早期的编程高级语言，由于没有指针，链表结构结构按照前面的讲法，它就没发实现了，怎么办？<br>有人想出来用数组来代替指针，来描述单链表。<br>首先我们让数据的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。<br>数据域data，用来存放数据元素，也就是通常我们要处理的数据，<br>而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。<br>我们把这种用数据描述的链表叫做静态链表，这种描述方法还有起名叫游标实现法。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>1.在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了再顺序存储结构中的插入和删除操作需要移动大量元素的缺点<br>缺点：<br>2.没有解决连续存储分配带来的表长难以确定的问题<br>3.失去了顺序存储结构随机存取的特性.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>若不使用指针如何处理链表结构的静态链表方法。<br>静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。<br>尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。</p>
<h2 id="线性表类型——3-循环链表"><a href="#线性表类型——3-循环链表" class="headerlink" title="线性表类型——3.循环链表"></a>线性表类型——3.循环链表</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）</p>
<p>对于单链表，由于每个结点只存储了向后的指针，到了尾标志就停止向后链的操作，这样，当中某一结点就无法找到它的前驱结点了，这就意味着无法回头。</p>
<p>循环链表是线性表的另外一种链式存储结构，他在单链表的基础上，将表尾结点的指针域指向表头结点，整个链表行成环状结构。</p>
<h3 id="循环链表的空链表"><a href="#循环链表的空链表" class="headerlink" title="循环链表的空链表"></a>循环链表的空链表</h3><p>循环链表也有head属性，head属性是一个指针，它单独指向头结点。<br>判断一个循环链表是不是空链表的条件就是head == head &gt;next<br>也就是head指向结点的下一个结点还是head指针，这就说明循环链表里没有结点。</p>
<p>循环链表带有头结点的空链表如图<br><img src="/images/it_datastructure_linearlist4.png" alt="UML图"></p>
<p>非空的循环链表<br><img src="/images/it_datastructure_linearlist5.png" alt="UML图"></p>
<h3 id="循环链表和单链表的主要差异"><a href="#循环链表和单链表的主要差异" class="headerlink" title="循环链表和单链表的主要差异"></a>循环链表和单链表的主要差异</h3><ul>
<li><p>循环的判断条件<br>就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。</p>
</li>
<li><p>时间复杂度<br>在单链表中，有了头结点时，我们可以用O（1）的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍。<br>不过有方法用O（1）的时间由链表指针访问到最后一个结点<br>需要改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端阶段都很方便了<br><img src="/images/it_datastructure_linearlist6.png" alt="UML图"><br>从上图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂度也为O（1）</p>
</li>
</ul>
<h3 id="如何检测一个链表有环？"><a href="#如何检测一个链表有环？" class="headerlink" title="如何检测一个链表有环？"></a>如何检测一个链表有环？</h3><p><a href="http://blog.csdn.net/qishouzhang/article/details/47007177" target="_blank" rel="external">http://blog.csdn.net/qishouzhang/article/details/47007177</a></p>
<h2 id="线性表类型——4-双链表"><a href="#线性表类型——4-双链表" class="headerlink" title="线性表类型——4.双链表"></a>线性表类型——4.双链表</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><p>双向链表跟循环链表类似，都是在单链表基础上做了复杂化处理的结构。</p>
<p>在单链表中，有了next指针，这就使得我们要查找下一节点的时间复杂度为O(1),<br>可是我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。</p>
<p>为了克服单向性这一缺点，老科学家们设计出了双向链表。</p>
<p>双向链表（double linked list）是在单链表的每个结点中，在设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>&#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span>  <span class="comment">/*直接前驱指针*/</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span>   <span class="comment">/*直接后继指针*/</span></div><div class="line">&#125;DulNode, *DuLinkList;</div></pre></td></tr></table></figure>
<p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。</p>
<p>双向链表的循环带头结点的空链表<br><img src="/images/it_datastructure_linearlist7.png" alt="UML图"></p>
<p>非空的循环的带头结点的双向链表<br><img src="/images/it_datastructure_linearlist8.png" alt="UML图"></p>
<p>由于这是双向链表，那么对于链表中的某一个结点p，它的后继的前驱是谁？当然还是它自己。<br>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next<br>这就如同上海的下一站是苏州，那么上海的下一站的前一站是哪里？  哈哈</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>双向链表相对于单链表来说，要更复杂一些，毕竟它多了prior指针，对于插入和删除时，需要格外小心。<br>另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过，由于它良好的对称性，使得对某个节点的前后节点的操作，带来了方便，可以有效提高算法的时间性能。说白了就是用空间来换时间。</p>
<h2 id="线性表类型——5-跳跃链表"><a href="#线性表类型——5-跳跃链表" class="headerlink" title="线性表类型——5.跳跃链表"></a>线性表类型——5.跳跃链表</h2><p>待学….</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_linearlist1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：计数排序</title>
    <link href="https://hengxing0080.github.io/2017/07/31/it/Algorithm/SortCounting/"/>
    <id>https://hengxing0080.github.io/2017/07/31/it/Algorithm/SortCounting/</id>
    <published>2017-07-31T14:02:57.000Z</published>
    <updated>2017-08-13T08:30:46.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 计数排序<br>外文名 Counting sort<br>提出人  Harold H. Seward<br>提出时间 1954<br>定义 非基于比较的排序算法<br>类别 分配式排序<br><a id="more"></a></p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>是一种稳定的线性时间排序算法。</p>
<p>运行时间θ(n)，是稳定不是原地排序，需要占用很大的内存空间，当然这是一种牺牲空间换取时间的做法。</p>
<p>但是计数排序有个缺点，要排序的数必须是一个小范围内的数，在实践中，当k=O(n)时，常采用计数排序。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>数据结构：数组<br>最坏时间复杂度：O ( n + k )<br>最优时间复杂度：O ( n + k )<br>平均时间复杂度：O ( n + k )<br>空间复杂度：O ( n + k )<br>是否稳定：稳定</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260299.html" target="_blank" rel="external">经典排序算法 - 计数排序Counting sort</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h1&gt;&lt;p&gt;中文名 计数排序&lt;br&gt;外文名 Counting sort&lt;br&gt;提出人  Harold H. Seward&lt;br&gt;提出时间 1954&lt;br&gt;定义 非基于比较的排序算法&lt;br&gt;类别 分配式排序&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：桶排序</title>
    <link href="https://hengxing0080.github.io/2017/07/30/it/Algorithm/SortBucket/"/>
    <id>https://hengxing0080.github.io/2017/07/30/it/Algorithm/SortBucket/</id>
    <published>2017-07-30T11:01:33.000Z</published>
    <updated>2017-08-13T08:09:44.186Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbucket.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 桶排序<br>又名     箱排序<br>英文名 Bucket sort<br>类别   分配式排序 </p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>有时也称为盒子排序（Bin Sort），来源于邮局使用的盒子信件分发方法</p>
<p>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p>
<p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。<br>桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。<br>但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>桶排序以下列程序进行：<br>1.设置一个定量的数组当作空桶子。<br>2.寻访序列，并且把项目一个一个放到对应的桶子去。<br>3.对每个不是空的桶子进行排序。<br>4.从不是空的桶子里把项目再放回原来的序列中。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function bucket-sort(array, n) is</div><div class="line">    buckets ← new array of n empty lists</div><div class="line">    for i = 0 to (length(array)-1) do</div><div class="line">        insert array[i] into buckets[msbits(array[i], k)]</div><div class="line">    for i = 0 to n - 1 do</div><div class="line">        next-sort(buckets[i])</div><div class="line">    return the concatenation of buckets[0], ..., buckets[n-1]</div></pre></td></tr></table></figure></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>数据结构：数组 </p>
<p>最坏时间复杂度：O ( n 2 )<br>平均时间复杂度：O ( n + k )<br>空间复杂度：O ( n ∗ k ) </p>
<p>是否稳定：桶排序是稳定的</p>
<p>优缺点：<br>桶排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法，如果待排序的数有10亿，总不能准备10亿个桶吧？</p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * <span class="doctag">@param</span> a 待排序数组元素</div><div class="line">  * <span class="doctag">@param</span> step 步长(桶的宽度/区间),具体长度可根据情况设定</div><div class="line">  * <span class="doctag">@return</span> 桶的位置/索引</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> step)</span></span>&#123;</div><div class="line">     <span class="keyword">return</span> a/step;</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">int</span> max=arr[<span class="number">0</span>],min=arr[<span class="number">0</span>];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> a:arr) &#123;</div><div class="line">         <span class="keyword">if</span> (max&lt;a)</div><div class="line">             max=a;</div><div class="line">         <span class="keyword">if</span> (min&gt;a)</div><div class="line">             min=a;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//该值也可根据实际情况选择</span></div><div class="line">     <span class="keyword">int</span> bucketNum=max/<span class="number">10</span>-min/<span class="number">10</span>+<span class="number">1</span>;</div><div class="line">     List buckList=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">     <span class="comment">//create bucket</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bucketNum;i++)&#123;</div><div class="line">         buckList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//push into the bucket</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">         <span class="keyword">int</span> index=indexFor(arr[i],<span class="number">10</span>);</div><div class="line">         ((ArrayList&lt;Integer&gt;)buckList.get(index)).add(arr[i]);</div><div class="line">     &#125;</div><div class="line">     ArrayList&lt;Integer&gt; bucket=<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)&#123;</div><div class="line">         bucket=(ArrayList&lt;Integer&gt;)buckList.get(i);</div><div class="line">         insertSort(bucket);</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k : bucket) &#123;</div><div class="line">             arr[index++]=k;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> <span class="comment">//把桶内元素插入排序</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(List&lt;Integer&gt; bucket)</span></span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bucket.size();i++)&#123;</div><div class="line">         <span class="keyword">int</span> temp=bucket.get(i);</div><div class="line">         <span class="keyword">int</span> j=i-<span class="number">1</span>;</div><div class="line">         <span class="keyword">for</span> (; j&gt;=<span class="number">0</span> &amp;&amp; bucket.get(j)&gt;temp;j--)&#123;</div><div class="line">             bucket.set(j+<span class="number">1</span>,bucket.get(j));</div><div class="line">         &#125;</div><div class="line">         bucket.set(j+<span class="number">1</span>,temp);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbucket.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：基数排序</title>
    <link href="https://hengxing0080.github.io/2017/07/29/it/Algorithm/SortRadix/"/>
    <id>https://hengxing0080.github.io/2017/07/29/it/Algorithm/SortRadix/</id>
    <published>2017-07-29T03:52:09.000Z</published>
    <updated>2017-08-13T06:50:02.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortradix.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 基数排序<br>外文名 Radix sort<br>类别   分配式排序<br>别称   “桶子法”<br>方法   最高位优先法和最低位优先<br>发明者 赫尔曼·何乐礼 </p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，<br>顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，</p>
<p>是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。<br>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>然后，从最低位开始，依次进行一次排序。<br>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><p>第一步<br>　以LSD为例，假设原来有一串数值如下所示：<br>　73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>　首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br>　0<br>　1 81<br>　2 22<br>　3 73 93 43<br>　4 14<br>　5 55 65<br>　6<br>　7<br>　8 28<br>　9 39<br>第二步<br>　接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>　81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>　接着再进行一次分配，这次是根据十位数来分配：<br>　0<br>　1 14<br>　2 22 28<br>　3 39<br>　4 43<br>　5 55<br>　6 65<br>　7 73<br>　8 81<br>　9 93<br>第三步<br>　接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>　14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>　这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p>
<p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<p>数据结构       数组<br>最坏时间复杂度  O ( k N )<br>空间复杂度      O ( k + N )</p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> d)</span> <span class="comment">//d表示最大的数有多少位</span></span></div><div class="line">    &#123;</div><div class="line">        intk = <span class="number">0</span>;</div><div class="line">        intn = <span class="number">1</span>;</div><div class="line">        intm = <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位</span></div><div class="line">        <span class="keyword">int</span>[][]temp = newint[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9</span></div><div class="line">        <span class="keyword">int</span>[]order = newint[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数</span></div><div class="line">        <span class="keyword">while</span>(m &lt;= d)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; number.length; i++)</div><div class="line">            &#123;</div><div class="line">                intlsd = ((number[i] / n) % <span class="number">10</span>);</div><div class="line">                temp[lsd][order[lsd]] = number[i];</div><div class="line">                order[lsd]++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(order[i] != <span class="number">0</span>)</div><div class="line">                    <span class="keyword">for</span>(intj = <span class="number">0</span>; j &lt; order[i]; j++)</div><div class="line">                    &#123;</div><div class="line">                        number[k] = temp[i][j];</div><div class="line">                        k++;</div><div class="line">                    &#125;</div><div class="line">                order[i] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            n *= <span class="number">10</span>;</div><div class="line">            k = <span class="number">0</span>;</div><div class="line">            m++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span>[]data = &#123;<span class="number">73</span>, <span class="number">22</span>, <span class="number">93</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">14</span>, <span class="number">28</span>, <span class="number">65</span>, <span class="number">39</span>, <span class="number">81</span>, <span class="number">33</span>, <span class="number">100</span>&#125;;</div><div class="line">        RadixSort.sort(data, <span class="number">3</span>);</div><div class="line">        <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; data.length; i++)</div><div class="line">        &#123;</div><div class="line">            System.out.print(data[i] + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortradix.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序算法总结</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortAlgorithm/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortAlgorithm/</id>
    <published>2017-07-28T15:01:02.000Z</published>
    <updated>2017-08-13T05:49:49.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sort0.png" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="排序定义和理解"><a href="#排序定义和理解" class="headerlink" title="排序定义和理解"></a>排序定义和理解</h1><hr>
<p>常用的场景工作中，一旦建立了一个重要的数据库后，就可能根据某些需求对数据进行不同的排序，比如对姓名按字母排序，对学习按年级排序等等。<br>由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题，而且人们的确已经研究出一些非常成熟的方法。<br>如冒泡排序和选择排序。</p>
<p>排序是一种操作，将无序的序列调整为有序的序列。</p>
<p>注意我们在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p>
<p>如何排序：<br>计算机程序却不能像人这样通览所有数据。<br>它只能根据计算机的‘比较’操作原理，在同一时间内对两个队员进行比较。<br>算法的这种原理将是一个反复出现的问题。<br>在人类看来很简单的事情，计算机的算法却不能看到全景，因此只能一步一步地解决具体问题和遵循一些简单的规则。</p>
<p>按照算法的复杂度分为两大类：<br>冒泡排序，简单选择排序和直接插入排序属于简单算法。<br>希尔排序，堆排序，归并排序，快速排序属于改进算法。</p>
<p>内排序和外排序：<br>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p>内排序：<br>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。<br>内排序分为：插入排序，交换排序，选择排序和归并排序。<br>内排序算法的性能主要是受3个方面影响：<br>1.时间性能<br>2.辅助空间<br>3.算法的复杂性</p>
<p>外排序：<br>外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p>
<hr>
<h1 id="7种算法总结"><a href="#7种算法总结" class="headerlink" title="7种算法总结"></a>7种算法总结</h1><hr>
<p>根据将排序记录是否全部被放置到内存中，将排序分为内排序和外排序两种，外排序需要在内外存之间多次交换数据才能进行。<br>我们讲内排序分为：插入排序，交换排序，选择排序，归并排序4类<br>算法类文章介绍的其中7种排序法，就分别是各种分类的代表算法。<br><img src="/images/it_algorithm_sort1.png" alt="UML图"></p>
<p>7种算法的各种指标进行对比<br><img src="/images/it_algorithm_sort2.png" alt="UML图"></p>
<p>从算法的简单性来看，我们将7种算法分为两类：<br>1.简单算法：冒泡，简单选择，直接插入<br>2.改进算法：希尔，堆，归并，快速</p>
<p>从平均情况来看<br>显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。</p>
<p>从最好情况看<br>反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑后4种复杂的改进算法。<br>　　<br>从最坏情况看<br>堆排序与归并排序又强过快速排序以及其他简单排序。<br>　　<br>从这三组时间复杂度的数据对比中，我们可以得出这样一个认识。<br>堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。<br>而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。<br>但是他们如果都来比赛计算个位数的加减法，它们反而算不过成绩极普通的冒泡和直接插入。</p>
<p>从空间复杂度来说<br>归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少时，选择归并排序和快速排序就不是一个较好的决策了。</p>
<p>从稳定性来看<br>归并排序独占鳌头，我们前面也说过，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p>
<p>从待排序记录的个数上来说<br>待排序的个数n越小，采用简单排序方法越合适。反之，n越大，采用改进排序方法越合适。这也就是我们为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p>
<p>从7种算法的各种指标（上图）的数据中，似乎简单选择排序在3种简单排序中性能最差<br>其实也不完全是，比如，如果记录的关键字本身信息量比较大（例如，关键字都是数十位的数字），此时表明其占用存储空间很大，这样移动记录所花费的时间也就越多，我们给出3种简单排序算法的移动次数比较，如图所示。<br><img src="/images/it_algorithm_sort3.png" alt="UML图"><br>你会发现，此时简单选择排序就变得非常有优势，原因也就在于，它是通过大量比较后选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p>
<p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合我们也应该考虑使用不同的算法来应对它。</p>
<hr>
<h1 id="推荐排序方式"><a href="#推荐排序方式" class="headerlink" title="推荐排序方式"></a>推荐排序方式</h1><hr>
<p>开发时如果用数据量就用快速排序(递归排序)，数据量小用简单插入排序。</p>
<p>最重要还是要根据上面总结的场景来使用正确的排序方式。</p>
<hr>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><hr>
<p><a href="http://blog.csdn.net/wangwei890702/article/details/8197597" target="_blank" rel="external">7种常用排序算法总结</a><br><a href="http://blog.csdn.net/sgn132/article/details/47279511" target="_blank" rel="external">GIF演示排序算法</a><br><a href="http://www.cnblogs.com/ytb-wpq/p/6479240.html" target="_blank" rel="external">常用算法js版(冒泡/选择/插入/希尔/归并/快速/堆/计数/桶/基数)</a><br><a href="http://blog.csdn.net/litong09282039/article/details/46332127" target="_blank" rel="external">超级详细解读基本排序算法（不看后悔，带排序演示动画）</a><br><a href="http://blog.csdn.net/chivalrousman/article/details/51585639" target="_blank" rel="external">详解五大排序算法</a><br><a href="http://blog.csdn.net/cjf_iceking/article/details/7953637" target="_blank" rel="external">九种常用排序的性能分析总结</a><br><a href="http://blog.jobbole.com/11745/" target="_blank" rel="external">视觉直观感受7种常用的排序算法</a><br><a href="http://blog.sina.com.cn/s/blog_8898a00d0102whmd.html" target="_blank" rel="external">中国MOOC大学-程序设计基础-6.问题解决和算法基础3</a><br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="external">6分钟演示15种排序算法</a><br><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">可视化排序</a><br><a href="http://www.cnbeta.com/articles/tech/202221.htm" target="_blank" rel="external">[视频]程序员的艺术：排序算法舞蹈</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sort0.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：快速排序</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortQuick/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortQuick/</id>
    <published>2017-07-28T13:35:12.000Z</published>
    <updated>2017-07-29T15:32:33.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortquick1.gif" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>快速排序（Quick Sort）<br>快速排序采用“分而治之、各个击破”的观念，使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>作者为Tony Hoare，图领奖获得者，上世纪最伟大的计算机科学家之一。 在1962年提出。</p>
<p>很牛，20世纪十大算法之一。排序算法王者，要好好研究并掌握它。</p>
<p>快速排序其实就是前面认为的最慢的冒泡排序的升级，它们都属于交换排序类。<br>即它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从·后面直接移动到前面，从而减少了总的比较次数和移动交换次数。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>基本思想：<br>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对着两份记录进行排序，整个排序过程可以递归进行，以达到整个序列有序的目的。</p>
<p>步骤为：<br>1.从数列中挑出一个元素，称为”基准”（pivot），<br>2.重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>3.递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p>在简单的伪代码中，此算法可以被表示为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function quicksort(q)&#123;</div><div class="line">    var list less, pivotList, greater</div><div class="line">    if length(q) ≤ 1 &#123;</div><div class="line">        return q</div><div class="line">    &#125; else &#123;</div><div class="line">        select a pivot value pivot from q</div><div class="line">        for each x in q except the pivot element</div><div class="line">            if x &lt; pivot then add x to less</div><div class="line">            if x ≥ pivot then add x to greater</div><div class="line">        add pivot to pivotList</div><div class="line">        return concatenate(quicksort(less), pivotList, quicksort(greater))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="未优化代码"><a href="#未优化代码" class="headerlink" title="未优化代码"></a>未优化代码</h2><p>其中Partition函数是最关键的，它要做的，就是先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，将这样的关键字称为枢轴（pivot）<br>通过下面代码的模拟，可以看到Partition函数，其实就是将选取的pivotkey不断交换，将比它小的换到它的左边，比它大的换到它的右边，它也在交换中不断更改自己的位置，知道完全满足这个要求为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></div><div class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivotkey;</div><div class="line"></div><div class="line">    pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></div><div class="line">    <span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">            high--;</div><div class="line">        swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">            low++;</div><div class="line">        swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivot;</div><div class="line">    <span class="keyword">if</span>(low&lt;high)</div><div class="line">    &#123;</div><div class="line">            pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></div><div class="line">            QSort(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></div><div class="line">            QSort(L,pivot+<span class="number">1</span>,high);		<span class="comment">/*  对高子表递归排序 */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    QSort(L,<span class="number">1</span>,L-&gt;length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="优化快速排序代码"><a href="#优化快速排序代码" class="headerlink" title="优化快速排序代码"></a>优化快速排序代码</h2><p>上面的快速排序有不少可以改进的地方，来看一些优化方案。</p>
<p>1.优化选取枢轴<br>2.优化不必要的交换<br>3.优化小数组时的排序方案<br>4.优化递归操作</p>
<p>（具体优化细节描述请查看大数数据结构——422页）</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 改进后快速排序******************************** */</span></div><div class="line"><span class="comment">/* 快速排序优化算法 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivotkey;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </div><div class="line">    <span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])			</div><div class="line">        swap(L,low,high);	<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></div><div class="line">    <span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</div><div class="line">        swap(L,high,m);	<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></div><div class="line">    <span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</div><div class="line">        swap(L,m,low);		<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></div><div class="line">    </div><div class="line">    pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></div><div class="line">    L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></div><div class="line">    <span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">            high--;</div><div class="line">        L-&gt;r[low]=L-&gt;r[high];</div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">            low++;</div><div class="line">        L-&gt;r[high]=L-&gt;r[low];</div><div class="line">    &#125;</div><div class="line">    L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</div><div class="line">    <span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivot;</div><div class="line">    <span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)</div><div class="line">        &#123;</div><div class="line">            pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></div><div class="line">            QSort1(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></div><div class="line">            <span class="comment">/* QSort(L,pivot+1,high);		/*  对高子表递归排序 */</span></div><div class="line">            low=pivot+<span class="number">1</span>;	<span class="comment">/* 尾递归 */</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        InsertSort(L);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    QSort1(L,<span class="number">1</span>,L-&gt;length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏时间复杂度  O( n 2 )<br>最优时间复杂度  O( n log n )<br>平均时间复杂度  O( n log n ) </p>
<p>快速排序的时间性能取决于排序递归的深度，可以用递归树来描述递归算法的执行情况。<br>如下图所示，它是{50,10,90,30,70,40,80,60,20}在快速排序过程中递归过程。<br>由于第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。<br><img src="/images/it_algorithm_sortquick2.png" alt="UML图"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>主要是递归造成的栈空间的使用<br>最好情况：递归树的深度为log2n，其空间复杂度为O( n log n )<br>最坏情景：需要进行n-1递归调用，起空间复杂度为O（n）<br>平均情况：O ( n log n ) </p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>不稳定<br>由于关键字的比较和交换是跳跃进行的，因此它是一种不稳定的排序的排序方法。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>事实上目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越，它也存在排序不稳定，需要大量辅助空间，对少量数据排序无优势等不足。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortquick1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络 —— 协议：HTTP</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/NetworkProtocol/HTTP/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/NetworkProtocol/HTTP/</id>
    <published>2017-07-28T09:11:55.000Z</published>
    <updated>2017-07-28T10:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_http.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名 　超文本传输协议<br>外文名 　HTTP（HyperText Transfer Protocol）</p>
<hr>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><hr>
<p>定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器.<br>从层次的角度看,HTTP是面向(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件，(包括文本,声音,图像等各种多媒体文件)的重要基础。         </p>
<p>通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）来标识。<br>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。<br>就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。<br>当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。<br>浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<p>简单的理解就是：<br>基于TCP，只不过封装了一些东西。<br>Http协议用于加载以 http:// 开头的普通远程网站的HTML网页。不加密。</p>
<hr>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><hr>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<p>HTTP三点注意事项：<br>1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>2.HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>3.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
<p>HTTP协议，你只需要稍微了解一些就足够了，它的工作原理特别的简单，就是客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理就可以了。<br>是不是非常简单？<br>一个浏览器的基本工作原理也就是如此了。<br>比如Android里使用到的WebView控件，其实也就是我们向百度的服务器发起了一条HTTP请求，接着服务器分析出我们想要访问的是百度的首页，于是会把该网页的HTML代码进行返回，然后WebView再调用手机浏览器的内核对返回的HTML代码进行解析，最终将页面展示出来。</p>
<p>http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。<br>http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p>
<hr>
<h1 id="HTTP版本历史"><a href="#HTTP版本历史" class="headerlink" title="HTTP版本历史"></a>HTTP版本历史</h1><hr>
<blockquote>
<p>超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的.</p>
</blockquote>
<ul>
<li><p>HTTP/0.9　<br>已过时。<br>只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。<br>由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。</p>
</li>
<li><p>HTTP/1.0　<br>这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。</p>
</li>
<li><p>HTTP/1.1<br>当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。<br>还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。<br>版本1.0和1.1 的区别:<br>　1 缓存处理<br>　2 带宽优化及网络连接的使用<br>　　在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。<br>　　HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。<br>　3 错误通知的管理<br>　4 消息在网络中的发送<br>　5 互联网地址的维护<br>　6 安全性及完整性</p>
</li>
</ul>
<p>想要提交数据到数据器，必须和它要接口（url, method请求方式, param参数，header消息头）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_http.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：归并排序</title>
    <link href="https://hengxing0080.github.io/2017/07/27/it/Algorithm/SortMerging/"/>
    <id>https://hengxing0080.github.io/2017/07/27/it/Algorithm/SortMerging/</id>
    <published>2017-07-27T12:47:32.000Z</published>
    <updated>2017-07-29T15:20:29.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortmerging1.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortmerging2.jpg" alt="UML图"></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>归并排序（Merging Sort）是建立在归并操作上的一种有效的排序算法<br>发明者为约翰·冯·诺伊曼<br>该算法是采用分治法（Divide and Conquer）实现快速排序<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>归并的就是合并，并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。<br>就是利用归并的思想实现的排序方法。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>回想上一个讲的堆排序充分利用了完全二叉树的深度是[log2n]+1的特性，所以效率比较高。<br>不过堆结构的设计本身是比较复杂的，那么有没有更直接简单的办法利用完全二叉树来排序呢？ 有，归并排序。</p>
<p>看图所示，将无序的数组序列{16,7,13,10,9,15,3,2,5,8,12,1,11,4,6,14}，通过两两合并排序后在合并，最终获得了一个有序的数组。<br>注意它的形状，它像极了一颗导致的完全二叉树，通常涉及到完全二叉树结构的排序算法，效率一般都不低的<br><img src="/images/it_algorithm_sortmerging3.png" alt="UML图"></p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> j,k,l;</div><div class="line">     <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)	<span class="comment">/* 将SR中记录由小到大地并入TR */</span></div><div class="line">     &#123;</div><div class="line">         <span class="keyword">if</span> (SR[i]&lt;SR[j])</div><div class="line">             TR[k]=SR[i++];</div><div class="line">         <span class="keyword">else</span></div><div class="line">             TR[k]=SR[j++];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(i&lt;=m)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</div><div class="line">             TR[k+l]=SR[i+l];		<span class="comment">/* 将剩余的SR[i..m]复制到TR */</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(j&lt;=n)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=n-j;l++)</div><div class="line">             TR[k+l]=SR[j+l];		<span class="comment">/* 将剩余的SR[j..n]复制到TR */</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/* 将SR[s..t]归并排序为TR1[s..t] */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> m;</div><div class="line">     <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</div><div class="line">     <span class="keyword">if</span>(s==t)</div><div class="line">         TR1[s]=SR[s];</div><div class="line">     <span class="keyword">else</span></div><div class="line">     &#123;</div><div class="line">         m=(s+t)/<span class="number">2</span>;			<span class="comment">/* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */</span></div><div class="line">         MSort(SR,TR2,s,m);		<span class="comment">/* 递归地将SR[s..m]归并为有序的TR2[s..m] */</span></div><div class="line">         MSort(SR,TR2,m+<span class="number">1</span>,t);	<span class="comment">/* 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] */</span></div><div class="line">         Merge(TR2,TR1,s,m,t);	<span class="comment">/* 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] */</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/* 对顺序表L作归并排序 */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></div><div class="line"> &#123; </div><div class="line">     MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h2><p>因为递归的方式尽管在代码中比较清晰，容易理解，但这会造成时间和空间上的性能损耗。<br>我们排序追求的就是笑了，有没有可能将递归转化成迭代呢？ 结论当然是有的，经过改动之后，性能上进一步提高了。看看下面代码！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> j;</div><div class="line">	<span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</div><div class="line">	&#123;<span class="comment">/* 两两归并 */</span></div><div class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</div><div class="line">		i=i+<span class="number">2</span>*s;        </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></div><div class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</div><div class="line">	<span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></div><div class="line">		<span class="keyword">for</span>(j =i;j &lt;= n;j++)</div><div class="line">			TR[j] = SR[j];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代的做法更加直接了当，从最小的序列开始归并直至完成。不需要像归并的递归算法一样，需要先拆分递归，在归并退出递归。<br>迭代的做法避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O（n），并且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑用非递归方法。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好，最坏，平均的时间性能为O(nlogn)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O（n+logn）<br>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为log2n的栈空间，所以空间复杂度为O（n+logn）</p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>稳定<br>通过示例代码中的Merge函数中有if(SR[i] &lt; SR[j])语句，这就说明它需要两两比较，不存在跳跃，所以是一种稳定的稳定的算法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
<p>推荐使用迭代方式实现归并排序</p>
<p>该算法速度仅次于快速排序</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortmerging1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：堆排序</title>
    <link href="https://hengxing0080.github.io/2017/07/26/it/Algorithm/SortHeap/"/>
    <id>https://hengxing0080.github.io/2017/07/26/it/Algorithm/SortHeap/</id>
    <published>2017-07-26T11:52:08.000Z</published>
    <updated>2017-07-24T12:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortheap1.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortheap2.gif" alt="UML图"></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法。<br>它是选择排序的一种（是简单选择排序的一种改进）。</p>
<p>它利用数组的特点快速定位指定索引的元素。<br>堆分为大根堆和小根堆，是完全二叉树。<br>大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。<br>在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h1 id="算法起源"><a href="#算法起源" class="headerlink" title="算法起源"></a>算法起源</h1><p>堆排序算法是斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明的。<br>同时，他们发明了“堆”这样的数据结构。（类似叠罗汉运动）</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p>例如图所示，<br>图1是一个大顶堆，90为最大值，将90与20（末尾元素）互换，<br>如图2所示，此时90就成了整个堆序列的最后一个元素，将20经过调整，使得除90以外的节点继续满足大顶堆定义（所有结果都大于等于其子孩子），见图3，然后在考虑将30与80互换……<br><img src="/images/it_algorithm_sortheap3.png" alt="UML图"><br><img src="/images/it_algorithm_sortheap4.png" alt="UML图"></p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><p>上面明白堆排序的基本思想了，不过要实现它还需要解决两个问题：<br>1.如何由一个无需序列构建成一个堆？<br>2.如果在输出堆顶元素后，调整剩余元素成为一个新的堆？<br>先看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*  对顺序表L进行堆排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;  <span class="comment">/* 把L中的r构建成一个大根堆 */</span></div><div class="line">		 HeapAdjust(L,i,L-&gt;length);</div><div class="line">&#125;</div><div class="line">	<span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</div><div class="line">	&#123; </div><div class="line">		 swap(L,<span class="number">1</span>,i);  <span class="comment">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></div><div class="line">		 HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">/* 将L-&gt;r[1..i-1]重新调整为大根堆 */</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中能看出，整个排序过程分为两个for循环。<br>第一个循环要完成是将显著的待排序序列构建成一个大顶堆。<br>第二个循环要完成的就是逐步将每个最大值的根节点与末尾元素交换，并且要调整其成为大顶堆。</p>
<p>然后在看看关键的HeapAdjust（堆调整）函数是如何实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义， */</span></div><div class="line"><span class="comment">/* 本函数调整L-&gt;r[s]的关键字,使L-&gt;r[s..m]成为一个大顶堆 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span> temp,j;</div><div class="line">	temp=L-&gt;r[s];</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>) <span class="comment">/* 沿关键字较大的孩子结点向下筛选 */</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</div><div class="line">			++j; <span class="comment">/* j为关键字中较大的记录的下标 */</span></div><div class="line">		<span class="keyword">if</span>(temp&gt;=L-&gt;r[j])</div><div class="line">			<span class="keyword">break</span>; <span class="comment">/* rc应插入在位置s上 */</span></div><div class="line">		L-&gt;r[s]=L-&gt;r[j];</div><div class="line">		s=j;</div><div class="line">	&#125;</div><div class="line">	L-&gt;r[s]=temp; <span class="comment">/* 插入 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>过程有点复杂，多试着模拟计算机执行的方式走几遍，应该就可以理解其原理。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>最坏时间复杂度    O(n\log n)<br>最优时间复杂度    O(n\log n)[1]<br>平均时间复杂度    θ (n\log n)</p>
<p>分析下堆排序的效率<br>它的运行时间主要是消耗在初始构建堆和重建堆时的反复筛选上。<br>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构建，将它和其孩子进行比较和若有必要的交换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为0（n）</p>
<h2 id="空间复杂度-："><a href="#空间复杂度-：" class="headerlink" title="空间复杂度    ："></a>空间复杂度    ：</h2><p>O(n) total, O(1) auxiliary</p>
<h2 id="是否稳定："><a href="#是否稳定：" class="headerlink" title="是否稳定："></a>是否稳定：</h2><p>不稳定<br>它只有一个用来交换的暂存单元，也非常的不错。<br>不过由于记录的比较与交换是跳跃式进行，所以不稳定。</p>
<h2 id="其他注意："><a href="#其他注意：" class="headerlink" title="其他注意："></a>其他注意：</h2><p>因为初建堆所需的比较次数较多，因此它并不适合待排序序列个数较少的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortheap1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
