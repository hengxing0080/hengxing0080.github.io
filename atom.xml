<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹空间</title>
  <subtitle>时间在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-10-08T16:13:34.692Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高效学习工作与管理的实用法则</title>
    <link href="https://hengxing0080.github.io/2017/09/21/manager/1.Rule/"/>
    <id>https://hengxing0080.github.io/2017/09/21/manager/1.Rule/</id>
    <published>2017-09-21T08:51:55.000Z</published>
    <updated>2017-10-08T16:13:34.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_manager_rule1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>工作期间收集的各种情景的实用方案，它们能让你更有章法的思考和工作和管理，更快的提升自己！</p>
<p>因精华太多篇幅太长，每个概念仅领进门，如对某个关键词感兴趣请自行搜索详细资料！</p>
<hr>
<h1 id="高效学习"><a href="#高效学习" class="headerlink" title="高效学习"></a>高效学习</h1><hr>
<h2 id="一万小时定律"><a href="#一万小时定律" class="headerlink" title="一万小时定律"></a>一万小时定律</h2><p><img src="/images/it_manager_rule21.jpg" alt="UML图"><br>中文名 一万小时定律<br>提出者 马尔科姆·格拉德威尔<br>提出时间 2009年01月19日<br>应用学科 所有学科<br>适用领域范围 所有领域<br>适用领域范围 对于量的积累</p>
<p>作家格拉德威尔在《异类》一书中指出：“<br>人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。<br>1万小时的锤炼是任何人从平凡变成超凡的必要条件.<br>要成为某个领域的专家，需要10000小时，<br>按比例计算就是：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。这就是一万小时定律。</p>
<p>相关文章：<br><a href="https://book.douban.com/review/5705791/" target="_blank" rel="external">无他，唯手熟尔！</a><br><a href="http://www.51pptmoban.com/zhuti/3493.html" target="_blank" rel="external">一万小时黄金定律（天才定律）ppt模板</a></p>
<h2 id="西蒙学习法"><a href="#西蒙学习法" class="headerlink" title="西蒙学习法"></a>西蒙学习法</h2><p>中文名 西蒙学习法<br>外文名 Simon learning method<br>创始者 西蒙教授<br>原理 持续连续的长时间学习</p>
<p>介绍：<br>“西蒙学习法”是指诺贝尔经济学奖获得者西蒙教授提出的一个理论：“对于一个有一定基础的人来说，只要真正肯下功夫，在6个月内就可以掌握任何一门学问。”<br>西蒙教授立论所依据的实验心理的研究成果表明：一个人1分钟到1分半钟可以记忆一个信息，心理学把这样一个信息称为“块”，估记每一门学问所包含的信息量大约是5万块，如果1分钟能记忆1“块”，那么5万块大约需要1000个小时，以每星期学习40小时计算，要掌握一门学问大约需要用6个月。<br>为了感谢西蒙的这个研究成果，教育心理学界称这种学习法为西蒙学习法。</p>
<p>为了形象地说明，把西蒙学习法比做一把锥子。正如居里夫人所说，“知识的专一性像锥尖，精力的集中好比是锥子的作用力，时间的连续性好比是不停顿地使锥子往前钻进。” 西蒙学习法所支配的学习活动，呈现出一种尖锐猛烈、持续不断的态势。<br>这种“锥形学习法”的高效原理在于，连续的长时间学习本身包涵对之前学习内容的应用，这样就省去了大量的复习时间。如果用烧水来做比喻，“锥形学习法”是连续的加热，所以热量散失的少；普通的间断学习是烧一会儿就停止加热，一段时间以后再继续加热，这样许多热量就白白散失了。两相比较，自然是持续“加热”效果显著了。<br>原理：烧一壶开水，如果断断续续地烧，1万个小时也烧不开，如果连续烧，1个小时就够用了。</p>
<h2 id="社会化学习"><a href="#社会化学习" class="headerlink" title="社会化学习"></a>社会化学习</h2><p><img src="/images/it_manager_rule22.jpg" alt="UML图"><br>个人理解：<br>就是经过10多年的填鸭式教育走出校门时在社会上无时不在无处不在的一种学习方式。<br>学习并不痛苦，学习是一种习惯一种不断晋升自我知识和技能的过程，学习是一种习惯性的心态和思维方式，正确理解后这样就能在社会打拼的种种过程都成转化为学习，所以，把社会当成一所庞大的永不毕业的大学来体验人生吧！ 人生的过程就是不断学习！</p>
<p>理论收集：<br>总结起来，社会化学习的路径其实很简单，就三条：<br>1) 学习在窗外<br>这里的“窗”是指传统教育体制。到真实社会和生活环境中去学习，而不仅仅局限在传统僵化的学校教育体制之内。<br>2) 他人即老师<br>和“他人”一起学习，向“他人”进行学习。这里的“他人”不是传统意义上的“学校老师”，而是在同学、父母、社区、社会之间创建各种各样的学习关系。<br>3) 世界是教材<br>过去，教材就是学习者的整个世界；未来，整个世界都可以是学习者的教材。</p>
<p>社会化学习往往发生于传统的教室、教学内容和教学方式之外。社会化学习的目的并不仅仅是让学习者记住某些知识点或者某个技术，而是将学习置身于真实的社会生活之中，帮助他们体验和发展“生而为人”最重要的品质和能力：创造能力、独立思考能力、沟通能力、好奇心、合作能力、勇气、公民素养，等等。</p>
<p>相关文章：<a href="http://www.sohu.com/a/133648011_100928" target="_blank" rel="external">顾远：什么是“社会化学习” ？</a></p>
<h2 id="康奈尔笔记系统-5R笔记法"><a href="#康奈尔笔记系统-5R笔记法" class="headerlink" title="康奈尔笔记系统/5R笔记法"></a>康奈尔笔记系统/5R笔记法</h2><p>康奈尔笔记系统是沃尔特·鲍克等人发明的，旨在为帮助学生有效地做笔记。康奈尔笔记系统把一页纸分成了三部分：左边四分之一左右（线索栏）和下方五分之一左右的空间（总结）和右上最大的空间（草稿）。</p>
<p>中文名 康奈尔笔记系统<br>发明者 沃尔特·鲍克</p>
<p>系统介绍：<br>康奈尔笔记系统把一页纸分成了三部分：<br>右上最大的空间是我们平时做笔记的地方，你按照平时的习惯记录<br>就行了。<br>左边那竖着的一条空间叫做“线索栏”，是用来归纳右边的内容的，写一些提纲挈领的东西，这个工作不要在做笔记的时候做，而是在上完课之后马上回顾，然后把要点都写到左边，这样一方面马上复习了内容，另一方面理清了头绪。<br>下面那横着的一栏是用来做总结的，就是用一两句话总结你这页记录的内容，这个工作可以延后一点儿做，起到促进你思考消化的作用，另外也是笔记内容的极度浓缩和升华。<br><img src="/images/it_manager_rule2.jpg" alt="UML图"></p>
<h2 id="学习高原现象"><a href="#学习高原现象" class="headerlink" title="学习高原现象"></a>学习高原现象</h2><p><img src="/images/it_manager_rule3.png" alt="UML图"></p>
<p>就是进阶某一学习阶段的瓶颈<br>克服“高原现象”<br>爱学习的人都会有这样的经历：学习持续了一段时间之后，往往会有一个瓶颈期，长时间似乎都没有什么进步，于是内心非常着急。<br>这种情况，实际上是由人的学习规律决定的一种“高原现象”。据研究，学习者在刚开始进步快，随后有一个明显的或长或短的进步停顿期，后期进步慢，中间的停顿期叫高原期（如上图所示）。</p>
<p>高原期，实质是一个消化期。由于前期的学习积累了太多的知识点，这些知识点在大脑中乱作一团，还没有形成一个知识体系。这时需要一定的时间来消化它，让它融会贯通，经常思考总结可以快速帮你跨过高原期。<br>处于高原期时，还可以换一个相关的方向来学习。例如，编程语言学不下去了，可以学习一下设计模式，设计模式也学不下去了，再换成数据库。通过学习这些相关的知识，不但补齐了知识体系中的短板，而且各个知识点之间可以互相启发，帮助你实现顿悟，跨过高原期。</p>
<h2 id="过度学习效应"><a href="#过度学习效应" class="headerlink" title="过度学习效应"></a>过度学习效应</h2><p>中文名 过度学习效应<br>外文名 Over learning effect<br>提出者 H·艾宾浩斯<br>提出时间 1950<br>应用学科 全部学科都适用<br>适用领域范围 学习领域</p>
<p>过度学习效应指的是人们对所学习、记忆的内容达到了初步掌握的程序后，如果再用原来所花时间的一半去巩固强化，使学习程度达到150%，将会使记忆得到强化。<br>艾宾浩斯所说的“过度学习”,不是毫无限度的“超度学习”。一般认为在一定范围内，过度学习是必须的，超过了一定限度，就是很不经济的，因为过度学习需要更多的时间和精力。一般说来，学习程度以150%为佳，其效应也最大。超过150%,会因学习疲劳而发生“报酬递减”现象,学习的效果就会逐渐下降，出现注意分散、厌倦、疲劳等消极效应。</p>
<h2 id="心流状态-心流理论"><a href="#心流状态-心流理论" class="headerlink" title="心流状态/心流理论"></a>心流状态/心流理论</h2><p><img src="/images/it_manager_rule23.jpg" alt="UML图"><br><img src="/images/it_manager_rule24.jpg" alt="UML图"><br>心流（英语：Mental flow）在心理学中是一种某者在专注进行某行为时所表现的心理状态。<br>如艺术家在创作时所表现的心理状态。某者在此状态时，通常不愿被打扰，即抗拒中断。<br>定义是一种将个人精神力完全投注在某种活动上的感觉；心流产生时同时会有高度的兴奋及充实感。齐克森米哈里认为，使心流发生的活动有多样性。</p>
<p>相关文章：<br><a href="https://baike.baidu.com/tashuo/browse/content?id=7e0fcb27ad2ceff4478d8ded&amp;fr=qingtian&amp;lemmaId=9824097" target="_blank" rel="external">为什么我一玩游戏，就忘记了时间？| “忘我”也可以令你获得幸福</a></p>
<h2 id="泉涌状态-涌流理论"><a href="#泉涌状态-涌流理论" class="headerlink" title="泉涌状态/涌流理论"></a>泉涌状态/涌流理论</h2><p>忘我的状态，专注，高效<br>工作、学习都需要激发这种状态<br>比如在音乐的世界中，不知不觉把事情做完</p>
<p>PS：暂未把泉涌状态和上面的心流状态弄明白有何区别，也可能是一个意思.</p>
<h2 id="期望定律"><a href="#期望定律" class="headerlink" title="期望定律"></a>期望定律</h2><p>提出者 心理学家罗森塔尔<br>提出时间 1966年<br>适用领域范围 管理</p>
<p>期望定律告诉我们，当我们怀着对某件事情非常强烈期望的时候，我们所期望的事物就会出现。 如果一个人有自信心，对自己怀着期望，他就会朝着自己期望的方向发展。</p>
<h2 id="用进废退"><a href="#用进废退" class="headerlink" title="用进废退"></a>用进废退</h2><p>中文名 用进废退<br>外文名 use and disuse theory<br>提出者 法国生物学家拉马克<br>理论应用 越是懒惰不动脑 难以正常运转<br>观点辨析 达尔文对他的观点进行了驳斥<br>例    证 长颈鹿<br>其他信息 达尔文认为物种的进化是渐进的</p>
<hr>
<h1 id="高效工作"><a href="#高效工作" class="headerlink" title="高效工作"></a>高效工作</h1><hr>
<h2 id="GTD"><a href="#GTD" class="headerlink" title="GTD"></a>GTD</h2><p><img src="/images/it_manager_rule19.jpg" alt="UML图"></p>
<p>中文名 竭尽所能<br>外文名 Getting Things Done<br>别称 GTD<br>表达式 收集、整理、组织、回顾、执行<br>提出者 David Allen(戴维·艾伦)<br>提出时间 2002年12月31日<br>推荐GTD应用 TickTick、any.do、wunderlist等<br>理论属性 行动管理法</p>
<p>GTD就是Getting Things Done的缩写，翻译过来就是“把事情做完”，GTD的核心理念概括就是必须记录下来要做的事，然后整理安排并使自己一一去执行。<br>GTD的五个核心原则是：收集、整理、组织、回顾、执行。<br>GTD的核心理念在于清空大脑，然后一步步按照设定的路线去努力执行。</p>
<h2 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h2><p><img src="/images/it_manager_rule20.jpg" alt="UML图"></p>
<p>中文名 番茄工作法<br>外文名 The pomodoro technique<br>创始人 弗朗西斯科·西里洛<br>时间 1992年<br>类型 时间管理方法<br>作用 提高效率</p>
<p>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。<br>使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。<br>番茄工作法极大地提高了工作的效率，还会有意想不到的成就感。</p>
<p>选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。<br>合理设置自己一个天的番茄时间段，尽量将重要的工作放在头脑高效的时段，比如上午8:30~11:00，下午15:00到17:00等。</p>
<h2 id="6点优先工作制"><a href="#6点优先工作制" class="headerlink" title="6点优先工作制"></a>6点优先工作制</h2><p><img src="/images/it_manager_rule25.jpg" alt="UML图"><br><img src="/images/it_manager_rule26.jpg" alt="UML图"><br>该方法是效率大师艾维利向美国一家钢铁公司提供咨询时提出的，它使这家公司用了5年的时间，从濒临破产一跃成为当时全美最大的私营钢铁企业，艾维利因此获得了2.5万美元咨询费，故管理界将该方法喻为“价值2.5万美元的时间管理方法”。<br>这一方法要求把每天所要做的事情按重要性排序，分别从“1”到“6”标出6件最重要的事情。每天一开始，先全力以赴做好标号为“1”的事情，直到它被完成或被完全准备好，然后再全力以赴地做标号为“2”的事，依此类推……<br>艾维利认为，一般情况下，如果一个人每都能全力以赴地完6件最重要的事情，那么他一定是一位高效率人士</p>
<h2 id="办公室美学"><a href="#办公室美学" class="headerlink" title="办公室美学"></a>办公室美学</h2><p><img src="/images/it_manager_rule27.jpg" alt="UML图"><br>秩序是一种美。均匀、对称、平衡和整齐的事物能给人一种美感。简洁就是速度，条理就是效率。简洁和条理也是一种美，是一种办公室的美学、工作的美学。<br>第一我们应当养成如下良好习惯：<br>★物以类聚，东西用毕物归原处；<br>★不乱放东西；<br>★把整理好的东西编上号，贴上标签，做好登记；<br>★好记性不如烂笔头，要勤于记录；<br>★处理文件的3个环节：第一，迅速回复。<br>第二，迅速归档，以免文件弄乱或弄丢。<br>第三，及时销毁。没用的文件要及时处理掉，以免继续浪费空间和时间。</p>
<h2 id="麦肯锡30秒电梯理论"><a href="#麦肯锡30秒电梯理论" class="headerlink" title="麦肯锡30秒电梯理论"></a>麦肯锡30秒电梯理论</h2><p><img src="/images/it_manager_rule30.jpg" alt="UML图"><br><img src="/images/it_manager_rule31.jpg" alt="UML图"><br>这是一种电梯法则.<br>不要妄想所有人都有时间和耐心，在 30 秒内清晰而准确地解释清楚你的解决方案，是加分项。要诀：一要出语惊人，二要短小精悍，三要提炼要点。 </p>
<p>麦肯锡公司曾经得到过一次沉痛的教训：该公司曾经为一家重要的客户做咨询。咨询结束的时候，麦肯锡的项目负责人在电梯间里遇见了对方的董事长，该董事长问麦肯锡的项目负责人：“你能不能说一下现在的结果呢？”由于该项目负责人没有准备，而且即使有准备也无法在电梯从30层1层运行的30秒钟内把结果说清楚。最终，麦肯锡失去了这一重要的客户。从此，麦肯锡要求公司员工凡事要在最短的时间内把结果表达清楚，凡事要直奔主题、直奔结果。麦肯锡认为，一般情况下人们最多记得住一二三，记不住四五六，所以凡事要归纳在3条以内`。这就是如今在商界流传甚广的“30秒电梯理论”或称“电梯演讲”。</p>
<h2 id="全脑模型"><a href="#全脑模型" class="headerlink" title="全脑模型"></a>全脑模型</h2><p><img src="/images/it_manager_rule4.png" alt="UML图"><br><img src="/images/it_manager_rule5.png" alt="UML图"></p>
<p>中文名 全脑模型<br>方式： 逻辑型、组织型、交流型、空想型<br>起源： 1970年</p>
<p>全脑模型（Whole Brain Model）是由20世纪70年代，担任GE管理发展中心主任的奈德·赫曼（Ned Herrmann）博士，对自己集音乐家、艺术家、科学家的兴趣感到好奇。因而投入大脑思维偏好的研究，在1976年经由德州大学以脑电仪证明HBDI理论的成立。是一种被用来分析个人和组织的思维方式的方法。</p>
<p>全脑模型的四种方式为：<br>1、逻辑型。分析的，数学的，技术的和解决问题的。<br>2、组织型。控制的，保守的，计划的，组织的和实际上管理的。<br>3、交流型。人际间，情绪的，音乐的，精神上的，和“谈话”模式。<br>4、空想型。 虚构的，综合的，艺术的和概念上模式。</p>
<hr>
<h1 id="高效记忆"><a href="#高效记忆" class="headerlink" title="高效记忆"></a>高效记忆</h1><hr>
<h2 id="艾宾浩斯记忆法"><a href="#艾宾浩斯记忆法" class="headerlink" title="艾宾浩斯记忆法"></a>艾宾浩斯记忆法</h2><p>中文名 艾宾浩斯记忆法<br>外文名 Hermann Ebbinghaus<br>创始人 艾宾浩斯<br>时间 1885年</p>
<p>信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。遵循艾宾浩斯遗忘曲线所揭示的记忆规律，对所学知识及时进行复习，这种记忆方法即为艾宾浩斯记忆法。 对所学知识和记忆效果及时进行复习和自测是艾宾浩斯记忆法的主要方式。<br>艾宾浩斯记忆法也是遗忘曲线；一个小时后就会遗忘；在一个小时内回想就可以记住那个东西；最好一天之后在回想；三天之后再回想就可以了。<br><img src="/images/it_manager_rule6.png" alt="UML图"><br><img src="/images/it_manager_rule9.jpg" alt="UML图"></p>
<h2 id="思维导图法"><a href="#思维导图法" class="headerlink" title="思维导图法"></a>思维导图法</h2><p>概    念 有效的思维模式<br>应    用 应用于记忆、学习、思考<br>作    用 利于人脑的扩散思维的展开<br>创    始 东尼·巴赞</p>
<p>思维导图是有效的思维模式，应用于记忆、学习、思考等的思维“地图”，利于人脑的扩散思维的展开。思维导图已经在全球范围得到广泛应用 ，包括大量的500强企业。思维导图的创始人是东尼·巴赞。中国应用思维导图大约有20多年时间。</p>
<p><img src="/images/it_manager_rule7.jpg" alt="UML图"></p>
<h2 id="超右脑"><a href="#超右脑" class="headerlink" title="超右脑"></a>超右脑</h2><p>相关文章：<a href="https://zhidao.baidu.com/daily/view?id=12395" target="_blank" rel="external">右脑记忆能力真的是左脑的100万倍？</a></p>
<h2 id="图像记忆法"><a href="#图像记忆法" class="headerlink" title="图像记忆法"></a>图像记忆法</h2><p><img src="/images/it_manager_rule8.jpg" alt="UML图"></p>
<hr>
<h1 id="休息管理"><a href="#休息管理" class="headerlink" title="休息管理"></a>休息管理</h1><hr>
<h2 id="莫法特休息法"><a href="#莫法特休息法" class="headerlink" title="莫法特休息法"></a>莫法特休息法</h2><p>连续分段时间管理法<br>《圣经•新约》的翻译者詹姆斯•莫法特的书房里有3张桌子：第一张摆着他正在翻译的《圣经•新约》译稿；第二张摆的是他的一篇论文的原稿；第三张摆的是他正在写的一篇侦探小说。<br>莫法特的休息方法就是从一张书桌搬到另一张书桌，继续工作。<br>“间作套种”是农业上常用的一种科学种田的方法。人们在实践中发现，连续几季都种相同的作物，土壤的肥力就会下降很多，因为同一种作物吸收的是同一类养分，长此以往，地力就会枯竭。人的脑力和体力也是这样，<br>如果长时间持续同一项工作内容，就会产生疲劳，使活动能力下降。如果这时改变工作内容，就会产生新的优势兴奋灶，而原来的兴奋灶则得到抑制，这样人的脑力和体力就可以得到有交的调剂和放松。</p>
<p>个人简评：现有工作和学习模式就是这样，腻了就来回切换地点工作学习，写字楼，图书馆，星巴克，便利店，只要环境安静干净，有公共座椅和Wifi就可以无缝切换，个人推荐这种！</p>
<h2 id="达芬奇睡眠法"><a href="#达芬奇睡眠法" class="headerlink" title="达芬奇睡眠法"></a>达芬奇睡眠法</h2><p>中文名 达芬奇睡眠法<br>外文名 Da Vinci sleep<br>别称 多阶段睡眠<br>提出者 达·芬奇<br>应用学科 睡眠<br>适用领域范围 特殊人群</p>
<p>一句话理解：减少睡眠时间的方式</p>
<p>达芬奇睡眠法是一种将人类习惯的单次睡眠过程分散成多个睡眠周期进行，以达成减少睡眠时间的睡眠方式，又称多阶段睡眠（Polyphasic sleep）、Uberman睡眠或多相睡眠。<br>传说达芬奇在500多年前创造了一个奇怪的睡眠作息时间表――“达芬奇睡眠法”，规定每4小时就要小睡15分钟。<br>这样一来，每天只需要睡一个半小时就够了.</p>
<p>个人简评：这种极端方式，只适应少数人，感兴趣可以自我实验1天试试，切勿深入着迷，反正我个人是受不了4小时一睡（关键是睡不着，时间都浪费在酝酿睡意上了）.</p>
<h2 id="维克斯健脑操"><a href="#维克斯健脑操" class="headerlink" title="维克斯健脑操"></a>维克斯健脑操</h2><p>英国爱丁堡大学脑医学博士维克斯先生经多年研究发明的一套“健脑操”，健脑操包括人的记忆思维能力和练习大脑的创造力两个部分。</p>
<p>详情看链接：<br><a href="https://www.douban.com/note/627418932/" target="_blank" rel="external">豆瓣-维克斯健脑操</a></p>
<hr>
<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><hr>
<h2 id="四像限原则"><a href="#四像限原则" class="headerlink" title="四像限原则"></a>四像限原则</h2><p>一种时间精力分配方法</p>
<p>究竟什么占据了人们的时间？这是一个经常令人困惑的问题。<br>著名管理学家科维提出了一个时间管理的理论，把工作按照重要和紧急两个不同的程度进行了划分，基本上可以分为四个“象限”：<br>　既紧急又重要<br>　重要但不紧急<br>　紧急但不重要<br>　既不紧急也不重要<br>这就是关于时间管理的“四象限法则”。<br><img src="/images/it_manager_rule10.jpg" alt="UML图"></p>
<h2 id="二八原则"><a href="#二八原则" class="headerlink" title="二八原则"></a>二八原则</h2><p>又名80/20定律、帕累托法则（定律）也叫巴莱特定律、最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。<br>是意大利经济学家巴莱多发明的。他认为，在任何一组东西中，最重要的只占其中一小部分，约20%。其余80%的尽管是多数，却是次要的，因此又称二八法则。<br>避免将时间花在琐碎的多数问题上，应该集中精力解决 20% 的少数问题，因为你只需花 20% 的时间，即可取得 80% 的成效。 </p>
<p>不可忽略的二八法则<br>犹太人认为，存在一条78∶22宇宙法则，世界上许多事物，都是按78∶22这样的比率存在的。比如空气中，氮气占78%，氧气及其他气体占22%。人体中的水分占78%，其他为22%等等。上升到理论高度，就是我们常说的“二八法则”（也叫“二八定律”）。</p>
<p>日常工作生活中，二八法则无处不在。占人口20%的人，拥有世界上80%的财富；商家发现，自己80%的收入，来自20%的消费者；而我们的工作中，用20%的时间完成80%的任务。</p>
<p>•通常一个企业80%的利润来自它20%的项目<br>•成功的关键是要确定带来80%利润的20%的顾客在哪里并且留住他们<br>•要事第一，重要产品第一，关键人物第一，核心环节第一<br>•找出工作最关键的部分，尽可能把精力放在上面</p>
<p>其核心内容是生活中80%的结果几乎源于20%的活动。比如，总是那些20%的客户给你带来了80%的业绩，可能创造了80%的利润；世界上创造了80%的财富是被20%的人掌握着，世界上80%的人只分享了 20%的财富。因此，要把注意力放在20%的关键事情上。<br>根据这一原则，我们应当对要做的事情分轻重缓急，进行如下的排序：<br>     A．重要且紧急（比如救火、抢险等）——必须立刻做。<br>     B．重要但不紧急（比如学习、做计划、与人谈心、体检等）——只要没有前一类事的压力，应该当成紧急的事去做，而不是拖延。<br>     C．紧急但不重要（比如有人因为打麻将“三缺一”而紧急约你、有人突然打电话请吃饭等）——只有在优先考虑了重要的事情后，再来考虑这类事。人们常犯的毛病是把“紧急”当成优先原则，而不是把“重要”当成优先原则。其实，许多看似很紧急的事，拖一拖，甚至不办，也无关大局。<br>     D．既不紧急也不重要（比如娱乐、消遣等事情）——有闲工夫再说。</p>
<hr>
<h1 id="企业管理"><a href="#企业管理" class="headerlink" title="企业管理"></a>企业管理</h1><hr>
<h2 id="马斯洛需求层次理论"><a href="#马斯洛需求层次理论" class="headerlink" title="马斯洛需求层次理论"></a>马斯洛需求层次理论</h2><p>中文名 马斯洛需求层次理论<br>外文名Maslow’s hierarchy of needs<br>别    称 需求层次理论<br>提出人亚伯拉罕·马斯洛<br>时    间 1943年<br>相关论文 《人类激励理论》<br>理论方向 激励，薪酬博弈，管理学 应用领域 人力资源，心理学，教育<br>理论流派 人本主义</p>
<p>马斯洛需求层次理论是人本主义科学的理论之一，由美国心理学家亚伯拉罕·马斯洛在1943年在《人类激励理论》论文中所提出。书中将人类需求像阶梯一样从低到高按层次分为五种，分别是：生理需求、安全需求、社交需求、尊重需求和自我实现需求。</p>
<p><img src="/images/it_manager_rule12.png" alt="UML图"></p>
<h2 id="麦肯锡7S模型"><a href="#麦肯锡7S模型" class="headerlink" title="麦肯锡7S模型"></a>麦肯锡7S模型</h2><p>中文名 麦肯锡解决问题7步法<br>外文名 Mckinsey 7S Model<br>简称 7s模型<br>隶属 麦肯锡顾问公司</p>
<p>麦肯锡7S模型(Mckinsey 7S Model)，简称7s模型，是麦肯锡顾问公司研究中心设计的企业组织七要素，指出了企业在发展过程中必须全面地考虑各方面的情况，包括结构（structure）、制度（system）、风格（style）、员工（staff）、技能（skill）、战略（strategy）、共同的价值观（shared values）。<br><img src="/images/it_manager_rule42.png" alt="UML图"></p>
<h2 id="波特五力模型"><a href="#波特五力模型" class="headerlink" title="波特五力模型"></a>波特五力模型</h2><p>波特五力模型是迈克尔·波特（Michael Porter）于20世纪80年代初提出。它认为行业中存在着决定竞争规模和程度的五种力量，这五种力量综合起来影响着产业的吸引力以及现有企业的竞争战略决策。五种力量分别为同行业内现有竞争者的竞争能力、潜在竞争者进入的能力、替代品的替代能力、供应商的讨价还价能力、购买者的讨价还价能力。</p>
<p>中文名 波特五力模型<br>外文名 Michael Porter five forces model<br>提出者 迈克尔·波特(Michael Porter)<br>应    用 企业战略规划</p>
<p><img src="/images/it_manager_rule51.png" alt="UML图"></p>
<h2 id="领导力五力模型"><a href="#领导力五力模型" class="headerlink" title="领导力五力模型"></a>领导力五力模型</h2><p>中文名 领导力五力模型<br>应用学科 企业经营管理<br>内    容 感召、前瞻、影响、决断和控制力</p>
<p>领导力概念与领导过程、领导行为、领导能力、领导知识和领导情境等密切相关，它们共同构成了领导力概念链，并诠释了领导力诸要素的关系：处于核心层（第一圈层）的是领导过程；第二圈层的领导行为、领导能力和领导知识都是领导过程的直接或间接产物；第三圈层的领导情境是指确保领导过程正常运行的环境因素的总和，是领导行为、领导能力和领导知识等要素形成和发展的重要基础。</p>
<p>领导力五力模型<br><img src="/images/it_manager_rule49.png" alt="UML图"><br><img src="/images/it_manager_rule50.png" alt="UML图"></p>
<h2 id="5C理论"><a href="#5C理论" class="headerlink" title="5C理论"></a>5C理论</h2><p>中文名 5C理论<br>评价 总经理能力体系评价<br>类型 一种最新理论模型<br>含义 change 变革 cadreman骨干等</p>
<p>5C是指：change 变革 cadreman骨干 customer客户 check考核 culture文化。<br>以这五个方面的领导管理能力为主要标志，对企业领导（总经理）的测量、评价体系。<br><img src="/images/it_manager_rule41.png" alt="UML图"></p>
<h2 id="领导权变理论"><a href="#领导权变理论" class="headerlink" title="领导权变理论"></a>领导权变理论</h2><p>“权变”一词有“随具体情境而变”或“依具体情况而定的意思”。<br>领导权变理论主要研究与领导行为有关的情境因素对领导效力的潜在影响。该理论认为，在不同的情境中，不同的领导行为有不同的效果，所以又被称为领导情境理论。<br>中文名 领导权变理论<br>发源于 西方组织管理学<br>性    质 管理理论<br>内    容 领导行为有关<br>又    称 领导情境理论<br>发源地 西方</p>
<h2 id="STAR法则"><a href="#STAR法则" class="headerlink" title="STAR法则"></a>STAR法则</h2><p>STAR法则是情境(situation)、任务(task)、行动(action)、结果(result)四项的缩写。STAR法则是一种常常被面试官使用的工具，用来收集面试者与工作相关的具体信息和能力。S<br>TAR法则比起传统的面试手法来说，可以更精确地预测面试者未来的工作表现。<br>中文名 STAR法则<br>定    义 一种讲述自己故事的方式<br>优    点 更精确地预测面试者未来工作表现<br>STAR 四个单词的缩写</p>
<p>STAR法则,即为Situation Task Action Result的缩写，具体含义是:<br>Situation: 事情是在什么情况下发生<br>Task: 你是如何明确你的任务的<br>Action: 针对这样的情况分析，你采用了什么行动方式<br>Result: 结果怎样，在这样的情况下你学习到了什么<br>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>
<p>相关文章：<a href="http://www.jianshu.com/p/d833c4cd4f46" target="_blank" rel="external">STAR法则，被这个理由拒绝这么多次，必须搞明白！</a></p>
<p><img src="/images/it_manager_rule40.jpg" alt="UML图"></p>
<h2 id="SMART原则"><a href="#SMART原则" class="headerlink" title="SMART原则"></a>SMART原则</h2><p>绩效管理的一种方式<br>原则即目标管理，目标管理是使经理的工作变被动为主动的一个很好的手段，实施目标管理不但是有利于员工更加明确高效地工作，更是为未来的绩效考核制定了目标和考核标准，使考核更加科学化、规范化，更能保证考核的公开、公平与公正，没有目标是无法考核员工的。</p>
<p>•具体的（Specific）<br>•可以衡量的（Measurable）<br>•可以达到的（Attainable）<br>•相关性的(Relevant) 比如一个前台，你让她学点英语以便接电话的时候用得上，这时候提升英语水平和前台接电话的服务质量有关联<br>•具有明确的截止期限（Time-bound）</p>
<p><img src="/images/it_manager_rule39.jpg" alt="UML图"></p>
<p>相关文章：<a href="http://jixiaoguanli.baike.com/article-703023.html" target="_blank" rel="external">什么是SMART原则？</a></p>
<h2 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h2><p>著名的PDCA循环（Plan Do Check Action），也称戴明环。PDCA是为了提高质量的管理思想，是一套科学程序，注重管理活动的全部过程。</p>
<p>“P”是PLAN：制定目标和计划。《礼记·中庸》提到：“凡事预则立，不预则废。”，说明了目标和计划的重要性。很多时候，我们都是走一步算一步，缺少目标的定制和计划，认为这个很虚，没有必要，也就缺少对目标的实施，到底完成了多少，实现了多少，还是那些未能实现，是什么原因导致的，都无从知晓。</p>
<p>“D”是DO：开始行动，实施计划很多人制定了计划，可以说，计划是相当完美，可因见异思迁，三分钟热度，一时的激情过后就没了动力了。有位记者采访通用公司前总裁杰克·韦尔奇时，记者问：“请问韦尔奇先生，你们为什么能成功？”，韦尔奇先生回答说：“你们知道了，我们做到了”。很多时候我们都没有勇敢的迈出第一步，总是想着这，顾虑那，慢慢就放弃了。</p>
<p>“C”是CHECK，对行动的结果进行检验，行动了，做了，要有个结果，对其结果是否满意，思考下次方案是否可以改进等。</p>
<p>“A”是ACTION：纠正错误，调整方向。其实也就是总结、完善的意思善于总结，我们伟大的毛主席就非常提倡这点，他把他的成功归咎于善于总结经验，集中群众智慧，可见总结这个环节不容忽视。工作中，小到日报，周报，大到月总结，季总结等。有总结我们才能更进一步把工作做得更好。</p>
<p><img src="/images/it_manager_rule32.png" alt="UML图"></p>
<h2 id="1-25裂变定律"><a href="#1-25裂变定律" class="headerlink" title="1:25裂变定律"></a>1:25裂变定律</h2><p>1比25裂变定律，即你如果认识一个人，那么通过他，你就有可能再认识25个人。这套著名的理论由美国社会学家博恩·思希提出，曾被西方商业界广泛采用。<br>一个资源的无限裂变<br>适用于人际交往</p>
<p>西方商业界：<br>1比25裂变定律 曾被西方商业界广泛采用。他们在营销过程中，推行微笑服务，让服务人员不要得罪任何一名顾客，因为在一位顾客的背后，潜藏着25个客户。<br>成功学领域：<br>1比25裂变定律理论又被引入到成功学领域。更有人推波助澜，打出这样的公式：成功=20%的知识+80%的人脉。把人脉当成了事业成功的黄金定律。<br>拓展黄金人脉：<br>十年前，这一理论传入中国。有一阵子，甚至出现这样一种现象：一些私营企业的老总为了拓展黄金人脉，花高价或通过巨额赞助的方式，把子女送到北大和清华，让他们插班学习，自己也通过某种方式，到中央党校进修。他们学习也能学到一点东西，但更重要的，是认识了很多人，很多重量级的人。扩大社交圈，拓展黄金人脉，成为他们的潜在目的。</p>
<p>评价：<br>无论你的产业有多大，人脉有多广，你一生所面对的，说到底就是身边的那几个人。<br>相互琢磨和提防的，也就是你身边的那几个人。而真正给你爱和你真正能爱的，也就是那几个人。<br>——这也许是博恩·思希想说而没有说的。<br>你周围的亲人，从小认识的那几个朋友，以及身处的小环境，也许就是你最具有价值的人脉。</p>
<p><img src="/images/it_manager_rule33.jpg" alt="UML图"></p>
<h2 id="能力素质模型"><a href="#能力素质模型" class="headerlink" title="能力素质模型"></a>能力素质模型</h2><p>中文名 能力素质模型<br>外文名 Competence Model<br>开发方法 关键事件访谈法<br>应用 人才甄选、绩效管理、继任计划等</p>
<p>能力素质模型通常包括三类能力：通用能力、可转移的能力、独特的能力。这些行为和技能必须是可衡量、可观察、可指导的，并对员工的个人绩效以及企业的成功产生关键影响。</p>
<p><img src="/images/it_manager_rule43.png" alt="UML图"></p>
<h2 id="岗位胜任力素质模型"><a href="#岗位胜任力素质模型" class="headerlink" title="岗位胜任力素质模型"></a>岗位胜任力素质模型</h2><p>中文名 胜任素质模型<br>外文名 Competency Model<br>别称 素质模型<br>用途 员工产生工作绩效的各种特征集合 </p>
<p>胜任素质模型就是个体为完成某项工作、达成某一绩效目标所应具备的系列不同素质要素的组合，分为内在动机、知识技能、自我形象与社会角色特征等几个方面。这些行为和技能必须是可衡量、可观察、可指导的，并对员工的个人绩效以及企业的成功产生关键影响。</p>
<p><img src="/images/it_manager_rule44.png" alt="UML图"></p>
<h2 id="冰山模型"><a href="#冰山模型" class="headerlink" title="冰山模型"></a>冰山模型</h2><p>冰山模型是美国著名心理学家麦克利兰于1973年提出了一个著名的模型，所谓“冰山模型”，就是将人员个体素质的不同表现表式划分为表面的“冰山以上部分”和深藏的“冰山以下部分”。</p>
<p>中文名 冰山模型<br>提出者 麦克利兰（美）<br>用    处 心理治疗<br>归    类 社会科学/心理学</p>
<p><img src="/images/it_manager_rule45.png" alt="UML图"></p>
<h2 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h2><p>洋葱模型是在冰山模型基础上演变而来的。美国学者理查德·博亚特兹对麦克利兰的素质理论进行了深入和广泛的研究，提出了“素质洋葱模型”，展示了素质构成的核心要素，并说明了各构成要素可被观察和衡量的特点。洋葱模型，是把胜任素质由内到外概括为层层包裹的结构，最核心的是动机，然后向外依次展开为个性、自我形象与价值观、社会角色、态度、知识、技能。越向外层，越易于培养和评价；越向内层，越难以评价和习得。</p>
<p>中文名 洋葱模型<br>外文名 Onion model<br>提出者 美国学者R.博亚特兹<br>核心要素 素质构成<br>应    用人员选拔，人员测评</p>
<p><img src="/images/it_manager_rule46.png" alt="UML图"></p>
<h2 id="高绩效素质模型"><a href="#高绩效素质模型" class="headerlink" title="高绩效素质模型"></a>高绩效素质模型</h2><p>高绩效素质模型是对一个企业当中高绩效模型的描述，分成动脑，动心，动手，动嘴四个模块，简称BHM体系。通过这种无缝联接，可以系统的或者单独模块的就企业员工素质进行业绩导向的提升，是企业业绩提升的有利工具。</p>
<p><img src="/images/it_manager_rule47.png" alt="UML图"></p>
<h2 id="GROW模型"><a href="#GROW模型" class="headerlink" title="GROW模型"></a>GROW模型</h2><p>GROW的意思是成长，帮助员工成长。<br>G（Goal setting）：代表确认员工业绩目标；<br>R（Reality Check）：是现状，要搞清楚目前的现状、客观事实是什么；寻找动因；<br>O（Options）：代表寻找解决方案；<br>W（Way Forward）：What? When? Who? Will? What should be done? When by whom and does the will exist to do it?代表制定行动计划和评审时间。</p>
<p>Grow模型可以在生活很多不同的地方运用，它的主旨意为理清现状，减少某些事情的干扰，使执行人从内心找到对应的办法。<br>GROW其目标，是使得员工认识也认同现目标的自己有什么能做的，或者怎么做。<br><img src="/images/it_manager_rule52.png" alt="UML图"></p>
<h2 id="坏苹果法则"><a href="#坏苹果法则" class="headerlink" title="坏苹果法则"></a>坏苹果法则</h2><p>中文名 坏苹果法则<br>外文名 Bad apple law<br>法    则 态度决定团队<br>内    容 坏苹果留在好苹果里，结果全变烂</p>
<p>一句话理解：人的态度将影响到团队</p>
<p><img src="/images/it_manager_rule37.jpg" alt="UML图"></p>
<h2 id="蘑菇定律"><a href="#蘑菇定律" class="headerlink" title="蘑菇定律"></a>蘑菇定律</h2><p>中文名 蘑菇定律<br>别    称 蘑菇管理<br>提出者 电脑程序员<br>提出时间 20世纪70年代<br>适用领域范围 心理学</p>
<p>战胜苦难突出重围</p>
<p>蘑菇定律是指初入世者常常会被置于阴暗的角落，不受重视或打杂跑腿，就象蘑菇培育一样还要被浇上大粪，接受各种无端的批评、指责、代人受过，得不到必要的指导和提携，处于自生自灭过程中。蘑菇生长必须经历这样一个过程，人的成长也肯定会经历这样一个过程。这就是蘑菇定律，或叫萌发定律。</p>
<p>“蘑菇管理”指的是组织或个人对待新进者的一种管理心态。因为初学者常常被置于阴暗的角落，不受重视的部门，只是做一些打杂跑腿的工作，有时还会被浇上一头大粪，受到无端的批评、指责、代人受过，组织或个人任其自生自灭，初学者得不到必要的指导和提携，这种情况与蘑菇的生长情景极为相似 。一般在管理机构比较正式的大企业和公司里，这种情况比较多  。相信很多人都有过这样一段“蘑菇”的经历，这不一定是什么坏事，尤其是当一切刚刚开始的时候，当几天“蘑菇”，能够消除我们很多不切实际的幻想，让我们更加接近现实，看问题也更加实际.</p>
<p><img src="/images/it_manager_rule36.jpg" alt="UML图"></p>
<h2 id="异性效应"><a href="#异性效应" class="headerlink" title="异性效应"></a>异性效应</h2><p>中文名 异性效应<br>意义 自愿为了事业进步、丰富生活<br>范围 三情（友情、爱情、亲情）<br>本质 心理现象</p>
<p>一句话理解：男女搭配干活不累</p>
<p>在个体间关系中，异性接触会产生一种特殊的相互吸引力和激发力，并能从中体验到难以言传的感情追求，对动物的活动和学习通常起积极的影响，这种现象称为异性效应，也叫“磁铁效应”，即“同性相斥，异性相吸”，俗话说：“男女搭配，干活不累”正是如此。</p>
<p><img src="/images/it_manager_rule35.jpg" alt="UML图"></p>
<h2 id="懒蚂蚁效应"><a href="#懒蚂蚁效应" class="headerlink" title="懒蚂蚁效应"></a>懒蚂蚁效应</h2><p>中文名 懒蚂蚁效应<br>外文名 Lazy ant effect<br>适用领域 企业管理 市场研究<br>特征 能够为集体寻找一些重要线索</p>
<p>懒蚂蚁效应是日本北海道大学进化生物研究小组对三个分别由30只蚂蚁组成的黑蚁群的活动观察。结果发现。大部分蚂蚁都很勤快地寻找、搬运食物、少数蚂蚁却整日无所事事、东张西望，人们把这少数蚂蚁叫做“懒蚂蚁”。 有趣的是，当生物学家在这些“懒蚂蚁”身上做上标记，并且断绝蚁群的食物来源时，那些平时工作很勤快的蚂蚁表现得一筹莫展，而“懒蚂蚁”们则“挺身而出”，带领众蚂蚁向它们早已侦察到的新的食物源转移。原来“懒蚂蚁”们把大部分时间都花在了“侦察”和“研究”上了。它们能观察到组织的薄弱之处，同时保持对新的食物的探索状态，从而保证群体不断得到新的食物来源。在蚁群和企业中，“懒蚂蚁”很重要，此现象被称为“懒蚂蚁效应”。</p>
<p><img src="/images/it_manager_rule34.jpg" alt="UML图"></p>
<h2 id="顾客细分"><a href="#顾客细分" class="headerlink" title="顾客细分"></a>顾客细分</h2><p>中文名 顾客细分<br>提    出美国学者温德尔·史密斯<br>提出时间 20世纪50年代中期<br>理论依据 顾客特征与顾客反映</p>
<p>顾客（客户）细分是20世纪50年代中期由美国学者温德尔·史密斯提出的一种将顾客分类的方法，其理论依据主要有两点：顾客特征与顾客反映。</p>
<p><img src="/images/it_manager_rule48.png" alt="UML图"></p>
<h2 id="营销漏斗模型"><a href="#营销漏斗模型" class="headerlink" title="营销漏斗模型"></a>营销漏斗模型</h2><p>中文名 营销漏斗模型<br>全    称搜索营销效果转化漏斗<br>作    用 反映客户数量及流失<br>关键要素 营销的环节，相邻环节的转化率</p>
<p>全称为”搜索营销效果转化漏斗”，漏斗的五层对应了企业搜索营销的各个环节，反映了从展现、点击、访问、咨询，直到生成订单过程中的客户数量及流失。从最大的展现量到最小的订单量，这个一层层缩小的过程表示不断有客户因为各种原因离开，对企业失去兴趣或放弃购买。</p>
<p><img src="/images/it_manager_rule53.jpg" alt="UML图"></p>
<h2 id="产品定位五步法"><a href="#产品定位五步法" class="headerlink" title="产品定位五步法"></a>产品定位五步法</h2><p>产品定位是指确定公司或产品在顾客或消费者心目中的形象和地位．这个形象和地位应该是与众不同的。但是，对于如何定位，部分人士认为，定位是给产品定位。营销研究与竞争实践表明，仅有产品定位已经不够了，必须从产品定位扩展至营销定位。<br>相关文章：<a href="http://wiki.mbalib.com/wiki/%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E4%BA%94%E6%AD%A5%E6%B3%95" target="_blank" rel="external">产品定位五步法</a></p>
<p><img src="/images/it_manager_rule54.jpg" alt="UML图"></p>
<hr>
<h1 id="创业管理"><a href="#创业管理" class="headerlink" title="创业管理"></a>创业管理</h1><hr>
<h2 id="ABZ规划"><a href="#ABZ规划" class="headerlink" title="ABZ规划"></a>ABZ规划</h2><p>有一种计划叫ABZ理论，据说实践过后都成了有钱银！</p>
<p>linkedln和paypal的联合创始人Reid Hoffman有一个非常著名的ABZ理论，他认为，你在任何时刻，都要有三个计划，abz计划。</p>
<p>A主业（当前的工作）<br>B副业（预留的职业，当A计划无法执行时，可以顺利的切换B计划）<br>Z（B到A这个过程需要的投资，或者是最稳妥的退路。）</p>
<p>简单理解<br>a是你目前能够长期从事下去的工作，值得你持续投入，并可以获得安全感，并且这份工作，你个人还很满意。<br>b是除去a计划外，你给自己的一些培训机会，或者兴趣爱好，你只坚持a，可能未来某天会被其他人或者机器替代，b，是除了a之外的，你愿意长期投入精力的一项属于自己的“小事业”，未来某天，机会合适，你也完全可以把b变为a。<br>z，是你的安全牌，假设有一天你的ab计划全部落空失败，你的z计划，可以保证你在未来某一段时间内，可以继续保持现有的生活品质。我的理解就是一定金额的储蓄存款。</p>
<p>尤其是马云的英语，成就了今天的马云，哦不，是绝对帮助了今天的马云，这个观点特别赞同，如果你特别能喝酒，这也可能会成为未来的一项优势，技多不压身嘛！</p>
<h2 id="收入四象限"><a href="#收入四象限" class="headerlink" title="收入四象限"></a>收入四象限</h2><p><img src="/images/it_manager_rule11.png" alt="UML图"><br>相关文章：<a href="http://www.finnciti.cc/2659.html" target="_blank" rel="external">四个收入象限让你决定人生该往哪个方向走</a></p>
<h2 id="养猪理论"><a href="#养猪理论" class="headerlink" title="养猪理论"></a>养猪理论</h2><p>领域 创业管理<br>提出者 单祥双</p>
<p>在创业管理中有一个“养猪理论”，是说猪越肥代表价格越高，劝人在职场上把自己也要当猪来养，不断学习，增加自己的附加值，以此才能在职场上为自己卖到好价钱。</p>
<hr>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><hr>
<h2 id="WBS工作分解结构"><a href="#WBS工作分解结构" class="headerlink" title="WBS工作分解结构"></a>WBS工作分解结构</h2><p><img src="/images/it_manager_rule56.jpg" alt="UML图"><br>中文名工作分解结构<br>外文名 WBS<br>全称 Work Breakdown Structure<br>属性项目管理<br>构成 三个关键元素</p>
<p>创建WBS是把项目 交付成果和项目工作分解成较小的，更易于管理的组成部分的过程。</p>
<hr>
<h1 id="营销管理"><a href="#营销管理" class="headerlink" title="营销管理"></a>营销管理</h1><hr>
<h2 id="4P理论"><a href="#4P理论" class="headerlink" title="4P理论"></a>4P理论</h2><p>类    别 一种营销理论<br>提出人杰瑞·麦卡锡教授</p>
<p>4p理论是一种营销理论即；Product、Price、Place、Promotion。取其开头字母，意思为产品，价格，渠道，宣传。<br>杰瑞·麦卡锡（Jerry McCarthy）教授在其《营销学》（Marketing，第一版，出版于1960年左右）最早提出了这个理论。</p>
<h2 id="空雨伞"><a href="#空雨伞" class="headerlink" title="空雨伞"></a>空雨伞</h2><p><a href="https://www.digitaling.com/articles/22929.html" target="_blank" rel="external">一把「空雨伞」秘密武器，让你的文字更精彩！</a><br><a href="https://www.digitaling.com/articles/22929.html" target="_blank" rel="external">揭秘百万销冠工作笔记—空雨伞黄金三分法，三分钟学会受用一生 
</a></p>
<h2 id="FABE销售法"><a href="#FABE销售法" class="headerlink" title="FABE销售法"></a>FABE销售法</h2><p>中文名 FABE销售法<br>F代表 特征(Features)<br>A代表 优点(Advantages)<br>B代表 利益(Benefits)<br>E代表 证据(Evidence)</p>
<p>FABE模式是由美国奥克拉荷大学企业管理博士、台湾中兴大学商学院院长郭昆漠总结出来的。FABE推销法是非常典型的利益推销法，而且是非常具体、具有高度、可操作性很强的利益推销法。它通过四个关键环节，极为巧妙地处理好了顾客关心的问题，从而顺利地实现产品的销售。</p>
<h2 id="AIDMA"><a href="#AIDMA" class="headerlink" title="AIDMA"></a>AIDMA</h2><p>中文名 AIDMA<br>分类 广告 </p>
<p>定义 心理学 消费者行为学<br>AIDMA是消费者行为学领域很成熟的理论模型之一，由美国广告学家E.S.刘易斯在1898年提出。该理论认为，消费者从接触到信息到最后达成购买，会经历这5个阶段：</p>
<p>A：Attention（引起注意）——花哨的名片、提包上绣着广告词等被经常采用的引起注意的方法</p>
<p>I:Interest （引起兴趣）——一般使用的方法是精制的彩色目录、有关商品的新闻简报加以剪贴。</p>
<p>D:Desire（唤起欲望）——推销茶叶的要随时准备茶具，给顾客沏上一杯香气扑鼻的浓茶，顾客一品茶香体会茶的美味，就会产生购买欲。推销房子的，要带顾客参观房子。餐馆的入口处要陈列色香味具全的精制样品，让顾客倍感商品的魅力，就能唤起他的购买欲。</p>
<p>M:Memory（留下记忆）—— 一位成功的推销员说：“每次我在宣传自己公司的产品时，总是拿着别公司的产品目录，一一加以详细说明比较。因为如果总是说自己的产品有多好多好，顾客对你不相信。反而想多了解一下其他公司的产品，而如果你先提出其他公司的产品，顾客反而会认定你自己的产品。”</p>
<p>A:Action（购买行动）——从引起注意到付诸购买的整个销售过程，推销员必须始终信心十足。过分自信也会引起顾客的反感，以为你在说大话、吹牛皮。从而不信任你的话。</p>
<hr>
<h1 id="思考策略"><a href="#思考策略" class="headerlink" title="思考策略"></a>思考策略</h1><hr>
<h2 id="MECE分析法"><a href="#MECE分析法" class="headerlink" title="MECE分析法"></a>MECE分析法</h2><p><img src="/images/it_manager_rule28.jpg" alt="UML图"><br><img src="/images/it_manager_rule29.jpg" alt="UML图"><br>MECE 原则：取自“Mutually Exclusive Collectively Exhaustive”，意为“相互独立，完全穷尽”。<br>类似剥洋葱，从一个最高层的问题开始，逐层向下进行分解，形成系统化的思维模式。（把复杂问题，拆分成小的容易解决的子问题） </p>
<h2 id="六顶思考帽"><a href="#六顶思考帽" class="headerlink" title="六顶思考帽"></a>六顶思考帽</h2><p><img src="/images/it_manager_rule55.jpg" alt="UML图"><br>中文名 六顶思考帽<br>国    家英国<br>开    发 爱德华·德·博诺<br>性    质 思维训练模式</p>
<p>六顶思考帽是英国学者爱德华·德·博诺（Edward de Bono）博士开发的一种思维训练模式，或者说是一个全面思考问题的模型。它提供了“平行思维”的工具，避免将时间浪费在互相争执上。强调的是“能够成为什么”，而非 “本身是什么”，是寻求一条向前发展的路，而不是争论谁对谁错。运用德博诺的六顶思考帽，将会使混乱的思考变得更清晰，使团体中无意义的争论变成集思广益的创造，使每个人变得富有创造性。</p>
<p>所谓六顶思考帽，是指使用六种不同颜色的帽子代表六种不同的思维模式。任何人都有能力使用以下六种基本思维模式：</p>
<p>白色思考帽<br>白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。</p>
<p>绿色思考帽<br>绿色代表茵茵芳草，象征勃勃生机。绿色思考帽寓意创造力和想象力。它具有创造性思考、头脑风暴、求异思维等功能。</p>
<p>黄色思考帽<br>黄色代表价值与肯定。戴上黄色思考帽，人们从正面考虑问题，表达乐观的、满怀希望的、建设性的观点。</p>
<p>黑色思考帽<br>戴上黑色思考帽，人们可以运用否定、怀疑、质疑的看法，合乎逻辑的进行批判，尽情发表负面的意见，找出逻辑上的错误。</p>
<p>红色思考帽<br>红色是情感的色彩。戴上红色思考帽，人们可以表现自己的情绪，人们还可以表达直觉、感受、预感等方面的看法。</p>
<p>蓝色思考帽<br>蓝色思考帽负责控制和调节思维过程。它负责控制各种思考帽的使用顺序，它规划和管理整个思考过程，并负责做出结论。</p>
<p>作用:<br>六顶思考帽是平行思维工具，是创新思维工具，也是人际沟通的操作框架，更是提高团队智商的有效方法 。<br>六顶思考帽是一个操作简单、经过反复验证的思维工具，它给人以热情，勇气和创造力，让每一次会议，每一次讨论，每一份报告，每一个决策都充满新意和生命力。这个工具能够帮助人们：<br>●提出建设性的观点；<br>●聆听别人的观点；<br>●从不同角度思考同一个问题，从而创造高效能的解决方案。<br>●用“平行思维“取代批判式思维和垂直思维。<br>●提高团队成员的集思广益能力，为统合综效提供操作工具。</p>
<p>应用步骤:<br>用“六顶思考帽”来考虑我们工作中存在的问题，也会起到意外的效果。<br>运用“白色思考帽”来思考、搜集各环节的信息，收取各个部门存在的问题，找到基础数据。<br>戴上“绿色思考帽”，用创新的思维来考虑这些问题，不是一个人思考，而是各层次管理人员都用创新的思维去思考，大家提出各自解决问题的办法、好的建议、好的措施。也许这些方法不对、甚至无法实施。但是，运用创新的思考方式就是要跳出一般的思考模式。<br>接着，分别戴上“黄色思考帽”和“黑色思考帽”，对所有的想法从“光明面”和“良性面”进行逐个分析，对每一种想法的危险性和隐患进行分析，找出最佳切合点。“黄色思考帽”和“黑色思考帽”这两种思考方法，就好像是孟子的性善论和性恶论，都能进行否决或都进行肯定。<br>到了这个时候，再戴上“红色思考帽”，从经验、直觉上，对已经过滤的问题进行分析、筛选，做出决定。<br>在思考的过程中，还应随时运用“蓝色思考帽”，对思考的顺序进行调整和控制，甚至有时还要刹车。因为，观点可能是正确的，也可能会进入死胡同。所以，在整个思考过程中，应随时调换思考帽，进行不同角度的分析和讨论。</p>
<h2 id="头脑风暴法-智力激励法-BS法"><a href="#头脑风暴法-智力激励法-BS法" class="headerlink" title="头脑风暴法/智力激励法/BS法"></a>头脑风暴法/智力激励法/BS法</h2><p>中文名 头脑风暴法<br>外文名 Brainstorming<br>属    性 一种集体研讨行为<br>最    早精神病理学上的用语</p>
<p>（Brain Storming——BS）：一种通过集思广益、发挥团体智慧，从各种不同角度找出问题所有原因或构成要素的会议方法。BS有四大原则：严禁批评、自由奔放、多多益善、搭便车。</p>
<p>头脑风暴法出自”头脑风暴”一词。所谓头脑风暴是最早是精神病理学上的用语，指精神病患者的精神错乱状态而言的，如今转而为无限制的自由联想和讨论，其目的在于产生新观念或激发创新设想。<br>在群体决策中，由于群体成员心理相互作用影响，易屈于权威或大多数人意见，形成所谓的“群体思维”。群体思维削弱了群体的批判精神和创造力，损害了决策的质量。为了保证群体决策的创造性，提高决策质量，管理上发展了一系列改善群体决策的方法，头脑风暴法是较为典型的一个。</p>
<p><img src="/images/it_manager_rule38.jpg" alt="UML图"></p>
<h2 id="鱼骨分析法"><a href="#鱼骨分析法" class="headerlink" title="鱼骨分析法"></a>鱼骨分析法</h2><p>中文名 鱼骨分析法<br>外文名 Fishbone analysis method<br>别    名因果分析法<br>含    义 发现问题“根本原因”的分析方法<br>应    用 现代工商管理教育</p>
<p>鱼骨分析法，又名因果分析法，是一种发现问题“根本原因”的分析方法，现代工商管理教育如MBA、EMBA等将其划分为问题型、原因型及对策型鱼骨分析等几类先进技术分析。</p>
<p>问题的特性总是受到一些因素的影响，通过头脑风暴找出这些因素，并将它们与特性值一起，按相互关联性整理而成的层次分明、条理清楚，因其形状如鱼骨，所以叫鱼骨图。<br>鱼骨图(Fishbone analysis method)是由日本管理大师石川馨先生所发展出来的，故又名石川图。鱼骨图是一种发现问题“根本原因”的方法，它也可以称之为“因果图”。鱼骨图主要用于工商管理中建立分析模型。<br><img src="/images/it_manager_rule13.png" alt="UML图"></p>
<h2 id="SWOT分析模型"><a href="#SWOT分析模型" class="headerlink" title="SWOT分析模型"></a>SWOT分析模型</h2><p>中文名 SWOT分析模型<br>外文名 SWOT<br>内容 优势、劣势、机会、威胁<br>应用领域 企业战略规划</p>
<p>SWOT分析模型，又称为态势分析法，EMBA及MBA等主流商管教育均将SWOT分析法作为一种常用的战略规划工具包含在内。</p>
<h2 id="5why分析法"><a href="#5why分析法" class="headerlink" title="5why分析法"></a>5why分析法</h2><p>中文名 5why分析法<br>别称 5问法<br>提出者 丰田佐吉</p>
<p>所谓5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要3次，有时也许要10次，如古话所言：打破砂锅问到底。5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。<br><img src="/images/it_manager_rule14.png" alt="UML图"></p>
<h2 id="5W1H分析法"><a href="#5W1H分析法" class="headerlink" title="5W1H分析法"></a>5W1H分析法</h2><p>5W1H（WWWWWH）分析法也叫六何分析法，是一种思考方法，也可以说是一种创造技法。在企业管理、日常工作生活和学习中得到广泛的应用。</p>
<p>5W+1H：是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。<br>1、对象 （What）——什么事情<br>公司生产什么产品？车间生产什么零配件？为什么要生产这<br>5W1H分析法思路<br>5W1H分析法思路<br>个产品？能不能生产别的？我到底应该生产什么？例如:如果这个产品不挣钱，换个利润高点的好不好？<br>2、场所 （Where）——什么地点<br>生产是在哪里干的？为什么偏偏要在这个地方干？换个地方行不行？到底应该在什么地方干？这是选择工作场所应该考虑的。<br>3、时间和程序 （When）——什么时候<br>例如这个工序或者零部件是在什么时候干的？为什么要在这个时候干？能不能在其他时候干？把后工序提到前面行不行？到底应该在什么时间干？<br>4、人员 （Who）——责任人<br>这个事情是谁在干？为什么要让他干？如果他既不负责任，脾气又很大，是不是可以换个人？有时候换一个人，整个生产就有起色了。<br>5、为什么（Why）——原因<br>为什么采用这个技术参数？为什么不能有变动？为什么不能使用？为什么变成红色？为什么要做成这个形状？为什么采用机器代替人力？为什么非做不可？<br>6、方式 （How）——如何<br>手段也就是工艺方法，例如，我们是怎样干的？为什么用这种方法来干？有没有别的方法可以干？到底应该怎么干？有时候方法一改，全局就会改变。<br><img src="/images/it_manager_rule15.png" alt="UML图"></p>
<h2 id="5W2H分析法"><a href="#5W2H分析法" class="headerlink" title="5W2H分析法"></a>5W2H分析法</h2><p>中文名 5W2H分析法<br>别    称 七何分析法<br>表达式 WHAT+WHY+WHEN+WHERE+WHO+HOW+HOW MUCH<br>提出者 美国陆军兵器修理部</p>
<p>5W2H分析法又叫七何分析法，是二战中美国陆军兵器修理部首创。简单、方便，易于理解、使用，富有启发意义，广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>发明者用五个以W开头的英语单词和两个以H开头的英语单词进行设问，发现解决问题的线索，寻找发明<br>5W2H分析法<br>思路，进行设计构思，从而搞出新的发明项目，这就叫做5W2H法。<br>（1） WHAT——是什么？目的是什么？做什么工作？<br>（2）WHY——为什么要做？可不可以不做？有没有替代方案？<br>（3）WHO——谁？由谁来做？<br>（4）WHEN——何时？什么时间做？什么时机最适宜？<br>（5） WHERE——何处？在哪里做？<br>（6）HOW ——怎么做？如何提高效率？如何实施？方法是什么？<br>（7） HOW MUCH——多少？做到什么程度？数量如何？质量水平如何？费用产出如何？<br><img src="/images/it_manager_rule16.png" alt="UML图"></p>
<h2 id="九宫图分析法"><a href="#九宫图分析法" class="headerlink" title="九宫图分析法"></a>九宫图分析法</h2><p>中文名 九宫图分析法<br>利用 九宫格图<br>作用 扩散性思维<br>类型 思考策略<br>曼陀罗法 将主题写在中央<br>莲花法 曼陀罗法的基本单位</p>
<p>九宫图法 是一种有助扩散性思维的思考策略，利用一幅像九宫格图，将主题写在中央，然后把由主题所引发的各种想法或联想写在其余优点乃由事物之核心出发，向八个方向去思考，发挥八种不同的创见。依循此思维方式加以发挥并扩散其思考范围。<br><img src="/images/it_manager_rule17.png" alt="UML图"></p>
<h2 id="PEST分析法"><a href="#PEST分析法" class="headerlink" title="PEST分析法"></a>PEST分析法</h2><p>中文名 PEST分析法<br>外文名 PEST<br>内    容 政治、经济、社会、技术<br>应    用 战略分析</p>
<p>PEST分析是指宏观环境的分析，P是政治(politics)，E是经济(economy)，S是社会(society)，T是技术(technology)。<br>在分析一个企业集团所处的背景的时候，通常是通过这四个因素来进行分析企业集团所面临的状况。<br><img src="/images/it_manager_rule18.png" alt="UML图"></p>
<h2 id="杜邦分析法"><a href="#杜邦分析法" class="headerlink" title="杜邦分析法"></a>杜邦分析法</h2><p>中文名 杜邦分析法<br>外文名 DuPont Analysis<br>相关公司 美国杜邦公司<br>作    用 综合地分析企业的财务状况</p>
<p>杜邦分析法（DuPont Analysis）是利用几种主要的财务比率之间的关系来综合地分析企业的财务状况。具体来说，它是一种用来评价公司赢利能力和股东权益回报水平，从财务角度评价企业绩效的一种经典方法。其基本思想是将企业净资产收益率逐级分解为多项财务比率乘积，这样有助于深入分析比较企业经营业绩。由于这种分析方法最早由美国杜邦公司使用，故名杜邦分析法。</p>
<hr>
<h1 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h1><hr>
<p>与其日复一日重复昨天，不如改变一下思维，换个角度重新出发！看看吧，这些思维方式如果擅于运用将比聪明、智慧还要厉害百倍！</p>
<h2 id="费米思维"><a href="#费米思维" class="headerlink" title="费米思维"></a>费米思维</h2><p>简单化才是最经济、最优化，费米思维一种最简单、最省力、最准确的思维法则，具有普遍的适用性。<br>任何问题的复杂化，都是因为没有抓住最深刻的本质，没有揭示最基本规律与问题之间最短的联系，只是停留在表层的复杂性上，反而离解决问题越来越远。<br>最简单的往往是最合理的。</p>
<h2 id="奥卡姆思维"><a href="#奥卡姆思维" class="headerlink" title="奥卡姆思维"></a>奥卡姆思维</h2><p>奥卡姆思维，就是舍弃一切复杂的表象，直指问题的本质。这种思维的可贵之处，是因为它直戳现实中的这么一种病态：今天的人们，往往自以为掌握了许多知识，而喜欢将事情往复杂处瞎鼓捣。</p>
<h2 id="拉哥尼亚思维"><a href="#拉哥尼亚思维" class="headerlink" title="拉哥尼亚思维"></a>拉哥尼亚思维</h2><p>简练才是真正的丰富，只有最简单的东西才具有最大孕育性和想象空间，也才最符合“拉哥尼亚”思维法则。</p>
<p><a href="http://www.360doc.com/content/12/0301/21/7970410_190950535.shtml" target="_blank" rel="external">拉 哥 尼 亚 思 维</a></p>
<h2 id="上帝思维"><a href="#上帝思维" class="headerlink" title="上帝思维"></a>上帝思维</h2><p>“关爱别人，受益自己。”上帝说，天堂里的居民，凡事都是这么想的，世人要是拥有爱的思维，那他无论身处何方，都是活在天堂里.</p>
<h2 id="司马光思维"><a href="#司马光思维" class="headerlink" title="司马光思维"></a>司马光思维</h2><p>打破，才能得生机。这，就是司马光思维的精髓所在：只有打破旧思维的桎梏，思路才会见光明。</p>
<h2 id="孙子思维"><a href="#孙子思维" class="headerlink" title="孙子思维"></a>孙子思维</h2><p>孙子曰：“知已知彼，百战不殆。”这句名言，体现了一种十分可贵的思维方式，那就是：要战胜对手，就必须了解对手。</p>
<h2 id="拿破仑思维"><a href="#拿破仑思维" class="headerlink" title="拿破仑思维"></a>拿破仑思维</h2><p>所谓拿破仑思维，就是敢想敢干，不被外界所干扰，在任何情况下，始终保持自己的主见，用自己的目光去审视世界，用自己方法去解决问题。</p>
<h2 id="亚历山大思维"><a href="#亚历山大思维" class="headerlink" title="亚历山大思维"></a>亚历山大思维</h2><p>它蕴涵着一种很霸气的、更值得称道的思维方式，那就是，成大事者，决不被陈规旧习所束缚。</p>
<h2 id="哥伦布思维"><a href="#哥伦布思维" class="headerlink" title="哥伦布思维"></a>哥伦布思维</h2><p>想了就要干———这，才是哥伦布思维的可贵之处，自古成功自有道，这个道，往往就是在众人认为不可能地方闯出来。</p>
<h2 id="洛克菲勒思维"><a href="#洛克菲勒思维" class="headerlink" title="洛克菲勒思维"></a>洛克菲勒思维</h2><p>时时求主动，处处占先机，以最小代价，求得利益最大化。这，就洛克菲勒思维的主旨。</p>
<h2 id="1爱迪生思维"><a href="#1爱迪生思维" class="headerlink" title="1爱迪生思维"></a>1爱迪生思维</h2><p>迂者拘泥于形，易被外在束缚；巧者注重本质，因而心明眼亮。爱迪生思维独到之处，就在于其灵动自如直奔目标，而不为人间万象所困惑干扰。</p>
<h2 id="布勃卡思维"><a href="#布勃卡思维" class="headerlink" title="布勃卡思维"></a>布勃卡思维</h2><p>凡事留有余地，力气不必用尽，把握在手的东西，要懂得慢慢享用。这，就是布勃卡思维的精妙之处。</p>
<h2 id="狼性思维"><a href="#狼性思维" class="headerlink" title="狼性思维"></a>狼性思维</h2><p>危险的往往是生机之所在，这种思维，体现了一种物极必反的哲理。拥有如此思维人，同时也得拥有非凡的勇气。</p>
<h2 id="裁缝思维"><a href="#裁缝思维" class="headerlink" title="裁缝思维"></a>裁缝思维</h2><p>眼前的对手，才是真正的对手；现实的问题，才是最有意义的问题。这，就是裁缝思维的主旨。只有认真对待现实中的问题，人们才有可能真正改善自身的处境。</p>
<h2 id="囚徒思维"><a href="#囚徒思维" class="headerlink" title="囚徒思维"></a>囚徒思维</h2><p>囚徒思维传达出这样的信息：人要懂得借势借力，自己要是没有能力去办好某一件事，那就定得想方设法请个能人代劳；要是自己有能力，有时，也得考虑一下是否该让更有能力的人，把一件事情办得更漂亮一些。</p>
<h2 id="浪子思维"><a href="#浪子思维" class="headerlink" title="浪子思维"></a>浪子思维</h2><p>浪子无羁，浪子思维更具有杀伤力！在实战中，浪子思维往往达到出奇制胜的效果。<br>设定一个较低的预期，以便营造更大的发展空间。</p>
<h2 id="多米诺思维"><a href="#多米诺思维" class="headerlink" title="多米诺思维"></a>多米诺思维</h2><p>多米诺思维要说的，就是量变引起质变的道理。在这个世界上，你不可以忽视任何一个微小的事物。往往，一些微小的东西，很可能就是改变大局触发点。</p>
<hr>
<h1 id="决策管理"><a href="#决策管理" class="headerlink" title="决策管理"></a>决策管理</h1><hr>
<h2 id="正反面决策法"><a href="#正反面决策法" class="headerlink" title="正反面决策法"></a>正反面决策法</h2><p>富兰克林发明了正反面决策法，他指出，在面对多种选择时，只要列出每种选择方案的正面影响（Pros）和负面影响（Cons），最佳答案自然会浮出水面。</p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>所谓决策树，其实是一种通过图像方式来呈现各种解决方案的方法。通过决策树，你可以看到各种解决方案将会带来什么最终结果。</p>
<p>打个比方，想象你是一家公司的总经理，你想要聘请一位很给力的销售主管，但又担心此人可能是个骗子。你就可能绘制出下面的决策树<br><img src="/images/it_manager_rule56.jpg" alt="UML图"></p>
<h2 id="可能指数和渴望指数"><a href="#可能指数和渴望指数" class="headerlink" title="可能指数和渴望指数"></a>可能指数和渴望指数</h2><p>除了正反面决策外，你还可以用可能指数（Likelihood，表示该结果出现的可能性有多大）和渴望指数（Desirability，表示你对该结果有多么渴望）。</p>
<p>打个比方，你想确定一场慈善晚宴的主题演讲人，此时你只能邀请三个候选对象中的一位。你要邀请哪位呢？</p>
<p>下面的表格列出了三位候选人的吸引力指数（可能指数与渴望指数的乘积）：<br><img src="/images/it_manager_rule57.jpg" alt="UML图"></p>
<h2 id="卡佛矩阵"><a href="#卡佛矩阵" class="headerlink" title="卡佛矩阵"></a>卡佛矩阵</h2><p>卡佛矩阵源自美国军方，现在也可以用来解决日常工作和生活问题，帮助你从几个可能的选择中确认最佳答案。具体来讲，在面临多种选择时，你可以问自己以下几个问题：</p>
<p>关键度：这个目标究竟有多重要？</p>
<p>实现度：实现这个目标究竟有多容易？</p>
<p>确认度：实现该目标所需要的信息是否容易获取？是否容易判断自己是否实现了该目标？</p>
<p>脆弱度：该目标是否过于简单？你为实现该目标所投入的精力越少，它通常就越脆弱。</p>
<p>影响：实现该目标会在多大程度上影响你的生活？</p>
<p>可恢复性：如果没有实现该目标，你为此所白白失去的时间和精力有多少？</p>
<p>举个例子，理查德目标正面临事业上的十字路口，他有三个选择：提前退休、还家公司或者接替上司的职位。他画出的卡佛矩阵如下：<br><img src="/images/it_manager_rule59.jpg" alt="UML图"><br>根据该矩阵，“接替上司”应该是他目前最理想的选择。</p>
<hr>
<h1 id="习惯管理"><a href="#习惯管理" class="headerlink" title="习惯管理"></a>习惯管理</h1><hr>
<h2 id="重要事情优先"><a href="#重要事情优先" class="headerlink" title="重要事情优先"></a>重要事情优先</h2><p>列出3到4件重要的事情，先完成</p>
<h2 id="随时记录"><a href="#随时记录" class="headerlink" title="随时记录"></a>随时记录</h2><p>捕捉头脑中闪过的想法，记在手机笔记便签或者笔记本上，经常拿出来看看，逐一归类到待办事项.</p>
<h2 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h2><p>日总结、周总结、月总结、季总结、年总结</p>
<h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>感兴趣自行搜索</p>
<h2 id="角色平衡"><a href="#角色平衡" class="headerlink" title="角色平衡"></a>角色平衡</h2><p>父亲、伴侣、儿子、职员、同学朋友平衡好自己的角色</p>
<h2 id="个人使命宣言"><a href="#个人使命宣言" class="headerlink" title="个人使命宣言"></a>个人使命宣言</h2><p>经常反省自己是否离这个大目标更近，周期性的回顾和修正使命宣言<br>•使命: 帮助更多的人获得积极快乐的人生!<br>•生活: 永远保持积极乐观的生活态度!<br>•信念: 坚持不懈，直到成功，为中华崛起而奋斗!<br>•儿子：让父母幸福，健康，长寿。<br>•父亲：让儿女幸福，健康，富裕。<br>•丈夫: 让妻子幸福，健康，积极，乐观。<br>•学习：每个月看一本书。<br>•工作: 和战友们一起共同奋斗。<br>•爱好：永远热爱事业,永远热爱生活。</p>
<h2 id="戴上耳机"><a href="#戴上耳机" class="headerlink" title="戴上耳机"></a>戴上耳机</h2><p>偶尔也要给自己私人空间</p>
<h2 id="单个任务"><a href="#单个任务" class="headerlink" title="单个任务"></a>单个任务</h2><p>•一次只做一件事情<br>•事情一件一件做</p>
<h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>•培养良好的生活和工作习惯<br>•习惯养成了，好习惯养成了，目标就不远了</p>
<h2 id="保持整洁有序"><a href="#保持整洁有序" class="headerlink" title="保持整洁有序"></a>保持整洁有序</h2><p>•心情就会舒畅，心情好，大脑兴奋，没有疲劳感，自然工作效率高。<br>•东西摆放整齐，丢东西或者出差错的几率就小，自然工作效率高。<br>•环境好，空气好，细菌少，生病少，身体倍棒，自然工作效率高。</p>
<h2 id="懂得拒绝"><a href="#懂得拒绝" class="headerlink" title="懂得拒绝"></a>懂得拒绝</h2><p>学会拒绝</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_manager_rule1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="管理学与心理学" scheme="https://hengxing0080.github.io/categories/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    
      <category term="管理学与心理学" scheme="https://hengxing0080.github.io/tags/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Android —— 性能优化系列</title>
    <link href="https://hengxing0080.github.io/2017/09/08/it/1.Android/Performance/"/>
    <id>https://hengxing0080.github.io/2017/09/08/it/1.Android/Performance/</id>
    <published>2017-09-08T15:56:13.000Z</published>
    <updated>2017-10-08T12:25:09.720Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_performance_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>(上图临时占位，等后续总结成思维导图待替换…)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">优化的原则</div><div class="line">    1.时间换空间</div><div class="line">        牺牲时间换取空间, 流的读写</div><div class="line">    2.空间换时间</div><div class="line">        把文件的路径存放到数据库里面,以后查询效率就高很多</div><div class="line">        Android下的图库应用检索sd卡的图片</div><div class="line">    3.空间换空间</div><div class="line">        把内存换成硬盘 或者把硬盘换成内存</div><div class="line">    4.时间换时间</div><div class="line">        开启启动速度的优化</div></pre></td></tr></table></figure>
<p>工作中随着代码体量变得日趋臃肿，视图层级越来越深，工程结构也越来越复杂。<br>相应的，输出的apk包越来越大，界面流畅性大不如前，经常性发生卡顿，甚至不时出现内存溢出崩溃。<br>在这个阶段，Android开发需要掌握以下方面的技术：<br>AndroidStudio的使用(包括调试工具，测试工具，快捷键等)<br>Android资源管理<br>Android视图架构（Activity视图层级、layout inflate）<br>代码优化<br>UI优化<br>内存优化<br>电量优化<br>流量优化<br>网络优化<br>数据库优化<br>动画优化<br>NDK JNI开发<br>……</p>
<p>工作学习中不断自我收集和收集各种技术大牛博客总结的，此文将不断的更新，下面开始各个章节的介绍：</p>
<hr>
<h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><hr>
<p>UI界面布局也会对应用程序的性能会产生很大的影响，如果布局写得糟糕的话，那么程序加载UI的速度就会非常慢，从而造成不好的用户体验。<br>那么本篇文章就来学习一下，如何通过优化布局来提供应用程序的性能。</p>
<h2 id="巧用抽象布局标签-include-viewstub-merge"><a href="#巧用抽象布局标签-include-viewstub-merge" class="headerlink" title="巧用抽象布局标签(include, viewstub, merge)"></a>巧用抽象布局标签(include, viewstub, merge)</h2><p>在布局优化中，Androi的官方提到了这三种布局并介绍了这三种布局各有的优势<br>当你在Application中创建复杂的布局时，页面的渲染过程也变得更加缓慢。<br>此时，我们需要利用include标签(布局重用,避免重复渲染)和ViewStub标签(延迟加载)和merge标签(布局合并)来优化我们的页面。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/43376527" target="_blank" rel="external">Android最佳性能实践(四)——布局优化技巧</a></p>
<h2 id="OverDraw（过度绘制）-amp-渲染绘制的性能优化"><a href="#OverDraw（过度绘制）-amp-渲染绘制的性能优化" class="headerlink" title="OverDraw（过度绘制）&amp; 渲染绘制的性能优化"></a>OverDraw（过度绘制）&amp; 渲染绘制的性能优化</h2><p>相关文章：<br>    <a href="http://blog.csdn.net/lmj623565791/article/details/45556391" target="_blank" rel="external">Android UI性能优化实战 识别绘制中的性能问题</a><br>    <a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a><br>    <a href="http://www.jianshu.com/p/9e095bacf44a" target="_blank" rel="external">实战 Android中的UI过度绘制</a></p>
<p>准备知识：<br>    Android渲染机制</p>
<p>处理方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.移除不必要的background</div><div class="line">    1.1.移除Window默认的Background</div><div class="line">    1.2.移除XML布局文件中非必需的Background</div><div class="line"></div><div class="line">2.onDraw多次重复绘制图案</div><div class="line">    1.1.clipRect的妙用</div><div class="line">    1.2.drawRect等等</div></pre></td></tr></table></figure></p>
<h2 id="去除不必要的层级嵌套和View节点"><a href="#去除不必要的层级嵌套和View节点" class="headerlink" title="去除不必要的层级嵌套和View节点"></a>去除不必要的层级嵌套和View节点</h2><p>4.0及以上Android版本可通过设置-&gt;开发者选项-&gt;显示布局边界打开页面布局显示，看看是否有不必要的节点和嵌套。4.0以下版本可通过hierarchy viewer查看。</p>
<p>(1) 首次不需要使用的节点设置为GONE或使用viewstub<br>很多人在工作中将不常用的元素使用INVISIBLE或者GONE进行隐藏，然后当用户需要使用这些元素的时候再把它们置成VISIBLE显示出来。使用这种方式肯定可以实现功能的，但是性能方面就表现得一般了，因为即使是将元素进行隐藏，它们其实还是在布局当中的，每个元素还拥有着自己的宽、高、背景等等属性，解析布局的时候也会将这些隐藏的元素一一解析出来。</p>
<p>那么我们如何才能让这些不常用的元素仅在需要时才去加载呢？Android为此提供了一种非常轻量级的控件，ViewStub。ViewStub虽说也是View的一种，但是它没有大小，没有绘制功能，也不参与布局，资源消耗非常低，将它放置在布局当中基本可以认为是完全不会影响性能的。</p>
<p>(2) 使用RelativeLayout代替LinearLayout<br>大约在Android4.0之前，新建工程的默认main.xml中顶节点是LinearLayout，而在之后已经改为RelativeLayout，因为RelativeLayout性能更优，且可以简单实现LinearLayout嵌套才能实现的布局。<br>使用RelativeLayout减少视图树的层级，防止过度绘制</p>
<p>某网友关键评论如下：<br>通过测试，相同层级的情况下， RelativeLayout 和LinearLayour之间的效率没<br>有太大差异，但是对于同样的一个布局效果，用RelativeLayout产生的View层级嵌套比<br>LinearLayout的层级要少一些，我们知道，层级嵌套越深，资源消耗是越大的，测量和布局<br>所花费的时间是越长的。所以，相对来说RelativeLayout的效率比LinearLayout要高一些。<br>Google更加推荐咱们在写布局时，使用RelativeLayout，当我们在创建一个新工程时，<br>main_activity.xml的最外层布局是RelativeLayout。</p>
<p><a href="http://www.jianshu.com/p/8a7d059da746" target="_blank" rel="external">Android中RelativeLayout和LinearLayout性能分析</a><br><a href="http://blog.csdn.net/wangjia55/article/details/37772763" target="_blank" rel="external">【Android性能优化】尽可能用RelativeLayout来代替多层嵌套的LinearLayout</a><br><a href="https://www.zhihu.com/question/36762882" target="_blank" rel="external">安卓FrameLayout LinearLayout RelativeLayout 效率高低？</a></p>
<h2 id="减少不必要的infalte"><a href="#减少不必要的infalte" class="headerlink" title="减少不必要的infalte"></a>减少不必要的infalte</h2><p>(1) 对于inflate的布局可以直接缓存，用全部变量代替局部变量，避免下次需再次inflate<br>如上面ViewStub示例中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</div><div class="line">  networkErrorView.setVisibility(View.VISIBLE);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</div><div class="line">  networkErrorView.setVisibility(View.VISIBLE);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2) ListView提供了item缓存，adapter getView的标准写法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">  ImageView appIcon;</div><div class="line">  TextView  appName;</div><div class="line">  TextView  appInfo;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">  ViewHolder holder;</div><div class="line">  <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">    convertView = inflater.inflate(R.layout.list_item, <span class="keyword">null</span>);</div><div class="line">    holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">    ……</div><div class="line">    convertView.setTag(holder);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    holder = (ViewHolder)convertView.getTag();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于ListView缓存原理可见Android ListView缓存机制。</p>
<h2 id="用SurfaceView或TextureView代替普通View"><a href="#用SurfaceView或TextureView代替普通View" class="headerlink" title="用SurfaceView或TextureView代替普通View"></a>用SurfaceView或TextureView代替普通View</h2><p>SurfaceView或TextureView可以通过将绘图操作移动到另一个单独线程上提高性能。<br>普通View的绘制过程都是在主线程(UI线程)中完成，如果某些绘图操作影响性能就不好优化了，这时我们可以考虑使用SurfaceView和TextureView，他们的绘图操作发生在UI线程之外的另一个线程上。<br>因为SurfaceView在常规视图系统之外，所以无法像常规试图一样移动、缩放或旋转一个SurfaceView。<br>TextureView是Android4.0引入的，除了与SurfaceView一样在单独线程绘制外，还可以像常规视图一样被改变。</p>
<h2 id="尽量为所有分辨率创建资源"><a href="#尽量为所有分辨率创建资源" class="headerlink" title="尽量为所有分辨率创建资源"></a>尽量为所有分辨率创建资源</h2><p>减少不必要的硬件缩放，这会降低UI的绘制速度，可借助Android asset studio</p>
<hr>
<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><hr>
<p>处理每一个细节</p>
<p>时间和空间的处理</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42318689" target="_blank" rel="external">Android最佳性能实践(三)——高性能编码优化</a></p>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>减少变量创建的次数<br>去掉大量的临时变量和部分全局变量<br>但当局部变量不需要时，不需明显的设为null，因为一个方法执行完毕时，这些引用会自动被清理。</p>
<p>我们所要遵守的一个基本原则就是尽可能地少创建临时对象，越少的对象意味着越少的GC操作，同时也就意味着越好的程序性能和用户体验。</p>
<p>避免创建对象的场景：<br>1.在没有特殊原因的情况下，尽量使用基本数据类来代替封装数据类型，int比Integer要更加高效，其它数据类型也是一样。<br>2.正如前面所说，基本数据类型要优于对象数据类型，类似地，基本数据类型的数组也要优于对象数据类型的数组。另外，两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的两个数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效得多。</p>
<h3 id="StringBuff替代String"><a href="#StringBuff替代String" class="headerlink" title="StringBuff替代String"></a>StringBuff替代String</h3><p>尽量采用StringBuff而不是String，String对象在进程处理时是新建一个对象。</p>
<p>场景：<br>1.如果我们有一个需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。</p>
<p>2.当一个方法的返回值是String的时候，通常可以去判断一下这个String的作用是什么，如果我们明确地知道调用方会将这个返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。</p>
<h2 id="对象不用了把对象数据成员设为null或者从集合中移除该对象。"><a href="#对象不用了把对象数据成员设为null或者从集合中移除该对象。" class="headerlink" title="对象不用了把对象数据成员设为null或者从集合中移除该对象。"></a>对象不用了把对象数据成员设为null或者从集合中移除该对象。</h2><p>有一些变量的引用没有被释放，导致资源不能被垃圾回收掉</p>
<p>还有一个特殊场景要注意<br>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">100</span>);     </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;      </div><div class="line">    Object o = <span class="keyword">new</span> Object();      　</div><div class="line">    v.add(o);      　</div><div class="line">    o = <span class="keyword">null</span>;      </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 循环执行完之后，此时，所有的Object对象都没有被释放，因为变量v引用这些对象（还在集合里）。</span></div></pre></td></tr></table></figure></p>
<h2 id="优化for循环-使用增强for循环"><a href="#优化for循环-使用增强for循环" class="headerlink" title="优化for循环(使用增强for循环)"></a>优化for循环(使用增强for循环)</h2><p>增强型for循环（也被称为for-each循环）可以用于去遍历实现Iterable接口的集合以及数组，这是jdk 1.5中新增的一种循环模式。当然除了这种新增的循环模式之外，我们仍然还可以使用原有的普通循环模式，只不过它们之间是有效率区别的，我们来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> mCount;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">Counter[] mArray = ...  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;  </div><div class="line">        sum += mArray[i].mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    Counter[] localArray = mArray;  </div><div class="line">    <span class="keyword">int</span> len = localArray.length;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;  </div><div class="line">        sum += localArray[i].mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (Counter a : mArray) &#123;  </div><div class="line">        sum += a.mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，上述代码当中我们使用了三种不同的循环方式来对mArray中的所有元素进行求和。其中zero()方法是最慢的一种，因为它是把mArray.length写在循环当中的，也就是说每循环一次都需要重新计算一次mArray的长度。而one()方法则相对快得多，因为它使用了一个局部变量len来记录数组的长度，这样就省去了每次循环时字段搜寻的时间。two()方法在没有JIT（Just In Time Compiler）的设备上是运行最快的，而在有JIT的设备上运行效率和one()方法不相上下，唯一需要注意的是这种写法需要JDK 1.5之后才支持。</p>
<p>但是这里要跟大家提一个特殊情况，对于ArrayList这种集合，自己手写的循环要比增强型for循环更快，而其他的集合就没有这种情况。因此，对于我们来说，默认情况下可以都使用增强型for循环，而遍历ArrayList时就还是使用传统的循环方式吧。</p>
<h2 id="巧用静态方法"><a href="#巧用静态方法" class="headerlink" title="巧用静态方法"></a>巧用静态方法</h2><p>如果你并不需要访问一个对象中的某些字段，只是想调用它的某个方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，这会让调用的速度提升15%-20%，同时也不用为了调用这个方法而去专门创建对象了，这样还满足了上面的一条原则。另外这也是一种好的编程习惯，因为我们可以放心地调用静态方法，而不用担心调用这个方法后是否会改变对象的状态（静态方法内无法访问非静态字段）。</p>
<h2 id="对常量使用static-final修饰符"><a href="#对常量使用static-final修饰符" class="headerlink" title="对常量使用static final修饰符"></a>对常量使用static final修饰符</h2><p>我们先来看一下在一个类的最顶部定义如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;  </div><div class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>编译器会为上述代码生成一个初始化方法，称为<clinit>方法，该方法会在定义类第一次被使用的时候调用。然后这个方法会将42的值赋值到intVal当中，并从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式来去访问具体的值了。</clinit></p>
<p>但是我们还可以通过final关键字来对上述代码进行优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;  </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>经过这样修改之后，定义类就不再需要一个<clinit>方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal时会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。</clinit></p>
<p>另外需要大家注意的是，这种优化方式只对基本数据类型以及String类型的常量有效，对于其它数据类型的常量是无效的。不过，对于任何常量都是用static final的关键字来进行声明仍然是一种非常好的习惯。</p>
<h2 id="多使用系统封装好的API"><a href="#多使用系统封装好的API" class="headerlink" title="多使用系统封装好的API"></a>多使用系统封装好的API</h2><p>Java语言当中其实给我们提供了非常丰富的API接口，我们在编写程序时如果可以使用系统提供的API就应该尽量使用，系统提供的API完成不了我们需要的功能时才应该自己去写，因为使用系统的API在很多时候比我们自己写的代码要快得多，它们的很多功能都是通过底层的汇编模式执行的。</p>
<p>比如说String类当中提供的好多API都是拥有极高的效率的，像indexOf()方法和一些其它相关的API，虽说我们通过自己编写算法也能够完成同样的功能，但是效率方面会和这些方法差的比较远。这里举个例子，如果我们要实现一个数组拷贝的功能，使用循环的方式来对数组中的每一个元素一一进行赋值当然是可行的，但是如果我们直接使用系统中提供的System.arraycopy()方法将会让执行效率快9倍以上。</p>
<h2 id="避免在内部调用Getters-Setters方法"><a href="#避免在内部调用Getters-Setters方法" class="headerlink" title="避免在内部调用Getters/Setters方法"></a>避免在内部调用Getters/Setters方法</h2><p>我们平时写代码时都被告知，一定要使用面向对象的思维去写代码，而面向对象的三大特性我们都知道，封装、多态和继承。其中封装的基本思想就是不要把类内部的字段暴漏给外部，而是提供特定的方法来允许外部操作相应类的内部字段，从而在Java语言当中就出现了Getters/Setters这种封装技巧。</p>
<p>然而在Android上这个技巧就不再是那么的受推崇了，因为字段搜寻要比方法调用效率高得多，我们直接访问某个字段可能要比通过getters方法来去访问这个字段快3到7倍。不过我们肯定不能仅仅因为效率的原因就将封装这个技巧给抛弃了，编写代码还是要按照面向对象思维的，但是我们可以在能优化的地方进行优化，比如说避免在内部调用getters/setters方法。</p>
<p>那什么叫做在内部调用getters/setters方法呢？这里我举一个非常简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one = <span class="number">1</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two = <span class="number">2</span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOne</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> one;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTwo</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> two;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> getOne() + getTwo();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上面是一个Calculate类，这个类的功能非常简单，先将one和two这两个字段进行了封装，然后提供了getOne()方法获取one字段的值，提供了getTwo()方法获取two字段的值，还提供了一个getSum()方法用于获取总和的值。</p>
<p>这里我们注意到，getSum()方法当中的算法就是将one和two的值相加进行返回，但是它获取one和two的值的方式也是通过getters方法进行获取的，其实这是一种完全没有必要的方式，因为getSum()方法本身就是Calculate类内部的方法，它是可以直接访问到Calculate类中的封装字段的，因此这种写法在Android上是不推崇的，我们可以进行如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one = <span class="number">1</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two = <span class="number">2</span>;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> one + two;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改成这种写法之后，我们就避免了在内部调用getters/setters方法，而对于外部而言Calculate类仍然是具有很好的封装性的。</p>
<h2 id="简化代码规范"><a href="#简化代码规范" class="headerlink" title="简化代码规范"></a>简化代码规范</h2><p>这是一个不可以忽略的问题。与那些连基本的Android开发编码规范都不遵守的人一起工作是很困难的。</p>
<p>这不是什么困难的事情，要不了几个小时的时间就可以学习基本的Java 和 Android 编码规范。而且这不是一次性买卖，作为一个开发者终生受益。</p>
<p>提示：这里 有一个开始学习标准编码规范的极佳资源。<br><a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md" target="_blank" rel="external">https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md</a></p>
<hr>
<h2 id="重构App"><a href="#重构App" class="headerlink" title="重构App"></a>重构App</h2><hr>
<p>就是重新架构app</p>
<p>大多数时候我们都笼统的把代码放到Activity和Fragment中（在这个问题上你也可以责怪我），导致它们变成庞大的“上帝对象”，这几乎不可维护和测试。</p>
<p>为app采用一个好的架构是非常重要的，比如MVP, MVVM, Redux等。考虑把app的业务逻辑，视图交互，数据交换分为不同的层，让它们更易管理和测试。</p>
<p>提示：看一看谷歌的 这些 模版可以让你在架构app的时候更容易。<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">https://github.com/googlesamples/android-architecture</a></p>
<hr>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><hr>
<p>相关文章收集：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a></p>
<p>学习之前要知道这2个至关重要的概念，所有的内存优化方式都是避免下面这俩种情况发生.</p>
<h2 id="内存泄露-amp-内存溢出"><a href="#内存泄露-amp-内存溢出" class="headerlink" title="内存泄露&amp;内存溢出"></a>内存泄露&amp;内存溢出</h2><h3 id="内存泄露-a-memory-leak"><a href="#内存泄露-a-memory-leak" class="headerlink" title="内存泄露(a memory leak)"></a>内存泄露(a memory leak)</h3><p>定义：<br>内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕由于错误或漏洞造成的内存占用过多没释放，或占用内存后无法释放</p>
<p>简单理解：<br>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，<br>结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），<br>而系统也不能再次将它分配给需要的程序。</p>
<p>详细的说：<br>就说是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，<br>但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。</p>
<p>形象比喻：<br>操作系统可提供给所有进程的存储空间正在被某个进程榨干”，<br>最终结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。<br>所以“内存泄漏”是从操作系统的角度来看的。<br>这里的存储空间并不是指物理内存，而是指虚拟内存大小，<br>这个虚拟内存大小取决于磁盘交换区设定的大小。<br>由程序申请的一块内存，如果没有任何一个指针指向它，那么这块内存就泄漏了。</p>
<p>Java中有内存泄露吗？为什么？<br>有！<br>所谓内存泄露就是对象再也不用了程序一直运行还一直占用内存空间没有被释放掉，<br>程序还在一直运行，导致浪费内存，最后导致内存溢出，就叫内存泄露！</p>
<p>Android系统中GC什么情况下会出现内存泄露呢？<br>有Java带垃圾回收的机制,为什么还会内存泄露呢?<br>导致内存泄漏主要的原因是，先前申请了内存空间而忘记了释放。<br>如果程序中存在对无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器GC验证这些对象是否不再需要。<br>如果存在对象的引用，这个对象就被定义为”有效的活动”，同时不会被释放。<br>要确定对象所占内存将被回收，我们就要务必确认该对象不再会被使用。<br>安卓的内存泄露不明显：如电池不扛用没电了关机重启下就恢复了，因为内存不足在后台，被系统给回收掉了重启一下<br>也因为安卓应用内存泄露不明显，很多公司不去处理这个问题</p>
<h3 id="内存溢出-OOM-Out-of-Memory"><a href="#内存溢出-OOM-Out-of-Memory" class="headerlink" title="内存溢出(OOM:Out of Memory)"></a>内存溢出(OOM:Out of Memory)</h3><p>形象比喻：<br>一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！</p>
<p>通俗理解：<br>就是内存不够了<br>你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出</p>
<p>详细理解：<br>内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，即使已有的数据超过了其获得到的内存所能存储的范围，所以出现out of memory；<br>比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>比如用一个字节存放1000这个数字也属于内存溢出</p>
<p>通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，此时软件或游戏就运行不了，系统会提示内存溢出，<br>有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件或游戏一段时间。</p>
<p>安卓里出现OOM只有2种可能：<br>Bitmap<br>线程</p>
<h2 id="引用没释放造成的内存泄露"><a href="#引用没释放造成的内存泄露" class="headerlink" title="引用没释放造成的内存泄露"></a>引用没释放造成的内存泄露</h2><h3 id="Handler泄露"><a href="#Handler泄露" class="headerlink" title="Handler泄露"></a>Handler泄露</h3><p>注意：<br>避免使用非静态内部类</p>
<p>解决方案：<br>1.使用显形的引用<br>1.1.静态内部类<br>1.2.放在外部类(单独的类文件)</p>
<p>2.使用弱引用 WeakReference<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * Handler：静态内部类的方式避免内存泄漏</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_2 = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_3 = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mHandler.sendMessageDelayed(Message.obtain(), <span class="number">60000</span>);</div><div class="line">        finish();<span class="comment">// just finish this activity</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;HandlerActivity2&gt; mActivity;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</div><div class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            System.out.println(msg);</div><div class="line">            <span class="keyword">if</span> (mActivity.get() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mActivity.get().todo();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span> </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>还没完，上面这样就可以了吗？No</p>
<p>3.Activity onStop或者onDestroy,取消掉该Handler对象的Message和Runnable。 通过查看Handler的API，它有几个方法：<br>removeCallbacks(Runnable r)和removeMessages(int what)等。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一切都是为了不要让mHandler拖泥带水</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    mHandler.removeMessages(MESSAGE_1);</div><div class="line">    mHandler.removeMessages(MESSAGE_2);</div><div class="line">    mHandler.removeMessages(MESSAGE_3);</div><div class="line">    <span class="comment">// ... ...</span></div><div class="line">    mHandler.removeCallbacks(mRunnable);</div><div class="line">    <span class="comment">// ... ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果上面觉的麻烦，也可以如下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//  If null, all callbacks and messages will be removed.</span></div><div class="line">    mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/" target="_blank" rel="external">Android中Handler引起的内存泄露</a><br><a href="http://www.open-open.com/lib/view/open1455981510995.html" target="_blank" rel="external">Android内存泄露之Handler</a></p>
<h3 id="Context泄漏"><a href="#Context泄漏" class="headerlink" title="Context泄漏"></a>Context泄漏</h3><p>长期持有(Activity)Context导致的泄漏</p>
<p>不要保留对context—-activity长时间的引用，对activity的引用，一定要确保拥有和activity一样的生命周期</p>
<p>这是一个很隐晦的OutOfMemoryError的情况。先看一个Android官网提供的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;  </div><div class="line"></div><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);  </div><div class="line">  </div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);  </div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;  </div><div class="line">      sBackground = getDrawable(R.drawable.large_bitmap);  </div><div class="line">    &#125;  </div><div class="line">    label.setBackgroundDrawable(sBackground);  </div><div class="line">  </div><div class="line">    setContentView(label);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码效率很快，但同时又是极其错误的；<br>在第一次屏幕方向切换时它泄露了一开始创建的Activity。当一个Drawable附加到一个 View上时，<br>View会将其作为一个callback设定到Drawable上。上述的代码片段，意味着Drawable拥有一个TextView的引用，<br>而TextView又拥有Activity（Context类型）的引用，换句话说，Drawable拥有了更多的对象引用。即使Activity被 销毁，内存仍然不会被释放。<br>另外，对Context的引用超过它本身的生命周期，也会导致Context泄漏。所以尽量使用Application这种Context类型。<br>这种Context拥有和应用程序一样长的生命周期，并且不依赖Activity的生命周期。如果你打算保存一个长时间的对象，<br>并且其需要一个 Context，记得使用Application对象。你可以通过调用Context.getApplicationContext()或 Activity.getApplication()轻松得到Application对象。<br>最近遇到一种情况引起了Context泄漏，就是在Activity销毁时，里面有其他线程没有停。 </p>
<p>总结一下避免Context泄漏应该注意的问题：<br>1.使用Application这种Context类型。<br>2.注意对Context的引用不要超过它本身的生命周期。<br>3.慎重的使用“static”关键字。<br>4.Context里如果有线程，一定要在onDestroy()里及时停掉。 </p>
<h3 id="Listener泄露"><a href="#Listener泄露" class="headerlink" title="Listener泄露"></a>Listener泄露</h3><p>下面各类监听器注册后，没有在对应的位置写取消（反注册）的代码：<br>广播接受者(BroadcastReceiver)<br>观察者(Observer)<br>传感器(Sensor)</p>
<h4 id="广播接受者"><a href="#广播接受者" class="headerlink" title="广播接受者"></a>广播接受者</h4><p>广播接收者（BroadcastReceiver）经常在应用中用到，可以在多线程任务完成后发送广播通知UI更新，也可以接收系统广播实现一些功能 </p>
<p>泄漏关键就是调用registerReceiver()后未调用unregisterReceiver(). </p>
<p>流程如下：<br>可以通过代码的方式注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntentFilter postFilter = <span class="keyword">new</span> IntentFilter(); </div><div class="line">postFilter.addAction(getPackageName() + <span class="string">".background.job"</span>); </div><div class="line"><span class="keyword">this</span>.registerReceiver(receiver, postFilter);</div></pre></td></tr></table></figure></p>
<p>当我们Activity中使用了registerReceiver()方法注册了BroadcastReceiver，<br>一定要在Activity的生命周期内调用unregisterReceiver()方法取消注册<br>也就是说registerReceiver()和unregisterReceiver()方法一定要成对出现，通常我们可以重写Activity的onDestory()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">this</span>.unregisterReceiver(receiver);  </div><div class="line">      <span class="keyword">super</span>.onDestroy();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="NotificationManager泄漏"><a href="#NotificationManager泄漏" class="headerlink" title="NotificationManager泄漏"></a>NotificationManager泄漏</h3><p>android 直到4.1.3 之前的版本，通知栏API 都存在内存泄露BUG，反复调用 NotificationManager.notify 方法会造成手机死机重启。<br>绕过此BUG 的方法是每次调用notify 时都必须 new 一个新的RemoteViews。</p>
<h3 id="new-Message的泄露"><a href="#new-Message的泄露" class="headerlink" title="new Message的泄露"></a>new Message的泄露</h3><p>尽量采用Message.obtain();</p>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>小心静态变量引用了activity<br>代码有静态变量引用了activity，随着代码的运行导致内存越来越大导致内存泄漏</p>
<p>要谨慎的对象：<br>Bitmap<br>Animation </p>
<p>原因：<br>因为有静态关键字，字节码被装载进来了，static对应的空间就被申请进来了<br>即使MainActivity被回收掉了，如静态bitmap空间还被占用着</p>
<p>解决方案：<br>就是把静态的引用去掉</p>
<p>相关文章：<br><a href="http://blog.csdn.net/wuchuy/article/details/51242738" target="_blank" rel="external">android中不小心使用静态变量会导致内存泄露</a></p>
<h3 id="非static的内部类"><a href="#非static的内部类" class="headerlink" title="非static的内部类"></a>非static的内部类</h3><p>如果你不想控制内部类的生命周期，应该避免在activity中使用非静态的内部类，而应该是静态的内部类</p>
<p>典型案例：<br>Handler</p>
<h3 id="集合容器对象没有清理造成的内存泄露"><a href="#集合容器对象没有清理造成的内存泄露" class="headerlink" title="集合容器对象没有清理造成的内存泄露"></a>集合容器对象没有清理造成的内存泄露</h3><p>记得不用了就赋予null</p>
<h2 id="资源对象没有关闭造成的内存泄露"><a href="#资源对象没有关闭造成的内存泄露" class="headerlink" title="资源对象没有关闭造成的内存泄露"></a>资源对象没有关闭造成的内存泄露</h2><h3 id="数据库的cursor-未及时关闭"><a href="#数据库的cursor-未及时关闭" class="headerlink" title="数据库的cursor 未及时关闭"></a>数据库的cursor 未及时关闭</h3><p>操作Sqlite数据库时，Cursor是数据库表中每一行的集合，Cursor提供了很多方法，可以很方便的读取数据库中的值，<br>可以根据索引，列名等获取数据库中的值，通过游标的方式可以调用moveToNext()移到下一行<br>当我们操作完数据库后，一定要记得调用Cursor对象的close()来关闭游标，释放资源。 </p>
<h3 id="网络连接Socket、IO流没有及时关闭（InputStream-OutputStream），File"><a href="#网络连接Socket、IO流没有及时关闭（InputStream-OutputStream），File" class="headerlink" title="网络连接Socket、IO流没有及时关闭（InputStream/OutputStream），File"></a>网络连接Socket、IO流没有及时关闭（InputStream/OutputStream），File</h3><p>这个就不多说了，我们操作完输入输出流都要关闭流 </p>
<h2 id="资源对象没有回收造成的内存泄漏"><a href="#资源对象没有回收造成的内存泄漏" class="headerlink" title="资源对象没有回收造成的内存泄漏"></a>资源对象没有回收造成的内存泄漏</h2><p>1.Bitmap recycle</p>
<p>2.TypedArray recycle</p>
<h2 id="当界面不可见时释放内存-onStop-onTrimMemory"><a href="#当界面不可见时释放内存-onStop-onTrimMemory" class="headerlink" title="当界面不可见时释放内存(onStop,onTrimMemory)"></a>当界面不可见时释放内存(onStop,onTrimMemory)</h2><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h3><p>取消网络连接<br>注销广播接收器</p>
<h3 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a>onTrimMemory</h3><p>在适当的生命周期中创建释放对象<br>onTrimMemory回调：应用响应此回调释放非必须内存，如图片的内存占用</p>
<p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。</p>
<p>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onTrimMemory(level);  </div><div class="line">    <span class="keyword">switch</span> (level) &#123;  </div><div class="line">    <span class="keyword">case</span> TRIM_MEMORY_UI_HIDDEN:  </div><div class="line">        <span class="comment">// 进行资源释放操作  </span></div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>
<h2 id="当内存紧张时释放内存"><a href="#当内存紧张时释放内存" class="headerlink" title="当内存紧张时释放内存"></a>当内存紧张时释放内存</h2><p>详情查看里面的部分段落<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a></p>
<h2 id="知晓内存的开支情况"><a href="#知晓内存的开支情况" class="headerlink" title="知晓内存的开支情况"></a>知晓内存的开支情况</h2><p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：</p>
<p>任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。<br>任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。<br>在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</p>
<h2 id="缓存重复利用的优化"><a href="#缓存重复利用的优化" class="headerlink" title="缓存重复利用的优化"></a>缓存重复利用的优化</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>Message msg1 = handler1.obtainMessage();</p>
<h2 id="View控件优化"><a href="#View控件优化" class="headerlink" title="View控件优化"></a>View控件优化</h2><h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><h4 id="构造adapter没有使用缓存contentview。"><a href="#构造adapter没有使用缓存contentview。" class="headerlink" title="构造adapter没有使用缓存contentview。"></a>构造adapter没有使用缓存contentview。</h4><p>这个最常用的缓存方法如果不小心写错了造成的内存损失也相当巨大，数据量大手机内存小的情况下只需疯狂滑动几下app即可崩溃.</p>
<p>标准模板也留下一个：<br>在继承BaseAdapter时会让我们重写getView(int position, View   convertView, ViewGroup parent)方法，<br>第二个参数convertView就是我们要用到的重用的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;  </div><div class="line">    ViewHolder vHolder = <span class="keyword">null</span>;  </div><div class="line">    <span class="comment">//如果convertView对象为空则创建新对象，不为空则复用  </span></div><div class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;  </div><div class="line">        convertView = inflater.inflate(..., <span class="keyword">null</span>);  </div><div class="line">        <span class="comment">// 创建 ViewHodler 对象  </span></div><div class="line">        vHolder = <span class="keyword">new</span> ViewHolder();  </div><div class="line">        vHolder.img= (ImageView) convertView.findViewById(...);  </div><div class="line">        vHolder.tv= (TextView) convertView.findViewById(...);  </div><div class="line">        <span class="comment">// 将ViewHodler保存到Tag中  </span></div><div class="line">        convertView.setTag(vHolder);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                       <span class="comment">//当convertView不为空时，通过getTag()得到View  </span></div><div class="line">        vHolder = (ViewHolder) convertView.getTag();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 给对象赋值，修改显示的值  </span></div><div class="line">    vHolder.img.setImageBitmap(...);  </div><div class="line">    vHolder.tv.setText(...);  </div><div class="line">    <span class="keyword">return</span> convertView;  </div><div class="line">&#125;  </div><div class="line">       <span class="comment">//将显示的View 包装成类  </span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;  </div><div class="line">    TextView tv;  </div><div class="line">    ImageView img;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里只讲使用方法，具体性能测试文章请见：<br><a href="http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html" target="_blank" rel="external">ListView中getView的原理＋如何在ListView中放置多个item</a><br><a href="http://shinfocom.iteye.com/blog/1231511" target="_blank" rel="external">Android开发之ListView适配器（Adapter）优化</a></p>
<h4 id="Listview判断不滑动才加载数据"><a href="#Listview判断不滑动才加载数据" class="headerlink" title="Listview判断不滑动才加载数据"></a>Listview判断不滑动才加载数据</h4><p><a href="http://blog.csdn.net/yy1300326388/article/details/45153813" target="_blank" rel="external">Listview滑动时不加载数据，停下来时加载数据，让App更优</a></p>
<h3 id="GridView优化"><a href="#GridView优化" class="headerlink" title="GridView优化"></a>GridView优化</h3><h4 id="Gridview的滥用"><a href="#Gridview的滥用" class="headerlink" title="Gridview的滥用"></a>Gridview的滥用</h4><p>Gridview和Listview的实现方式一样，GridVIew的view不是及时创建，而全部保存在内存中，比如Gridview有100项，虽然我们只能看10项，但是其实整个100项都是在内存中</p>
<h3 id="Webview优化"><a href="#Webview优化" class="headerlink" title="Webview优化"></a>Webview优化</h3><p>Webview也能泄漏，如webview对象没有销毁，所以要注意了</p>
<h2 id="Service优化"><a href="#Service优化" class="headerlink" title="Service优化"></a>Service优化</h2><h3 id="节制使用Service，推荐使用IntentService"><a href="#节制使用Service，推荐使用IntentService" class="headerlink" title="节制使用Service，推荐使用IntentService"></a>节制使用Service，推荐使用IntentService</h3><p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>
<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。关于IntentService更加详细的用法讲解，可以参考《第一行代码——Android》的9.5.2节。</p>
<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载（我个人就会这么做）。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>参考书籍：<br>    《第一行代码——Android》的9.5.2节。</p>
<h2 id="Bitmap图片优化"><a href="#Bitmap图片优化" class="headerlink" title="Bitmap图片优化"></a>Bitmap图片优化</h2><p>Bitmap是安卓里最胖最爱吃内存的对象<br>Android发生OOM百分之99都是Bitmap影响的<br>所以要避免在Bitmap这个大胖子上浪费内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">存储图片为什么为出现OOM异常？</div><div class="line">    由于图片在内存中是以shot数组的形式存储，并且需要连续的内存空间，</div><div class="line">    当内存中没有连续的内存大小，即使内存充足也会出现OOM异常.</div><div class="line"></div><div class="line">    Android最消耗内存的就是连续占用空间的，耗内存大户就是bitmap.</div><div class="line">    </div><div class="line">    数组也是，但是没见过见过数组长度为100一点事都没有，</div><div class="line">    得1000到10000才能有连续空间的感觉，也没有人就故意去建这么长的数据</div><div class="line"></div><div class="line">详细说下为什么BitMap占内存？</div><div class="line">    BitMap就是二维数组，底层存的是short类型的数组</div><div class="line">    数组有个特点：需要有连续的内存空间</div><div class="line">    比如你的应用还有空闲的16M的内存空间</div><div class="line">    但是这16M内存空间被各种应用各种占领不大大小的空间（16M空间被各种应用瓜分了）</div><div class="line">    每个空白区域找不到连续4M的内存空间</div><div class="line">    那么就装不下去，这个bitMap就内存溢出了</div><div class="line">    必须得连续，不连续就显示不出来，这是它的特点</div><div class="line"></div><div class="line">    如有的应用虽然占了10几M，但是也没内存溢出，</div><div class="line">    就是因为这个不需要连续的内存空间，只需要零散的空间，有空间就能钻进去</div><div class="line"></div><div class="line">注意大图片分辨率：</div><div class="line">    当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。</div><div class="line">    在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。</div><div class="line">    需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，</div><div class="line">    可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，</div><div class="line">    比如有张图片是1500*1000像素，使用的ARGB_8888颜色类型，</div><div class="line">    那么每个像素点就会占用4个字节，总内存就是1500*1000*4字节，也就是5.7M，</div><div class="line">    这个数据看起来就比较恐怖了。</div><div class="line"></div><div class="line">图片优化方案：</div><div class="line">    图片缩略图使用</div><div class="line">    图片大小压缩</div><div class="line">    Bitmap在onTrimMemory释放资源</div><div class="line">    Bitmap不要定义成静态成员变量</div><div class="line">    Bitmap的recycle和isRecycled方法的灵活使用</div></pre></td></tr></table></figure>
<h3 id="图片缩略图使用"><a href="#图片缩略图使用" class="headerlink" title="图片缩略图使用"></a>图片缩略图使用</h3><p> 直接使用ImageView显示bitmap会占用较多资源，特别是图片较大的时候，可能导致崩溃。<br>使用BitmapFactory.Options设置inSampleSize, 这样做可以减少对系统资源的要求。<br>属性值inSampleSize表示缩略图大小为原始图片大小的几分之一，即如果这个值为2，则取出的缩略图的宽和高都是原始图片的1/2，图片大小就为原始大小的1/4。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options bitmapFactoryOptions = <span class="keyword">new</span> BitmapFactory.Options();  </div><div class="line">bitmapFactoryOptions.inJustDecodeBounds = <span class="keyword">true</span>;  </div><div class="line">bitmapFactoryOptions.inSampleSize = <span class="number">2</span>;  </div><div class="line"><span class="comment">// 这里一定要将其设置回false，因为之前我们将其设置成了true  </span></div><div class="line"><span class="comment">// 设置inJustDecodeBounds为true后，decodeFile并不分配空间，即，BitmapFactory解码出来的Bitmap为Null,但可计算出原始图片的长度和宽度  </span></div><div class="line">options.inJustDecodeBounds = <span class="keyword">false</span>; </div><div class="line">Bitmap bmp = BitmapFactory.decodeFile(sourceBitmap, options);</div></pre></td></tr></table></figure></p>
<h3 id="Bitmap的recycle和isRecycled方法的灵活使用"><a href="#Bitmap的recycle和isRecycled方法的灵活使用" class="headerlink" title="Bitmap的recycle和isRecycled方法的灵活使用"></a>Bitmap的recycle和isRecycled方法的灵活使用</h3><p>BItmap对象，使用完成后没有调用recycle（）方法，告诉GC优先回收<br>图片处理不好是造成内存溢出的又一个头号原因，（在我们的产品中也有体现)，<br>当我们处理完图片之后可以通过调用recycle()方法来回收图片对象 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!bitmap.isRecycled())  &#123;  </div><div class="line">    bitmap.recycle()  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>听说自Android3.0之后，由于Bitmap被放置到了堆中，其内存由GC管理，就不需要进行释放了</p>
<p>参考文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external">Android高效加载大图、多图解决方案，有效避免程序OOM</a></p>
<h2 id="集合容器优化"><a href="#集合容器优化" class="headerlink" title="集合容器优化"></a>集合容器优化</h2><h3 id="SparseArray系列替代Hash系列集合"><a href="#SparseArray系列替代Hash系列集合" class="headerlink" title="SparseArray系列替代Hash系列集合"></a>SparseArray系列替代Hash系列集合</h3><p>Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，以及LongSparseArray等，使用这些API可以让我们的程序更加高效。传统Java API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>
<h2 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h2><h3 id="Thread内存泄露"><a href="#Thread内存泄露" class="headerlink" title="Thread内存泄露"></a>Thread内存泄露</h3><p>线程也是造成内存泄露的一个重要的源头。<br>线程产生内存泄露的主要原因在于线程生命周期的不可控。</p>
<p>看一下下面是否存在问题,是否您以前也是这样用的呢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * <span class="doctag">@version</span> 1.0.0</div><div class="line"> * <span class="doctag">@author</span> Abay Zhuang &lt;br/&gt;</div><div class="line"> *         Create at 2014-7-17</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">new</span> MyThread().start();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.run();</div><div class="line">            dosomthing();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dosomthing</span><span class="params">()</span></span>&#123;</div><div class="line">                                                                    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用线程池替代不断的new Thread</p>
<p>详情查看自我统计的文章的线程池章节：<br><a href="http://www.hengxing.me/2017/09/06/it/1.Java/Multithreading/" target="_blank" rel="external">Java多线程并发异步的总结</a></p>
<h3 id="Threadlocal内存泄漏"><a href="#Threadlocal内存泄漏" class="headerlink" title="Threadlocal内存泄漏"></a>Threadlocal内存泄漏</h3><p>threadlocal使用不当<br>如果我们粗暴的把ThreadLocal设置null，而不调用renmove方法或者set（null）。<br>那么就可能造成Threadlocal绑定的对象长期也不能够回收，因而产生泄露</p>
<h3 id="HandlerThread-没有quit"><a href="#HandlerThread-没有quit" class="headerlink" title="HandlerThread 没有quit"></a>HandlerThread 没有quit</h3><h2 id="多进程优化"><a href="#多进程优化" class="headerlink" title="多进程优化"></a>多进程优化</h2><p>这个技巧其实并不是非常建议使用，但它确实是一种可以帮助我们节省和管理内存的高级技巧。如果你要使用它的话一定要谨慎使用，因为绝大多数的应用程序都不应该在多个进程当中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于那些需要在后台去完成一项独立的任务，和前台的功能是可以完全区分开的场景。</p>
<p>这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。</p>
<p>想要实现多进程的功能也非常简单，只需要在AndroidManifest文件的应用程序组件中声明一个android:process属性就可以了，比如说我们希望播放音乐的Service可以运行在一个单独的进程当中，就可以这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=<span class="string">".PlaybackService"</span>  </div><div class="line">         android:process=<span class="string">":background"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>这里指定的进程名是background，你也可以将它改成任意你喜欢的名字。需要注意的是，进程名的前面都应该加上一个冒号，表示该进程是一个当前应用程序的私有进程。</p>
<h2 id="谨慎使用抽象编程"><a href="#谨慎使用抽象编程" class="headerlink" title="谨慎使用抽象编程"></a>谨慎使用抽象编程</h2><p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>
<h2 id="不建议使用枚举"><a href="#不建议使用枚举" class="headerlink" title="不建议使用枚举"></a>不建议使用枚举</h2><p>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。</p>
<h2 id="尽量避免使用依赖注入框架"><a href="#尽量避免使用依赖注入框架" class="headerlink" title="尽量避免使用依赖注入框架"></a>尽量避免使用依赖注入框架</h2><p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidWay</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;   </div><div class="line">    TextView name;   </div><div class="line">    ImageView thumbnail;   </div><div class="line">    LocationManager loc;   </div><div class="line">    Drawable icon;   </div><div class="line">    String myName;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">        name      = (TextView) findViewById(R.id.name);   </div><div class="line">        thumbnail = (ImageView) findViewById(R.id.thumbnail);   </div><div class="line">        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE);   </div><div class="line">        icon      = getResources().getDrawable(R.drawable.icon);   </div><div class="line">        myName    = getString(R.string.app_name);   </div><div class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简化成这样的一种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ContentView</span>(R.layout.main)  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoboWay</span> <span class="keyword">extends</span> <span class="title">RoboActivity</span> </span>&#123;   </div><div class="line">    <span class="meta">@InjectView</span>(R.id.name)             TextView name;   </div><div class="line">    <span class="meta">@InjectView</span>(R.id.thumbnail)        ImageView thumbnail;   </div><div class="line">    <span class="meta">@InjectResource</span>(R.drawable.icon)   Drawable icon;   </div><div class="line">    <span class="meta">@InjectResource</span>(R.string.app_name) String myName;   </div><div class="line">    <span class="meta">@Inject</span>                            LocationManager loc;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </div><div class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>
<h2 id="使用ProGuard简化代码"><a href="#使用ProGuard简化代码" class="headerlink" title="使用ProGuard简化代码"></a>使用ProGuard简化代码</h2><p>ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。ProGuard会对我们的代码进行检索，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。</p>
<hr>
<h1 id="工具优化"><a href="#工具优化" class="headerlink" title="工具优化"></a>工具优化</h1><hr>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238633" target="_blank" rel="external">Android最佳性能实践(二)——分析内存的使用情况</a></p>
<h2 id="性能优化分析工具"><a href="#性能优化分析工具" class="headerlink" title="性能优化分析工具"></a>性能优化分析工具</h2><p>用途：性能分析优化监视/查看UI/调试Bug/检测内存泄露工具 </p>
<h3 id="手机-设置-开发者选项"><a href="#手机-设置-开发者选项" class="headerlink" title="手机/设置/开发者选项"></a>手机/设置/开发者选项</h3><p>1.查看UI过度绘制<br>手机 / 设置 / 开发者选项 / 显示布局边界（Show GPU Overdraw）<br><a href="http://jingyan.baidu.com/article/1e5468f97c4772484961b72a.html" target="_blank" rel="external">手机怎么设置调试GPU过度绘制</a></p>
<h3 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h3><p>减少不必要的层次：巧用Hierarchy Viewer<br>hierarchy viewer可以方便的查看Activity的布局，各个View的属性、measure、layout、draw的时间，如果耗时较多会用红色标记，否则显示绿色。<br>hierarchy viewer.bat位于<sdk>/tools/目录下</sdk></p>
<h3 id="ViewServer"><a href="#ViewServer" class="headerlink" title="ViewServer"></a>ViewServer</h3><p>下载地址：<br><a href="https://github.com/romainguy/ViewServer" target="_blank" rel="external">https://github.com/romainguy/ViewServer</a></p>
<p>相关文章：<br><a href="http://blog.csdn.net/wanglu198506/article/details/43106133" target="_blank" rel="external">使用ViewServer让Android真机可用HierarchyView视图检测工具</a></p>
<p>参考书籍：<br>Android群英传-10.1.5</p>
<h3 id="无线uiviewer"><a href="#无线uiviewer" class="headerlink" title="无线uiviewer"></a>无线uiviewer</h3><p>安卓UI集成调试必备利器！<br>在android手机端实现Hierarchyviewer里的uiautomatorviewer功能，查看UI布局、控件位置不再需要通过数据线连接到电脑查看，在手机上随时随地可以查看任意界面！<br>有了此工具，安卓测试人员可以底气十足的告诉开发人员，开发出来的界面控件位置、大小哪些是错的，哪些是对的！<br>有了此工具，安卓开发人员可以信心百倍的告诉测试人员，我开发出来的界面与UI标注图是一模一样的！不信你用“无线uiviewer”量一量！</p>
<p>PS：手机需要root</p>
<p>下载地址：<br><a href="http://download.csdn.net/download/duantihi/9448886" target="_blank" rel="external">http://download.csdn.net/download/duantihi/9448886</a></p>
<h3 id="开发助手"><a href="#开发助手" class="headerlink" title="开发助手"></a>开发助手</h3><p><a href="http://www.trinea.cn/android/android-develop-and-debug-tools/" target="_blank" rel="external">Android应用开发调试利器——开发助手，数十倍效率提升</a></p>
<h3 id="ddms-bat"><a href="#ddms-bat" class="headerlink" title="ddms.bat"></a>ddms.bat</h3><p>DDMS 全称是Dalvik Debug Monitor Service，是 Android 开发环境中的Dalvik虚拟机调试监控服务。<br>adt插件的功能, 提供一个调试的视图</p>
<p>具体功能：<br>设备列表,进程列表<br>文件管理<br>模拟器控制 打入电话 发入短信 定位信息<br>查看模拟器资源信息</p>
<h4 id="dump-View-Hierarchy-for-UI-automator"><a href="#dump-View-Hierarchy-for-UI-automator" class="headerlink" title="dump View Hierarchy for UI automator"></a>dump View Hierarchy for UI automator</h4><p><a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/38498337" target="_blank" rel="external">android 开发UI好工具—–dump View Hierarchy for UI automator</a></p>
<h3 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h3><p>程序性能分析器<br><a href="http://www.trinea.cn/android/android-traceview/" target="_blank" rel="external">Android性能调优工具TraceView介绍</a></p>
<h3 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a>Memory Monitor</h3><p>AndroidStudio自带的内存检测工具<br>Android Memory Monitor内置于Android Studio中，用于展示应用内存的使用和释放情况。<br>当你的App占用的内存持续增加，而且你同时出发GC，也没有进行释放，那么你的App很有可能发生了内存泄漏问题。</p>
<h3 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h3><p>Android性能调优利器StrictMode</p>
<h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h3><p>Android Memory Monitor内置于Android Studio中，用于展示应用内存的使用和释放情况。它大致长成这个样子<br>当你的App占用的内存持续增加，而且你同时出发GC，也没有进行释放，那么你的App很有可能发生了内存泄漏问题。</p>
<p>内存泄露目前在项目中一般用leakcanary基本就能搞定，配置起来也相当简单</p>
<p><a href="http://droidyue.com/blog/2016/03/28/android-leakcanary/" target="_blank" rel="external">Android内存泄漏检测利器：LeakCanary</a></p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT：Eclipse Memory Analyzer Tool<br>内存泄漏分析工具<br><a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/" target="_blank" rel="external">分析Android app的内存使用</a></p>
<h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><p>函数流程调试工具</p>
<h3 id="Method-Trace"><a href="#Method-Trace" class="headerlink" title="Method Trace"></a>Method Trace</h3><p>函数流程调试工具</p>
<h3 id="draw9patch-bat"><a href="#draw9patch-bat" class="headerlink" title="draw9patch.bat"></a>draw9patch.bat</h3><p>做点九图的工具</p>
<h3 id="emulator-exe"><a href="#emulator-exe" class="headerlink" title="emulator.exe"></a>emulator.exe</h3><p>模拟器</p>
<h3 id="mksdcard-exe"><a href="#mksdcard-exe" class="headerlink" title="mksdcard.exe"></a>mksdcard.exe</h3><p>创建sd卡的工具</p>
<h2 id="代码分析扫描工具"><a href="#代码分析扫描工具" class="headerlink" title="代码分析扫描工具"></a>代码分析扫描工具</h2><p>用途：静态代码扫描/程序分析/代码提示/代码检查</p>
<h3 id="Android-Lint工具"><a href="#Android-Lint工具" class="headerlink" title="Android Lint工具"></a>Android Lint工具</h3><p>先说下layoutopt<br>layoutopt是一个可以提供layout及其层级优化提示的命令行，在sdk16以后已经被lint取代，在Windows-&gt;Show View-&gt;Other-&gt;Android-&gt;Lint Warnings查看lint优化提示，lint具体介绍可见Improving Your Code with lint。</p>
<p>Android lint是在ADT 16提供的新工具，它是一个代码扫描工具，能够帮助我们识别代码结构存在的问题</p>
<p>lint检查：通过Android Studio中的 Analyze-&gt;Inspect Code 对工程代码做静态扫描；找出潜在的问题代码并修改，去掉无用的图片</p>
<p>相关文章：<br><a href="http://blog.csdn.net/xyz_lmn/article/details/14222939" target="_blank" rel="external">Android代码优化——使用Android lint工具</a><br><a href="http://www.bubuko.com/infodetail-1055648.html" target="_blank" rel="external">Android Studio使用Lint进行代码检查</a></p>
<p>相关书籍：<br>Android群英传-10.3 Lint工具</p>
<h3 id="Tools-Attributes"><a href="#Tools-Attributes" class="headerlink" title="Tools Attributes"></a>Tools Attributes</h3><p>官方文档：<br><a href="http://tools.android.com/tech-docs/tools-attributes" target="_blank" rel="external">http://tools.android.com/tech-docs/tools-attributes</a></p>
<p>相关文章：<br><a href="http://www.bubuko.com/infodetail-916616.html" target="_blank" rel="external">android中xml tools属性详解（转）</a><br><a href="http://blog.csdn.net/u011277123/article/details/52814521" target="_blank" rel="external">Android Tools Attributes，让布局设计所见即所得</a></p>
<p>看似Android开发人员只有一种方法来检查成品布局——在设备上运行它。但是，你还可以使用内置于开发框架的Tools Attributes，在我们的例子中所使用的框架是Android Studio。</p>
<p>开发人员在设计Android Layout布局时，总会伴随着一些乱七八槽的困扰。比如，为了更加逼真的真实数据预览效果，我们在开发时会将TextView的text属性写上一些假数据，而当运行到模拟器或真机上时这些假数据就成了造成体验上甚至测试BUG的脏数据，又需要一一清除。再比如，我们想在XML的预览界面上就看到ListView的Item内容，而不是只有通过编译运行时才能查看。等等，诸如这些存在于开发Layout内容阶段的困扰，都可以通过Tools Attributes得以解决，不妨了解一下。</p>
<p>Tools Attributes可以使用额外的命名空间来帮助管理Android Studio，这样开发框架就不会传输运行时版本的属性到最终构建。</p>
<h3 id="Support-Annotations"><a href="#Support-Annotations" class="headerlink" title="Support Annotations"></a>Support Annotations</h3><p>官方文档<br><a href="http://tools.android.com/tech-docs/support-annotations" target="_blank" rel="external">http://tools.android.com/tech-docs/support-annotations</a></p>
<p>学习文章<br><a href="http://www.cnblogs.com/punkisnotdead/p/4705258.html" target="_blank" rel="external">Android 注解的一些应用以及原理</a><br><a href="http://www.codeceo.com/article/android-support-annotations-2.html" target="_blank" rel="external">Android Support Annotations 使用详解</a><br><a href="http://www.mincoder.com/article/6375.shtml" target="_blank" rel="external">使用Android Support Annotations优化你的代码</a></p>
<p>如果你还没有听说过Android Support Annotations 函数库，你将错过一个整洁的新软件包，它有助于你捕获程序中的bugs。该函数库包含了许多的Java注解，用于帮助Android Studio检测代码中可能存在的错误，并报告给开发者。注解类型有很多种</p>
<h3 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h3><p>代码检查工具能帮我们检查一些隐藏的bug，代码检查工具中sonar是比较好的一个</p>
<p><a href="http://blog.csdn.net/rain_butterfly/article/details/42170601" target="_blank" rel="external">Android 代码检查工具SonarQube</a></p>
<h3 id="DroidJitChecker"><a href="#DroidJitChecker" class="headerlink" title="DroidJitChecker"></a>DroidJitChecker</h3><p>JIT：JIT全称Just-in-time compilation。意思为实时编译，是JVM中一种优化技术，对频繁调用并且符合条件的方法进行优化将字节码翻译成机器代码，提升执行效率。</p>
<p><a href="http://droidyue.com/blog/2016/04/10/jit-friendly-checker-for-android/" target="_blank" rel="external">一个Android代码JIT友好度检测工具</a></p>
<h3 id="UCDetector"><a href="#UCDetector" class="headerlink" title="UCDetector"></a>UCDetector</h3><p>UCDetector是 eclipse 工具 可以审查出程序中  未被使用的、 冗余的、 变量不规范 的代码 </p>
<p><a href="http://blog.csdn.net/aaawqqq/article/details/46684441" target="_blank" rel="external">android优化 清除无效代码 UCDetector</a></p>
<h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><p>静态分析工具承诺无需开发人员费劲就能找出代码中已有的缺陷。当然，如果有多年的编写经验，就会知道这些承诺并不是一定能兑现。</p>
<h2 id="高效工具-自动化及格式化"><a href="#高效工具-自动化及格式化" class="headerlink" title="高效工具(自动化及格式化)"></a>高效工具(自动化及格式化)</h2><p>相关文章<br><a href="https://github.com/jiang111/awesome-androidstudio-plugins" target="_blank" rel="external">收集Android studio 常用的插件</a><br><a href="https://www.2cto.com/kf/201504/389231.html" target="_blank" rel="external">打造你的开发神器——介绍Android Studio上的几个插件</a></p>
<h3 id="layoutformatter"><a href="#layoutformatter" class="headerlink" title="layoutformatter"></a>layoutformatter</h3><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0424/4176.html" target="_blank" rel="external">XML 布局文件代码的优雅性</a><br><a href="https://github.com/drakeet/LayoutFormatter" target="_blank" rel="external">https://github.com/drakeet/LayoutFormatter</a></p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>根据Gson库使用的要求,将JSONObject格式的String 解析成实体<br>写在前头:本插件只适用 android studio和 Intellij IDEA 工具,eclipse 的少年无视我吧!!!<br>这是一个根据JSONObject格式的字符串,自动生成实体类参数.<br><a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="external">https://github.com/zzz40500/GsonFormat</a></p>
<h3 id="android-layout-id-converter"><a href="#android-layout-id-converter" class="headerlink" title="android layout id converter"></a>android layout id converter</h3><p>Android Studio的一个插件<br>简而言之，可以一秒定义控件并且找到<br>相关文章:<br><a href="http://blog.csdn.net/poison_h/article/details/46722649" target="_blank" rel="external">Android Studio插件之Android Layout ID Converter教程</a></p>
<h3 id="AndroidCodeGenerator"><a href="#AndroidCodeGenerator" class="headerlink" title="AndroidCodeGenerator"></a>AndroidCodeGenerator</h3><p>Android studio 插件<br>可以自动生成findViewById方法和ViewHolder</p>
<p>下载地址：<br><a href="https://github.com/fuxiuyuan/AndroidCodeGenerator" target="_blank" rel="external">https://github.com/fuxiuyuan/AndroidCodeGenerator</a></p>
<h3 id="Android-Toolbox-Plugin"><a href="#Android-Toolbox-Plugin" class="headerlink" title="Android Toolbox Plugin"></a>Android Toolbox Plugin</h3><p>生成viewholder</p>
<h3 id="Android-Studio-Prettify"><a href="#Android-Studio-Prettify" class="headerlink" title="Android Studio Prettify"></a>Android Studio Prettify</h3><p>Studio1.5以上的版本鼠标放在<a href="http://R.layout.xxx右键－Generator可以看到View" target="_blank" rel="external">http://R.layout.xxx右键－Generator可以看到View</a> Variables和View Fields，可以帮你初始化资源文件中有id的view，可以再也不用findViewById了（没有的话请安装JetBrains Plugin Repository :: Android Studio Prettify，2.0以上默认没有<br><a href="http://plugins.jetbrains.com/plugin/7405?pr=androidstudio" target="_blank" rel="external">http://plugins.jetbrains.com/plugin/7405?pr=androidstudio</a></p>
<h3 id="Android-Parcelable-code-generator"><a href="#Android-Parcelable-code-generator" class="headerlink" title="Android Parcelable code generator"></a>Android Parcelable code generator</h3><p>生成实现了Parcelable接口的代码的插件.<br><a href="https://www.2cto.com/kf/201603/493780.html" target="_blank" rel="external">Android Studio添加Parcelable序列化小工具（快速提高开发效率）</a></p>
<h3 id="SelectorChapek-for-Android"><a href="#SelectorChapek-for-Android" class="headerlink" title="SelectorChapek for Android"></a>SelectorChapek for Android</h3><p>这是用于生成Selector的插件</p>
<h3 id="Sexy-Editor"><a href="#Sexy-Editor" class="headerlink" title="Sexy Editor"></a>Sexy Editor</h3><p>设置AS背景插件<br><a href="http://www.jianshu.com/p/6a176c87ef29" target="_blank" rel="external">让你的Android Studio性感起来–Sexy Editor</a></p>
<h3 id="Strings-xml-tools"><a href="#Strings-xml-tools" class="headerlink" title="Strings-xml-tools"></a>Strings-xml-tools</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="jimu-Mirror"><a href="#jimu-Mirror" class="headerlink" title="jimu Mirror"></a>jimu Mirror</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="Android-Holo-Colors-Generator"><a href="#Android-Holo-Colors-Generator" class="headerlink" title="Android Holo Colors Generator"></a>Android Holo Colors Generator</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h3><h3 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a>Android Drawable Importer</h3><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="Genymotion-虚拟机"><a href="#Genymotion-虚拟机" class="headerlink" title="Genymotion 虚拟机"></a>Genymotion 虚拟机</h3><p>刚开始做开发的时候，每次使用官方的虚拟机，都想吐槽一下，但是发现了Genymotion 之后，这一切都变化了，它的速度几乎可以和真机媲美了，当然如果有真机，当然还是推荐使用真机测试。</p>
<h3 id="ES-Explorer"><a href="#ES-Explorer" class="headerlink" title="ES Explorer"></a>ES Explorer</h3><p>ES Explorer 是一款文件管理器，但实际它又不仅仅是一款文件管理器，在获得Root 之后，它的功能更强大了，它可以浏览受限制的文件目录；而且提供了一系列小工具，比如下载器；还有集成了众多云储存服务。</p>
<h3 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h3><p>Codota 是一款Android 代码搜索工具，Codota 目前已经收录超过七百万精品代码实例；具体的详细介绍请看文章<br><a href="http://www.jianshu.com/p/59b89c26f9e0" target="_blank" rel="external">《Android 开发工具之Codota——搜索最好的Android 代码 - 简书》</a></p>
<h3 id="AndroidAssetStudio"><a href="#AndroidAssetStudio" class="headerlink" title="AndroidAssetStudio"></a>AndroidAssetStudio</h3><p>Android Asset Studio 是一个在线制作工具，它可以制作Iocn，ActionBar，点9 图等等，简单的操作，大大提高了我们开发的效率。<br><a href="http://romannurik.github.io/AndroidAssetStudio/" target="_blank" rel="external">http://romannurik.github.io/AndroidAssetStudio/</a></p>
<h3 id="WiFi-ADB"><a href="#WiFi-ADB" class="headerlink" title="WiFi ADB"></a>WiFi ADB</h3><p>WiFi ADB 是一个通过无线网络来使电脑和手机连接，当我们做测试的时候，只需在手机上打开，只需在命令行输入 adb connect xxx.xxx.xxx.xxx:5555，电脑可以连接手机，就可以通过无线网络来调试开发的应用。</p>
<p>PS：此文用来个人工作方便查资料使用，无商业用途和目的，因为本人喜欢资源整合，很多实用段落是各处收集，所有出处链接已都落款留下，无意冒犯原作者产权请谅解，所以所以请勿对号入座.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_performance_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>UML —— 类图</title>
    <link href="https://hengxing0080.github.io/2017/09/07/it/3.UML/UMLClass/"/>
    <id>https://hengxing0080.github.io/2017/09/07/it/3.UML/UMLClass/</id>
    <published>2017-09-07T12:25:22.000Z</published>
    <updated>2017-10-05T12:25:47.183Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_uml_class1.png" alt="UML图"><br><a id="more"></a></p>
<p>学习设计模式之前，一定要先整明白UML类图，什么关联，依赖，聚合，组合等等都得搞明白儿的，否则学习起来也依然会很吃力。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名：UML类图<br>关系：是类图中比较复杂的内容<br>内容：关联、聚合、组合<br>定义：一般元素和特殊元素之间的分类</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。<br>UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。</p>
<h1 id="类的UML表示"><a href="#类的UML表示" class="headerlink" title="类的UML表示"></a>类的UML表示</h1><p>类的命名尽量应用领域中的术语，应明确、无岐义，以利于相互交流和理解。<br>类的属性、操作中的可见性使用+、#、－分别表示public、protected、private。<br><img src="/images/it_uml_class2.png" alt="UML图"></p>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><p><img src="/images/it_uml_class3.png" alt="UML图"><br>类之间的关系是类图中比较复杂的内容。有关联、聚合、组合、泛化、依赖。</p>
<h2 id="1-关联"><a href="#1-关联" class="headerlink" title="1.关联"></a>1.关联</h2><p>是模型元素之间的一种语义联系，是类之间的一种很弱的联系。关联可以有方向，可以是单向关联，也可以是双向关联。可以给关联加上关联名来描述关联的作用。<br>关联两端的类也可以以某种角色参与关联，角色可以具有多重性，表示可以有多少个对象参与关联。可以通过关联类进一步描述关联的属性、操作以及其他信息。<br>关联类通过一条虚线与关联连接。对于关联可以加上一些约束，以加强关联的含义。如下图所示：<br><img src="/images/it_uml_class4.png" alt="UML图"></p>
<h2 id="2-聚合"><a href="#2-聚合" class="headerlink" title="2.聚合"></a>2.聚合</h2><p>是一种特殊的关联，聚合表示整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构。从而找出一些组成类，该整体类和组成类之间就形成了聚合关系。例如舰队是由一系列的舰船组成。需求描述中“包含”、“组成”、“分为….部分”等词常意味着聚合关系。</p>
<h2 id="3-组合"><a href="#3-组合" class="headerlink" title="3.组合"></a>3.组合</h2><p>也是一种特殊的关联，也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在。部分对象与整体对象之间具有共生死的关系。</p>
<p>聚合和组合的区别：聚合关系是“has－a”关系，组合关系是“contains－a”关系；聚合关系表示整体与部分的关系比较弱，而组合比较强；聚合关系中代表部分事物的对象与代表聚合事物的对象的生存期无关，一旦删除了聚合对象不一定就删除了代表部分事物的对象。组合中一旦删除了组合对象，同时也就删除了代表部分事物的对象。</p>
<h2 id="4-泛化"><a href="#4-泛化" class="headerlink" title="4.泛化"></a>4.泛化</h2><p>定义了一般元素和特殊元素之间的分类关系，类之间的这种泛化关系也就是继承关系。泛化关系是“a－kind－of”关系，定义一般元素和特殊元素之间的分类关系。下图是一个泛化关系的例子。<br><img src="/images/it_uml_class5.png" alt="UML图"></p>
<h2 id="5-依赖"><a href="#5-依赖" class="headerlink" title="5.依赖"></a>5.依赖</h2><p>有两个元素如果修改X的定义可能会导致对Y的定义，则认为Y依赖X。<br>依赖关系可能由各种原因引起，如一个类向另一个类发送消息，或者一个类是另一个类的数据成员类型，或者一个类是另一个类的操作的参数类型等。有时依赖关系和关联关系比较难区分。<br>如果类A和类B有关联关系，它们之间必然有依赖关系。<br>如果两个类之间有关联关系时不用再表示出这两个类之间的依赖关系。</p>
<h1 id="三种模型"><a href="#三种模型" class="headerlink" title="三种模型"></a>三种模型</h1><p>功能模型，从用户的角度展示系统的功能，包括用例图。<br>对象模型，采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图。<br>动态模型，展现系统的内部行为。包括序列图，活动图，状态图。</p>
<h1 id="建立类图"><a href="#建立类图" class="headerlink" title="建立类图"></a>建立类图</h1><p>在软件开发不同阶段使用的类图具有不同的抽象层次，即概念层、说明层、和实现层。使用UML进行应用建模也应该是一个迭代的过程，所以我们应该建立一个类图的层次的概念。</p>
<h2 id="概念层类图"><a href="#概念层类图" class="headerlink" title="概念层类图"></a>概念层类图</h2><p>描述应用领域中的概念，这些概念与实现它们的类有联系。通常没有直接的映射关系。画概念层类图时很少考虑或不考虑实现问题，因此概念层类图应独立于具体的编程语言。下面是一个概念层类的表示。</p>
<h2 id="说明层类图"><a href="#说明层类图" class="headerlink" title="说明层类图"></a>说明层类图</h2><p>此时我们考察的是类的接口部分，而不是实现部分。这个接口可能因为实现环境、运行特性等有多种不同的实现。下面是一个说明层类的表示。<br><img src="/images/it_uml_class6.png" alt="UML图"></p>
<h2 id="实现层类图"><a href="#实现层类图" class="headerlink" title="实现层类图"></a>实现层类图</h2><p>才真正考虑类的实现问题，提供实现的细节。此时的类的概念才应该是真正的严格意义上的类。它揭示了软件实体的构成情况。实现层的类是最常用的，在很多的时候说明层的类更有助于人们对软件的理解。<br><img src="/images/it_uml_class7.png" alt="UML图"></p>
<h1 id="使用类图"><a href="#使用类图" class="headerlink" title="使用类图"></a>使用类图</h1><p>类图几乎是所有面向对象方法的支柱，应该如何使用类图呢？以下提供了一些使用类图的一些建议。<br>不要试图在项目的初始阶段使用所有的符号，首先应该从简单概念开始。<br>比如类的关系等等，在需要的时候才使用。在项目的不同开发阶段，应该使用不同的观点来画类图。<br>如果处于分析阶段应该画概念层类图，当开始着手软件设计时，应该画说明层类图，当针对某个特定的技术实现时应该画实现层类图。<br>不要为每个事物都画一个模型，应该把精力放在关键的领域。<br>使用类图的最大危险是过早的陷入实现的细节，为了避免这个问题，应该将重点放在概念层和说明层。</p>
<h1 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h1><p>亿图，Visio，PowerDesigner</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>书籍：<br>大话设计模式——1.11 UML</p>
<p>文章：<br><a href="http://www.cnblogs.com/jisijie/p/5062109.html" target="_blank" rel="external">一张图让你快速学会UML（聚合、组合、依赖、继承、接口、类）</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_uml_class1.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - UML" scheme="https://hengxing0080.github.io/categories/IT-UML/"/>
    
    
      <category term="UML" scheme="https://hengxing0080.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架的总结</title>
    <link href="https://hengxing0080.github.io/2017/09/07/it/1.Java/CollectionsFramework/"/>
    <id>https://hengxing0080.github.io/2017/09/07/it/1.Java/CollectionsFramework/</id>
    <published>2017-09-07T10:33:02.000Z</published>
    <updated>2017-10-05T16:06:06.964Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<hr>
<h1 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h1><hr>
<p>集合类（集合框架,Collctions Framework, JavaSE(JDK2)特性））    </p>
<p>为什么出现集合类？<br>面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，就对对象进行存储，<br>集合就是存储对象最常用的一种方式。<br>数据多了用对象存<br>对象多了用集合存（2种方式，另一种是数组）</p>
<p>集合类的特点?<br>集合只用于存储对象，而且可以是不同类型的对象<br>集合长度是可变的<br>集合应用更广泛，没有局限性</p>
<p>数组和集合类同是容器，有何不同?<br>数组虽然也可以存储对象，但数组长度是固定的；集合长度是可变的。<br>数组中可以存储基本数据类型，集合只能存储对象。</p>
<p>集合的长度方法是：size<br>数组的长度方法是：length</p>
<p>集合存的不是对象实体，和数组一样，存储的都是对象的引用（内存地址值）</p>
<p>在安卓里常用的容器要么是list ,要么是map</p>
<hr>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><hr>
<p>Collection的子接口：<br>List和Set<br>这2个接口开发最为常见，其他的几乎用不着</p>
<p>Collection接口的由来：<br>集合框架是搜集共性不断向上抽取出来的体系，顶层集合是Collection，是收集集合的意思</p>
<p>集合类是工具包的成员：java.util → Collection<br>在不断抽取的过程中已经成为接口，里面全是抽象的方法<br>它有很多子类（实现类就是子类），如ArrayList<br>它有很多子接口，这里重点讲List和Set</p>
<p>为什么会出现这么多的容器呢？<br>因为每一个容器对数据的存储方式都是不同的<br>这个存储方式称之为：数据结构</p>
<p>为什么继承体系出来以后先看顶层？<br>因为顶层当中定义的都是这些体系中最共性最基础的行为，顶层看明白了，这个体系的基本功能就了解了<br>为什么看顶层，使用底层？<br>1.因为不断向上抽取出来的对象很有可能不让创建对象，因为抽象<br>2.创建子类对象方法会更多一些<br>所以看顶层，参阅底层</p>
<h2 id="Collection方法"><a href="#Collection方法" class="headerlink" title="Collection方法"></a>Collection方法</h2><p>Collection定义了集合框架的共性功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.添加</div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span></div><div class="line">添加元素，add方法的参数类型（E）可以理解成Object，以便于接收任意类型对象。是1.5新特性的泛型</div><div class="line">类似StringBuffer的append方法，方法名不一样，功能是一样的</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </div><div class="line">一次添加一组（一堆）元素</div><div class="line"></div><div class="line">2.删除</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </div><div class="line">移除一个元素</div><div class="line">remove的底层原理调用了equals</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </div><div class="line">一次性删除一堆元素，不是全部</div><div class="line"> </div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </div><div class="line">清空容器（容器中所有元素都删掉）</div><div class="line"></div><div class="line">3.判断</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </div><div class="line">包含某个元素</div><div class="line">调用contains，实际上contains是在调用equals，这它的底层原理</div><div class="line">        </div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </div><div class="line">包含某一堆元素</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </div><div class="line">判断集合中是否有元素，长度为0了就是为空了，比如clear方法</div><div class="line"></div><div class="line">4.获取</div><div class="line">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </div><div class="line">迭代取出</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </div><div class="line">返回此 collection 中的元素数。 </div><div class="line">size为0就为空</div><div class="line"></div><div class="line">5.获取交集</div><div class="line"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </div><div class="line">取交集</div><div class="line"></div><div class="line">6.集合变数组</div><div class="line">Object[] <span class="title">toArray</span><span class="params">()</span> </div><div class="line">集合中所有元素变成数组</div><div class="line"></div><div class="line">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span> </div><div class="line">toArray的重载形式，T可以理解成Object，是1.5新特性的泛型</div></pre></td></tr></table></figure></p>
<h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List集合判断元素是否相同，依据是元素的equals方法。（要记住）<br>contains，remove底层用的全都是equals方法<br>数据结构不同，依赖的方法是不一样的<br>ArrayList，LinkedList依据的都是equals方法，无论是包含还是删除</p>
<p>List增加了一些特有方法（凡是可以操作角标的方法都是该体系特有的方法）<br>但凡操作角标的都是数组原理。<br>有一个特殊的取值方式：遍历，只要有角标就能做到这点</p>
<h4 id="List方法"><a href="#List方法" class="headerlink" title="List方法"></a>List方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">除拥有上述Collection共性方法，还增加了以下方法</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></div><div class="line">在指定位置插入元素</div><div class="line"> </div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </div><div class="line">在指定位置插入一堆元素</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </div><div class="line">通过索引获取 / 通过某个位置获得元素</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </div><div class="line"> 改变指定位置的元素（只有List集合具备修改功能） </div><div class="line"></div><div class="line"><span class="keyword">abstract</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </div><div class="line">返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。 </div><div class="line">包含头，不包含尾</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </div><div class="line">判断元素的位置</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object object)</span></div><div class="line"></div><div class="line"><span class="keyword">abstract</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </div><div class="line">按照角标移除（凡是带角标的，都是特有方法）</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> location)</span></div><div class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></div></pre></td></tr></table></figure>
<h4 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h4><p>1.写出3种遍历一个list的方法（使用for循环）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String s : list)&#123;</div><div class="line">    System.out.print(s+<span class="string">"/t"</span>);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</div><div class="line">   	System.out.print(list.get(i)+<span class="string">"/t"</span>);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">for</span>(Iterator item = list.iterator();item.hasNext();)&#123;</div><div class="line">   	System.out.print(item.next()+<span class="string">"/t"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.在Java中怎么修改ArrayList()中元素的值？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)set(索引位置,元素类型对象)</div><div class="line">(<span class="number">2</span>)get(position).现有元素值 = 最新元素值;</div></pre></td></tr></table></figure></p>
<h4 id="List子类"><a href="#List子类" class="headerlink" title="List子类"></a>List子类</h4><p>List接口下有3个实现类曾经或现在很常用：<br>ArrayList，LinkedList，Vector</p>
<h5 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h5><p>Vector现已被被ArrayList所替代</p>
<p>Vector和ArrayList的区别：<br>ArrayList和Vector都是数组结构的<br>数组结构特点：固定长度<br>集合结构特点：可变长度<br>ArrayList默认长度为10，<br>如果在添加它就会new一个新数组，长度50%延长（15），<br>然后把原来数组中的元素拷贝到新数组中，<br>再把新元素添加到后面去，<br>用它比较好，既能延长又节省空间<br>Vector长度为10，超过这数就会100%延长（20），有点浪费空间，<br>所以Vector现在已经不用了，现在一般都用ArrayList和ListedList</p>
<h6 id="Vector特有方法"><a href="#Vector特有方法" class="headerlink" title="Vector特有方法"></a>Vector特有方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span></div><div class="line">将指定的组件添加到此向量的末尾，将其大小增加 1。</div><div class="line">特有方法 （带element的全是特有方法）</div><div class="line"></div><div class="line">E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span></div><div class="line">返回指定索引处的组件 / 相当于get</div><div class="line"></div><div class="line">E <span class="title">firstElement</span><span class="params">()</span></div><div class="line">返回此向量的第一个组件（位于索引 0) 处的项）/ 获取第一个</div><div class="line"></div><div class="line">Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </div><div class="line">返回此向量的组件的枚举。</div></pre></td></tr></table></figure>
<h6 id="Vector相关接口"><a href="#Vector相关接口" class="headerlink" title="Vector相关接口"></a>Vector相关接口</h6><p>Enumeration接口（枚举）</p>
<p>枚举就是Vector特有的取出方式。<br>早期1.0版本就是这种方式，那时没有迭代，只有枚举<br>发现枚举和迭代器很像。其实枚举和迭代是一样的。<br>ArrayList没有枚举，因为除了Vector剩下的都统一用迭代器了<br>因为枚举的名称以及方法的名称都过长。<br>所以被迭代器取代了。枚举郁郁而终了。</p>
<p>此接口的功能与 Iterator 接口的功能是重复的。<br>此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。<br>新的实现应该优先考虑使用 Iterator 接口而不是 Enumeration 接口。 </p>
<p>Vector有几种取值（取出元素）方式？<br>遍历（for循环（get方法））/ 就是按角标索引)<br>迭代器<br>枚举</p>
<p>Enumeration接口方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span>：测试此枚举是否包含更多的元素。 </span></div><div class="line"></div><div class="line">E <span class="title">nextElement</span><span class="params">()</span>：如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</div></pre></td></tr></table></figure></p>
<h5 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h5><p>ArrayList的底层实现是Object类型的数组<br>ArrayList默认构造的数组大小是10个, 如果不够存数据能动态加数据,在加就变成15个 (按照原来一半的速度增长)</p>
<p>ArrayList几个用法的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * ArrayList练习1：去除ArrayList集合中的重复元素</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义旧的ArrayList集合</span></div><div class="line">        ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line">        al.add(<span class="string">"01"</span>);</div><div class="line">        al.add(<span class="string">"02"</span>);</div><div class="line">        al.add(<span class="string">"01"</span>);</div><div class="line">        al.add(<span class="string">"01"</span>);</div><div class="line">        al.add(<span class="string">"03"</span>);</div><div class="line">        al.add(<span class="string">"02"</span>);</div><div class="line"></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">            <span class="comment">// 在迭代时循环中next调用一次，就要hasNext判断一次。</span></div><div class="line">            sop(it.next());</div><div class="line">            <span class="comment">//	sop(it.next()+"...." + it.next());</span></div><div class="line">            <span class="comment">/*  如果写2个next方法一判断，比如上面6个注释1个剩5个就出现没有这个元素异常，偶数没问题，奇数肯定有问题，所以在这个循环中next方法就写一次  */</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sop(al);    <span class="comment">// 去掉重复前输出：[01, 02, 01, 01, 03, 02]</span></div><div class="line">        al = singleElement(al);   <span class="comment">// al传给singleElement，返回一个新集合al</span></div><div class="line">        sop(al);   <span class="comment">// 去掉重复后输出：[01, 02, 03]		</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">singleElement</span><span class="params">(ArrayList al)</span> </span>&#123;  <span class="comment">// 返回List更合适，接口，因为是父类型</span></div><div class="line">        <span class="comment">// 定义个临时容器（新的ArrayList）</span></div><div class="line">        ArrayList newAl = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">        <span class="comment">// 遍历之前的旧的ArrayList集合</span></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">            Object obj = it.next();    <span class="comment">// Object记录下一个元素</span></div><div class="line">            <span class="keyword">if</span> (!newAl.contains(obj))&#123; <span class="comment">// 如果不包含才往里存</span></div><div class="line">                newAl.add(obj);        <span class="comment">// 往新集合里存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newAl;                  <span class="comment">// 返回新集合</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">ArrayList练习2：</div><div class="line"></div><div class="line">将自定义对象作为元素存到ArrayList集合中，并去除重复元素。</div><div class="line"></div><div class="line">比如：存人对象。同姓名同年龄，视为同一个人。为重复元素，就不要存了</div><div class="line"></div><div class="line">思路：</div><div class="line">1.对人描述，将数据封装进人对象。</div><div class="line">2.定义容器，将人存入。</div><div class="line">3.取出。</div><div class="line">*/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;         </div><div class="line">    </div><div class="line">    Person(String name,<span class="keyword">int</span> age)&#123; </div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="comment">// 如果不是Person</span></div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 要更严谨的话就直接抛异常</span></div><div class="line"></div><div class="line">        <span class="comment">// 如果是Person，那么</span></div><div class="line">        Person p = (Person)obj;</div><div class="line">        <span class="comment">//	System.out.println(this.name + "..." + p.name);  // 打印equals比较过程</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">        <span class="comment">// 存入（存的不是对象，是引用地址）</span></div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">30</span>));  <span class="comment">// 因为Person类一上来就构造函数初始化2个参数（姓名和年龄），所以这里传2个参数）</span></div><div class="line">        <span class="comment">// al.add(Object obj);   // 只有Object才能接受任意对象  // Object obj = new Person("lisi01",30);</span></div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">32</span>));</div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">33</span>));</div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">35</span>));</div><div class="line"></div><div class="line">        al = singleElement(al);</div><div class="line"></div><div class="line">        <span class="comment">// 取出姓名和年龄都打印出来</span></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">            Person p = (Person)it.next();</div><div class="line">            sop(p.getName() + <span class="string">"::"</span> + p.getAge());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sop(<span class="string">"remove 03 : "</span> + al.remove(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">33</span>)));  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">singleElement</span><span class="params">(ArrayList al)</span>  <span class="comment">// 返回List更合适，因为是父类型</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 定义个临时容器</span></div><div class="line">        ArrayList newAl = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">        <span class="comment">// 遍历老集合</span></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext())</div><div class="line">        &#123;</div><div class="line">            Object obj = it.next();   <span class="comment">// Object记录下一个元素</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span>(!newAl.contains(obj)) <span class="comment">// 如果不包含才往里存</span></div><div class="line">                newAl.add(obj);      <span class="comment">// 往新集合里存</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newAl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h5><p>LinkedList是List接口的链接列表（链表）实现类</p>
<p>增删操作频繁，用LinkedList</p>
<p>增删操作不频繁，用ArrayList（因为大批量的增删不常见，基本都是查询，所以它作为最常用的容器存在）</p>
<p>当你不知道用什么好，建议用ArrayList，只要元素不是特多，ArrayList增删也可以允许，虽然有点慢</p>
<h6 id="LinkedList特有方法"><a href="#LinkedList特有方法" class="headerlink" title="LinkedList特有方法"></a>LinkedList特有方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>	<span class="title">addLast</span><span class="params">(E e)</span></span></div><div class="line">将指定元素添加到此列表的结尾。（添加尾）</div><div class="line"></div><div class="line"><span class="keyword">void</span>	<span class="title">addFirst</span><span class="params">(E e)</span></div><div class="line">将指定元素插入此列表的开头。  （添加头）</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">offer</span><span class="params">(E o)</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">offerFirst</span><span class="params">(E e)</span>  （1.6版本）</div><div class="line">在此列表的开头插入指定的元素。</div><div class="line">替代addLast</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">offerLast</span><span class="params">(E e)</span>   （1.6版本）</div><div class="line">在此列表末尾插入指定的元素。</div><div class="line">替代addFirst</div><div class="line"></div><div class="line">E	<span class="title">getFirst</span><span class="params">()</span></div><div class="line">返回此列表的第一个元素。</div><div class="line"></div><div class="line">E	<span class="title">getLast</span><span class="params">()</span></div><div class="line">返回此列表的最后一个元素。</div><div class="line"></div><div class="line">E	<span class="title">peek</span><span class="params">()</span></div><div class="line"></div><div class="line">E	<span class="title">peekFirst</span><span class="params">()</span>        （1.6版本）</div><div class="line">获取但不移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代getFirst</div><div class="line"></div><div class="line">E	<span class="title">peekLast</span><span class="params">()</span>         （1.6版本）</div><div class="line">获取但不移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代getLast</div><div class="line"></div><div class="line">E	<span class="title">removeFirst</span><span class="params">()</span></div><div class="line">移除并返回此列表的第一个元素。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></div><div class="line"></div><div class="line">E	<span class="title">removeLast</span><span class="params">()</span></div><div class="line">移除并返回此列表的最后一个元素。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></div><div class="line"></div><div class="line">E	<span class="title">poll</span><span class="params">()</span></div><div class="line"></div><div class="line">E	<span class="title">pollFirst</span><span class="params">()</span>          （1.6版本）</div><div class="line">获取并移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代removeFirst</div><div class="line"></div><div class="line">E	<span class="title">pollLast</span><span class="params">()</span>           （1.6版本）</div><div class="line">获取并移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代removeLast</div></pre></td></tr></table></figure>
<h6 id="LinkedList示例代码"><a href="#LinkedList示例代码" class="headerlink" title="LinkedList示例代码"></a>LinkedList示例代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用LinkedList模拟一个堆栈或者队列数据结构</div><div class="line"> * 建一个基于链表的容器演示先进先出和先进后出</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuiLie</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LinkedList link; </div><div class="line">    DuiLie()&#123;			   </div><div class="line">        link = <span class="keyword">new</span> LinkedList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAdd</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        link.addLast(obj); </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">myGet</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//	return link.removeFirst();  // 先进先出</span></div><div class="line">        <span class="keyword">return</span> link.removeLast();  <span class="comment">// 先进后出</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> link.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DuiLie dl = <span class="keyword">new</span> DuiLie();</div><div class="line">        dl.myAdd(<span class="string">"java01"</span>);   <span class="comment">// 自己的容器（基于链表的容器）</span></div><div class="line">        dl.myAdd(<span class="string">"java02"</span>);</div><div class="line">        dl.myAdd(<span class="string">"java03"</span>);</div><div class="line">        dl.myAdd(<span class="string">"java04"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!dl.isNull())&#123; <span class="comment">// 循环取出全部数据（只要不为空的情况下）</span></div><div class="line">            System.out.println(dl.myGet());</div><div class="line">            <span class="comment">// 打印先进先出</span></div><div class="line">            <span class="comment">/*	输出：java01</span></div><div class="line">                      java02</div><div class="line">                      java03</div><div class="line">                      java04	*/</div><div class="line"></div><div class="line">            <span class="comment">// 打印先进后出</span></div><div class="line">            <span class="comment">/*	输出：java04</span></div><div class="line">                      java03</div><div class="line">                      java02</div><div class="line">                      java01	*/</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set一个不包含重复元素的collection<br>它的方法和Collection是一样的，全是共性方法，没有特有方法，直接拿来用就行了</p>
<p>常用子类有HashSet和TreeSet </p>
<h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h4><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/HashSet.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/HashSet.html</a></p>
<p>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示 HashSet </div><div class="line"> *</div><div class="line"> * 往HashSet集合中存入自定义对象</div><div class="line"> * 姓名和年龄相同为同一个人（重复元素）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</div><div class="line"></div><div class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"a1"</span>,<span class="number">11</span>));</div><div class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"a2"</span>,<span class="number">12</span>));</div><div class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"a3"</span>,<span class="number">13</span>));</div><div class="line">        <span class="comment">//	hs.add(new Person("a2",12));  // 输出是无序的，而且保证唯一性</span></div><div class="line">        <span class="comment">// 每个元素都有自己不同的哈希值，在哈希表里有4个位置的存储，都存进去了就不读取equals了</span></div><div class="line">        Iterator it = hs.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">            Person p = (Person)it.next();  <span class="comment">// 强转子类（向下转型）</span></div><div class="line">            sop(p.getName() + <span class="string">"::"</span> +p.getAge());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sop(<span class="string">"a1:"</span> + hs.contains(<span class="keyword">new</span> Person(<span class="string">"a2"</span>,<span class="number">12</span>)));</div><div class="line">        <span class="comment">// 先判断哈希值，如有有这值，所以去比较equals，最后为真，所以它认为这个值在表里是存在的</span></div><div class="line"></div><div class="line">        hs.remove(<span class="keyword">new</span> Person(<span class="string">"a3"</span>,<span class="number">13</span>));</div><div class="line">        <span class="comment">// 先算哈希值（里面没有，所以就删除了，所以就不读equals了）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    Person(String name,<span class="keyword">int</span> age) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重写hashCode方法（建立Person对象自己的哈希值方法）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name.hashCode()+age*<span class="number">37</span>;</div><div class="line">		<span class="comment">/* 37：张三20岁，字符串哈希值40，共60</span></div><div class="line">		      李四40岁，字符串哈希值20，共60</div><div class="line">		      所以*39才能导致哈希值的不一样，让不然还得判断equals（很低效的），这样才能保证哈希值的唯一性</div><div class="line">		      当然，不能*1，别的乘什么都行，</div><div class="line">              如果乘age（hashCode()*age），因为返回值是int，有可能超出int范围，所以还是乘37比较靠谱 		  */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重写equals</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Person p = (Person)obj;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</div><div class="line">        <span class="comment">// 判断是否为1个对象：姓名和年龄是否都相同是视为同一个对象（名字用equals方法比较，年龄用等于号比较）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h4><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/TreeSet.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/TreeSet.html</a></p>
<h5 id="TreeSet相关接口"><a href="#TreeSet相关接口" class="headerlink" title="TreeSet相关接口"></a>TreeSet相关接口</h5><h6 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h6><p>中文名：比较接口<br>所属包：java.lang<br>在线API：<a href="http://www.android-doc.com/reference/java/lang/Comparable.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/lang/Comparable.html</a></p>
<p>此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然（默认）排序，类的 compareTo 方法被称为它的自然比较方法。</p>
<p>Java中很多东西具备比较性就是这东西，比如String和Integer都实现了Comparable接口（在描述的时候就已经具备了可比性）</p>
<p>方法摘要：此接口只有一个方法<br>int compareTo(T o) ：比较此对象与指定对象的顺序。    </p>
<h6 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h6><p>中文名：比较器接口<br>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/Comparator.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/Comparator.html</a></p>
<p>方法摘要：此接口也只有一个方法<br>int compare(T o1, T o2) ：比较用来排序的两个参数。 </p>
<h5 id="TreeSet示例代码"><a href="#TreeSet示例代码" class="headerlink" title="TreeSet示例代码"></a>TreeSet示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示TreeSet1：TreeSet输出的结果按字典顺序排序</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    TreeSet ts = <span class="keyword">new</span> TreeSet();</div><div class="line">    ts.add(<span class="string">"abc"</span>);</div><div class="line">    ts.add(<span class="string">"cba"</span>);</div><div class="line">    ts.add(<span class="string">"bva"</span>);</div><div class="line">    ts.add(<span class="string">"zva"</span>);</div><div class="line">    ts.add(<span class="string">"DDA"</span>);</div><div class="line">    Iterator it = ts.iterator();</div><div class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">      System.out.println(it.next());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// TreeSet输出的结果按字典顺序（字母的自然顺序，ASCII表）给排序了，怎么挪结果都一样</span></div><div class="line">    <span class="comment">/* 输出：</span></div><div class="line">        DDA</div><div class="line">        abc</div><div class="line">        bva</div><div class="line">        cba</div><div class="line">        zva   */</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示 TreeSet2 —— Comparable接口</div><div class="line"> * </div><div class="line"> * 需求：</div><div class="line"> * 往TreeSet集合中存储自定义对象学生。</div><div class="line"> * 想按照学生的年龄进行排序</div><div class="line"> *</div><div class="line"> * 思路：</div><div class="line"> * 重点在于实现Comparable接口，复写ComparTo方法（在里面判断主要条件（年龄）和次要条件（姓名））</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo2</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet();</div><div class="line"></div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list02"</span>,<span class="number">22</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list07"</span>,<span class="number">20</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list09"</span>,<span class="number">19</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list08"</span>,<span class="number">19</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list01"</span>,<span class="number">40</span>));</div><div class="line"></div><div class="line">        Iterator it = ts.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">            Studen str = (Studen)it.next();</div><div class="line">            System.out.println(str.getName() + <span class="string">"..."</span> + str.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123; <span class="comment">// 实现Comparable接口，该接口强制让学生具备比较性</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    Student(String name,<span class="keyword">int</span> age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123; </div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))&#123; </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不是学生对象"</span>);</div><div class="line">        &#125;</div><div class="line">        Student s = (Student)obj;   </div><div class="line"></div><div class="line">        <span class="comment">// 判断主要条件排序（先判断年龄）</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; s.age) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 正整数 返回 大于 指定对象</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 判断次要条件排序（当年龄相同的情况下在判断姓名）</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age == s.age) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);   </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 负整数 返回 小于 指定对象</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示 TreeSet3 —— Comparator接口</div><div class="line"> *</div><div class="line"> * 需求：</div><div class="line"> * 接上一示例代码，在不允许改代码的前提下按姓名排序（把名字相同和年龄不相同的对象存进去）</div><div class="line"> * </div><div class="line"> * 分析：</div><div class="line"> * 当元素自身不具备比较性，或者具备的比较性不是所需要的。</div><div class="line"> * 这时需要让容器自身具备比较性。</div><div class="line"> * 定义了比较器Comparator，复写Compare方法，主要判断名字，次要判断年龄</div><div class="line"> * 将比较器对象作为参数传递给TreeSet集合的构造函数。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo3</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyCompare());    <span class="comment">// 比较器对象 传给这个构造函数</span></div><div class="line">        <span class="comment">//	TreeSet ts = new TreeSet();  // 如果不传比较器对象，那么打印结果是按年龄排序</span></div><div class="line">        <span class="comment">// 当两种排序都存在时，以比较器为主</span></div><div class="line"></div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi02"</span>,<span class="number">22</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi02"</span>,<span class="number">21</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi007"</span>,<span class="number">20</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi09"</span>,<span class="number">19</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi06"</span>,<span class="number">18</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi06"</span>,<span class="number">18</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi007"</span>,<span class="number">29</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi007"</span>,<span class="number">20</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi01"</span>,<span class="number">40</span>));</div><div class="line"></div><div class="line">        Iterator it = ts.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">            Student stu = (Student)it.next();</div><div class="line">            System.out.println(stu.getName() + <span class="string">"..."</span> + stu.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123; <span class="comment">// 自定义比较器类 实现 比较器接口</span></div><div class="line">    </div><div class="line">    <span class="comment">// 覆盖compare方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123; <span class="comment">// 因为比较器是给集合比较，可得出必须是2个参数以上互相比较才成立</span></div><div class="line">        </div><div class="line">        <span class="comment">// MyCompare继承了Object，里面已有equals，所以不用覆盖，直接用就行</span></div><div class="line">        <span class="comment">// 我们这里用return 0判断</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!(o1 <span class="keyword">instanceof</span> Person)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!(o2 <span class="keyword">instanceof</span> Person)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">        &#125;</div><div class="line">        Student s1 = (Student)o1;</div><div class="line">        Student s2 = (Student)o2;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = s1.getName().compareTo(s2.getName()); </div><div class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(s1.getAge()).compareTo(<span class="keyword">new</span> Integer(s2.getAge()));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    Student(String name,<span class="keyword">int</span> age) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不是学生对象"</span>);</div><div class="line">        Student s = (Student)obj;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; s.age)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age == s.age) </div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示 TreeSet 4</div><div class="line"> *</div><div class="line"> * 练习：练习字符串长度排序（从短到长）</div><div class="line"> * </div><div class="line"> * 分析：字符串本身具备比较性，但是它的比较方法不是所需要的</div><div class="line"> * 		这时就只能使用比较器（比较器更为方便更为常见一些）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo4</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> StrLenComparator());  </div><div class="line"></div><div class="line">        ts.add(<span class="string">"abcs"</span>);</div><div class="line">        ts.add(<span class="string">"cc"</span>);</div><div class="line">        ts.add(<span class="string">"cba"</span>);</div><div class="line">        ts.add(<span class="string">"aaa"</span>);</div><div class="line">        ts.add(<span class="string">"z"</span>);</div><div class="line">        ts.add(<span class="string">"hahahas"</span>);</div><div class="line"></div><div class="line">        Iterator it =ts.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">            System.out.println(it.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrLenComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">        String s1 = (String)o1;   </div><div class="line">        String s2 = (String)o2;</div><div class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Integer(s1.length()).compareTo(<span class="keyword">new</span> Integer(s2.length()));  <span class="comment">// 判断主要条件（长度）</span></div><div class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)  <span class="comment">// 判断次要条件（之前测试可以看出长度一样，内容不一样的字符串没有存进去，所以还要继续判断次要）</span></div><div class="line">            <span class="keyword">return</span> s1.compareTo(s2); <span class="comment">// 返回 比较字符串的自然顺序</span></div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Collection总结"><a href="#Collection总结" class="headerlink" title="Collection总结"></a>Collection总结</h2><p>1.List<br>元素是有序的，元素可以重复。因为该集合体系有索引。  它有3个子类对象 </p>
<p>1.1.ArrayList : 数组列表<br>底层的数据结构使用的是数组结构<br>查询速度很快，但是增删稍慢，元素越多速度越慢，元素少无所谓<br>线程不同步</p>
<p>1.2.LinkedList : 链表（链接列表）<br>底层使用的链表数据结构<br>增删速度很快<br>查询很慢（例如：1问2，2问3，3继续问它下一个诸多此类）<br>线程不同步</p>
<p>1.3.Vector：向量<br>底层是数组数据结构。<br>和ArrayList几乎一样，被ArrayList替代了。因为效率低，增删改查都是超慢<br>线程同步<br>JDK出现版本：Vector版本：1.0 ，ArrayList版本：1.2<br>Vector是元老级集合，1.0和1.1是它的时代，那时候容器就是它，它出现时还没有集合框架，集合出现版本（1.2）<br>Vector（线程同步）和ArrayList（线程不同步），前者增删查询都超慢，还是用后者效率高<br>多线程也不用Vector（因为只有它线程同步），因为可以自己加锁     </p>
<p>2.Set<br>元素是无序，元素不可以重复。该集合没有索引<br>Set集合的功能（方法）和Collection是一致的。<br>Set没有角标和特有方法</p>
<p>ArrayList和Set依赖区别：<br>ArrayList：判断元素是否存在以及删除是依赖equals的方法<br>Set：判断元素是否存在以及删除是先依赖元素的hashCode，然后equals方法</p>
<p>2.1.HashSet：哈希集合<br>底层数据结构是哈希表<br>线程不安全的（线程不同步）</p>
<p>HashSet保证元素唯一性的依据原理：<br>是通过元素的两个方法，hashCode和equals来完成。<br>如果元素的HashCode值相同，才会判断equals是否为true。<br>如果元素的hashCode值不同，不会调用equals。</p>
<p>2.2.TreeSet：树集合<br>底层数据结构是二叉树（和哈希值没关系）<br>可以对Set集合中的元素进行排序， 比如按ABCD字母顺序排名</p>
<p>TreeSet排序的第一种方式：Comparable<br>让元素自身具备比较性。<br>元素需要实现Comparable接口，覆盖compareTo方法。<br>这种方式也成为元素的自然顺序，或者叫做默认顺序。</p>
<p>TreeSet排序的第二种方式：Comparator<br>当元素自身不具备比较性时，或者具备的比较性不是所需要的。<br>这时就需要让集合（容器）自身具备比较性。<br>在集合初始化时，就有了比较方式。<br>定义了比较器Comparator，将比较器对象作为参数传递给TreeSet集合的构造函数。</p>
<p>TreeSet的二种方式的区别：<br>Comparable和Comparator的原理都是二叉树<br>Comparable和Comparator的保证元素唯一性的依据都是compareTo方法return 0（返回0就表示都是相同的，否则都是不相同）<br>Comparable是让元素自身具备比较性<br>Comparator是让容器自身具备比较性<br>如果当两种排序都存在时，以比较器为主。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;h1 id=&quot;集合简介&quot;&gt;&lt;a href=&quot;#集合简介&quot; class=&quot;headerlink&quot; title=&quot;集合简介&quot;&gt;&lt;/a&gt;集合简介&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;集合类（集合框架,Collctions Framework, Jav
    
    </summary>
    
      <category term="IT - Java" scheme="https://hengxing0080.github.io/categories/IT-Java/"/>
    
    
      <category term="Java" scheme="https://hengxing0080.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程并发异步的总结</title>
    <link href="https://hengxing0080.github.io/2017/09/06/it/1.Java/Multithreading/"/>
    <id>https://hengxing0080.github.io/2017/09/06/it/1.Java/Multithreading/</id>
    <published>2017-09-06T07:54:12.000Z</published>
    <updated>2017-10-05T16:06:12.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_java_thread.jpg" alt="UML图"><br><a id="more"></a><br>注意：此图总结不全用于临时展示，后续待上传最新思维导图</p>
<hr>
<h1 id="进程和线程的理解"><a href="#进程和线程的理解" class="headerlink" title="进程和线程的理解"></a>进程和线程的理解</h1><hr>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是计算机系统中，一个正在进行执行中的程序, 程序运行的实体，也是线程的容器。<br>每一个进程执行都有一个执行顺序,该顺序是一个从头执行到尾的控制单元(控制单元也叫执行情景或执行路径).</p>
<p>进程的作用：<br>如qq或迅雷，它们启动时都在内存中分配一块空间和地址，进程就是来定义和标识空间，用来封装里面的控制单元！</p>
<p>java有2个进程：<br>编译进程：javac(编译器)也是一个进程, javac.exe(编译完就结束了，进程就消失了)<br>运行进程：jvm(虚拟机),启动时会有一个进程java.exe </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>通俗的理解线程就是代码一行行向下执行的线路和流程。<br>线程就是进程中的一个独立的控制单元.<br>线程是进程中实际执行单位，一个线程是程序执行流的最小单元。<br>线程在控制着进程的执行<br>线程是进程中的内容（线程运行在进程里面）<br>每一个应用程序(进程)至少有一个线程<br>Java虚拟机允许应用程序(进程)并发地运行多个执行线程。 </p>
<p>多线程：<br>就是分出另外一个执行线程，同时又多条线路并行运行。<br>一个进程里有多个线程在执行, 就是有多条执行路径就叫多线程 （例如：下载就是多线程）<br>多线程和CPU有关，单核CPU不能开启多线程，只能单线程</p>
<p>主线程：<br>该进程中至少有一个线程负责java程序的执行<br>而且这个线程运行的代码存在于main方法中<br>该线程称为主线程<br>主线程要运行的代码存在main方法，是虚拟机定义的（它的控制单元只认main方法），这就是虚拟机调用main方法的原因，因为是主线程在调用！</p>
<p>垃圾回收机制的线程：<br>其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。</p>
<p>线程类API：<br>java.lang → Thread<br>Java中万物皆对象,线程也被描述成了一个对象就是Thread对象.<br>Java对多线程的支持也是特别完善的,特别是JDK1.5之后.</p>
<p>如未通俗的理解进程和线程，请看下面的文章↓<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">进程与线程的一个简单解释</a></p>
<hr>
<h1 id="创建线程的3种方式"><a href="#创建线程的3种方式" class="headerlink" title="创建线程的3种方式"></a>创建线程的3种方式</h1><hr>
<h2 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h2><p>(1)将类声明为 Thread 的子类。<br>(2)子类覆盖父类中的run方法，将线程运行的代码存放在run方法中。（目的：将自定义代码存储在run方法，让线程运行）<br>(3)建立子类对象的同时线程也被创建。<br>(4)通过调用start方法开启线程。(start方法有2个作用：1.启动线程 2.调用run方法)</p>
<h2 id="2-实现Runnable接口创建线程类"><a href="#2-实现Runnable接口创建线程类" class="headerlink" title="2.实现Runnable接口创建线程类"></a>2.实现Runnable接口创建线程类</h2><p>(1)定义类实现Runnable接口<br>(2)覆盖Runnable接口中的run方法（将线程要运行的代码存放在该run方法中）<br>(3)通过Thread类建立线程对象<br>(4)将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数<br>(5)调用Thread类的start方法开启线程并调用Runnable接口子类的run方法</p>
<p>注意：<br>Runnable只是一个任务，真正干活的还是Thread<br>因为查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run方法。</p>
<h2 id="3-实现Callable接口和通过Future创建线程"><a href="#3-实现Callable接口和通过Future创建线程" class="headerlink" title="3.实现Callable接口和通过Future创建线程"></a>3.实现Callable接口和通过Future创建线程</h2><p>(1)创建Callable接口的实现类，并实现call()方法(相当于run)，该call()方法将作为线程执行体，并且有返回值。<br>(2)创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>(3)使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<h3 id="关于Callable-amp-Future的介绍"><a href="#关于Callable-amp-Future的介绍" class="headerlink" title="关于Callable&amp;Future的介绍"></a>关于Callable&amp;Future的介绍</h3><p>一个程序启动一个线程，这个线程运行完了有一返回结果，这些类可以获得这个结果</p>
<p>Callable是任务来返回结果，然后返回的结果由Future去拿</p>
<p>Future取得的结果类型和Callable返回的结果类型必须一致，这是通过泛型来实现的。</p>
<p>Callable要采用ExecutorSevice的submit方法提交，返回的future对象可以取消任务。</p>
<p>Callable&amp;Future的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</div><div class="line">        Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123; </div><div class="line">            <span class="comment">// Callable任务来返回结果，获取的结果由Future来拿，Callable如果没有结果，Future会一直等</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"等待结果"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"拿到结果："</span> + future.get());</div><div class="line">    <span class="comment">//      System.out.println("拿到结果："+future.get(100,TimeUnit.SECONDS));</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ExecutorService threadPool2 = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="comment">// CompletionService用于提交一组Callable任务，其take方法返回已完成的一个Callable任务对应的Future对象。</span></div><div class="line">        <span class="comment">// 好比我同时种了几块地的麦子，然后就等待收割。收割时，则是哪块先成熟了，则先去收割哪块麦子。</span></div><div class="line">        CompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;Integer&gt;(threadPool2); <span class="comment">// 接口不能直接new，需要new它的子类</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = i;</div><div class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>));</div><div class="line">                    <span class="keyword">return</span> seq;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(completionService.take().get()); <span class="comment">// 按最先运行的线程来获取</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建并开启线程的7种方式"><a href="#创建并开启线程的7种方式" class="headerlink" title="创建并开启线程的7种方式"></a>创建并开启线程的7种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">开发时的线程写法（当然只是示范，不一定非得这么写，只是一种写法）</div><div class="line">什么时候用多线程？当某些代码要被同时执行就用单独的线程封装</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 单独封装线程1（Thread子类对象）</span></div><div class="line">        <span class="comment">// 在主方法里new个对象，这样封装，即使这个对象没运行完，下面的for也能运行</span></div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  /</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"线程1"</span> + x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line"></div><div class="line">        <span class="comment">// 单独封装线程2（技巧写法，用匿名内部类完成）</span></div><div class="line">        Runnable r = <span class="keyword">new</span> Runnable()  &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"线程2"</span> + x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">new</span> Thread(r).start();  </div><div class="line"></div><div class="line">        <span class="comment">// 线程3（主线程）</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"线程3"</span> + x);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 线程4</span></div><div class="line">        <span class="keyword">new</span> Thread2().start(); </div><div class="line"></div><div class="line">        <span class="comment">// 线程5</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable2()).start();</div><div class="line"></div><div class="line">        <span class="comment">// 上面定义5个线程，这么一封装，这样就能同时运行了而且高效了</span></div><div class="line">    </div><div class="line">        <span class="comment">//  new Test1().start();  // 如果放这开启就不是4个同时开始，而是先执行上面3个才执行它</span></div><div class="line"></div><div class="line">        <span class="comment">// 以下还有3种方式</span></div><div class="line">        <span class="comment">// 线程6</span></div><div class="line">        Thread thread6 = <span class="keyword">new</span> Thread()&#123; <span class="comment">// new一个子类，复写run方法</span></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">					<span class="keyword">try</span> &#123;Thread.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</div><div class="line">				    System.out.println(<span class="string">"1："</span>+Thread.currentThread().getName());</div><div class="line">					System.out.println(<span class="string">"2："</span>+<span class="keyword">this</span>.getName()); <span class="comment">// this代表run方法所在的对象（thread对象），但是工作中不建议这么写</span></div><div class="line">                &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		&#125;;</div><div class="line">		thread6.start();</div><div class="line"></div><div class="line">        <span class="comment">// 线程7</span></div><div class="line">        Thread thread7 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 等待</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(ANIMATION_DELAY);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 做页面跳转</span></div><div class="line">                <span class="comment">// doNavgation();</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(isTopActivity(WelcomeActivity.<span class="keyword">this</span>))&#123;</div><div class="line">                    IntentUtil.startActivityAndFinish(MainActivity.class);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        thread7.start();</div><div class="line"></div><div class="line">        <span class="comment">// 线程8</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 等待</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(ANIMATION_DELAY);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 做页面跳转</span></div><div class="line">                <span class="comment">//doNavgation();</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span>(isTopActivity(WelcomeActivity.<span class="keyword">this</span>))&#123;</div><div class="line">                    IntentUtil.startActivityAndFinish(MainActivity.class);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  <span class="comment">// 继承和实现都行</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程4："</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程5："</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.创建线程的三种方式的对比<br>使用继承Thread类的方式创建多线程时<br>优势：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势：线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>采用实现Runnable、Callable接口的方式创见多线程时<br>优势：<br>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>劣势：<br>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>2.实现方式(Runnable)和继承方式(Thread)有什么区别呢？<br>实现方式好处：避免了单继承的局限性</p>
<p>两种方式区别在于存放代码位置不一样： ↓<br>继承Thread：线程代码存放Thread类的子类run方法中<br>实现Runnable，线程代码存在Runnable接口的子类的run方法</p>
<p>在定义线程时，建议使用实现方式（Runnable）<br>当然，自己的类没有父类的时候可以用继承Thread</p>
<p>图解：<br>继承：因为Java只支持单继承，所以Student类继承了Person类后就无法在继承Thread类.<br>实现：Student类继承了Person类还实现了Runnable接口，功能还扩展了.<br><img src="/images/it_java_thread1.png" alt="UML图"></p>
<p>PS:Thread类本身也实现了Runnable</p>
<p>3.为什么要覆盖run方法呢？<br>Thread类用于描述线程。<br>该类就定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。<br>就是说Thread类中的run方法，用于存储线程要运行的代码。<br>结论就是run方法就是初始化代码</p>
<p>4.start方法和run方法的区别？  调用start方法结果是什么？  调用run方法结果又是什么？<br>d.start();<br>开启线程并执行该线程的run方法<br>它调用底层让控制单元去执行的动作，这是start的作用<br>它很重要，只有它才能开启线程</p>
<p>d.run();<br>仅仅是对象调用方法。而线程创建了，并没有运行。<br>run的功能就是封装线程要运行的代码</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://www.cnblogs.com/DreamDrive/p/6180918.html" target="_blank" rel="external">创建线程的三种方式 </a><br><a href="http://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="external">java创建线程的三种方式及其对比</a></p>
<hr>
<h1 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h1><hr>
<h2 id="interrupt-停止线程"><a href="#interrupt-停止线程" class="headerlink" title="interrupt(停止线程)"></a>interrupt(停止线程)</h2><h3 id="先看下终止线程的三种方法"><a href="#先看下终止线程的三种方法" class="headerlink" title="先看下终止线程的三种方法"></a>先看下终止线程的三种方法</h3><p>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>定义循环结束标记,因为线程运行代码一般都是循环，只要控制了循环即可，就可以让run方法结束，也就是线程结束。</p>
<p>不过有种特殊情况：<br>当线程处于了冻结状态<br>就不会读取到标记<br>那么线程就不会结束  </p>
<p>所以推荐下面的interrupt<br>写程序时很常见的问题，只要线程挂着不动，就用interrupt</p>
<p>2.使用interrupt方法中断线程。(推荐)<br>该方法是结束线程的冻结状态，使线程回到运行状态中来。</p>
<p>详细就是当没有指定的方式让冻结的线程恢复到运行状态时，这时就需要对冻结进行清除。<br>强制让线程恢复到运行状态（获取运行资格）中来，这样就可以操作标记让线程结束。</p>
<p>注意这个方法不是停止线程，是强制清洁冻结状态的线程.<br>中断状态就是冻结状态<br>中断状态不是停止线程<br>stop方法才是停止线程<br>stop()，wait()，join() 都能被中断</p>
<p>3.使用stop方法强行终止线程。(不推荐)<br>这个方法已经过时不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的<br>虚拟机不识别不说而且此方法有bug，就是强制停止线程.<br>suspend方法也已过时（发送死锁）</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束线程方法1：加结束标记的情况：只要能让循环结束，那么线程就能结束</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;  <span class="comment">// 定义方法（改变标记）</span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span>&#123;</div><div class="line">        <span class="keyword">while</span>(flag)&#123;   <span class="comment">// 循环结束那么线程就能结束</span></div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread(); <span class="comment">// 主线程</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);       <span class="comment">// 其他线程1</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);       <span class="comment">// 其他线程2</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="comment">// 开始控制线程 </span></div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 无限循环</span></div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                st.changeFlag();  <span class="comment">// 结束标记（改变标记为假，循环和线程结束）</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num);  <span class="comment">// 得到主线程名字和编号</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 证明主线程执行完的提示语</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束线程2：(特殊情况) 加了同步后，线程停不下来，只能用interrupt</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  <span class="comment">// 遇到同步就等于拿到锁</span></div><div class="line">        <span class="keyword">while</span>(flag)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                wait();  <span class="comment">// 线程0和1进来遇到它就冻结等待了（放弃了执行资格）</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"...Exception"</span>); </div><div class="line">                flag = <span class="keyword">false</span>;  <span class="comment">// 只要能发送发生异常就代表在用interrupt，所以定义标记处理成false就能结束线程了</span></div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread(); </div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);      <span class="comment">// 线程0</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);      <span class="comment">// 线程1</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                <span class="comment">//  st.changeFlag(); // 虽然改变了标记，但是这次程序因为同步的原因没有停下来</span></div><div class="line">                t1.interrupt();      <span class="comment">// 冻结状态强制被清除了，中断线程，出中断异常</span></div><div class="line">                t2.interrupt();      <span class="comment">// 同上</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num);  </div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 用了interrupt，主线程正常停下来了</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="setDeamon-守护线程"><a href="#setDeamon-守护线程" class="headerlink" title="setDeamon(守护线程)"></a>setDeamon(守护线程)</h2><p>将该线程标记为守护线程或用户线程。<br>当正在运行的线程都是守护线程时，Java 虚拟机退出。<br>该方法必须在启动线程前调用。</p>
<p>能看到的线程都是前台线程，当把某线程标记成后台线程后，就具备了特殊的含义<br>开启运行时，后台线程和前台线程都一样一起抢夺CPU资源，就结束有区别<br>当所有的前台线程都结束后，后台线程会自动结束（前台不在了，后台也挂了）</p>
<p>主线程是前台线程，主线程一结束就都结束</p>
<p>示例代码2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示：守护线程</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(flag)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread();</div><div class="line">        </div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st); </div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);     </div><div class="line">        </div><div class="line">        <span class="comment">// 给t1和t2标记守护线程（传个真就守护了）</span></div><div class="line">        t1.setDaemon(<span class="keyword">true</span>);         </div><div class="line">        t2.setDaemon(<span class="keyword">true</span>);  </div><div class="line">        <span class="comment">// 主线程结束后，不管t1和t2是什么情况（睡眠，冻结，等待，无限循环等等）都能结束）</span></div><div class="line">        <span class="comment">// 该方法必须在启动线程前调用（开启守护模式当然必须在线程开动前期）     </span></div><div class="line">        <span class="comment">// 所以线程停下来的原因是因为主线程结束了（前台线程）</span></div><div class="line">        <span class="comment">// 而标记t1和t2的守护线程时他们是后台线程所以也跟着结束了，原理是这个方法让虚拟机结束了</span></div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num); </div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="join方法-临时加入线程"><a href="#join方法-临时加入线程" class="headerlink" title="join方法(临时加入线程)"></a>join方法(临时加入线程)</h2><p>Join用途：<br>临时加入线程用的<br>一个线程在运行中要临时加入另外一个线程，让这个线程运算完，然后让另外一个线程在继续运行</p>
<p>Join特点：<br>当A线程执行到了B线程的join()方法时，A就会等待。<br>等B线程都执行完，A才会执行。<br>join可以用来临时加入线程执行<br>join用的频率不高，但是很有技术含量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示：join</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">70</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        </div><div class="line">        t1.join()  <span class="comment">// t1先拥有执行权，主线程就处于冻结状态，等到t1打印完结束了，主线程才恢复到运行状态中来</span></div><div class="line"></div><div class="line">        t2.start();</div><div class="line"></div><div class="line">    <span class="comment">//  t1.join(); // 主线程先执行，执行到t1.join，主线程就冻结然后等待t1，</span></div><div class="line">                   <span class="comment">// 这时t1和t2交替执行，等t1结束了，主线程解冻和t2抢夺执行权</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">80</span>; x++)&#123;</div><div class="line">            System.out.println(<span class="string">"main....."</span>+x);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 证明主函数结束的标语</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息"><a href="#yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息" class="headerlink" title="yield方法(临时停止线程) &amp; setPriority(设置优先级) &amp; toString(返回线程全部信息)"></a>yield方法(临时停止线程) &amp; setPriority(设置优先级) &amp; toString(返回线程全部信息)</h2><ul>
<li><p>yield()<br>临时停止<br>暂停当前正在执行的线程对象，并执行其他线程。<br>用的频率也不高</p>
</li>
<li><p>setPriority()<br>所有的线程包括主线程默认优先级是5，优先级一共10<br>优先级代表抢资源的频率</p>
<p>  因为1，5，10 这3个优先级跨度最大，所以有了3个字段 ↓<br>  static int MAX_PRIORITY   （优先级10,最高优先级）<br>  static int MIN_PRIORITY   （优先级1,最低优先级）<br>  static int NORM_PRIORITY  （优先级5,默认优先级）</p>
</li>
<li><p>toString()<br>返回该线程的字符串表示形式，包括线程名称、线程组和优先级。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *演示：toString &amp; setPriority &amp; yield</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">70</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().toString()+<span class="string">"....."</span>+x);</div><div class="line">            <span class="comment">// 输出：线程组（谁开启就属于哪个组，这里是主线程开启的t1和t2，所以属于main）</span></div><div class="line"></div><div class="line">            Thread.yield(); </div><div class="line">            <span class="comment">// 起到稍微减缓线程执行的频率的运行，能让所有的线程都有机会平均的运行效果（类似你一下，我一下的执行效果）</span></div><div class="line">            <span class="comment">// 强制性的让线程临时释放执行权</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t1.setPriority(Thread.MAX_PRIRITY); <span class="comment">// 不过这方法不严谨，设完了也是互相抢资源，相对就是抢的频率高一些</span></div><div class="line">        t2.start();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">80</span>; x++)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"main....."</span>+x);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="线程的5种生命周期状态"><a href="#线程的5种生命周期状态" class="headerlink" title="线程的5种生命周期状态"></a>线程的5种生命周期状态</h1><hr>
<p><img src="/images/it_java_thread2.jpg" alt="UML图"><br><img src="/images/it_java_thread3.jpg" alt="UML图"><br><img src="/images/it_java_thread4.jpg" alt="UML图"></p>
<p>Java线程的生命周期分为如下几种：<br>新建：创建线程对象<br>就绪：拥有执行资格，但是没有执行权<br>运行：有执行资格且有执行权<br>阻塞：没有执行资格和执行权，但是可以被激活到就绪<br>死亡：线程对象变为垃圾，等待被回收。</p>
<ul>
<li><p>1.新建状态<br>创建线程对象<br>new一个Thread对象就是一个线程，new一个Thread子类也是</p>
</li>
<li><p>2.就绪状态<br>有执行资格的状态<br>特点：具备运行资格，但没有执行权</p>
</li>
<li><p>3.运行状态<br>即有资格又有执行权叫运行状态<br>方法：start()：开始启动线程</p>
</li>
<li><p>4.阻塞/冻结/睡眠/等待状态<br>没有执行资格的状态叫冻结状态(特点：放弃了执行资格，当然更没有执行权了)<br>方法：<br>sleep()：睡眠（需要指定睡眠时间，单位是毫秒）<br>wait()：等待<br>notify()：唤醒</p>
</li>
<li><p>5.消亡/线程死亡/销毁状态<br>方法：<br>stop()：停止<br>run()：run方法也是结束(当线程里内容执行完没有内容了就结束了)</p>
</li>
</ul>
<hr>
<h1 id="多线程同步安全问题与互斥技术"><a href="#多线程同步安全问题与互斥技术" class="headerlink" title="多线程同步安全问题与互斥技术"></a>多线程同步安全问题与互斥技术</h1><hr>
<p>}<br>同步：<br>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p>
<p>线程安全：<br>经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码.</p>
<p>多线程的运行出现了安全问题，原因是：<br>1.多个线程访问出现延迟<br>2.线程随机性</p>
<p>多线程安全问题经典案例：银行转账（1个人存，一个人取）</p>
<p>问题的原因：<br>当多条语句在操作同一线程共享数据时，一个线程对多条语句只执行了一部分，<br>还没有执行完，另一个线程参与进行执行。导致共享数据的错误。</p>
<p>解决方法：<br>对多条操作共享数据的语句，只能让一个线程都执行完。<br>在执行过程中，其他线程不可以参与运行。<br>java对于多余线程的安全问题提供了专业的解决方式：同步锁<br>对象如同锁，持有锁的线程可以在同步中执行。<br>没有持有锁的线程即使获取CPU的执行权，也执行不起，因为没有获取锁。</p>
<p>同步的前提：<br>1.必须要有两个或者两个以上的线程。<br>2.必须是多个线程使用同一个锁。<br>3.必须保证同步中能有一个线程运行。</p>
<p>同步的好处：解决了多线程的安全问题</p>
<p>同步的弊端：多个线程需要判断锁，较为消耗资源，影响程序效率.</p>
<p>相关名称：<br>互斥：多个线程互相排斥，互不干扰，这样就同步了。<br>互斥锁（Mutual exclusion，缩写 Mutex）：防止多个线程同时读写某一块内存区域。<br>信号量（Semaphore）：用来保证多个线程不会互相冲突。</p>
<p>同步有两种锁机制：<br>乐观锁和悲观锁<br>不懂俩锁的可以看下面文章快速联系<br><a href="http://blog.csdn.net/hongchangfirst/article/details/26004335" target="_blank" rel="external">一分钟教你知道乐观锁和悲观锁的区别</a></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁是一种非独占锁，非阻塞锁。</p>
<p>相关文章：<br><a href="http://www.importnew.com/20472.html" target="_blank" rel="external">乐观锁的一种实现方式——CAS</a><br><a href="http://www.cnblogs.com/gossip/p/6182028.html" target="_blank" rel="external">Java并发_volatile实现可见性但不保证原子性</a><br><a href="http://www.cnblogs.com/yuyutianxia/p/3991869.html" target="_blank" rel="external">锁、volatile、CAS 比较</a></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS(Compare and Swap)比较并交换的无锁算法<br>解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<p>java.util.concurrent包中借助CAS实现了区别于synchronized同步锁的一种乐观锁。<br>AtomicInteger</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>与锁相比，volatile变量是一和更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作</p>
<p>volatile变量也存在一些局限：不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用volatile变量</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁是一种是独占锁，阻塞锁.</p>
<p>悲观锁机制存在以下问题：<br>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>悲观锁种类：<br>有Synchronized和Lock两种方式</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized就是一种阻塞算法.<br>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。<br>独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p>
<p>Synchronized有如下几种表现方式和情况： </p>
<h4 id="1-同步代码块（互斥的代码块上锁，加任意对象锁）"><a href="#1-同步代码块（互斥的代码块上锁，加任意对象锁）" class="headerlink" title="1.同步代码块（互斥的代码块上锁，加任意对象锁）"></a>1.同步代码块（互斥的代码块上锁，加任意对象锁）</h4><p>同步代码块的锁可以创建一个任意类型的对象来用，如Object类型或该类所属字节码文件对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">格式：synchronized ( 对象 )&#123; </div><div class="line">    需要被同步的代码 ;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">Object obj = <span class="keyword">new</span> Object();  <span class="comment">// 新建对象锁，Object现成的基类直接拿来用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(obj)&#123;      <span class="comment">// 同步代码块(在操作共享数据的地方加同步代码块，多了一层代码阶段形状相当于加了一道同步锁(或者是监视器)</span></div><div class="line">        sum = sum + n;</div><div class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</div><div class="line">        System.out.println(<span class="string">"sum"</span> + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-同步函数（互斥非静态方法上锁，加this锁）"><a href="#2-同步函数（互斥非静态方法上锁，加this锁）" class="headerlink" title="2.同步函数（互斥非静态方法上锁，加this锁）"></a>2.同步函数（互斥非静态方法上锁，加this锁）</h4><p>同步函数用的是哪一个锁？<br>函数需要被对象调用，那么函数都有一个所属对象引用：this，所以同步函数使用的锁是this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">格式：在函数上加上synchronized修饰符即可</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 同步函数（让函数具备同步性）  </span></div><div class="line">    sum = sum + n;</div><div class="line">    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</div><div class="line">    System.out.println(<span class="string">"sum"</span> + sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-静态同步函数-互斥静态方法上锁，加类锁"><a href="#3-静态同步函数-互斥静态方法上锁，加类锁" class="headerlink" title="3.静态同步函数(互斥静态方法上锁，加类锁)"></a>3.静态同步函数(互斥静态方法上锁，加类锁)</h4><p>同步函数被静态修饰后，使用的锁是什么呢？<br>通过验证，发现不在是this（因为静态方法中不可以定义this）<br>静态进内存时，内存中还没有本类对象，但是一定有该类对应的字节码文件对象：类名.class，所以该对象的类型是class<br>静态的同步方法，使用的锁是该方法所在类的字节码文件对象：类名.class（这个对象在内存里是唯一的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  演示 静态同步函数的锁是Class对象</div><div class="line"> */ </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tick = <span class="number">100</span>; <span class="comment">// 静态（加静态后是方法区共享数据，不加静态是堆内存共享数据）</span></div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(Ticket.class)&#123;  <span class="comment">// Ticket的字节码</span></div><div class="line">                    <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"同步代码块 : "</span> + tick--);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;  <span class="comment">// 静态同步方法</span></div><div class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"同步函数 : "</span> + tick--);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Ticket ticket = <span class="keyword">new</span> Ticket(); </div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ticket);  </div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ticket); </div><div class="line">        thread1.start(); </div><div class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">        ticket.flag = <span class="keyword">false</span>;</div><div class="line">        thread2.start(); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综合示例演示3种方式的对比<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 线程的互斥：关键字synchronized</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ThreadSynchronized().init();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 内部方法</span></div><div class="line">        <span class="keyword">final</span> Output output = <span class="keyword">new</span> Output();</div><div class="line"></div><div class="line">        <span class="comment">//下面2个线程中的2段代码在线程执行时要互斥</span></div><div class="line">        <span class="comment">//要互斥的代码必须用synchronize代码块包围起来.</span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123; </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</div><div class="line">                    output.output(<span class="string">"cat"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</div><div class="line">                    output.output2(<span class="string">"dog"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span></span>&#123; <span class="comment">// 内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">synchronized</span> (Output.class)&#123;  <span class="comment">// 同步代码块  // this：谁调用我谁就是锁</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                    System.out.print(name.charAt(i));</div><div class="line">                &#125;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 同步函数 （注意：一个方法最好就1个synchronized，如果还有同步代码块就容易产生死锁）</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output2</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                System.out.print(name.charAt(i));</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output3</span><span class="params">(String name)</span></span>&#123; <span class="comment">// 静态同步函数</span></div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                System.out.print(name.charAt(i));</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以必须要用一把锁来挡住冲突的线程，不同的锁是无法挡住这些冲突的线程的.</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock比传统线程模型中的synchronized方法更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。</p>
<p>两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。<br>锁是上在代表要操作的资源的类的内部方法中，而不是线程代码中。</p>
<p>Lock使用lock()、unlock()加锁解锁，比synchronized功能更多，JDK6后性能和synchronized差不多</p>
<p>除此之外Lock接口还有两个非常强大的实现类<br>(1)ReentrantLock重入锁<br>(2)ReentrantReadWriteLock读写锁</p>
<p>相关文章：<br><a href="http://blog.csdn.net/canot/article/details/52050633" target="_blank" rel="external">Java中的锁-Lock接口解析</a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>同步还有个小小的弊端——死锁     </p>
<p>死锁：同步中嵌套同步的锁<br>如你持有一个锁，我也有一个锁，我要到你那里去运行，所以要拿你的锁，<br>而你又要到我这里运行，你跟我也要锁，我不放我的锁我要进你那里去，你也不放你的锁要进我这里来，<br>谁都不放，这种现象就叫死锁，导致程序挂着不动了。</p>
<p>下面看几个死锁示例，面试题也有写出死锁程序，因为，能写出死锁，意味着理解死锁也就能避免死锁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 死锁示例1</div><div class="line"> **/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">1000</span>;</div><div class="line">    Object obj = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  <span class="comment">// 实现Runnable接口后要覆盖run方法 </span></div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(obj)&#123;  <span class="comment">// 同步代码块，锁是obj</span></div><div class="line">                    show();         <span class="comment">// 同步代码块里有同步函数（obj锁里有this锁）</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">// 同步函数，锁是this</span></div><div class="line">        <span class="comment">// 注意：这里放while(true)将会无法死锁</span></div><div class="line">        <span class="keyword">synchronized</span>(obj)&#123; <span class="comment">// 同步函数里有同步代码块，this锁里有obj锁</span></div><div class="line">            <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"同步代码块 : "</span> + tick--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Ticket t = <span class="keyword">new</span> Ticket();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);  </div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);  </div><div class="line">        t1.start();</div><div class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">        t.flag = <span class="keyword">false</span>;</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">死锁示例2</div><div class="line">比上面的简单一些,这个程序要掌握!</div><div class="line">考的是对死锁的理解，能写出来，多线程就差不多了，死锁能理解，就能避免死锁，同步也能很熟了，不熟的话是写不出死锁的.</div><div class="line">用于面试题：请写一个死锁程序</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(<span class="keyword">true</span>));</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(<span class="keyword">false</span>));</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> Object locka = <span class="keyword">new</span> Object();  <span class="comment">// 想要调用locka就得创建对象，麻烦，所以静态（static）方便调用</span></div><div class="line">    <span class="keyword">static</span> Object lockb = <span class="keyword">new</span> Object();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">// 实现Runnable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;       <span class="comment">// 定义一个标记</span></div><div class="line">    Test(<span class="keyword">boolean</span> flag)&#123;</div><div class="line">        <span class="keyword">this</span>.flag = flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   <span class="comment">// 实现Runnable接口后要覆盖run方法 </span></div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 少运行怕锁不上，所以一直循环，为了让它锁上</span></div><div class="line">                <span class="keyword">synchronized</span>(MyLock.locka)&#123;               <span class="comment">// A锁（嵌套B锁）</span></div><div class="line">                    System.out.println(<span class="string">"if locka"</span>);       <span class="comment">// 打印if A锁</span></div><div class="line">                    <span class="keyword">synchronized</span>(MyLock.lockb)&#123;           <span class="comment">// B锁（被A锁嵌套）</span></div><div class="line">                        System.out.println(<span class="string">"if lockb"</span>);   <span class="comment">// 打印if B锁</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(MyLock.lockb)&#123;               <span class="comment">// B锁（嵌套A锁）</span></div><div class="line">                    System.out.println(<span class="string">"else lockb"</span>);     <span class="comment">// 打印else B锁</span></div><div class="line">                    <span class="keyword">synchronized</span>(MyLock.locka)&#123;           <span class="comment">// A锁（被B锁嵌套）</span></div><div class="line">                        System.out.println(<span class="string">"else locka"</span>); <span class="comment">// 打印else A锁</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="多线程间通信问题"><a href="#多线程间通信问题" class="headerlink" title="多线程间通信问题"></a>多线程间通信问题</h1><hr>
<p>线程间通讯其实就是多个线程在操作同一个资源，<br>但是操作的动作不同，一个线程负责存进数据，另一个负责拿走数据<br>所以说得2个run方法存放数据存放在2个类中<br>不过就是因为多个线程在一存一取，一旦发生不同步问题，所以会引发巨大的隐患.</p>
<h2 id="线程间通信机制"><a href="#线程间通信机制" class="headerlink" title="线程间通信机制"></a>线程间通信机制</h2><p>针对上述情况有以下几种解决方案：<br>1.等待唤醒机制<br>2.条件对象Condition:<br>3.BlockingQueue</p>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>等待唤醒机制在开发时非常常见<br>比喻2个人同时做事情，而且做的不一样，等第一个人做完了第二个在做，<br>操作局部数据2个人可以随便<br>操作共享数据时为了避免出现问题会定一个规矩：我完事了叫你动了你在动</p>
<p>3个相关方法：</p>
<ul>
<li><p>wait()<br>等待<br>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。<br>换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。<br>当前线程必须拥有此对象监视器（对象监视器就是同步的锁。什么时候有锁？只有同步才有锁）<br>这个方法需要抓异常<br>特点：放弃了执行资格</p>
</li>
<li><p>notify()<br>唤醒（用在同步里面）（API：java.lang，Object）</p>
</li>
<li><p>notifyAll()<br>集体唤醒线程池中的所有线程（用在同步里面）（API：java.lang，Object）</p>
</li>
</ul>
<p>以上3个方法都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，因为只有同步才具有锁.</p>
<h4 id="等待唤醒机制示例"><a href="#等待唤醒机制示例" class="headerlink" title="等待唤醒机制示例"></a>等待唤醒机制示例</h4><p>需求：子线程循环5次，接着主线程循环10次，接着又回到子线程循环5次，接着再回到主线程又循环10次，如此循环50次，请写出程序。</p>
<p>版本1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ThreadTest().init();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">                            business.SubThread(i);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        ).start();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            business.MainThread(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 经验：要用到共同数据（包括同步锁）或共同算法的的若干个方法应该归在同一个类身上，这种设计正好体现了高类聚和程序的健壮性，易维护。</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> bShouldSub = <span class="keyword">true</span>; <span class="comment">//这里相当于定义了控制该谁执行的一个信号灯</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">MainThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (bShouldSub)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bShouldSub = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">SubThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!bShouldSub)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bShouldSub = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>版本2：优化上一代码<br>不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bShouldMain = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(</div><div class="line">            <span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</div><div class="line">                        <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</div><div class="line">                            <span class="keyword">if</span> (bShouldMain) &#123;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    ThreadTest.class.wait();</div><div class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                    e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">                            &#125;</div><div class="line">                            bShouldMain = <span class="keyword">true</span>;</div><div class="line">                            ThreadTest.class.notify();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ).start();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</div><div class="line">                <span class="keyword">if</span> (!bShouldMain) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        ThreadTest.class.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bShouldMain = <span class="keyword">false</span>;</div><div class="line">                ThreadTest.class.notify();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>版本3：下面使用jdk5中的并发库来实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition subThreadCondition = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bBhouldSubThread = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">                    lock.lock();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (!bBhouldSubThread)</div><div class="line">                            subThreadCondition.await();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">",j="</span> + j);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        bBhouldSubThread = <span class="keyword">false</span>;</div><div class="line">                        subThreadCondition.signal();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        lock.unlock();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        threadPool.shutdown();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            lock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (bBhouldSubThread)</div><div class="line">                    subThreadCondition.await();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">",j="</span> + j);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bBhouldSubThread = <span class="keyword">true</span>;</div><div class="line">                subThreadCondition.signal();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="条件对象Condition"><a href="#条件对象Condition" class="headerlink" title="条件对象Condition"></a>条件对象Condition</h3><p>await/signal/signalAll</p>
<h3 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h3><p><a href="http://blog.csdn.net/suifeng3051/article/details/48807423" target="_blank" rel="external">【Java并发之】BlockingQueue</a></p>
<h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p><a href="http://www.cnblogs.com/linjiqin/p/3217050.html" target="_blank" rel="external">Java多线程-并发协作(生产者消费者模型)</a></p>
<h2 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.wait()，notify()，notify All()，用来操作线程为什么定义在了Object类中？<br>(1)这些方法存在与同步中<br>(2)使用这些方法时必须要标识所属的同步的锁<br>(3)锁可以是任意对象，所以任意对象调用的方法一定定义在Object类中</p>
<p>2.wait()，sleep()有什么区别？<br>(1)wait()：释放资源，释放锁<br>(2)sleep()：释放资源，不释放锁</p>
<p>3.等待的线程在哪呢？<br>线程运行的时候会建立一个线程池，等待线程都临时存在这个线程池当中（线程没挂，但是不能动）<br>notify唤醒的都是线程池中的线程，唤醒的顺序是第一个被等待的，因为是按顺序往里存的</p>
<p>4.为什么定义notifyAll？<br>因为需要唤醒对方线程<br>因为只用notify，容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待！</p>
<p>5.死锁和notifyAll(全部等待)的区别：<br>死锁：我的和你要，你的和我要，谁都不放<br>全部等待：你我都动不了，都不是活的，全冻结了</p>
<p>6.对于多个生产者和消费者，为什么要定义while判断标记？<br>原因：让被唤醒的线程再一次判断标记。</p>
<p>7.生产者和消费者有什么替代方案？<br>JDK1.5之前一个锁对应一个wait notify，如果还想要一组wait notify就得还定义一个锁，<br>在建锁就得在建同步，一同步2个就形成嵌套就容易死锁</p>
<p>JDK1.5现在变成了一个锁有好几组wait notify(可以对应好几个Condition对象)，就是wait notify封装成了Condition对象<br>详细说就是JDK1.5版本中提供了显示的锁机制，以及锁对象身上的等待唤醒操作机制，同时它把等待和唤醒给封装了，一个锁有多个Condition</p>
<p>Lock：替代了Synchronized<br>    lock(); 获取锁（加锁）<br>    unlock(); 释放锁（解锁）<br>    newCondition(); 返回Condition对象</p>
<p>Condition：替代了Object 类的 wait / notify / notifyAll<br>    await();<br>    signal();<br>    signalAll();</p>
<hr>
<h1 id="线程管理类-线程池"><a href="#线程管理类-线程池" class="headerlink" title="线程管理类(线程池)"></a>线程管理类(线程池)</h1><hr>
<h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><p>首先介绍在Tcp服务器编程模型的原理，每一个客户端连接用一个单独的线程为之服务，当与客户端的会话结束时，线程也就结束了，即每来一个客户端连接，服务器端就要创建一个新线程。<br>如果访问服务器的客户端很多，那么服务器要不断的创建和销毁线程，这将严重影响服务器的性能。<br>所以要创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池中。<br>就这样，在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程。</p>
<p>线程池（thread pool）：<br>就是有多个线程</p>
<p>线程池的作用：<br>管理好几个线程，固定几个线程，<br>不然拼命New Thread就浪费资源了，因为如果不对线程的数量进行控制，而不断New Thread（开线程）很浪费资源</p>
<p>线程池就2个东西：<br>几个线程，里面仍了几个任务<br>我们要做的就是把任务扔到池子里让线程池自己办</p>
<p>一个应用程序可能有多个线程池，每个线程池负责一件事，如网络访问有一个线程池，数据库操作有一个线程池，优先级的的操作也有一个池（池就是容器,如List ,Map）</p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。<br>线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。<br>如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。<br>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>下面说下new Thread的弊端及Java四种线程池的使用，对Android同样适用<br>还有但凡和线程池/线程/同步/锁等有关的实践问题，建议尽量不要用Android的解决方案，如AsyncTask，而要用Java中已经历经考验的实践方案 如FutureTask+ThreadPoolExecuters。</p>
<h2 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>执行一个异步任务你还只是如下new Thread吗？<br>那你就out太多了，new Thread的弊端如下：<br>a. 每次new Thread新建对象性能差。<br>b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。<br>c. 缺乏更多功能，如定时执行、定期执行、线程中断。<br>相比new Thread，Java提供的四种线程池的好处在于：<br>a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。<br>b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br>c. 提供定时执行、定期执行、单线程、并发数控制等功能。</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Java5通过Executors提供4种线程池，分别为：</p>
<p>1.newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(index);</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p>
<p>2.newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(index * <span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(index);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 </p>
<p>3.newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</div><div class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"delay 3 seconds"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>表示延迟3秒执行。</p>
<p>定期执行示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。<br>ScheduledExecutorService比Timer类更安全，功能更强大。</p>
<p>4.newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(index);</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果依次输出，相当于顺序执行各个任务。<br>现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p>
<h3 id="相关问题-2"><a href="#相关问题-2" class="headerlink" title="相关问题"></a>相关问题</h3><p>1.如果实现线程死掉后重新启动？<br>创建单一线程池（newSingleThreadExecutor）<br>它里面会创建一个线程，如果这个线程死了就马上在创建一个线程，始终有一个线程活着</p>
<p>2.执行线程的2个方法<br>Executor的execute    （没有返回值）<br>ExecutorService的submit  （有返回值，返回Future&lt;?&gt;）</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>自定义线程池<br>查看Executors源码我们知道，Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，也就是上面所说的四种Executors线程池，但是 ThreadPoolExecutor 提供的功能远不止于此。<br>不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池<br>我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。 </p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolProxy</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> ThreadPoolExecutor  mExecutor;          <span class="comment">// 线程池</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 mCorePoolSize;      <span class="comment">// 核心线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 mMaximumPoolSize;   <span class="comment">// 最大线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span>                mKeepAliveTime;     <span class="comment">// 保持存活时间</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolProxy</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mCorePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.mMaximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.mKeepAliveTime = keepAliveTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initThreadPoolExecutor</span><span class="params">(Runnable task)</span></span>&#123; <span class="comment">//+同步一个时间点只能执行一次这个方法，更严谨</span></div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mExecutor == <span class="keyword">null</span> || mExecutor.isShutdown() || mExecutor.isTerminated())&#123;</div><div class="line">            <span class="comment">// keepAliveTime单位</span></div><div class="line">            TimeUnit unit = TimeUnit.MILLISECONDS;</div><div class="line"></div><div class="line">            <span class="comment">// 任务队列/阻塞队列</span></div><div class="line">            BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();                      <span class="comment">// 不固定大小队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(10);                  // 固定大小队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new PriorityBlockingQueue(initialCapacity, comparator);// 优先级队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new SynchronousQueue&lt;Runnable&gt;();                      // 同步队列，FIFO</span></div><div class="line"></div><div class="line">            <span class="comment">// 线程工厂</span></div><div class="line">            ThreadFactory threadFactory = Executors.defaultThreadFactory();</div><div class="line"></div><div class="line">            <span class="comment">// 错误捕获器（下面这种形式类似策略设计模式）</span></div><div class="line">            RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();         <span class="comment">// 如果出现错误，不做处理</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy();        // 如果出现错误，则直接抛出异常</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();   // 如果出现错误，直接执行加入的任务</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardOldestPolicy();// 如果出现错误,移除第一个任务,执行加入的任务</span></div><div class="line"></div><div class="line">            mExecutor = <span class="keyword">new</span> ThreadPoolExecutor(mCorePoolSize,  mMaximumPoolSize,mKeepAliveTime, unit, workQueue, threadFactory,handler);        </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务（方式1）</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> task</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</div><div class="line">        initThreadPoolExecutor(task); <span class="comment">// 初始化线程池</span></div><div class="line">        mExecutor.execute(task);  <span class="comment">// 执行线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务（方式2）</div><div class="line">     * </div><div class="line">     * submit方法和execute的区别是有返回值的（Future），说明被持有了，然后可以做了操作（如停掉）</div><div class="line">	 * future有cancel方法，可以把线程停掉（整个线程杀掉，任务正在运行就是做耗时操作也是被干掉）</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> task</div><div class="line">     * <span class="doctag">@return</span> Future</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task)&#123;</div><div class="line">        initThreadPoolExecutor(task);</div><div class="line">        <span class="keyword">return</span> mExecutor.submit(task); <span class="comment">// 执行线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * remove方法只是移出任务队列，不归我管了，因为队列里已经没有它</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Runnable task)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (mExecutor != <span class="keyword">null</span>)&#123;</div><div class="line">            mExecutor.remove(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/java-android-thread-pool/" target="_blank" rel="external">Java(Android)线程池</a><br><a href="http://blog.csdn.net/l540675759/article/details/62230562" target="_blank" rel="external">深入理解在Android中线程池的使用</a><br><a href="http://blog.csdn.net/xlxxcc/article/details/52108534" target="_blank" rel="external">Java Executors 和 ThreadPoolExecutor 线程池</a></p>
<hr>
<h1 id="线程范围内共享变量"><a href="#线程范围内共享变量" class="headerlink" title="线程范围内共享变量"></a>线程范围内共享变量</h1><hr>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>线程范围内的共享数据<br>JavsEE（底层框架）用的比较多的知识<br>Andriod用的比较少</p>
<p>先看下线程范围的共享变量的应用场景<br>示例代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData</span></span>&#123;	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>; <span class="comment">// 定义一个全局变量</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Thread,Integer&gt; threadData = <span class="keyword">new</span> HashMap&lt;Thread,Integer&gt;();</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  <span class="comment">// 循环2遍相当于启动2个线程</span></div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;	</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">					threadData.put(Thread.currentThread(), data);</div><div class="line">					<span class="keyword">new</span> A().get();  <span class="comment">// 调用A模块取数据</span></div><div class="line">					<span class="keyword">new</span> B().get();  <span class="comment">// 调用B模块取数据</span></div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> data = threadData.get(Thread.currentThread());</div><div class="line">			System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> data = threadData.get(Thread.currentThread());</div><div class="line">			System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread-0 has put data : 11</div><div class="line">Thread-1 has put data : 22</div><div class="line">A from Thread-0 get data : 11</div><div class="line">A from Thread-1 get data : 22</div><div class="line">B from Thread-0 get data : 11</div><div class="line">B from Thread-1 get data : 22</div></pre></td></tr></table></figure></p>
<p>结果分析：<br>线程1存进去数值11<br>线程2存进去数值22<br>A对象从线程1拿到的也是11，线程2拿到的是22<br>B同样，从线程1和线程2拿到也是11和22<br>这样就实现了每个线程有各自独立的数据，在这个线程范围内，不管哪个对象拿到的也是正常的相同线程的数量变量</p>
<p>下面开始主题，介绍下ThreadLocal<br>ThreadLocal的作用和目的：用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。</p>
<p>ThreadLocal的原理：<br>内部就是一个map<br>每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。在线程结束时可以调用ThreadLocal.clear()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。</p>
<p>ThreadLocal的应用场景：<br>1.订单处理包含一系列操作：减少库存量、增加一条流水台账、修改总账，这几个操作要在同一个事务中完成，通常也即同一个线程中进行处理，如果累加公司应收款的操作失败了，则应该把前面的操作回滚，否则，提交所有操作，这要求这些操作使用相同的数据库连接对象，而这些操作的代码分别位于不同的模块类中。<br>2.银行转账包含一系列操作： 把转出帐户的余额减少，把转入帐户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，转入和转出操作的代码分别是两个不同的帐户对象的方法。<br>3.例如Strut2的ActionContext，同一段代码被不同的线程调用运行时，该代码操作的数据是每个线程各自的状态和数据，对于不同的线程来说，getContext方法拿到的对象都不相同，对同一个线程来说，不管调用getContext方法多少次和在哪个模块中getContext方法，拿到的都是同一个。</p>
<p>实验案例：<br>定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。</p>
<p>ThreadLocal总结：<br>一个ThreadLocal代表一个变量，故其中里只能放一个数据，你有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象。如果有一个百个变量要线程共享呢？那请先定义一个对象来装这一百个变量，然后在ThreadLocal中存储这一个对象。</p>
<p>示例代码2：<br>上述代码替换成ThreadLocal形式，特别简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建议：<br>实现对ThreadLocal变量的封装，让外界不要直接操作ThreadLocal变量。<br>对基本类型的数据的封装，这种应用相对很少见。<br>对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。<br>示例代码3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    MyThreadScopeData myData = <span class="keyword">new</span> MyThreadScopeData();</div><div class="line">                    myData.setName(<span class="string">"name"</span> + data);</div><div class="line">                    myData.setAge(data);</div><div class="line">                    myThreadScopeData.set(myData);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = myThreadScopeData.get();</div><div class="line">            System.out.println(</div><div class="line">                    <span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更优雅的方式，直接单例模式<br>示例代码4：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    MyThreadScopeData.getThreadInstance().setName(<span class="string">"name"</span> + data);</div><div class="line">                    MyThreadScopeData.getThreadInstance().setAge(data);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; map = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadScopeData</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyThreadScopeData <span class="title">getThreadInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 互斥也不用加了</span></div><div class="line">        MyThreadScopeData instance = map.get();</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> MyThreadScopeData();</div><div class="line">            map.set(instance);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="多个线程访问共享对象和数据的方法"><a href="#多个线程访问共享对象和数据的方法" class="headerlink" title="多个线程访问共享对象和数据的方法"></a>多个线程访问共享对象和数据的方法</h2><hr>
<p>需求：设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</p>
<p>示例代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadShareData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ShareData1 data1 = <span class="keyword">new</span> ShareData1();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ShareData1 data2 = <span class="keyword">new</span> ShareData1();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable1(data2)).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable2(data2)).start();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ShareData1 data1 = <span class="keyword">new</span> ShareData1();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                data1.decrement();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                data1.increment();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ShareData1 data1;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable1</span><span class="params">(ShareData1 data1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data1 = data1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data1.decrement();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ShareData1 data1;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable2</span><span class="params">(ShareData1 data1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data1 = data1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data1.increment();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例代码2：（比较复杂）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line"></div><div class="line">        ThreadTest1 tt = <span class="keyword">new</span> ThreadTest1();</div><div class="line"></div><div class="line">        Inc inc = tt.new Inc();</div><div class="line">        Dec dec = tt.new Dec();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread(inc);</div><div class="line">            t.start();</div><div class="line">            t = <span class="keyword">new</span> Thread(dec);</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-inc:"</span> + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-dec:"</span> + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                inc();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                dec();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例代码2：（更简化的版本）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    JManager j = <span class="keyword">new</span> JManager();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> A().call();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        j.accumulate();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        j.subtract();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtract</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="原子类-AtomicInteger、AtomicBoolean…"><a href="#原子类-AtomicInteger、AtomicBoolean…" class="headerlink" title="原子类(AtomicInteger、AtomicBoolean…)"></a>原子类(AtomicInteger、AtomicBoolean…)</h1><hr>
<p>一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。这个类在AsyncTask中用到了。</p>
<p>多个线程访问同一个整数数据的情况下，一定要用这个类</p>
<hr>
<h1 id="线程安全容器类"><a href="#线程安全容器类" class="headerlink" title="线程安全容器类"></a>线程安全容器类</h1><hr>
<p>ConcurrentHashMap<br>BlockingQueue<br>CopyOnWrite容器<br>并发Queue<br>Sorted容器</p>
<h1 id="相关多线程文章"><a href="#相关多线程文章" class="headerlink" title="相关多线程文章"></a>相关多线程文章</h1><p><a href="http://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="external">Java中的多线程你只要看这一篇就够了</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_java_thread.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Java" scheme="https://hengxing0080.github.io/categories/IT-Java/"/>
    
    
      <category term="Java" scheme="https://hengxing0080.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Session &amp; Cookie &amp; Token的区别</title>
    <link href="https://hengxing0080.github.io/2017/09/04/it/2.NetworkProtocol/Session/"/>
    <id>https://hengxing0080.github.io/2017/09/04/it/2.NetworkProtocol/Session/</id>
    <published>2017-09-04T10:20:01.000Z</published>
    <updated>2017-09-29T16:29:48.823Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_session1.jpg" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><hr>
<p>中文名：时域 | 会话<br>外文名：Session<br>应用学科：软件 网络通信<br>属性：用户与交互系统通信的时间间隔</p>
<h2 id="Session简介"><a href="#Session简介" class="headerlink" title="Session简介"></a>Session简介</h2><p>简单理解就是存在服务端的缓存</p>
<p>session的中文翻译是“会话”，当用户打开某个web应用时，便与web服务器产生一次session。<br>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。<br>这种用户信息存储方式相对cookie来说更安全<br>比如说你用某个账号登陆某新浪，那么新浪的服务器端就会生成一个session来记录你的登陆状态，一般10分钟或者20分钟就失效了，<br>而cookie是网页指令让浏览器生成本地的记录你的登陆状态的文件。一般对安全性要求不高的话就可以直接在客户端生成cookie来记录登陆状态，否则就需要超时处理用session</p>
<p>session在WEB技术中占有非常重要的份量。<br>由于网页是一种无状态的连接程序，因此你无法得知用户的浏览状态。<br>因此我们必须通过session记录用户的有关信息，以供用户再次以此身份对web服务器提供要求时作确认，<br>例如，我们在某些网站中常常要求用户登录，但我们怎么知道用户已经登录了呢，<br>如果没有session的话，登录信息是无法保留的，那岂不要让用户在每一页网页中都要提供用户名和密码。 </p>
<h2 id="Session和Cookie的生命周期"><a href="#Session和Cookie的生命周期" class="headerlink" title="Session和Cookie的生命周期"></a>Session和Cookie的生命周期</h2><p>session和cookies都是来存储信息的但是他们的寿命不一样：比如你登录一个网站你有自己的帐号。昵称啊什么的这些就保存在session里当网页不关闭，session就存在。但是当你关闭之后session就清空了。<br>而cookies则可以在电脑的缓存文件里添加记录，这样即使当你的程序关闭了，但是记录却被永久保存了下来。存活期较session长。</p>
<h2 id="Session缺陷"><a href="#Session缺陷" class="headerlink" title="Session缺陷"></a>Session缺陷</h2><p>如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>
<h2 id="Session和Cookie的区别比较"><a href="#Session和Cookie的区别比较" class="headerlink" title="Session和Cookie的区别比较"></a>Session和Cookie的区别比较</h2><p><img src="/images/it_network_session2.jpg" alt="UML图"></p>
<p>用处：<br>两者都可以用来跟踪和保存客户端的状态信息</p>
<p>保存地点：<br>Session是在服务器端创建,在服务端保存(所以Session的安全性高于Cookie)<br>Cookie是在服务器端创建,在客户端保存，</p>
<p>保存类型：<br>Session是依赖于Cookie的, Sessionid还是存放在Cookie中并保存在客户端的浏览器中<br>Cookie中只能存放String类型,而session中可以存放Object类型。</p>
<p>安全性：<br>cookie存在客户端的磁盘上对用户透明<br>session存在服务器端而且sessionID是加密的相对来说seesion较安全。<br>用户的会话通过cookie中存储的session id 来和服务器端的session进行关联从而保持正常的会话。</p>
<h2 id="Session都是可以存在哪？"><a href="#Session都是可以存在哪？" class="headerlink" title="Session都是可以存在哪？"></a>Session都是可以存在哪？</h2><p>数据库、缓存、文件</p>
<h2 id="如果把Cookie-禁掉Session还能用吗？"><a href="#如果把Cookie-禁掉Session还能用吗？" class="headerlink" title="如果把Cookie 禁掉Session还能用吗？"></a>如果把Cookie 禁掉Session还能用吗？</h2><p>1.通过url传值，把session id附加到url上（缺点：整个站点中不能有纯静态页面，因为当是纯静态页面session id 将无法继续向后传了）</p>
<p>2.通过隐藏表单，把session id 放到表单的隐藏文本框中同表单一块提交过去（缺点：不适用<a>标签这种直接跳转的非表单的情况）</a></p>
<p>3.直接配置php.ini文件,将php.ini文件里的session.use_trans_sid= 0设为1,</p>
<p>4.用文件、数据库等形式保存Session ID，在跨页过程中手动调用</p>
<hr>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><hr>
<p>中文名：储存在用户本地终端上的数据<br>外文名：Cookie<br>复数形式：Cookies</p>
<h2 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h2><p>网站为了辨别用户身份，而储存在本地设备上的数据，包括用户名和密码</p>
<p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而储存在用户本地终端上的数据（通常经过加密）。</p>
<p>Cookie是保存在本地终端的数据。<br>Ccokie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</p>
<h2 id="Cookie的组成"><a href="#Cookie的组成" class="headerlink" title="Cookie的组成"></a>Cookie的组成</h2><p>名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”\”)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。</p>
<h2 id="Cookie分两种"><a href="#Cookie分两种" class="headerlink" title="Cookie分两种"></a>Cookie分两种</h2><p>一种叫会话cookie是没有设置过期时间，当关闭浏览器后cookie将消失；<br>另一种是设置了过期时间叫持久cookie，这种cookie存储在磁盘中关闭浏览器后cookie不会消失。</p>
<h2 id="各浏览器Cookie大小、个数限制"><a href="#各浏览器Cookie大小、个数限制" class="headerlink" title="各浏览器Cookie大小、个数限制"></a>各浏览器Cookie大小、个数限制</h2><p>由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。<br>详情查看文章：↓<br><a href="http://www.cnblogs.com/henryhappier/archive/2011/03/03/1969564.html" target="_blank" rel="external">各浏览器Cookie大小、个数限制</a></p>
<hr>
<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><hr>
<p>中文名 令牌，标记<br>外文名 Token </p>
<h2 id="Token简介"><a href="#Token简介" class="headerlink" title="Token简介"></a>Token简介</h2><p>代表执行某些操作的权利的对象,是用户身份的验证方式。</p>
<h2 id="Token组成"><a href="#Token组成" class="headerlink" title="Token组成"></a>Token组成</h2><p>最简单的token组成:<br>　uid(用户唯一的身份标识)<br>　time(当前时间的时间戳)<br>　sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。<br>　还可以把不变的参数也放进token，避免多次查库</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><h3 id="访问令牌（Access-token）"><a href="#访问令牌（Access-token）" class="headerlink" title="访问令牌（Access token）"></a>访问令牌（Access token）</h3><p>表示访问控制操作主体的系统对象</p>
<p>access_token一般作为请求操作时的访问令牌，比如你让用户用QQ登陆后要去拿用户的QQ头像，这时候向腾讯API发送请求时就需要带上access_token。</p>
<p>如果只是单纯的登陆的话，登陆后不做任何请求，理论上是可以不存access_token的，但是还是推荐你按照Oath2.0的标准来做。<br>想象一种情况，我授权了一个应用，它拿到了我的access_token，然后我忘记我授权过了，于是我以后每次发布的内容都被它拿去存起来，或者它利用我的账号偷偷的发消息，我一点都不知道。 这种情况还是很可怕的。</p>
<h3 id="密保令牌（Security-token）"><a href="#密保令牌（Security-token）" class="headerlink" title="密保令牌（Security token）"></a>密保令牌（Security token）</h3><p>或者硬件令牌，例如U盾，或者叫做认证令牌或者加密令牌，一种计算机身份校验的物理设备</p>
<h3 id="会话令牌（Session-token）"><a href="#会话令牌（Session-token）" class="headerlink" title="会话令牌（Session token）"></a>会话令牌（Session token）</h3><p>交互会话中唯一身份标识符</p>
<h3 id="令牌化技术-Tokenization"><a href="#令牌化技术-Tokenization" class="headerlink" title="令牌化技术 (Tokenization)"></a>令牌化技术 (Tokenization)</h3><p>取代敏感信息条目的处理过程</p>
<h3 id="邀请码"><a href="#邀请码" class="headerlink" title="邀请码"></a>邀请码</h3><p>在邀请系统中使用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_session1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 网络 - 相关" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Socket机制</title>
    <link href="https://hengxing0080.github.io/2017/09/03/it/2.NetworkProtocol/Socket/"/>
    <id>https://hengxing0080.github.io/2017/09/03/it/2.NetworkProtocol/Socket/</id>
    <published>2017-09-03T07:19:20.000Z</published>
    <updated>2017-10-06T11:46:50.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_socket1.png" alt="UML图"></p>
<a id="more"></a>
<p>中文名：套接字<br>外文名：Socket<br>英文原义：“孔”或“插座”地方<br>常用类型：流式Socket和数据包式Socket<br>相关模型：对等模型、C/S模型<br>相关应用：C#/C++语言应用, python应用<br>区号：它的网络地址</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>可以理解成码头（港口），2个港口通过船传输货物。所以说想要通讯必须要有港口。<br>或者理解成就是插座。服务器的socket，就是服务器提供插座，等着客户端的插头插进来。一旦插入完成，服务器-客户端的通信就建立了。 ​​</p>
<p>网络编程其实指的就是Socket编程 （Socket编程主要是记住流程，代码是查询文档不是很难）</p>
<p>Socket：套接字，多指传输层网络接口。<br>Socket就是为网络服务提供的一种机制。<br>通信的两端都有Socket。<br>网络通信其实就是Socket间的通信。<br>数据在两个Socket间通过IO传输。</p>
<p>Socket和SocketServer是基于套接字的服务端和客户端实现<br>Socket和SocketServer是服务端和客户端的区别</p>
<p>Socket是为了实现以上的通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。<br>socket只是一种连接模式，不是协议，tcp、udp，简单的说（虽然不准确）是两个最基本的协议,很多其它协议都是基于这两个协议如，http就是基于tcp的，.用socket可以创建tcp连接，也可以创建udp连接，这意味着，用socket可以创建任何协议的连接，因为其它协议都是基于此的。</p>
<h1 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h1><p>根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。<br>（1）服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。<br>（2）客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>（3）连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h1 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h1><p><img src="/images/it_network_socket2.png" alt="UML图"><br><img src="/images/it_network_socket3.png" alt="UML图"></p>
<h1 id="套接字的理解"><a href="#套接字的理解" class="headerlink" title="套接字的理解"></a>套接字的理解</h1><p>中文名 套接字<br>外文名 Socket<br>连接方式 通过传输层进行数据通信<br>流式套接字 双向字节流</p>
<p>源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。<br>其用于标识客户端请求的服务器和服务。<br>它是网络通信过程中端点的抽象表示，<br>包含进行网络通信必需的5种信息：<br>(1)连接使用的协议<br>(2)本地主机的IP地址<br>(3)本地进程的协议端口<br>(4)远地主机的IP地址<br>(5)远地进程的协议端口</p>
<p>TCP/IP的”传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_socket1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 相关" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>URI &amp; URL &amp; URN 的区别</title>
    <link href="https://hengxing0080.github.io/2017/09/02/it/2.NetworkProtocol/URI/"/>
    <id>https://hengxing0080.github.io/2017/09/02/it/2.NetworkProtocol/URI/</id>
    <published>2017-09-02T02:10:51.000Z</published>
    <updated>2017-09-29T16:29:33.429Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_uri1.jpg" alt="UML图"></p>
<a id="more"></a>
<ul>
<li><p>URI ：Uniform Resource Identifier，统一资源标识符<br>统一资源标识符（URI）提供了一个简单、可扩展的资源标识方式。<br>URI规范中的语义和语法来源于万维网全球信息主动引入的概念，万维网从1990年起使用这种标识符数据，并被描述为“万维网中的统一资源描述符”。</p>
</li>
<li><p>URL：Uniform Resource Locator，统一资源定位符<br>URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置。</p>
</li>
<li><p>URN：Uniform Resource Name，统一资源名称<br>URN是URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</p>
</li>
</ul>
<p>注意要记住，其中，URL,URN是URI的子集。<br><img src="/images/it_network_uri2.jpg" alt="UML图"></p>
<hr>
<h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><hr>
<p>中文名：统一资源标识符<br>外文名：Uniform Resource Identifier<br>简称：URI<br>应用：万维网</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>比URL范围更广泛, 接收自定义的路径<br>标识、定位任何资源的字符串<br>该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。<br>URI由包括确定语法和相关协议的方案所定义。<br>Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用URI进行定位。</p>
<p>URI  是一个用于标识某一互联网资源名称的字符串。<br>该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。</p>
<h2 id="URI组成"><a href="#URI组成" class="headerlink" title="URI组成"></a>URI组成</h2><p>URI一般由三部分组成：<br>一、主机名<br>二、标志符<br>三、相对URI</p>
<h2 id="URI示例"><a href="#URI示例" class="headerlink" title="URI示例"></a>URI示例</h2><p>电话<br>tel://110</p>
<p>远程图片<br><a href="http://或者https://" target="_blank" rel="external">http://或者https://</a> </p>
<p>本地文件<br>file:// </p>
<p>Content provider  ( 内容提供者 )<br>content://    </p>
<p>asset目录下资源<br>assets:// </p>
<p>res目录下资源<br>res:// </p>
<hr>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><hr>
<p>中文名：统一资源定位符 | 统一资源定位器<br>外文名：Uniform Resource Locator<br>缩写：URL<br>发明者：蒂姆·伯纳斯·李</p>
<h2 id="URL简介"><a href="#URL简介" class="headerlink" title="URL简介"></a>URL简介</h2><p>简单理解：网络路径地址，用于描述一个网络上的资源, 用于定位万维网上的文档（或其他数据）。如网址http, ftp,  rtsp等等</p>
<p>概念理解：URL是统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。<br>互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<h2 id="URL组成"><a href="#URL组成" class="headerlink" title="URL组成"></a>URL组成</h2><p>网址比如：<a href="http://www.w3school.com.cn/html/index.asp，" target="_blank" rel="external">http://www.w3school.com.cn/html/index.asp，</a><br>遵守这样的语法规则：scheme://host.domain:port/path/filename</p>
<p>解释：<br>scheme - 定义因特网服务的类型。最常见的类型是 http<br>host - 定义域主机（http 的默认主机是 www）<br>domain - 定义因特网域名，比如 w3school.com.cn<br>:port - 定义主机上的端口号（http 的默认端口号是 80）<br>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename - 定义文档/资源的名称</p>
<p>基本URL包含：<br>模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如“协议://授权/路径?查询”。</p>
<p>完整的、带有授权部分的普通统一资源标志符语法看上去如下：<br>协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志</p>
<h2 id="URL例子"><a href="#URL例子" class="headerlink" title="URL例子"></a>URL例子</h2><p><a href="http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff" target="_blank" rel="external">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</a><br>　Schema:                 http<br>　host:                   www.mywebsite.com<br>　path:                   /sj/test/test.aspx<br>　Query String:           name=sviergn&amp;x=true<br>　Anchor:                 stuff</p>
<p><a href="http://www.crazyit.org:80/ethos.php" target="_blank" rel="external">http://www.crazyit.org:80/ethos.php</a><br>　这种可分为如下3个部分<br>　<a href="http://：URL的写部分，只要通过HTTP协议来访问网络，这部分是固定的。" target="_blank" rel="external">http://：URL的写部分，只要通过HTTP协议来访问网络，这部分是固定的。</a><br>　www.crazyit.org：域名部分。只要访问制定的网站，这个部分总是固定的。<br>　ethos.php：网站资源部分。当访问者需要访问不同资源时，这部分是动态改变的。</p>
<p>URL是URI的一个子集，告诉我们访问网络位置的方式。在我们的例子中，URL应该如下所示：</p>
<h2 id="Url最长可以有多长"><a href="#Url最长可以有多长" class="headerlink" title="Url最长可以有多长"></a>Url最长可以有多长</h2><p>在http协议中，其实并没有对url长度作出限制，往往url的最大长度和用户浏览器和Web服务器有关，不一样的浏览器，能接受的最大长度往往是不一样的，当然，不一样的Web服务器能够处理的最大长度的URL的能力也是不一样的。</p>
<p>Microsoft Internet Explorer (Browser)<br>IE浏览器对URL的最大限制为2083个字符</p>
<p>Firefox (Browser)<br>对于Firefox浏览器URL的长度限制为65,536个字符，但当我测试时，最大只能处理8182个字符，这是因为url的长度除了浏览器限制外，还会受Web服务器的限制，而我本机使用的是ubuntu apache服务器，最大处理能力为8192个字符(相差10个字符，不知道是什么原因)，一旦超过这个长度，服务器就返回错误信息。</p>
<p>Safari (Browser)<br>URL最大长度限制为 80,000个字符。</p>
<p>Opera (Browser)<br>URL最大长度限制为190,000个字符。</p>
<p>Google (chrome)<br>url长度一旦超过8182个字符时，出现服务器错误</p>
<p>Apache (Server)<br>能接受最大url长度为8,192个字符，但我的测试数据是8,182。</p>
<p>Microsoft Internet Information Server(IIS)<br>能接受最大url的长度为16,384个字符。</p>
<p>通过上面的数据可知，为了让所有的用户都能正常浏览，我们的URL最好不要超过IE的最大长度限制(2083个字符），当然，如果URL不直接提供给用户，而是提供给程序调用，侧这时的长度就只受Web服务器影响了。</p>
<p>注：可能有些朋友会想当然的认为，如果最大长度限制为2083字符，是不是参数差不多可以传递1000个左右的汉字。这样认为其实是不对的，对于中文的传递，最终会为urlencode后的编码形式进行传递，如果浏览器的编码为UTF8的话，一个汉字最终编码后的字符长度为9个字符。</p>
<p>详情文章：<br><a href="http://www.cnblogs.com/henryhappier/archive/2010/10/09/1846554.html" target="_blank" rel="external">URL最大长度问题</a></p>
<hr>
<h1 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h1><hr>
<p>中文名：统一资源名称<br>外文名：URN<br>全称：Uniform Resource Name<br>作用：标识持久性 Internet 资源</p>
<h2 id="URN简介"><a href="#URN简介" class="headerlink" title="URN简介"></a>URN简介</h2><p>唯一标识一个实体的标识符，但是不能给出实体的位置。<br>系统可以先在本地寻找一个实体，在它试着在Web上找到该实体之前。<br>它也允许Web位置改变，然而这个实体却还是能够被找到。</p>
<p>标识持久性 Internet 资源。<br>URN 可以提供一种机制，用于查找和检索定义特定命名空间的架构文件。<br>尽管普通的 URL 可以提供类似的功能，但是在这方面，URN 更加强大并且更容易管理，因为 URN 可以引用多个 URL。</p>
<p>与 URL 不同，URN 与地址无关。<br>URN 和 URL 都属于 URI。<br>URN在web中主要应用是下拉菜单的制作。使用URN时下拉菜单的易扩展性将会得到很大的提高。<br>P2P下载中使用的磁力链接是URN的一种实现，它可以持久化的标识一个BT资源，资源分布式的存储在P2P网络中，无需中心服务器用户即可找到并下载它。</p>
<h2 id="URN示例"><a href="#URN示例" class="headerlink" title="URN示例"></a>URN示例</h2><p>URN是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bitpoetry.io/posts/hello.html#intro</div></pre></td></tr></table></figure></p>
<p>URL也是URI的一个子集，告诉我们访问网络位置的方式。上述URN的URN形式写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://bitpoetry.io/posts/hello.html</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_uri1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 相关" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议</title>
    <link href="https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/UDP/"/>
    <id>https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/UDP/</id>
    <published>2017-09-01T15:10:05.000Z</published>
    <updated>2017-09-29T08:21:43.696Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_udp.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名　用户数据报协议<br>外文名　User Datagram Protocol<br>特点　不可靠快速传输<br>简称　UDP<br>用途　应用程序之间的简单通信</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个简单的面向数据报的运输层协议。<br>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。<br>由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快<br>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p>
<h1 id="UDP连接和TCP的不同之处"><a href="#UDP连接和TCP的不同之处" class="headerlink" title="UDP连接和TCP的不同之处"></a>UDP连接和TCP的不同之处</h1><p>Tcp：<br>滑动窗口协议. 拥塞控制.<br>面向连接<br>类似InputStream和OutputStream，是个流，流里的数据不会断开，前后顺序也不会混乱<br>画面优先（数据不丢包）</p>
<p>Udp：<br>不关心数据是否达到,是否阻塞<br>面向无连接<br>流畅优先（速度快）</p>
<h1 id="Java中的UDP"><a href="#Java中的UDP" class="headerlink" title="Java中的UDP"></a>Java中的UDP</h1><p>对象：DatagramSocket与DatagramPacket</p>
<p>步骤：<br>建立发送端，接收端。<br>建立数据包。<br>调用Socket的发送接收方法。<br>关闭Socket。</p>
<p>运行顺序：<br>发送端与接收端是两个独立的运行程序。<br>因为是面向无连接，所以先运行哪个都行</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_udp.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/TCP/"/>
    <id>https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/TCP/</id>
    <published>2017-09-01T13:11:55.000Z</published>
    <updated>2017-09-29T08:21:38.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_tcp0.png" alt="UML图"></p>
<a id="more"></a>
<p>中文名　传输控制协议<br>英文名　Transmission Control Protocol<br>简称　TCP</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TCP 用于应用程序之间通信的一种协议规范,用于从应用程序到网络的数据传输控制。<br>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p>
<p>提供的是面向连接、可靠的字节流服务。<br>当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。<br>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端</p>
<p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。<br>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>TCP传输数据量大，UDP也能大量数据传输，不过UDP是以小包方式发出.</p>
<hr>
<h1 id="TCP的3次握手（连接建立）"><a href="#TCP的3次握手（连接建立）" class="headerlink" title="TCP的3次握手（连接建立）"></a>TCP的3次握手（连接建立）</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。<br>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK ，并最终对对方的 SYN 执行 ACK 确认。<br>这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>类似打电话效果<br>第一次握手：客户端发送数据包给服务端，等待服务器确认好建立连接（SYN)<br>第二次握手：服务器收到数据包，同时自己给发送个数据包给客户端（SYN+ACK）<br>第三次握手：客户端收到服务器的数据包，向服务器发送确认数据（ACK）<br>此包发送完毕，客户端和服务器进行连接状态，完成三次握手</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/images/it_network_tcp1.png" alt="UML图"></p>
<hr>
<h1 id="TCP的4次挥手（连接终止）"><a href="#TCP的4次挥手（连接终止）" class="headerlink" title="TCP的4次挥手（连接终止）"></a>TCP的4次挥手（连接终止）</h1><hr>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。<br>所谓四次挥手,是指断开一个TCP连接时，客户端和服务端发送4个包。<br>断开连接，双方都是可以主动断开的。客户端和服务端都有可能是主动断开者.<br>断开连接和和建立连接的区别：建立连接主动方永远是客户端，碰不到服务器来连接客户端</p>
<h2 id="挥手流程"><a href="#挥手流程" class="headerlink" title="挥手流程"></a>挥手流程</h2><ol>
<li><code>主动方</code> 发送请求给 <code>被动方</code>，请求断开连接.（FIN）</li>
<li><code>被动方</code> 接收断开请求，对 <code>主动方</code> 发送响应:收到断开请求。（ACK）</li>
<li><code>被动方</code> 送数据包给 <code>主动方</code> 你可以关闭了，并关闭与 <code>主动方</code> 的连接。（FIN）</li>
<li><code>主动方</code> 收到断开信号后，对 <code>被动方</code> 发送数据包:我断了哦。（ACK）</li>
</ol>
<h2 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h2><p><img src="/images/it_network_tcp2.png" alt="UML图"></p>
<h1 id="TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？"><a href="#TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？" class="headerlink" title="TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？"></a>TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？</h1><p><img src="/images/it_network_tcp3.jpg" alt="UML图"></p>
<ul>
<li><p>SYN：同步标志<br>同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。</p>
</li>
<li><p>ACK：确认标志<br>确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。</p>
</li>
<li><p>RST：复位标志<br>复位标志有效。用于复位相应的TCP连接。</p>
</li>
<li><p>URG：紧急标志<br>   紧急(The urgent pointer) 标志有效。紧急标志置位，</p>
</li>
<li><p>PSH：推标志<br>   该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。</p>
</li>
<li><p>FIN：结束标志<br>   带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据</p>
</li>
</ul>
<h1 id="Java中的TCP"><a href="#Java中的TCP" class="headerlink" title="Java中的TCP"></a>Java中的TCP</h1><p>TCP分客户端和服务端<br>客户端对应的对象是Socket<br>服务端对应的对象是ServerSocket</p>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="external">TCP 协议简介</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_tcp0.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>运算符系列：位运算符</title>
    <link href="https://hengxing0080.github.io/2017/08/25/it/1.Java/OperationBitwise/"/>
    <id>https://hengxing0080.github.io/2017/08/25/it/1.Java/OperationBitwise/</id>
    <published>2017-08-25T03:54:12.000Z</published>
    <updated>2017-10-05T16:06:24.364Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_bitwise.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>位运算符：位是二进制位的位，也就是说位运算符是直接对二进制进行运算的符号<br> 它是做所有运算中最快的<br> 有局限性，以2的倍数增长<br>（左移右移）</p>
<hr>
<h1 id="各个分析"><a href="#各个分析" class="headerlink" title="各个分析"></a>各个分析</h1><hr>
<h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>越往左移，数越大</p>
<h3 id="运算规律"><a href="#运算规律" class="headerlink" title="运算规律"></a>运算规律</h3><p>就是2的倍数或者2的几次幂 </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>3&lt;&lt;2 = 12<br>　3左移2位 等于12，实际上就是 3<em>4 =12　或者 3</em>22(3<em>(2</em>2)<br>　3的二进制表示形式：0000-0000-0000-0000-0000-0000-0000-0011<br>　12的二进制表示形式：0000-0000-0000-0000-0000-0000-0000-1100<br>　左移2位（舍弃），右边缺2个拿0补<br>3&lt;&lt;1 = 6<br>　实际上就是 3<em>2=6或3</em>21(3<em>(2</em>1)<br>　00000011 3&lt;&lt;1(左移1位) 之后：00000110 就是6<br>3&lt;&lt;3 =24<br>　实际上就是 3<em>8=24或3</em>23（3<em>(2</em>2*2)</p>
<h2 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移&gt;&gt;"></a>有符号右移&gt;&gt;</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>右移位运算就是将左操作数的比特位向右移动第二个操作数指定的位数，在二进制中，首位是用来表示正负的，若右移运算符的第一个操作数是正数，就填充0，是负数就填充1；</p>
<p>最高位补什么由原有数据的最高位值而定（最高位：如1111-1111）<br>如果最高位0，右移后，用0补空位<br>如果最高位1，右移后，用1补空位</p>
<p>就是将那个数转为2进制然后在前面补0或1<br>如果是正数就补0<br>负数补1</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>越往右移，数越小</p>
<h3 id="运算规律-1"><a href="#运算规律-1" class="headerlink" title="运算规律"></a>运算规律</h3><p>就是除以2的几次幂</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>6&gt;&gt;2 = 1<br>　6右移2位是1，实际上就是 6/2(2)=1 或者 6/(2<em>2)<br>　等于6除以4，都是整数，所以小数点舍弃得1<br>　右移2位（舍弃），左边补2个0<br>6&gt;&gt;1 = 3<br>　实际上就是 6/2 = 3<br>6&gt;&gt;3 = 0<br>　实际上就是 3</em>2 = 6<br>11 &gt;&gt; 2<br>　则是将数字11右移2位<br>　11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011，然后把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。<br>　则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。<br>　转换为十进制是2。
　</p>
<h2 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义</p>
<h3 id="运算规律-2"><a href="#运算规律-2" class="headerlink" title="运算规律"></a>运算规律</h3><p>物理最高位是什么，右移后，都用0补</p>
<h3 id="无符号右移与有符号右移的区别"><a href="#无符号右移与有符号右移的区别" class="headerlink" title="无符号右移与有符号右移的区别"></a>无符号右移与有符号右移的区别</h3><p>无符号始终补0</p>
<h2 id="与运算-amp"><a href="#与运算-amp" class="headerlink" title="与运算&amp;"></a>与运算&amp;</h2><p>概述：&amp;符号也可以做位运算符存在<br>运算技巧：0是假，1是真<br>示例：6 &amp; 3 = 2<br>示例代码： System.out.println(6 &amp; 3);<br><img src="/images/it_algorithm_bitwise2.png" alt="UML图"></p>
<h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算|"></a>或运算|</h2><p>示例：6 | 5 = 7<br><img src="/images/it_algorithm_bitwise3.png" alt="UML图"></p>
<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算^"></a>异或运算^</h2><p>示例：6 ^ 5 = 3<br>示例代码： System.out.println(6 ^ 5);<br><img src="/images/it_algorithm_bitwise4.png" alt="UML图"></p>
<h3 id="异或技巧"><a href="#异或技巧" class="headerlink" title="异或技巧"></a>异或技巧</h3><p>范例：7 ^ 4 = 3<br>范例：7 ^ 4 ^ 4 = 7<br>范例：7 ^ 5 ^ 5 = 7<br>结论：一个数异或同一个数2次，结果还是那个数。  （这个规律要记住）<br><img src="/images/it_algorithm_bitwise5.png" alt="UML图"></p>
<h3 id="异或用途"><a href="#异或用途" class="headerlink" title="异或用途"></a>异或用途</h3><p>用于加密算法，异或一次变反了，在异或一次就变回来了</p>
<p>数据加密（把某个数如4异或一次）<br>数据解密（和4在异或一次）</p>
<p>还有更复杂的加密方式，如又与又或有很多种运算，这就叫加密算法</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码~"></a>反码~</h2><p>理解：就是取反</p>
<p>示例代码： System.out.println(~7);</p>
<p>范例：<br>~6 = -7  (正6的取反)<br><img src="/images/it_algorithm_bitwise6.png" alt="UML图"></p>
<p>~-6 = -7+1  （负6的取反）<br><img src="/images/it_algorithm_bitwise7.png" alt="UML图"></p>
<hr>
<h1 id="面试题和使用场景"><a href="#面试题和使用场景" class="headerlink" title="面试题和使用场景"></a>面试题和使用场景</h1><hr>
<h2 id="1-最有效率的方式算出2乘以8等于几？"><a href="#1-最有效率的方式算出2乘以8等于几？" class="headerlink" title="1.最有效率的方式算出2乘以8等于几？"></a>1.最有效率的方式算出2乘以8等于几？</h2><p>最有效率的方式不是2*8，它的底层还是二进制运算<br>二进制是10000<br>十进制是16<br><img src="/images/it_algorithm_bitwise8.png" alt="UML图"></p>
<p>最高效的运算是位运算：2&lt;&lt;3<br>2乘以8：8是2的三次方，也就是将2左移3位（这3位去掉），右边补位（3个0），等于16<br><img src="/images/it_algorithm_bitwise9.png" alt="UML图"></p>
<h2 id="2-对两个整数变量的值进行互换"><a href="#2-对两个整数变量的值进行互换" class="headerlink" title="2.对两个整数变量的值进行互换"></a>2.对两个整数变量的值进行互换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperateDemo2</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = <span class="number">3</span>,m = <span class="number">8</span>;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"n="</span>+n+<span class="string">",m="</span>+m);  <span class="comment">// 打印互换之前的变量</span></div><div class="line"></div><div class="line">        <span class="comment">// 1.通过定义第三方变量（推荐这种最简单的方式，开发常用，阅读性强）</span></div><div class="line">        <span class="comment">//  11 = 3 + 8;</span></div><div class="line">        <span class="comment">//  3 = 11 - 8;</span></div><div class="line">        <span class="comment">//  8 = 11 - 3;</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        temp = n;</div><div class="line">        n = m;</div><div class="line">        m = temp;</div><div class="line"></div><div class="line">        <span class="comment">// 2.不用第三方变量</span></div><div class="line">        <span class="comment">// 2.1.第一种方式：(但是有局限性，如果n和m的值非常大，容易超出int范围，容易损失精度)</span></div><div class="line">        n = n + m;  <span class="comment">// 3+8=11，此时n=11</span></div><div class="line">        m = n - m;  <span class="comment">// 11-8=3，此时m=3</span></div><div class="line">        n = n - m;  <span class="comment">// 11-3=8，此时n=8</span></div><div class="line"></div><div class="line">        <span class="comment">// 2.2.第二种方式：(技巧型方式，记这个有规则，左边是nmn，右边是nnn和mmm)</span></div><div class="line">        n = n ^ m;</div><div class="line">        m = n ^ m;  <span class="comment">// 过程：(n^m)^m  （m异或一个数2次所以还是n）</span></div><div class="line">        n = n ^ m;  <span class="comment">// 过程：n^(n^m)                                      */</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"n="</span>+n+<span class="string">",m="</span>+m);   <span class="comment">// 打印互换之后的变量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_bitwise.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - Java" scheme="https://hengxing0080.github.io/categories/IT-Java/"/>
    
    
      <category term="Java" scheme="https://hengxing0080.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之12 —— 享元模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/23/it/2.OOP&amp;DesignPattern/2.12.Flyweight/"/>
    <id>https://hengxing0080.github.io/2017/08/23/it/2.OOP&amp;DesignPattern/2.12.Flyweight/</id>
    <published>2017-08-23T13:10:30.000Z</published>
    <updated>2017-09-29T16:19:11.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：享元模式<br>英文名：Flyweight Pattern<br>又名：共享模式<br>所属类型：结构型模式<br>设计原则：遵循 单一职责<br>使用概率：90%<br>复杂度：中</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_flyweight1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍：<br>(1) Flyweight(抽象享元角色)：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。在Java中可以由抽象类、接口来担当。</p>
<p>(2) ConcreteFlyweight(具体享元角色)：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。</p>
<p>(3) UnsharedConcreteFlyweight(具体不共享享元角色)：指那些不需要共享的Flyweight子类，因为Flyweight接口共享成为可能，但它并不强制共享.</p>
<p>(4) FlyweightFactory(享元工厂角色)：负责创建和管理享元角色.用于维护一个对象存储池来存放内部状态的对象.要想达到共享的目的，这个角色的实现是关键！</p>
<p>(5) Client(客户端角色)：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。</p>
<p>享元模式包含有单纯享元模式和复合享元模式，单纯享元模式是没有具体不共享享元角色的。<br>当然，上面开头的UML图提到是复合享元模式。<br>下面UML图的是单纯享元模式.<br><img src="/images/it_pattern_flyweight2.jpg" alt="UML图"></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>使用共享对象可有效地支持大量的细颗度的对象。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对象共享，可以避免大量非常相似类的开销。<br>运用共享技术有效地支持大量细粒度的对象。</p>
<p>它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。<br>通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。</p>
<p>享元模式是对象池的一种实现，代表轻量级的意思。<br>用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享，避免创建过多对象的效果，这样一来就可以提升性能，避免内存溢出等。<br>享元对象中的部分状态是可以共享，可以共享的状态称为内部状态，内存状态不会随着环境变化，不可共享的状态则称为外部状态，它们会随着环境的改变而改变。在享元模式中会简历一个对象容器，在景点的享元模式中该容器为一个Map，它的健是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免了创建过多对象的问题。</p>
<h1 id="两个状态（内部状态和外部状态）"><a href="#两个状态（内部状态和外部状态）" class="headerlink" title="两个状态（内部状态和外部状态）"></a>两个状态（内部状态和外部状态）</h1><p>享元模式中关键要理解“内蕴状态”和“外蕴状态”这两个概念。<br>内蕴状态：（Internal State）存储在享元内部，不会随环境的改变而有所不同，是可以共享的<br>外蕴状态：（External State）是不可以共享的，它随环境的改变而改变的，因此外蕴状态是由客户端来保持（因为环境的变化是由客户端引起的）。</p>
<hr>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><hr>
<p>针对上述的UML结构图的代码示例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">// Flyweight类，它是所有具体享元类的超类或接口，通过这个接口，Flyweight可以接受并作用于外部状态</div><div class="line">abstract class Flyweight&#123;</div><div class="line">    public abstract void Operation(int extrinsicstate);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteFlyweight是继承Flyweight超类或实现Flyweight接口，并为内部状态增加存储空间</div><div class="line">class ConcreteFlyweight : Flyweight&#123;</div><div class="line">    public overridevoid Operation(int extrinsicstate)&#123;</div><div class="line">        Console.WriteLine(“具体Flyweight：” extrinsicstate);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// UnsharedConcreteFlyweight是指那些不需要共享的Flyweight子类。</div><div class="line">// 不过为什么有UnsharedConcreteFlyweight的存在呢？</div><div class="line">// 因为Flyweight接口共享称为可能，但它并不强制共享.</div><div class="line">// 说白了就是因为个别时候也有可能不需要共享的，它的存在解决那么不需要共享对象的问题.</div><div class="line">class UnsharedConcreteFlyweight: Flyweight&#123;</div><div class="line">    public overridevoid Operation(int extrinsicstate)&#123;</div><div class="line">        Console.WriteLine(“不共享的具体Flyweight：” extrinsicstate);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// FlyweightFactory，是一个享元工厂，用来创建并管理Flyweight对象。它主要是用来确保合理地共享Flyweight对象。它主要是用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）</div><div class="line">class FlyweightFactory&#123;</div><div class="line">    private Hashtable flyweights = new Hashtable();</div><div class="line">    public FlyweightFactory()&#123;</div><div class="line">        // 初始化工厂时，先生成三个实例</div><div class="line">        flyweights.Add(“X”,new ConcreteFlyweight());</div><div class="line">        flyweights.Add(“Y”,new ConcreteFlyweight());</div><div class="line">        flyweights.Add(“Z”,new ConcreteFlyweight());</div><div class="line">        // FlyweightFactory根据客户需求返回早已生成好的对象，但一定要事先生成对象实例吗？</div><div class="line">        // 不一定需要，完全可以初始化时什么也不做，到需要时，再去判断对象是否为null来决定是否实例化</div><div class="line">&#125;</div><div class="line">public Flyweight GetFlyweight(string key)&#123;</div><div class="line">        return ((Flyweight)flyweight[key]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码</div><div class="line">public class Client&#123;</div><div class="line">    static void Main(string[] args)&#123;</div><div class="line">        int extrinsicstate = 22; // 代码外部状态</div><div class="line"></div><div class="line">        FlyweightFactory f = new FlyweightFactory();</div><div class="line"></div><div class="line">        Flyweight fx = f.GetFlyweight(“X”);</div><div class="line">        fx.Operation(--extrinsicstate);</div><div class="line"></div><div class="line">        Flyweight fy = f.GetFlyweight(“Y”);</div><div class="line">        fy.Operation(--extrinsicstate);</div><div class="line"></div><div class="line">        Flyweight fz = f.GetFlyweight(“Z”);</div><div class="line">        fz.Operation(--extrinsicstate);</div><div class="line"></div><div class="line">        UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();</div><div class="line">        uf.Operation(--extrinsicstate );</div><div class="line"></div><div class="line">        Console.Read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 结果显示</div><div class="line">具体Flyweight:21</div><div class="line">具体Flyweight:20</div><div class="line">具体Flyweight:19</div><div class="line">不共享的具体Flyweight:18</div></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>1.系统中存在大量的相似对象。<br>2.细颗度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。<br>3.需要缓冲池的场景。<br>4.一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p>总之就是如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用，还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p>
<h1 id="使用情景案例"><a href="#使用情景案例" class="headerlink" title="使用情景案例"></a>使用情景案例</h1><p>1.买火车票（Android源码设计模式解析与实战——22.5）</p>
<p>2.String（Android源码设计模式解析与实战——22.5）<br>在JDK中String也是类似消息池，Java中String是存在于常量池中。也就是一个String被定义之后它就被缓存到了常量池中，当其他地方要使用同样的字符串时，则直接使用的是缓存，而不会重复创建。</p>
<p>3.围棋和五子棋（Android源码设计模式解析与实战——26.5）</p>
<p>4.在word经常输入英文字符<br>如输出ABCDEFD很多很多的字符，每一个字符都是一个对象，最后导致会有很多的小对象，浪费！<br>所以，只要定义26个对象，分别代表26个字母，然后表示不同位置出现的对象<br>例：itegrity<br>其中有2个位置出现了i，所以定义i为一个对象，<br>这个对象有个叫显示的方法（display），<br>这个方法然后接收参数（在哪个地方显示），传入x位置和y位置（外部的状态）<br>例：i.display(int x,int y)<br>这样对象的数量大大的减少了</p>
<p>5.字处理软件<br>如果以每个文字都作为一个对象，几千个字，对象数就是几千，无疑是耗费内存，所以找出这些对象群的共同点，设计一个元类，封装可以被共享的类。</p>
<p>6.电脑桌面图标<br>桌面上的图标，比如文件夹，如果每一个文件夹图标都要建立一个对象那是很多很多的对象，<br>因为文件夹都是一样的外表，就定义成一个对象，叫做图标，有显示的位置和标题</p>
<p>7.缓存<br>把那些基本整数很小的，把它们缓存起来，在哪个地方出现整数就把这个缓存整数弄出来，而不是该定义一个新的整数对象</p>
<p>8.QQ好友管理器<br>管理并显示每一个好友发来的消息。在聊天的过程中，与一个好友之间的通信联系只通过一个享元对象实现消息的发送与接收，而不是每次发送接收消息都生成一个新的对象。</p>
<p>9.网吧管理软件<br>在网吧管理软件中，客户机软件向服务器软件发出请求（如：举手、上线解屏、下线锁屏……），服务器软件也会向客户机发出指令（如：远程关机，远程监视……），不管客户端与服务器端发生多少次交互，在服务器端每个客户端只保留一个对象实例，服务器与每个客户端之间通信就是通过该对象来实现的。</p>
<p>10.生成各种口味的咖啡（来源：大话设计模式-吴强————12.5咖啡外卖店）<br>客户买咖啡下订单，订单只区分咖啡口味，如果下了1W个订单，而咖啡店只卖20种口味的咖啡，那么久没有必要生成1W个订单对象，通过享元模式只需要生成20个订单对象。</p>
<p>11.在XML等数据源中的应用（来源：大话设计模式-吴强————Flyweight模式在XML等数据源中的应用）</p>
<h1 id="享元模式与单例模式的区别"><a href="#享元模式与单例模式的区别" class="headerlink" title="享元模式与单例模式的区别"></a>享元模式与单例模式的区别</h1><p><a href="http://www.cnblogs.com/feimo/archive/2013/05/23/3094424.html" target="_blank" rel="external">单例模式与享元模式</a></p>
<h1 id="Android源码中的享元模式实现"><a href="#Android源码中的享元模式实现" class="headerlink" title="Android源码中的享元模式实现"></a>Android源码中的享元模式实现</h1><p>1.Android中的Message、Parcel和TypedArray都利用了享元模式。<br>比如Message.obtainMessage通过重用Message对象来避免大量的Message对象被频繁的创建和销毁。</p>
<p>2.定义成员变量，都是享元模式。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 享元设计模式(只声明一次,为下面所有操作共享这些成员变量)</div><div class="line"> */</div><div class="line">private AlertDialog dialog;</div><div class="line">private AlertDialog.Builder builder;</div><div class="line">private View view;</div><div class="line">private EditText et_password;</div><div class="line">private Button bt_ok;</div><div class="line">private Button bt_cancel;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>享元模式实现比较简单，但是它的作用在某些场景确实极其重要的。<br>它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，<br>但它同时也提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>大幅度降低内存中对象的数量</p>
<p>缺点：<br>1.使系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使程序的逻辑复杂化。<br>2.享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。<br>3.使用享元模式需要维护一个记录了系统已有的所有享元的列表，而这本身需要耗费资源。</p>
<p>所以应当在有足够多的对象实例可供共享时才值得使用享元模式。</p>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="http://www.cnblogs.com/V1haoge/p/6542449.html" target="_blank" rel="external">Java设计模式之《享元模式》及应用场景</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：享元模式&lt;br&gt;英文名：Flyweight Pattern&lt;br&gt;又名：共享模式&lt;br&gt;所属类型：结构型模式&lt;br&gt;设计原则：遵循 单一职责&lt;br&gt;使用概率：90%&lt;br&gt;复杂度：中&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_flyweight1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之11 —— 桥接模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/22/it/2.OOP&amp;DesignPattern/2.11.Bridge/"/>
    <id>https://hengxing0080.github.io/2017/08/22/it/2.OOP&amp;DesignPattern/2.11.Bridge/</id>
    <published>2017-08-22T12:05:31.000Z</published>
    <updated>2017-09-29T16:19:06.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：桥接模式<br>英文名：Bridge Pattern<br>又名：桥梁模式 / 柄体(Handle and Body)模式 / 接口(Interface)模式<br>所属类型：结构型模式<br>设计原则：遵循 单一职责、迪米特、开放-封闭原则、合成/聚合复用原则（桥接模式的代表原则）<br>使用概率：20%<br>复杂度：中高</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_bridge1.jpg" alt="UML图"><br><a id="more"></a><br>角色介绍：</p>
<ul>
<li><p>Abstraction：抽象部分<br>该类保持一个对实现对象的引用，抽象部分中的方法需要调用实现部分的对象来实现，该类一般都抽象类。</p>
</li>
<li><p>RefinedAbstraction：优化的抽象部分<br>抽象部分的具体实现，该类一般是对抽象部分的方法进行完善和扩展。</p>
</li>
<li><p>Implementor：实现部分<br>可以为接口或抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分这些基本操作的业务方法。</p>
</li>
<li><p>ConcreteImplementorA/ConcreteImplementorB：实现部分的具体实现<br>完善实现部分中方法定义的具体逻辑</p>
</li>
<li><p>Client：客户类，客户端程序</p>
</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>什么叫抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>连接两地的交通枢纽</p>
<p>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。</p>
<p>将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化.</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1.分离接口及其实现部分，这里实现了Abstraction和Implementor的分离，有助于降低对实现部分的依赖性，从而产生更好的结构化系统。<br>2.提高了可扩充性，可以独立的对Abstraction和Implementor层次结构进行扩充.</p>
<hr>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><hr>
<p>针对上述的UML结构图的代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现部分的抽象接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span></span>&#123;</div><div class="line">    <span class="comment">// 实现抽象部分的具体方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImpl</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现部分具体的实现一</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImple</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 具体的实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现部分具体的实现二</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementrorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationImple</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 具体的实现</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象部分的实现</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Implementor mImplementor; <span class="comment">//声明一个私有成员变量引用实现部分的对象</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通过实现部分对象的引用构造抽象部分的对象</div><div class="line">     * <span class="doctag">@param</span> implementor 实现部分对象的引用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span></span>&#123;</div><div class="line">        mImplementor = implementor;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通过调用实现部分具体的方法实现具体的功能</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</div><div class="line">        mImplementor.operationImpl();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 抽象部分的子类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(implementor);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 对父类抽象部分中的方法进行扩展</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refinedOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">// 对Abstraction中的方法进行扩展</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户端实现</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 客户调用逻辑</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>多角度去分类实现对象，而只用继承会造成大量的类增加，不能满足开放-封闭原则时，就应该要考虑用桥接模式了。</p>
<p>桥梁的作用其实就是连接“抽象部分”与“实现部分”,但是事实上，任何多维度变化或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。<br>如果一个系统需要在构建的抽象化和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，可以通过桥接模式使它们在抽象层建立一个关联关系。<br>对象那么不希望使用继承或因为多层次几层导致系统类的个数急剧增加的系统，也可以考虑使用桥接模式。</p>
<p>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<h1 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h1><p>1.手机品牌和手机软件（大话设计模式——22章）</p>
<p>2.咖啡厅喝咖啡（Android源码设计模式解析与实战——24.5）<br>去咖啡馆喝咖啡一般分为4种：大杯加糖，大杯不加糖，小杯加糖，小杯不加糖.<br>对一杯咖啡来说这4种实质上就两种变化，一是大杯小杯，二是加糖不加糖.</p>
<p>3.实现不同样式的ProgressBar（Android源码设计模式解析与实战——24.8）</p>
<p>4.进行数据库dao类设计也会使用到桥接模式</p>
<p>5.开关与具体的电器<br>开关的类型有多种，而电器也是各式各样，这两者是独立变化的且又有耦合</p>
<p>6.显示屏<br>显示屏的尺寸与生厂商之间也是一种二维关系，具体的尺寸与具体的厂商独立变化</p>
<p>7.蜡笔与毛笔（大话设计模式（吴强）——第六章 蜡笔与毛笔）<br>蜡笔的颜色和蜡笔本身是分不开的，所以就造成必须使用36支色彩与大小各异的蜡笔来绘制图画。<br>而毛笔与颜料能够很好的脱耦，个子独立变化，便简化了操作。</p>
<p>8.Java的JRE<br>JRE本身就是一个桥，先写好在linex上执行的JRE，在写好可以在windows下执行的JRE，这样无论什么样的Java程序，只要配合相应的JRE就能在Linux或者Windows上运行。两个JRE兵没有限定你写什么样的程雪，但要求你必须用Java来写。</p>
<h1 id="Android源码中的桥接模式实现"><a href="#Android源码中的桥接模式实现" class="headerlink" title="Android源码中的桥接模式实现"></a>Android源码中的桥接模式实现</h1><p>1.Window与WindowManager</p>
<p>2.WindowManagerService</p>
<p>3.Adapter与AdapterView</p>
<p>4.View的视图曾觌与执行真正的硬件绘制相关功能实现类（DisplayList, HadrdwareLayer和Canvas负责）之间的关系是可以看做是一种桥接模式</p>
<p>5.对于Android来说，应用层与Native层之间的交互就是一个最好的例子<br>需要操纵Android设备硬件时就需要使用一个连接应用层与Native的桥梁，这个桥梁通常是一个具体的类，比如提供操作相机的Camera，播放音视频的MediaPlayer，提供图形绘制接口的OpenCV等，这些API类为我们操作底层硬件提供了可能。</p>
<h1 id="与其它模式的区别"><a href="#与其它模式的区别" class="headerlink" title="与其它模式的区别"></a>与其它模式的区别</h1><p>桥接模式与适配器模式有什么不用？<br>公共点：桥接和适配器都是让两个东西配合工作<br>不同点：出发点不同。<br>适配器模式：改变已有的两个接口，让他们相容。<br>桥接模式：分离抽象化和实现，使两者的接口可以不同，目的是分离。<br>所以说，如果拿到两个已有模块，想让他们同时工作，那么你使用适配器。<br>如果还什么都没有，但是想分开实现，那么桥接生一个选择。<br>桥接是先有桥，才有两端的东西。<br>适配是现有两边，才有适配器。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>桥接模式可以应用到许多开发中，但是它应用得却不多，一个很重要的原因是对于抽象与实现的分离的把握，是不是需要分离，如何分离？<br>所以对设计者来说要有一个恰到好处的分寸。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>分离抽象与实现，灵活的扩展以及对客户来说透明的实现</p>
<p>缺点：<br>不容易设计，对开发者来说要有一定的经验要求。理解很容易，设计却不容易。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：桥接模式&lt;br&gt;英文名：Bridge Pattern&lt;br&gt;又名：桥梁模式 / 柄体(Handle and Body)模式 / 接口(Interface)模式&lt;br&gt;所属类型：结构型模式&lt;br&gt;设计原则：遵循 单一职责、迪米特、开放-封闭原则、合成/聚合复用原则（桥接模式的代表原则）&lt;br&gt;使用概率：20%&lt;br&gt;复杂度：中高&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_bridge1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之10 —— 组合模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/21/it/2.OOP&amp;DesignPattern/2.10.Composite/"/>
    <id>https://hengxing0080.github.io/2017/08/21/it/2.OOP&amp;DesignPattern/2.10.Composite/</id>
    <published>2017-08-21T13:21:51.000Z</published>
    <updated>2017-09-29T16:19:03.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：组合模式(Composite Pattern)<br>又名：合成模式 | 部分-整体模式(Part-whole Patterm)<br>所属类型：结构型模式<br>设计原则：遵循依赖倒置原则、开闭原则，违背接口隔离原则<br>使用概率：30%<br>复杂度：中</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_composite1.png" alt="UML图"><br><a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将对象组合成树形结构以表示‘部分-整体’的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>将对象组成成树状嵌套结构以表示‘部分-整体’的层次结构。<br>组合模式使得拥护对单个对象和组合对象的使用具有一致性。</p>
<p>组合模式比较简单，它将一组相似的对象看做一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略对象与对象集合之间的差别。</p>
<p>正所谓，物以类聚。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>组合模式可以让客户端像修改配置文件一样简单的完成本来需要流程控制语句来完成的功能。</p>
<p>屏蔽了容器对象与单个对象在使用时的差异，为客户端提供统一的操作接口，从而降低客户代码与被调用对象的耦合关系，方便系统的维护与扩展。</p>
<h1 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h1><p>当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。<br>部分与整体的关系。</p>
<p>表示对象的部分-整体层次结构时。<br>从一个整体中能够独立出部分模块或功能的场景。</p>
<h1 id="使用场合示例"><a href="#使用场合示例" class="headerlink" title="使用场合示例"></a>使用场合示例</h1><p>1.Windows系统的文件系统（文件和文件夹）就是一种典型的组合模式例子。<br>—详情查看 Android源码设计模式解析与实战 —— 19.5 组合模式的简单实现</p>
<p>2.Android的目录选择器DirScelector</p>
<p>3.生活中一个比较典型的例子就是企业的组织结构的树状图。</p>
<p>4.系统目录结构，网站导航结构等。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">// Component为组合中的对象声明接口，在适当情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component的子部件。</div><div class="line">abstract class Component&#123;</div><div class="line">    protected string name;</div><div class="line"></div><div class="line">    public Component(string name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 通常都用Add和Remove方法来提供增加或移出树叶或树枝的功能</div><div class="line">    public abstract void Add(Component c);</div><div class="line">    public abstract void Remove(Component c); </div><div class="line">    public abstract void Display(int depth);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Left在组合中表示叶节点对象，叶节点没有子节点。</div><div class="line">class Leaf : Component&#123;</div><div class="line">    public Leaf(string name) ： base(name)&#123;&#125;</div><div class="line"></div><div class="line">    public override void Add(Component c)&#123;</div><div class="line">        Comsole.writeLine(“Cannot add to a leaf”);</div><div class="line">    &#125;</div><div class="line">    public override void Remove(Component c)&#123;</div><div class="line">        Console.WriteLine(“Cannot removee from a leaf”);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Display(int depth)&#123;</div><div class="line">        // 叶节点的具体方法，此处是显示其名称和级别</div><div class="line">        Console.WriteLine(new String(‘-’,depth)+name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Composite定义有枝结点行为，用来存储子部件，在Component接口中实现与子部件有关的操作，比如增加Add和删除Remove.</div><div class="line">class Composite : Component&#123;</div><div class="line">    private List&lt;Component&gt; children = new List&lt;Component&gt;();</div><div class="line"></div><div class="line">    public Composite(string name):base(name)&#123;&#125;</div><div class="line"></div><div class="line">    public override void Add(Component c)&#123;</div><div class="line">        children.Add(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Remove(Component c)&#123;</div><div class="line">        children.Remove(c);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Display(int depth)&#123;</div><div class="line">        Console.WriteLine(new String(‘-’,depth) + name);</div><div class="line">        foreach(Component component in children)&#123;</div><div class="line">            component.Display(depth + 2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码，能通过Component接口操作组合部件的对象。</div><div class="line">public class Client&#123;</div><div class="line">    static void Main(strin[] args)&#123;</div><div class="line">        // 生成树根root，根上长出两叶LeafA和LeafB</div><div class="line">        Composite root = new Composite(“root”);</div><div class="line">        root.Add(new Leaf(“Leaf A”));</div><div class="line">        root.Add(new Leaf(“Leaf B”));</div><div class="line"></div><div class="line">        // 根上长出分枝CompositeX,分枝上也有两叶LeafXA和LeafXB</div><div class="line">        Composite comp = new Composite(“Composite X”);</div><div class="line">        comp.Add(new Leaf(“leaf XA”));</div><div class="line">        comp.Add(new Leaf(“leaf XB”));</div><div class="line">        root.Add(comp);</div><div class="line"></div><div class="line">        // 在Composite X上在长出分枝CompositeXY,分枝上也有两叶LeafXYA和LeafXYB</div><div class="line">        Composite comp2 = new Composite(“Composite XY”);</div><div class="line">        comp2.Add(new Leaf(“leaf XYA”));</div><div class="line">        comp2.add(new Leaf(“leaf XYB”));</div><div class="line">        comp.Add(comp2);</div><div class="line"></div><div class="line">        // 根部又长出两叶LeafC和LeafD，可惜LeafD没长牢，被风吹走了</div><div class="line">        root.Add(new Leaf(“Leaf C”));</div><div class="line">        Leaf leaf = new Leaf(“Leaf D”);</div><div class="line">        root.Add(leaf);</div><div class="line">        root.Remove(leaf);</div><div class="line"></div><div class="line">        // 显示大树的样子</div><div class="line">        root.Display(1);</div><div class="line"></div><div class="line">        Console.Read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">结果显示</div><div class="line">    -root</div><div class="line">    ---Leaf A</div><div class="line">    ---Leaf B</div><div class="line">    ---Composite X</div><div class="line">    -----Leaf XA</div><div class="line">    -----Leaf XB</div><div class="line">    -----Composite XY</div><div class="line">    -------Leaf XYA</div><div class="line">    -------Leaf XYB</div><div class="line">    ---Leaf C</div></pre></td></tr></table></figure>
<h1 id="透明方式与安全方式"><a href="#透明方式与安全方式" class="headerlink" title="透明方式与安全方式"></a>透明方式与安全方式</h1><p>接上述代码示例。<br>为什么Leaf类也有Add和Remove，树叶不是不可以在长分枝吗？<br>这种方式叫透明方式，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add,Remove等。<br>这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，<br>它们具备完全一致的行为接口。<br>但问题也很明显，因为Leaf类本身不具备Add(),Remove()方法的功能，所以实现它是没有意义的。<br>Leaf类当中不用Add和Remove方法就是所谓的安全方式，也就是在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，这样做旧不会出现刚才提到的问题，<br>不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。<br>虽透明方式不用判断省事，但是两者各有好处，视情况而定！</p>
<h1 id="Android源码中模式实现"><a href="#Android源码中模式实现" class="headerlink" title="Android源码中模式实现"></a>Android源码中模式实现</h1><p>View和ViewGroup的嵌套组合</p>
<h1 id="组合模式和解释器模式的区别"><a href="#组合模式和解释器模式的区别" class="headerlink" title="组合模式和解释器模式的区别"></a>组合模式和解释器模式的区别</h1><p>组合模式和解释器模式有一定的类同，两者在迭代对象时都涉及递归的调用，但是组合模式所提供的属性层次结构使得我们能够一视同仁地对待单个对象和对象集合，不过，这是牺牲类的单一原则换来的，而且组合模式是通过继承来实现的，这样的缺乏缺少弹性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们平时在Android开发的过程中组合模式的应用并不算多，组合模式更适用于对一些界面UI的架构设计上，当然，绝大多数情况下，这部分代码都会由相应的程序语言提供，比如Java的AWT，Android和iOS的UI框架等，真正需要开发者去实现的不多。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>组合模式可以一致地使用组合结构和单个对象。</p>
<p>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让高层模块忽略了层次的差异，方便对整个层次结构进行控制。<br>高层模块可以一致地使用一个组合结构或其中单个对象，不必关系处理的是单个对象还是整个组合结构，简化了高层模块的代码。<br>组合模式中增加新的枝干构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。<br>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和枝干对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</p>
<p>缺点：<br>在新增构件时不好对枝干中的构件类型进行限制，不然依赖类型系统来增加这些约束，因为在大多数情况下，它们都来自于相同的抽象层，此时，必须进行蕾西检查来实现，这个实现过程较为复杂。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：组合模式(Composite Pattern)&lt;br&gt;又名：合成模式 | 部分-整体模式(Part-whole Patterm)&lt;br&gt;所属类型：结构型模式&lt;br&gt;设计原则：遵循依赖倒置原则、开闭原则，违背接口隔离原则&lt;br&gt;使用概率：30%&lt;br&gt;复杂度：中&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_composite1.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之9 —— 外观模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/20/it/2.OOP&amp;DesignPattern/2.9.State/"/>
    <id>https://hengxing0080.github.io/2017/08/20/it/2.OOP&amp;DesignPattern/2.9.State/</id>
    <published>2017-08-20T12:00:02.000Z</published>
    <updated>2017-09-29T16:18:59.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：外观模式<br>英文名：Facade Pattern<br>又名：门面模式<br>所属类型：结构型模式<br>设计原则：遵循依赖倒转原则和迪米特原则<br>使用概率：60%<br>复杂度：中</p>
<h1 id="UML结构图"><a href="#UML结构图" class="headerlink" title="UML结构图"></a>UML结构图</h1><p><img src="/images/it_pattern_facade2.png" alt="UML图"><br><a id="more"></a><br>外观模式接口比较简单，就是通过一个统一的接口对外提供服务，使得外层程序只通过一个类就可以实现系统内部的多种功能，而这些实现功能的内部子系统之间可能也有交互，或者说完成一个功能需要几个子系统之间进行协作，如果没有封装，那么用户就需要操作几个子系统的交互逻辑，容易出现错误。而通过外观类对外屏蔽这些复杂的交互，降低用户的使用成本。</p>
<p>角色介绍<br>Facade：系统对外的统一接口，系统内部系统地工作。简单的说就是这个外观类为子系统提供一个共同的对外接口<br>SystemA，SystemB，SystemC：子系统接口<br>Clients：客户对象通过一个外观接口读写子系统中各接口的数据资源。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。<br>外观模式提供一个高层次的接口，使得子系统更易于使用。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>外部与一个子系统的通信必须通过一个统一的门面对象进行。<br>门面模式提供一个高层次的接口，使得子系统更易于使用。<br>每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类<br>很常用，因为它完美体现了依赖倒转原则和迪米特法则的思想，所以是非常常用的模式之一。</p>
<p>在开发过程中的运用频率非常高，尤其是在现结点各种第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式。<br>通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低拥护的使用成本，也对拥护屏蔽了很多实现细节。<br>当然，在开发过程中，外观模式也是封装API的常用手段，例如网络模块，ImageLoader模块等。<br>可能你在开发中运用无数次外观模式，只是没有在理论层面认识它。</p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>在以下情况下可以考虑使用外观模式：<br>(1) 设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。<br>(2) 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。<br>(3) 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。</p>
<h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><p>生活中使用外观模式的例子非常多，任何一个类似中央调度结构的组织都类似外观模式。举个简单的例子，手机就是一个外观模式的例子，它集合了电话功能，短信功能，GPS，拍照等于一身，通过手机你就可以完成各种功能。而不是当你打电话时准备一个诺基亚1100，要拍照时非常用一个相机，如果是这样每使用一个功能你就必须操作特定的设备，会使得整个过程很繁琐。而手机给了你一个统一的入口，集电话，上网，拍照等功能于一身。使用方便，操作简单。</p>
<p>下面模拟手机的外观模式<br><img src="/images/it_pattern_facade3.png" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">MobilePhone</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Phone mPhone = <span class="keyword">new</span> PhoneImpl();</div><div class="line">    <span class="keyword">private</span> Camera mCamera = <span class="keyword">new</span> SamsungCamera();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>&#123;</div><div class="line">        mPhone.dail();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">videoChat</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“--&gt; 视频聊天接通中”);</div><div class="line">        mCamera.open();</div><div class="line">        mPhone.dail();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>&#123;</div><div class="line">        mPhone.hangup();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>&#123;</div><div class="line">        mCamera.open();</div><div class="line">        mCamera.takePicture();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeCamera</span><span class="params">()</span></span>&#123;</div><div class="line">        mCamera.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span></span>&#123;</div><div class="line">    <span class="comment">//打电话</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 挂断</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneImpl</span> <span class="keyword">implements</span> <span class="title">Phont</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dail</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“打电话”);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hangup</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“打电话”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Camera</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamsungCamera</span> <span class="keyword">implements</span> <span class="title">Camera</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“打开相机”);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“拍照”);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“关闭相机”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        MobilePhone nexus6 = <span class="keyword">new</span> MobilePhone();</div><div class="line">        <span class="comment">// 拍照</span></div><div class="line">        nexus6.takePicture();</div><div class="line">        <span class="comment">// 视频聊天</span></div><div class="line">        nexus6.videoChat();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">运行结果：</div><div class="line">    打开相机</div><div class="line">    拍照</div><div class="line">    打开相机</div><div class="line">    打电话</div></pre></td></tr></table></figure>
<p>从上述代码中可以看到，外观模式就是统一接口封装。<br>将子系统的逻辑，交互隐藏起来，为拥护提供一个高层次的接口，使得系统更加易用，同时也对外隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会感知到，<br>因为用户使用的是Facade高层接口，内部的变化对于用户来说并不可见。<br>这样一来就将变化隔离开来，使得系统也更加灵活。</p>
<h1 id="Android源码中的外观模式"><a href="#Android源码中的外观模式" class="headerlink" title="Android源码中的外观模式"></a>Android源码中的外观模式</h1><p>1.ContextImpl<br>Context对开发者来说是最重要的高层接口。不过它只是一个抽象类，它的真正实现在ContextImpl（外观）类中</p>
<p>2.SDK和开源库<br>外观模式在这里是使用率最高的模式，这些库通过外观类为用户提供统一的高层接口，使得用户不必了解一些更细节的实现。<br>例如在使用ImageLoader时我们通常只操作一个ImageLoader类就可以完成，而不要了解网络请求类，缓存类以及它们的交互细节。<br>又比如在使用友盟统计SDK时，通过MobclickAgent这个相当于是外观类就可以完成我们所需的功能，至于MobclickAgent类内部有其他的什么类型，它们的具体交互是什么我们都不需要关系。</p>
<h1 id="外观模式和中介者模式的区别"><a href="#外观模式和中介者模式的区别" class="headerlink" title="外观模式和中介者模式的区别"></a>外观模式和中介者模式的区别</h1><p>二者都是为了处理复杂的耦合关系，不同的是外观模式处理的是类之间复杂的依赖关系，中介者模式处理的是对象之间复杂的交互关系</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>外观模式一个高频率使用的设计模式，它的精髓就在于封装二字。<br>通过一个高层次结构为用户提供统一的API入口，使得用户通过一个类就基本能够操作整个系统，这样减少了用户的使用成本，也能够提升系统的灵活性。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点<br>1.对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。<br>2.外观类对子系统的接口封装，使得系统更易于使用。</p>
<p>缺点：<br>1.外观类接口膨胀<br>　　由于子系统的接口都有外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了用户使用成本。<br>2.外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：外观模式&lt;br&gt;英文名：Facade Pattern&lt;br&gt;又名：门面模式&lt;br&gt;所属类型：结构型模式&lt;br&gt;设计原则：遵循依赖倒转原则和迪米特原则&lt;br&gt;使用概率：60%&lt;br&gt;复杂度：中&lt;/p&gt;
&lt;h1 id=&quot;UML结构图&quot;&gt;&lt;a href=&quot;#UML结构图&quot; class=&quot;headerlink&quot; title=&quot;UML结构图&quot;&gt;&lt;/a&gt;UML结构图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_facade2.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之8 —— 适配器模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/19/it/2.OOP&amp;DesignPattern/2.8.adapter/"/>
    <id>https://hengxing0080.github.io/2017/08/19/it/2.OOP&amp;DesignPattern/2.8.adapter/</id>
    <published>2017-08-19T14:12:59.000Z</published>
    <updated>2017-09-29T16:18:54.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名：适配器模式<br>外文名：Adapter  Pattern<br>又名：变压器模式<br>设计原则：遵循开闭原则、体现功能复用<br>使用概率：40%<br>复杂度：中<br>基本信息：共有两类适配器模式<br>客户：需要调用我们的代码的对象<br>宗旨：保留现有类所提供的服务</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_adapter1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h1><p>Target：目标角色，也就是所期待得到的接口。注意，由于这里讨论的是类适配器模式，因此目标不可以是类。<br>Adaptee：现在需要适配的接口。<br>Adapter：适配器角色，也是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。<br>适配类可以根据参数返还一个合适的实例给客户端。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在计算机编程中，适配器模式（有时候也称包装样式或者包装）将一个类的接口适配成用户所期待的。<br>一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p>
<p>在软件开发中，也就是系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个缘由对象与某个接口匹配。<br>适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况，如何在需要和早期代码复用一些功能等应用上很有实际价值。</p>
<p>简单理解就是将2个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种解决方案使得它们能够协作起来进行很好的合作。<br>例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是没有如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时往往会使用一个Adapter，在这两种接口之间创建一个混血儿接口，这个Adapter会将两个接口进行兼容，在不修改原有代码的情况下满足需求。</p>
<p>所以Apdater模式在开发中运用非常广泛，因此，掌握Adapter模式是非常必要的。</p>
<h1 id="适配器模式和代理模式的区别"><a href="#适配器模式和代理模式的区别" class="headerlink" title="适配器模式和代理模式的区别"></a>适配器模式和代理模式的区别</h1><p>代理模式和适配器模式应该说很相像，但是他们的区别也很明显，代理模式和被代理者的接口是同一个，只是使用中客户访问不到被代理者，所以利用代理间接的访问，而适配器模式，是因为接口不同，为了让用户使用到统一的接口，把原先的对象通过适配器让用户统一的使用，大多数运用在代码维护的后期，或者借用第三方库的情况下。</p>
<h1 id="适配器模式的两种写法"><a href="#适配器模式的两种写法" class="headerlink" title="适配器模式的两种写法"></a>适配器模式的两种写法</h1><ul>
<li><p>对象适配器模式<br>– 在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p>
</li>
<li><p>类适配器模式<br>– 这种适配器模式下，适配器继承自已实现的类（一般多重继承）。<br>– 由于类适配器模式通过多重继承对一个接口与另一个接口进行匹配，而C#，VB.NET，Java等语言都不支持多重继承（C++支持），<br>也就是一个类只有一个父类。</p>
</li>
</ul>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>用电源接口做例子，笔记本电脑的电源一般都是用5V电压，但是我们生活中的电器电压一般都是200V。这个时候就出现了不匹配的状况，在软件开发中我们称之为接口不兼容，此时就需要适配器来进行一个接口转换。在软件开发中有一句话正好体现了这点：任何问题都可以加一个中间层来解决。这个层我们可以理解为这里的Adapter层，通过这层来进行一个接口转换就达到了兼容的目的。<br>下列代码中，5V电压就是Target接口，220V电压就是Adaptee类，而将电压从220V转换到5V就是Adapter<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Target角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FiveVolt</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adaptee角色，需要被转换的对象</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volt220</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt220</span><span class="params">()</span></span>&#123;</div><div class="line">        Return <span class="number">220</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Adapter角色，将220V的电压转换成5V的电压</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltAdapter</span> <span class="keyword">extends</span> <span class="title">Volt220</span> <span class="keyword">implements</span> <span class="title">FiveVolt</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVolt5</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">5</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    VoltAdapter adapter = <span class="keyword">new</span> VoltAdapter();</div><div class="line">        System.out.println(“输出电压：”+adapter.getVolt5());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用代理关系连接到Adaptee类，UML图如下<br><img src="/images/it_pattern_adapter2.jpg" alt="UML图"><br>从下列代码可以看到，Adaptee类（Volt220）并没有getVolt5()方法，而客户端则期待这个方法。为使客户端使用Adapter类，需要提供一个包装类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// Target角色</div><div class="line">public interface FiveVolt&#123;</div><div class="line">    Public int getVolt5();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Adaptee角色，需要被转换的对象</div><div class="line">public classs Volt220&#123;</div><div class="line">    public int getVolt220()&#123;</div><div class="line">        return 220;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 对象适配器模式</div><div class="line">public class VoltAdapter implements FiveVolt&#123;</div><div class="line">    Volt229 mVolt220;</div><div class="line">    public VoltAdapter(Volt220 adaptee)&#123;</div><div class="line">        mVolt220 = adaptee;</div><div class="line">    &#125;</div><div class="line">    public int getVolt220()&#123;</div><div class="line">        return mVolt220.getVolt220();</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public int getVolt5()&#123;</div><div class="line">        return 5;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Client</div><div class="line">public classs Test&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        VoltAdapter adapter = new VoltAdapter(new Volt220());</div><div class="line">        System.out.println(“输出电压：”+adapter.getVolt5());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现方式直接将要适配的对象传递到Adapter中，使用组合的形式实现接口兼容的效果。这比类适配器方式更为灵活，它的另一个好处是被适配对象的方法不会暴露出来，<br>而类适配器由于继承了被适配对象，因此，被适配对象类的函数在Adapter类中也都含有，这使得Adapter类出现一些奇怪的接口，用户使用成本较高。因此，对象适配器模式更加灵活、实用。</p>
<h1 id="Android涉及到的适配器模式"><a href="#Android涉及到的适配器模式" class="headerlink" title="Android涉及到的适配器模式"></a>Android涉及到的适配器模式</h1><p>在Android的开发使用率极高，从代码中随处可见的Adapter就可以判断出来。从最早的ListView，GridView到现在最新的RecyclerView都需要使用Adapter.<br>所以Adapter模式的是非常灵活的实现，如ListView中的隔离变化，使得整个UI架构变得更灵活，能够拥抱变化。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>更好的复用性<br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>更好的扩展性<br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体把握。<br>例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。<br>因此，如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
</ul>
<!--
相关书籍章节：
大话设计模式（程杰）——171页 第17章 在NBA我需要翻译——适配器模式)
Android源码设计模式解析与实战——371页 第20章 得心应手的粘合剂——适配器模式)
-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名：适配器模式&lt;br&gt;外文名：Adapter  Pattern&lt;br&gt;又名：变压器模式&lt;br&gt;设计原则：遵循开闭原则、体现功能复用&lt;br&gt;使用概率：40%&lt;br&gt;复杂度：中&lt;br&gt;基本信息：共有两类适配器模式&lt;br&gt;客户：需要调用我们的代码的对象&lt;br&gt;宗旨：保留现有类所提供的服务&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_adapter1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MVC &amp; MVP &amp; MVVM &amp; MVPVM</title>
    <link href="https://hengxing0080.github.io/2017/08/17/it/2.OOP&amp;DesignPattern/3.1.MVC/"/>
    <id>https://hengxing0080.github.io/2017/08/17/it/2.OOP&amp;DesignPattern/3.1.MVC/</id>
    <published>2017-08-17T13:11:01.000Z</published>
    <updated>2017-10-07T04:58:31.039Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_pattern_mvc1.png" alt="图"><br><a id="more"></a></p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li><p>架构<br>有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。<br>简单的说架构就是一个蓝图，是一种设计方案，将客户的不同需求抽象成为抽象组件，并且能够描述这些抽象组件之间的通信和调用。<br>总结一下，就是一整个软件工程项目中的骨架，是一种宏观的规划。</p>
</li>
<li><p>框架<br>软件框架是项目软件开发过程中提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型。<br>框架不是现成可用的应用系统，而是一个半成品，提供了诸多服务，开发人员进行二次开发，实现具体功能的应用系统。<br>框架则是一个半成品的应用，直接给出一个骨架。写框架能提升自己的架构能力。剖析别人框架的特点，写出属于自己的框架。</p>
</li>
</ul>
<p>多个设计模式组成就是框架</p>
<p>框架和架构的区别<br>查看文章↓<br><a href="http://blog.csdn.net/liuguobo/article/details/43451129" target="_blank" rel="external">架构和框架的区别</a></p>
<ul>
<li><p>库<br>库是解决某个问题而拼凑出来的一大堆函数与类的集合。</p>
</li>
<li><p>设计模式<br>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，它强调的是一个设计问题的解决方法。</p>
</li>
</ul>
<hr>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MVC英文：Model-View-Controller<br>中文含义：模型——视图——控制器<br>提出时间：1970年由TrygveReenskaug在Smalltalk-80系统上·首次提出<br>产生时间：1982年</p>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/it_pattern_mvc2.png" alt="图"><br>MVC中View接受事件,并调用Controller来操作Model,同时,当Model实例的数据发生变化后，Controller再更新界面(当然View也可以直接更新Model)。</p>
<h2 id="理念"><a href="#理念" class="headerlink" title="理念"></a>理念</h2><p>将数据模型和视图分离开来，并以控制器作为连接两者的桥梁以实现解耦</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MVC是一种框架模式而非设计模式<br>GOF把MVC看作是3种设计模式：观察者模式，策略模式与组合模式的合体，而且核心在观察者模式，也就是一个基于发布/订阅者模型的框架，很多时间在实际开发过程中我们常常还会在MVC框架中使用到其他的设计模式。</p>
<p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<h2 id="框架模式与设计模式的区别"><a href="#框架模式与设计模式的区别" class="headerlink" title="框架模式与设计模式的区别"></a>框架模式与设计模式的区别</h2><p>做开发的经常会听到这样活那样的框架，比如注解框架，通信框架，数据存储框架等通用性较强的框架，还有一些面向后端开发的，如Structs,Spring等框架，在这些框架中你常常会见到很多设计模式的应用。<br>对框架来说，通常是代码的重用，而对设计来说通常是对设计的重用，<br>简单理解就是框架面向于一系列相同行为代码的重用，而设计则面向的是一系列相同结构代码的重用，<br>我们平常所说的架构则介于框架与设计之间。<br>在软件开发领域有3种级别的重用：<br>内部重用，即在同一应用中能公共使用的抽象块;<br>代码重用，即将通用模块组合成库或工具集，以便在多一个应用和领域都能使用。<br>应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。<br>开发过程中场景的框架模式有MCV，MVP，MVVC ,MTV，CBD，ORM<br>框架是大智慧，用来对软件设计进行分工<br>设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>理解很容易，技术含量并不高，对开发和维护来说成本较低也易于维护和修改。<br>耦合性不高，表示层与业务层分离实现各司其职，对开发来说也是很有利，前端工程师专注于界面的研发，后端工程师则致力于业务逻辑的完善等。</p>
<p>缺点：<br>没有明确的定义，所以完全理解MVC模式并不是很容易。<br>使用MVC模式需要精心计划，由于它的内部原理比较复杂，需要花时间去思考。<br>开发一个MVC模式架构的工程，讲不得不花费相当可观的时间去考虑如何将MVC模式运用到应用程序中，同时由于Model和View要严格分离，这样也是调试应用程序带来了一定的困难。<br>由于MVC模式将一个应用程序分成了3个部件，所以，这意味着同一个工程将包含比以前更多的文件。因此，对于一些小规模的项目，MVC反而会更来更大的工作量以及复杂性。</p>
<h2 id="MVC在Android中的实现"><a href="#MVC在Android中的实现" class="headerlink" title="MVC在Android中的实现"></a>MVC在Android中的实现</h2><p>在传统的开发中Activity俨然既充当了Controller又充当了View的作用.既需要接受用户响应操作Model,又要更新界面.<br>这样做有一个好处就是数据的更新变得很简单,但是缺点也十分明显,Activity是非臃肿,后期不好维护.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Android的UI系统中，控制器Activity主要起到的作用就是解耦，将试图View和模型Model进行分离，两者在Activity中进行绑定或完成其他逻辑。<br>MVC更适合于大规模项目，比如Android的UI系统框架，但是android的健康非我们自己完成的，而是由framework给我们搭建好并提供给我们的，在平时的开发中，特别是用Android开发，我们并不常用到MVC模式去脱离Android UI系统构建自己的框架结构。</p>
<hr>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Model-View-Presenter<br>模型-视图-主导器</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>是传统MVC(Model-View-Controller)在Android开发上的一种变种演化版本、进化模式。<br>主要用来隔离UI、UI逻辑和业务逻辑、数据,创建松散耦合并可重用的对象。<br>我们知道View层是容易变化且多种多样的,业务逻辑也是多种多样的,与传统的MVC相比,P充当了C的作用.<br>Model存储数据，View表示Model的表现，Presenter协调两者之间的通信.</p>
<p>能有效地降低View复杂性，避免业务逻辑被塞进View中。<br>解除View与Model的耦合，同时也带来了良好的可扩展性，可测试性，保证了系统的整洁性，灵活性。<br>对于简单的应用来说MVP稍显麻烦，各种各样的接口与概念，使得整个应用充斥着零散的接口，但是对于比较复杂的应用来说，MVP模式是一种良好的架构模式，它能够非常好地组织应用结构，使得应用变得灵活，拥抱变化。</p>
<h2 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/it_pattern_mvc3.png" alt="图"><br>MVP中将业务逻辑单独抽出Presenter,View层变成一个被动的东西,Presenter负责完成View层与Model层的交互.<br>View 不可以直接和Model交互(MVC中允许Model和View交互),只有Presenter告知其更新，它才会去更新.<br>而且Presenter和View的交互是通过接口来完成.</p>
<h2 id="MVP模式的三个角色"><a href="#MVP模式的三个角色" class="headerlink" title="MVP模式的三个角色"></a>MVP模式的三个角色</h2><p>1.Presenter——交互中间人（中介）<br>主要作为沟通View和Model的桥梁，它从Model层检索数据后，返回给View层，使得View和Model之间没有耦合，也将业务逻辑从View角色上抽离出来。<br>2.View——用户界面<br>View通常是指Activity，Fragment或者某个View控件，它含有一个Presenter成员变量。通常View需要实现一个逻辑接口，将View上的操作通过会转交给Presenter进行实现，最后，Presenter调用View逻辑接口将结果返回给View元素。<br>3.Model——数据的存取<br>对于一个结构化的App来说，Model角色主要是提供数据的存取功能。Presenter需要通过Model层存储，获取数据，Model就像一个数据仓库。更直白的说，Model是封装了数据库DAO或者网络获取数据的角色，或者两种数据获取方式的集合。</p>
<h2 id="MVP与MVC-MVVM的区别"><a href="#MVP与MVC-MVVM的区别" class="headerlink" title="MVP与MVC,MVVM的区别"></a>MVP与MVC,MVVM的区别</h2><p>1.MVC特点<br>1.用户可以向View发送指令，再由View直接要求Model改变状态。<br>2.用户也可以直接向Controller发送指令，再由Controller发送给View<br>3.Controller起到事件路由的作用，同时业务逻辑都部署在Controller中。<br>可以看到，MVC的耦合性还是相对较高，View可以直接访问Model，导致3者之间构成回路。<br>因为,MVP与MVC的主要区别是，MVP中的View不能直接访问Model，需要通过Presenter发出请求，View与Model不直接通信。</p>
<p>2.MVVM特点<br>MVVM与MVP很相似，唯一的区别是View和Model进行双向绑定（data-binding），两者之间有一方发送变化则会反应到另一方上。<br>而MVP与MVVM的主要区别则是，MVP中的View更新需要通过Presenter，而MVVM不需要，因为View与Model进行了双向绑定，数据的修改会直接反应到View角色上，而View的修改也会导致数据的变更。此时，ViewModel角色需要做的只是业务逻辑的处理，以及修改View或者Model的状态。<br>MVVM模式有点像ListView与Adapter，数据集的关系，这个Adapter就是ViewModel角色，它与View进行了绑定，又与数据集进行了绑定，当数据集合发送变化时，调用Adapter的notifyDataSetChanged之后就直接更新，他们之间没有直接的耦合，使得ListView变的更为灵活。</p>
<h2 id="MVP与Activity-Fragment的生命周期"><a href="#MVP与Activity-Fragment的生命周期" class="headerlink" title="MVP与Activity,Fragment的生命周期"></a>MVP与Activity,Fragment的生命周期</h2><p>优点：<br>易维护，易测试，松耦合，复用性高，健壮稳定，易扩展。</p>
<p>缺点：<br>由于Presenter经常性需要执行一些耗时操作，例如网络请求数据，Presenter持有了Activity的强引用，如果在请求结束之前Activity被销毁了，那么由于网络请求还买有返回，导致Presenter一直持有Activity对象，使得Activity对象无法被回收，此时就发生了内存泄漏。</p>
<p>解决方案：<br>通过弱引用和Acitivyt,Fragment的生命周期来解决这个问题。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>MVP是开发过程中非常值得推荐的架构模式，它能够将各组件进行解耦，并且带来良好的可扩展性，可测试性，稳定性，可维护性，<br>同时使得每个类似的职责相对单一，简单，避免了大量代码的程序存在，例如数千行的Activity类。<br>有效的将业务逻辑，数据处理等工作从Activity等View元素中抽离出来，使得每个类尽可能简单，同时每个模块能够独立进行演化。<br>它的思维也体现了面向对象的设计原则，即抽象，单一职责，最小化，低耦合。</p>
<hr>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><hr>
<p><img src="/images/it_pattern_mvc4.png" alt="图"></p>
<p>MVVM (Model-View-ViewModel)<br>在MVP基础上的变种,相比较MVP而言,MVVM使数据绑定变得更加简单.</p>
<p>即ViewModel到View的映射，不需要再去自己找到view，然后更新字段，而是在映射建立后直接更新ViewModel然后反映到View上。<br>值得一提的是，MVP和MVVM都是微软提出的理念，最早都是在WPF里面被应用的，只是时至今日才在Android上被真正用起来。</p>
<p>MVVM最先使用在WPF中,通过ViewModel和View的映射,完成了View和Model的双向绑定.<br>View的事件直接传递到ViewModel，ViewModel去对Model进行操作并接受更新.进而反馈到View上.</p>
<h2 id="MVVM在Android中的实现"><a href="#MVVM在Android中的实现" class="headerlink" title="MVVM在Android中的实现"></a>MVVM在Android中的实现</h2><p>在Android上对应Data Binding</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>因为ViewModel与View的耦合,MVVM有一个缺点就是View的复用问题,<br>因为去掉了Presenter,View层依然过重.</p>
<hr>
<h1 id="MVPVM"><a href="#MVPVM" class="headerlink" title="MVPVM"></a>MVPVM</h1><hr>
<p><img src="/images/it_pattern_mvc5.png" alt="图"></p>
<p>MVPVM (Model-View-Presenter-ViewModel)</p>
<p>MVPVM是MVP和MVVM的演化变种版本,MVPVM在MVVM中加入引入Presenter层，降低了ViewModel与View的耦合,View只需要实现ViewModel的观察者接口实现更新.ViewModel不再对Model直接进行操作,而是交给了Presenter.Presenter操作Model并反馈到ViewModel上<br>Model,View,ViewModel之间通过Presenter联系了起来.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_pattern_mvc1.png&quot; alt=&quot;图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 架构&amp;框架" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%B6%E6%9E%84-%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 —— IOC（控制反转）</title>
    <link href="https://hengxing0080.github.io/2017/08/15/it/2.OOP&amp;DesignPattern/4.1.IOC/"/>
    <id>https://hengxing0080.github.io/2017/08/15/it/2.OOP&amp;DesignPattern/4.1.IOC/</id>
    <published>2017-08-15T07:21:32.000Z</published>
    <updated>2017-09-29T16:19:21.663Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_pattern_ioc1.jpg" alt="图"><br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名：控制反转<br>英文：IoC（Inversion of Control）<br>目的：描述框架的重要特征<br>起源时间：1988年</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IoC是框架的重要特征，并非面向对象编程的专用术语。<br>它与依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）并没有关系。</p>
<p>IoC是一个重要的面向对象编程的法则来削减计算机程序的耦合问题，也是轻量级的Spring框架的核心。 </p>
<p>IoC体现了<a href="https://baike.baidu.com/item/%E5%A5%BD%E8%8E%B1%E5%9D%9E%E5%8E%9F%E5%88%99/16019700?fr=aladdin" target="_blank" rel="external">好莱坞原则</a>，即“不要打电话过来，我们会打给你”。</p>
<p>IoC是Spring的核心，贯穿始终。所谓IOC就是有Spring来控制对象的生命周期和对象间的关系。<br>传统开发模式：对象之间相互依赖<br>IOC开发模式：IOC控制对象之间的依赖</p>
<p>IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。</p>
<p>也可以把IoC模式看做是工厂模式的升华，可以把IoC看作是一个大工厂，只不过这个大工厂里要生成的对象都是在XML文件中给出定义的，然后利用Java 的“反射”编程，根据XML中给出的类名生成相应的对象。从实现来看，IoC是把以前在工厂方法里写死的对象生成代码，改变为由XML文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。<br>IoC中最基本的Java技术就是“反射”编程。反射又是一个生涩的名词，通俗的说反射就是根据给出的类名（字符串）来生成对象。这种编程方式可以让对象在生成时才决定要生成哪一种对象。反射的应用是很广泛的，像Hibernate、Spring中都是用“反射”做为最基本的技术手段。<br>在过去，反射编程方式相对于正常的对象生成方式要慢10几倍，这也许也是当时为什么反射技术没有普遍应用开来的原因。但经SUN改良优化后，反射方式生成对象和通常对象生成方式，速度已经相差不大了（但依然有一倍以上的差距）。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>IoC最大的好处是什么？<br>因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是实现于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拔（有点像USB接口和SCSI硬盘了）。</p>
<p>IoC最大的缺点是什么？<br>（1）生成一个对象的步骤变复杂了（事实上操作上还是挺简单的），对于不习惯这种方式的人，会觉得有些别扭和不直观。<br>（2）对象生成因为是使用反射编程，在效率上有些损耗。但相对于IoC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。<br>（3）缺少IDE重构操作的支持，如果在Eclipse要对类改名，那么你还需要去XML文件里手工去改了，这似乎是所有XML方式的缺陷所在。</p>
<h1 id="实现策略类型"><a href="#实现策略类型" class="headerlink" title="实现策略类型"></a>实现策略类型</h1><p>IoC是一个很大的概念,可以用不同的方式实现。其主要形式有两种类型：依赖注入和依赖查找。<br>依赖注入应用比较广泛。</p>
<p>1.依赖注入（Dependency Injection，简称DI）<br>容器提供回调接口和上下文条件给组件。EJB和Apache Avalon 都使用这种方式。这样一来，组件就必须使用容器提供的API来查找资源和协作对象，仅有的控制反转只体现在那些回调方法上（也就是上面所说的 类型1）：容器将调用这些回调方法，从而让应用代码获得相关资源。</p>
<p>其又有三种方式：<br>接口注入（Interface Injection）<br>设置注入（Setter Injection）<br>构造注入（Constructor Injection）</p>
<p>2.依赖查找（Dependency Lookup，简称DL）<br>组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。容器全权负责的组件的装配，它会把符合依赖关系的对象通过JavaBean属性或者构造函数传递给需要的对象。通过JavaBean属性注射依赖关系的做法称为设值方法注入(Setter Injection)；将依赖关系作为构造函数参数传入的做法称为构造器注入（Constructor Injection）</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="http://stamen.iteye.com/blog/1489223/" target="_blank" rel="external">透透彻彻IoC（你没有理由不懂！）</a><br><a href="http://blog.csdn.net/bestcxx/article/details/77931436" target="_blank" rel="external">依赖注入和控制反转的理解，写的太好了</a><br><a href="http://blog.csdn.net/u013320868/article/details/54926578" target="_blank" rel="external">浅析android中的依赖注入</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_pattern_ioc1.jpg&quot; alt=&quot;图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之7 —— 代理模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/12/it/2.OOP&amp;DesignPattern/2.7.Proxy/"/>
    <id>https://hengxing0080.github.io/2017/08/12/it/2.OOP&amp;DesignPattern/2.7.Proxy/</id>
    <published>2017-08-12T03:22:47.000Z</published>
    <updated>2017-09-29T16:18:49.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名：代理模式<br>外文名：Proxy Pattern<br>又名：委托模式 | 第三方模式<br>设计原则：体现功能复用<br>使用概率：99.99999%<br>复杂度：中高</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_proxy1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>（1）抽象角色(Subject)：通过接口或抽象类声明真实角色实现的业务方法。<br>（2）代理角色(Proxy)：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>（3）真实角色(RealSubject)：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为其他对象提供一种代理以控制对这个对象的访问。<br>在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>跟MM在网上聊天，一开头总是“hi，你好”，“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 </p>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。  </p>
<p>代理模式是一个非常重要的模式，而且学起来很简单！</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象实现相同的接口。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>（1）代理对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2）代理对象包含一个真实对象的引用（reference）<br>（3）代理对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4）代理对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>（1）职责清晰<br>真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。<br>（2）代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了保护了目标对象的作用。<br>（3）高扩展性</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>几乎没有什么缺点而言，它是细分化至很小的一种模式，要真找缺点，那么就是所有设计模式的通病：对类的增加，不过在这种孰优孰劣的局势下，就算对类的稍微增加又何妨呢？</p>
<h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理<br>对象实现同一个接口,先访问代理类再访问真正要访问的对象。</p>
<p>代理模式分为静态代理、动态代理。</p>
<p>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</p>
<hr>
<h1 id="代理模式的2种方式"><a href="#代理模式的2种方式" class="headerlink" title="代理模式的2种方式"></a>代理模式的2种方式</h1><hr>
<h2 id="从Code方面"><a href="#从Code方面" class="headerlink" title="从Code方面"></a>从Code方面</h2><p>1.1.静态代理<br>如下述示例那样，代理者的代理由程序员自己或通过一些自动化工具生成固定的代理在对其进行编译。也就是说在我们的代理运行前代理类的class编译文件就已存在。</p>
<p>需求：小明以前在公司上班时，就遇到过被老板拖欠工资甚至克扣工资的情况，这种情况下小明还是通过法律途径来解决问题，一旦小明选择了走法律途径解决该纠纷，那么不可避免地就需要请一个律师来作为自己的诉讼代理人，我们将诉讼的流程抽象在一个接口类中。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 诉讼接口类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="comment">// 提交申请</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 进行举证</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 开始辩护</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 诉讼完成</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体诉讼人</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMin</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“老板·拖欠工资！特此申请仲裁！”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“这是合同书和过去一年的银行工资流水”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“证据确凿！不需要说什么了！”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“诉讼成功！判决老板即日起七天内结算工资”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代理律师类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lawyer</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> ILawsuit mLawsuit;  <span class="comment">// 持有一个具体被代理者的引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lawyer</span><span class="params">(ILawsult lawsuit)</span></span>&#123;</div><div class="line">        mLawsuit = lawsit;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.submit();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.burden();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.defend();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造一个小明</span></div><div class="line">        ILawsuit xiaoming = <span class="keyword">new</span> XiaoMin();</div><div class="line">        <span class="comment">// 构造一个代理律师并将小明作为构造参数传递进去</span></div><div class="line">        ILawsuit lawyer = <span class="keyword">new</span> Lawyer(xiaoming);</div><div class="line">        <span class="comment">// 律师提交诉讼申请</span></div><div class="line">        lawyer.submit();</div><div class="line">        <span class="comment">// 律师进行举证</span></div><div class="line">        lawyer.burden();</div><div class="line">        <span class="comment">// 完成诉讼</span></div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.2.动态代理<br>动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们在code阶段压根就不需要知道代理谁，代理谁我们将会在执行阶段决定。<br>而Java也给我们提供了一个便捷的动态代理接口InvocationHandler，实现该接口需要重写其调用方法invoke<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0,Method args1, Object[] args2)</span><span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过invoke方法来调用具体的被代理方法，也就是真实的方法。<br>动态代理可以使我们的代理逻辑更简洁</p>
<p>优化代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHander</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 被代理的类引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line">    &#125; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 调用被代理类对象的方法</span></div><div class="line">        Object result = method.invoke(obj, args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造一个小明</span></div><div class="line">        ILawsuit xiaoming = <span class="keyword">new</span> XiaoMin();</div><div class="line">        <span class="comment">// 构造一个动态代理</span></div><div class="line">        DynamicProxy proxy = <span class="keyword">new</span> DynamicProxy(xiaomin);</div><div class="line">        <span class="comment">// 获取被代理类小明的ClassLoader</span></div><div class="line">        ClassLoader loader = xiaoming.getClass().getClassLoader();</div><div class="line">        <span class="comment">// 动态构造一个代理者律师</span></div><div class="line">        ILawsuit lawyer = (ILawsuit)Proxy.newProxyInstance(loader,<span class="keyword">new</span> Class[] &#123; ILawsuit.class&#125;,proxy);</div><div class="line">        <span class="comment">// 律师提交诉讼申请</span></div><div class="line">        lawyer.submit();</div><div class="line">        <span class="comment">// 律师进行举证</span></div><div class="line">        lawyer.burden();</div><div class="line">        <span class="comment">// 律师代替小明进行辩护</span></div><div class="line">        lawyer.defend();</div><div class="line">        <span class="comment">// 完成诉讼</span></div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果和以前一致。<br>由此可见动态代理通过一个代理类来代理N多被代理类，其实质是对代理者与被代理者进行解耦，使两者直接没有直接的耦合关系。<br>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么久需要重新定义不同代理类，较为复杂，但是静态代理更符合面向对象原则。<br>在开发时具体使用哪种方式来实现代理，就看自己的偏好了。</p>
<h2 id="从适用范围区别几种不同类型的代理实现"><a href="#从适用范围区别几种不同类型的代理实现" class="headerlink" title="从适用范围区别几种不同类型的代理实现"></a>从适用范围区别几种不同类型的代理实现</h2><p>1.远程代理（Remote Proxy）：为某个对象在不同的内存地址空间提供局部代理。使系统可以将Server部分的实现隐藏，以便Client可以不必考虑Server的存在。<br>2.虚拟代理（Virtual Proxy）：使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。<br>3.保护代理（Protection Proxy）：使用代理控制对原始对象的访问。该类型的代理常被用于原始对象又不同访问权限的情况。<br>4.智能引用（Smart Reference）：在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数。<br>这里要注意的是，静态和动态代理都可以应用于上述4种情形，两者是各自独立的变化。</p>
<h1 id="代理模式实战场景"><a href="#代理模式实战场景" class="headerlink" title="代理模式实战场景"></a>代理模式实战场景</h1><p>1.NotificationManager的notify方法发送通知（详情看android源码设计模式解析与实战—18.8代理模式实战）</p>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>1.Binder跨进程通信机制与AIDL<br>代理模式：类似于ios开发的delegate委托模式，所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。<br>简介：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>2.子线程委托主线程的handler调用它的handlemessage来更新UI，类似代理设计模式</p>
<p>3.ActivityManagerProxy代理类</p>
<!--
相关书籍章节：
大话设计模式（程杰）——57页 第7章 为别人做嫁衣——代理模式)
Android源码设计模式解析与实战——371页 第20章 得心应手的粘合剂——适配器模式)
-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名：代理模式&lt;br&gt;外文名：Proxy Pattern&lt;br&gt;又名：委托模式 | 第三方模式&lt;br&gt;设计原则：体现功能复用&lt;br&gt;使用概率：99.99999%&lt;br&gt;复杂度：中高&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_proxy1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之6 —— 装饰模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/10/it/2.OOP&amp;DesignPattern/2.6.Decorator/"/>
    <id>https://hengxing0080.github.io/2017/08/10/it/2.OOP&amp;DesignPattern/2.6.Decorator/</id>
    <published>2017-08-10T00:11:22.000Z</published>
    <updated>2017-09-29T16:18:44.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名：装饰模式<br>外文名：Decorator Pattern<br>又名：装饰者模式 | 包装模式<br>设计原则：遵循单一职责原则、开闭原则、迪米特原则，破坏里氏替换原则，体现功能复用<br>使用概率：99.99999%<br>复杂度：中</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_decorator1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍<br> ● Client：客户端用户。<br> ● Prototype：抽象类或者接口，声明具备clone能力。<br> ● ConcretePrototype：具体的原型类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态地给一个对象添加一些额外的职责。<br>就增加功能来说，装饰模式相比生成子类更加灵活。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。</p>
<p>装饰模式是为已有功能动态地添加更多功能的一种方式。<br>这个模式还是算很好理解！</p>
<h1 id="现实中情景示例"><a href="#现实中情景示例" class="headerlink" title="现实中情景示例"></a>现实中情景示例</h1><p>人需要各式各样的衣着，不管你穿着怎么样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式，装饰物也各不相同但是装饰的对象本质是不变的。</p>
<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><p>以下情况使用Decorator模式<br>（1） 需要扩展一个类的功能，或给一个类添加附加职责。<br>（2） 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>（3） 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>（4） 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>需要透明且动态地扩展类的功能时。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2） 装饰对象包含一个真实对象的引用（reference）<br>（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>（1）Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。<br>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>（3）把类中的装饰功能从类中搬移去除，这样可以简化原有的类。 有效的把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复装饰逻辑。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>（1）这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。<br>（2）装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。<br>（3）装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>多用组合，少用继承。<ul>
<li>利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。</li>
<li>然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</li>
</ul>
</li>
<li>类应设计的对扩展开放，对修改关闭。 </li>
</ul>
<h1 id="装饰模式和代理模式的区别"><a href="#装饰模式和代理模式的区别" class="headerlink" title="装饰模式和代理模式的区别"></a>装饰模式和代理模式的区别</h1><p>装饰模式和代理模式有点类型，有时甚至容易混淆，倒不是把代码当成装饰，而容易将装饰看成代理，所以要注意！<br>装饰模式是对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，而代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用。<br>装饰模式应该为所装饰的对象增强功能，代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>
<h1 id="装饰模式与适配者模式的区别"><a href="#装饰模式与适配者模式的区别" class="headerlink" title="装饰模式与适配者模式的区别"></a>装饰模式与适配者模式的区别</h1><p>1.关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。<br>2.关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种–“半透明”装饰者）<br>3.关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。</p>
<h1 id="模式简化的2种方式"><a href="#模式简化的2种方式" class="headerlink" title="模式简化的2种方式"></a>模式简化的2种方式</h1><ol>
<li>如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。</li>
<li>如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。</li>
</ol>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">// Conponent类</div><div class="line">abstract class Compnent&#123;</div><div class="line">    public abstract void Operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteComponent类</div><div class="line">class ConcreteComponent : Component&#123;</div><div class="line">    public override void Operation()&#123;</div><div class="line">        Console.WriteLine(“具体对象的操作”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Decorator类</div><div class="line">abstract class Decorator :Conponent&#123;</div><div class="line">    protected Conponent component;</div><div class="line">    public void SetComponent(Component component)&#123;</div><div class="line">        this.component = component;	</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Operation()&#123;</div><div class="line">        if(component != null_&#123;</div><div class="line">            component.Operation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteDecoratorA类</div><div class="line">class ConcreteDecoratorA : Decorator&#123;</div><div class="line">    private string addedState; // 本类的独有功能，以区别于ConcreteDecoratorB</div><div class="line">    public override void Operation()&#123;</div><div class="line">        base.Operation();</div><div class="line">        addedState = “New State”;</div><div class="line">        Conscole.WriteLine(“具体装饰对象A的操作”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteDecoratorB类</div><div class="line">class ConcreteDecoratorB : Decorator&#123;</div><div class="line">    public override void Operation()&#123;</div><div class="line">        base.Operation();</div><div class="line">        AddedBehavior();</div><div class="line">        Conscole.WriteLine(“具体装饰对象A的操作”);</div><div class="line">    &#125;</div><div class="line">    private void AddedBehavior()&#123;  // 本类独有的方法，以区别于ConcreteDecoratorB</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码</div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    ConcreteConponent c = new ConcrtetComponent();</div><div class="line">    ConcreteDecoratorA d1 = new ConcreteDecoratorA();</div><div class="line">    ConcreteDecoratorB d2 = new ConcreteDecoratorB();;</div><div class="line"></div><div class="line">    // 装饰的方法是：首先用ConcreteComponent实例化对象c，然后用ConcreteDecoratorA的实例化对象d1来包装c，再用ConcreteDecoratorB的对象d2包装d1，最终执行d2的Operation();</div><div class="line">    d1.SetComponent(c);</div><div class="line">    d2.SetComponent(d1);</div><div class="line">    d2.Operation();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰模式就是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就喝如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p>
<p>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。<br>同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</p>
<p>优化代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">// Person类（ConcreteComponent）</div><div class="line">class Person&#123;</div><div class="line">    public Person()&#123;&#125;</div><div class="line">    public Person(string name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public virtual void Show()&#123;</div><div class="line">        Console.WriteLine(“装扮的&#123;0&#125;”,name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 服饰类（Decorator）</div><div class="line">class Finery : Person&#123;</div><div class="line">    protected Person component;</div><div class="line"></div><div class="line">    // 打扮</div><div class="line">    public void Decorate(Person component)&#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Show()&#123;</div><div class="line">        if(component != null)&#123;</div><div class="line">            component.Show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体服饰类（ConcreteDecorator）</div><div class="line">class TShirts : Finery&#123;</div><div class="line">    public override void Show()&#123;</div><div class="line">        Console.Write(“大T血”);</div><div class="line">        Base.Show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BigTrouser: Finery&#123;</div><div class="line">    public override void Show()&#123;</div><div class="line">        Console.Write(“大裤子”);</div><div class="line">        Base.Show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 其余类类似，省略......</div><div class="line"></div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    Person xc = new Person(“小明”);</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第一种装扮:“);</div><div class="line">    Sneakers pqx = new Sneakers();</div><div class="line">    BigTrouser kk = new BigTrouser();</div><div class="line">    TShirts dtx = new TShirts();</div><div class="line">    pqx.Decorate(xc);</div><div class="line">    kk.Decorate(pqx);</div><div class="line">    dtx.Decorate(kk);</div><div class="line">    dtx.Show();</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第二种装扮:“);</div><div class="line">    LeatherShoes px= new LeatherShoes ();</div><div class="line">    Tie ld = new Tie ();</div><div class="line">    Suit xz= new Suit ();</div><div class="line">    px.Decorate(xc);</div><div class="line">    kk.Decorate(pqx);</div><div class="line">    xz.Decorate(kk);</div><div class="line">    xz.Show();</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第三种装扮:“);</div><div class="line">    Sneakers pqx2= new Sneakers();</div><div class="line">    LeatherShoes px2= new LeatherShoes ();</div><div class="line">    BigTrouser kk2= new BigTrouser();</div><div class="line">    Tie ld2 = new Tie ();</div><div class="line">    pqx2.Decorate(xc);</div><div class="line">    px2.Decorate(pqx2);</div><div class="line">    kk2.Decorate(px2);</div><div class="line">    ld2 .Decorate(kk2);</div><div class="line">    ld2 .Show();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">第一种装扮：</div><div class="line">大T血  大裤子  破球鞋  装扮的小菜</div><div class="line"></div><div class="line">第二种装扮：</div><div class="line">西装  领带  皮鞋  装扮的小菜</div><div class="line"></div><div class="line">第三种装扮：</div><div class="line">领带  大裤子  皮鞋  破球鞋  装扮的小菜</div></pre></td></tr></table></figure></p>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>1.Context与ContextImpl<br>2.Activity的onCreate方法中一些相关的初始化操作。<br>装饰模式其实并不复杂，就是一种类间的封装。在平时的开发过程中也经常会不经意地使用类似的概念，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> classs DecoratorActivity extends Activity&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">// 初始化数据</span></div><div class="line">        initData();</div><div class="line">        <span class="comment">// 初始化控件</span></div><div class="line">        initViews();</div><div class="line">        <span class="comment">// 初始化事件</span></div><div class="line">        initEvent();</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 初始化数据</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 初始化控件</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span></span>&#123;</div><div class="line">            setContentView(R.layout.activity_main);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        *初始化事件</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实如上的一些新增方法的调用就类似装饰模式中的装饰者的职责，只不过这里没有保持对组件类的引用。</p>
<h1 id="Java中的装饰模式"><a href="#Java中的装饰模式" class="headerlink" title="Java中的装饰模式"></a>Java中的装饰模式</h1><p>Java IO 流是典型的装饰模式。</p>
<!--
相关书籍章节：
大话设计模式（程杰）——44页 第6章 穿什么有这么重要？——装饰模式
Android源码设计模式解析与实战——403页 第21章 装饰模式
-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名：装饰模式&lt;br&gt;外文名：Decorator Pattern&lt;br&gt;又名：装饰者模式 | 包装模式&lt;br&gt;设计原则：遵循单一职责原则、开闭原则、迪米特原则，破坏里氏替换原则，体现功能复用&lt;br&gt;使用概率：99.99999%&lt;br&gt;复杂度：中&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_decorator1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://hengxing0080.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
