<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹空间</title>
  <subtitle>时空在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-07-15T14:06:30.274Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法 —— 其他：取模运算</title>
    <link href="https://hengxing0080.github.io/2017/07/16/it/Algorithm/ModuloOperation/"/>
    <id>https://hengxing0080.github.io/2017/07/16/it/Algorithm/ModuloOperation/</id>
    <published>2017-07-16T12:26:32.000Z</published>
    <updated>2017-07-15T14:06:30.274Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_modulo1.jpg" alt="UML图"></p>
<p>有些刚毕业刚入职的程序猿同学因为上学时数学学的不好且有些算法好久不用而遗忘，<br>因为模运算在编程算法设计中属于高频使用，<br>而且负数，0,1，小数模于大数等等的模运算当时自己也弄的很迷茫，<br>所以工作多年后用自己白话的方式做了下整理以为遗忘时参考！</p>
<a id="more"></a>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>就是求余数</p>
<h1 id="根据排列组合得出运算规律"><a href="#根据排列组合得出运算规律" class="headerlink" title="根据排列组合得出运算规律"></a>根据排列组合得出运算规律</h1><ul>
<li>1.如果出现负数，只看被模数（左边的数），不看右边，例1%-5=1，-1%5=-1</li>
<li>2.左边是1，结果是1</li>
<li>3.右边是1，结果是0</li>
<li>4.左边小于右边，结果是左边</li>
<li>5.左边等于右边，结果是0</li>
<li>6.左边大于右边，这个就是简单最常用的情况了，直接看有没有余数</li>
</ul>
<h1 id="简单运算示例"><a href="#简单运算示例" class="headerlink" title="简单运算示例"></a>简单运算示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">0%0     NaN     // 除数不能为零，所以无意义，如果是Java编译的就报异常了（ArithmeticException / by zero)</div><div class="line">0%1     0       // 0模于什么都等于0，这组以下以此类推</div><div class="line">0%2     0</div><div class="line">0%100   0</div><div class="line"></div><div class="line">-1%-1   0   </div><div class="line">-1%1    0   </div><div class="line">1%1     0       </div><div class="line">1%2     1       // 那不就是1除以2，余数当然是1</div><div class="line">1%3     1       // 这组得1的都参考运算规律2</div><div class="line">1%4     1     </div><div class="line">-1%5    -1      // 参考运算规律1   </div><div class="line">1%5     1</div><div class="line">1%-5    1     </div><div class="line">1%100   1</div><div class="line"></div><div class="line">2%1     1      </div><div class="line">-2%3    -2</div><div class="line">2%      2</div><div class="line">2/5=?   0       // 如果不做类型转换的话结果去整数部分 所以是0</div><div class="line">2%5=?   2       // 0*5+2=2 所以是2</div><div class="line">2%-100  2       // 参考运算规律1  </div><div class="line"></div><div class="line">-3 % 3  0</div><div class="line">3 % 4   3       // 商0余3，结果为3</div><div class="line"></div><div class="line">-4%5    4       // 4除以5等于0余4，因此结果是4</div><div class="line">4%5     4       </div><div class="line">4%-5    4       // 正负跟第一个数有关，跟第二个无关，正如：-4%5=-4</div><div class="line"></div><div class="line">5 % 6   5</div><div class="line">5 % 9   5</div><div class="line"></div><div class="line">9 % 5   5</div></pre></td></tr></table></figure>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="判别奇偶数"><a href="#判别奇偶数" class="headerlink" title="判别奇偶数"></a>判别奇偶数</h2><p>奇偶数的判别是模运算最基本的应用，也非常简单。<br>已知一个整数n对2取模，如果余数为0，则表示n为偶数，否则n为奇数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">    System.out.print(<span class="string">"请输入您要判断的数字:"</span>);</div><div class="line">    <span class="keyword">int</span> num=sc.nextInt();</div><div class="line">    <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">        System.out.println(<span class="string">"您输入的是一个偶数"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        System.out.println(<span class="string">"您输入的是一个奇数"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a>判断素数</h2><p>质数又称素数,是指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数</p>
<p>一个数，如果只有1和它本身两个因数，这样的数叫做质数（或素数）。<br>例如 2，3，5，7 是质数，而 4，6，8，9 则不是，后者称为合成数或合数。</p>
<p>判断某个自然数是否是素数最常用的方法就是试除法：用比该自然数的平方根小的正整数去除这个自然数，若该自然数能被整除，则说明其非素数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 扫描器，接收控制台输入信息</span></div><div class="line">        System.out.print(<span class="string">"请输入一个整数："</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> num = scan.nextInt();          <span class="comment">// 取出控制台输入的信息</span></div><div class="line">            <span class="keyword">if</span> (isPrime(num)) &#123;     </div><div class="line">                System.out.println(num + <span class="string">"是素数！"</span>);   </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(num + <span class="string">"不是素数！"</span>); </div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"请输入整数"</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用于判断一个数是否为素数，若为素数，返回true,否则返回false</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> a 输入的值</div><div class="line">     * <span class="doctag">@return</span> true、false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (a &lt; <span class="number">2</span>) &#123; <span class="comment">// 素数不能小于2</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(a); i++) &#123;  <span class="comment">// 巧用开平方函数提高效率</span></div><div class="line">                <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;  <span class="comment">// 若能被整除，则说明不是素数，返回false</span></div><div class="line">                    flag = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> flag;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="取模运算符在Java和C的不同之处"><a href="#取模运算符在Java和C的不同之处" class="headerlink" title="取模运算符在Java和C的不同之处"></a>取模运算符在Java和C的不同之处</h1><p>Java中：如果两个操作数均是整数，结果也是整数； 如果两个操作数中有一个是浮点数，结果也是浮点数，保留小数部分。这一点和C语言不同。<br>C语言中：%运算符的两个操作数只能是整数，不允许是浮点数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_modulo1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;有些刚毕业刚入职的程序猿同学因为上学时数学学的不好且有些算法好久不用而遗忘，&lt;br&gt;因为模运算在编程算法设计中属于高频使用，&lt;br&gt;而且负数，0,1，小数模于大数等等的模运算当时自己也弄的很迷茫，&lt;br&gt;所以工作多年后用自己白话的方式做了下整理以为遗忘时参考！&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 其他" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：队列</title>
    <link href="https://hengxing0080.github.io/2017/07/15/it/DataStructure/Queue/"/>
    <id>https://hengxing0080.github.io/2017/07/15/it/DataStructure/Queue/</id>
    <published>2017-07-15T09:50:32.000Z</published>
    <updated>2017-07-15T11:22:21.200Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_queue1.jpg" alt="UML图"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 队列<br>英文名 Queue</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>队列是一种先进先出（First in First out（缩写FIFO））一种特殊的线性表<br>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，<br>和栈一样，队列是一种操作受限制的线性表。<br>进行插入操作的端称为队尾，进行删除操作的端称为队头。<br><a id="more"></a></p>
<h1 id="情景比喻"><a href="#情景比喻" class="headerlink" title="情景比喻"></a>情景比喻</h1><p>队列非常好理解<br>如同一个水管<br>或者就像电影院前人们站成的排一样，第一个进入队列的人最先买票（出列），最后面的人不断紧跟队伍排队（入列）。<br><img src="/images/it_datastructure_queue2.png" alt="UML图"></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>队列在程序设计中用得非常频繁<br>如操作系统和客服系统<br>键盘进行各种字母数字的输入，到显示器上如记事本软件上的输出，其实就是队列的典型应用。</p>
<h1 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h1><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT 队列（Queue）</div><div class="line">Data</div><div class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</div><div class="line">Operatoion</div><div class="line">    InitQueue( *Q )</div><div class="line">        初始化操作，构造一个空队列Q。</div><div class="line">    DestroyQueue ( *Q )</div><div class="line">      	若队列Q已存在，则销毁它。</div><div class="line">    ClearQueue ( *Q )</div><div class="line">      	将Q清为空队列。</div><div class="line">    QueueEmpty( Q )</div><div class="line">     	若Q为空队列，则返回TRUE，否则返回FALSE。</div><div class="line">    QueueLength( Q )</div><div class="line">      	返回Q的数据元素个数，即队列的长度。</div><div class="line">    GetHead( Q, *e )</div><div class="line">     	队列Q已存在且非空，用e返回Q的队头元素。</div><div class="line">    EnQueue( *Q, e )</div><div class="line">      	队列Q已存在，插入元素e为Q的新的队尾元素。</div><div class="line">    DeQueue( *Q, *e )</div><div class="line">      	队列Q已存在且非空，删除Q的队头元素，并用e返回其值。</div><div class="line">endADT</div></pre></td></tr></table></figure>
<hr>
<h1 id="队列的两种存储方式"><a href="#队列的两种存储方式" class="headerlink" title="队列的两种存储方式"></a>队列的两种存储方式</h1><hr>
<p>线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队列作为一种特殊的线性表，也同样存在这两种存储方式。<br>先看下队列的顺序存储结构。</p>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>队列的顺序储存结构称为顺序队列，就是用一组地址连续的存储空间来存放队列中的数据元素的。<br>顺序队列是队列的一种，它具有队列的特征。<br>顺序队列使用front和rear两个指针分别指示队头元素和队尾元素的位置。<br>顺序队列只能从队头（front端）删除元素，向队尾（rear端）添加新元素。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.静态分配存储空间。<br>2.入队操作只能在队尾，出队操作只能在队首<br>3.队列为空时，front = rear<br>4.队列为满时， rear = 队列长度 -1<br>5.队列非空非满时，Front &lt; rear &lt; 队列长度 -1</p>
<h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。</p>
<p>假设长度为5的数组，front与rear指针均指向下标为0的的位置，然后入队a1,a2,a3,a3,a4,front指针依然指向下标为0位置，而rear指针指向下标为4的位置<br><img src="/images/it_datastructure_queue3.png" alt="UML图"></p>
<p>出队a1,a2,则dfront指针指向下标为2的位置，rear不变，再入队a5,此时front指针不变，rear指针移动到数组之外？（问题来了）<br><img src="/images/it_datastructure_queue4.png" alt="UML图"></p>
<p>问题还不止于此。假设这个队列的总个数不超过5个，但目前如果接着入队的话，因数组末尾已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在下标为0和1的地方还是空闲的，这种现象叫做’假溢出’.</p>
<p>解决假溢出的方法就是后面满了，就再从头开始，也就是头尾相接的循环，<br>把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>对于队列来说，为了避免数组插入和删除时需要移动数据，引入循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
<h4 id="判断公式"><a href="#判断公式" class="headerlink" title="判断公式"></a>判断公式</h4><ul>
<li><p><strong>1.判断空队列条件</strong><br>front == rear</p>
<p>  不过下列图中有个问题<br>  <img src="/images/it_datastructure_queue5.png" alt="UML图"><br>  正常通用的情况是空队列时，front等于rear，不过上述图中当队列满时也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？</p>
<p>  办法1：设置一个标志遍历flag，当front == rear，且flag = 0时为队列空，当front==rear，且flag = 1时为队列满。</p>
<p>  办法2：当队列空时，条件就是front = rear当队列满时，我们修改其条件，数组中保留一个空闲元素空间。如上图左，我们就认为此队列已经满了，也就是说，不允许右图情况出现。</p>
</li>
<li><p><strong>2.判断满队列条件</strong><br>(rear+1)%QueueSize == front</p>
</li>
<li><p><strong>3.获取通用计算队列长度公式</strong><br>(rear-front+QueueSize)%QueueSize</p>
</li>
</ul>
<hr>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType; <span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">    QElemType data[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> front;      <span class="comment">/* 头指针 */</span></div><div class="line">    <span class="keyword">int</span> rear;       <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></div><div class="line">&#125;SqQueue;</div><div class="line"></div><div class="line"><span class="comment">/* 初始化一个空队列Q */</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></div><div class="line">&#123;</div><div class="line">    Q-&gt;front=<span class="number">0</span>;</div><div class="line">    Q-&gt;rear=<span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span>  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span>  (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 循环队列的入队操作*/</span></div><div class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE == Q-&gt;front)    <span class="comment">/* 队列满的判断 */</span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    Q-&gt;data[Q-&gt;rear]=e;         <span class="comment">/* 将元素e赋值给队尾 */</span></div><div class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></div><div class="line">                                <span class="comment">/* 若到最后则转到数组头部 */</span></div><div class="line">    <span class="keyword">return</span>  OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 循环队列的出队操作*/</span></div><div class="line"><span class="comment">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)        <span class="comment">/* 队列空的判断 */</span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    *e=Q-&gt;data[Q-&gt;front];           <span class="comment">/* 将队头元素赋值给e */</span></div><div class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;  <span class="comment">/* front指针向后移一位置， */</span></div><div class="line">                                    <span class="comment">/* 若到最后则转到数组头部 */</span></div><div class="line">    <span class="keyword">return</span>  OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h4><p>顺序存储，若不是循环队列，算法的实践性能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还要研究一下不需要担心队列长度的链式存储结构。</p>
<hr>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出，简称链队列。</p>
<p>队头指针指向链队列的头结点<br>队尾指针指向终端结点<br><img src="/images/it_datastructure_queue6.png" alt="UML图"></p>
<p>空队列时，front和rear都指向头结点。<br><img src="/images/it_datastructure_queue7.png" alt="UML图"></p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>1.动态分配存储空间<br>2.入队操作在队尾进行，出队操作在队头进行。<br>3.链式队列在入队时无队满情况问题<br>4.链式队列为空队列的条件：front = rear</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType; 	<span class="comment">/* QElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>	/* 结点结构 */</span></div><div class="line">&#123;</div><div class="line">   QElemType data;</div><div class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;QNode,*QueuePtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>			/* 队列的链表结构 */</span></div><div class="line">&#123;</div><div class="line">   QueuePtr front,rear; <span class="comment">/* 队头、队尾指针 */</span></div><div class="line">&#125;LinkQueue;</div></pre></td></tr></table></figure>
<h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><p>其实就是在链表尾部插入结点<br><img src="/images/it_datastructure_queue8.png" alt="UML图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为Q的新的队尾元素 */</span></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q,QElemType e)</span></span></div><div class="line">&#123; </div><div class="line">    QueuePtr s=(QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">    <span class="keyword">if</span>(!s) <span class="comment">/* 存储分配失败 */</span></div><div class="line">        <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">    s-&gt;data=e;</div><div class="line">    s-&gt;next=<span class="literal">NULL</span>;</div><div class="line">    Q-&gt;rear-&gt;next=s; <span class="comment">/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span></div><div class="line">    Q-&gt;rear=s;       <span class="comment">/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span></div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><p>就是头结点的后继结点出队，将头结点的后继改为它后面的结点<br>若链表除头结点外只剩一个元素时，则需将rear指向头结点<br><img src="/images/it_datastructure_queue9.png" alt="UML图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q,QElemType *e)</span></span></div><div class="line">&#123;</div><div class="line">    QueuePtr p;</div><div class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    p=Q-&gt;front-&gt;next;    <span class="comment">/* 将欲删除的队头结点暂存给p，见图中① */</span></div><div class="line">    *e=p-&gt;data;          <span class="comment">/* 将欲删除的队头结点的值赋值给e */</span></div><div class="line">    Q-&gt;front-&gt;next=p-&gt;next;<span class="comment">/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span></div><div class="line">    <span class="keyword">if</span>(Q-&gt;rear==p)       <span class="comment">/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span></div><div class="line">        Q-&gt;rear=Q-&gt;front;</div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链式队列和循环队列的比较"><a href="#链式队列和循环队列的比较" class="headerlink" title="链式队列和循环队列的比较"></a>链式队列和循环队列的比较</h3><ul>
<li>1.从时间上<br>它们的基本操作都是常数时间O（1）<br>不过循环队列是事先申请好空间，使用期间不释放<br>而对于链队列，每次申请和释放节点也会存在一些时间开销<br>如果入队出队频繁，则两者还是有细微差异。</li>
<li>2.从空间上<br>循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。<br>而连队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。<br>所以在空间上，连队列更加灵活。<br>总的来说，在可以确定队列长度的情况下，建议用循环队列，如果无法预估队列长度时，用链队列。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_queue1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名 队列&lt;br&gt;英文名 Queue&lt;/p&gt;
&lt;h1 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h1&gt;&lt;p&gt;队列是一种先进先出（First in First out（缩写FIFO））一种特殊的线性表&lt;br&gt;特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，&lt;br&gt;和栈一样，队列是一种操作受限制的线性表。&lt;br&gt;进行插入操作的端称为队尾，进行删除操作的端称为队头。&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：选择排序</title>
    <link href="https://hengxing0080.github.io/2017/07/09/it/Algorithm/SortSelection/"/>
    <id>https://hengxing0080.github.io/2017/07/09/it/Algorithm/SortSelection/</id>
    <published>2017-07-09T08:26:32.000Z</published>
    <updated>2017-07-15T11:22:22.685Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortselection1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortselection2.gif" alt="UML图"></p>
<a id="more"></a>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>选择排序（Selection sort）<br>是一种简单直观的排序算法。<br>它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 </p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n2)<br>尽管与冒泡排序同为O（n2），但选择排序的性能上还是要略优于冒泡排序。<br>因为交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)  (用于交换和记录索引)</p>
<h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>不稳定的排序方法。</p>
<p>举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>破坏顺序有什么关系？ 如果以节约时间为目的，选择排序似乎肯定要比冒泡排序好些，是这样吧？</p>
<p>他们两个的效率要根据具体的数据有不同的结论。主要是特殊的数据是递增还是递减，不过通常情况下选择排序的效率还是比较高的！<br>我们现在所做的拿数据简单的做测试对破坏顺序当然没什么关系。但是如果是那结构体来排序呢？比如一个结构体里面包含一个人的学号和分数，要求在分数相等的情况下再按照学号排序，这个时候顺序就有关系了。</p>
<hr>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><hr>
<h2 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[]a)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> minIndex=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>((a==<span class="keyword">null</span>)||(a.length==<span class="number">0</span>))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)</div><div class="line">    &#123;</div><div class="line">        minIndex=i;<span class="comment">//无序区的最小数据数组下标</span></div><div class="line">        <span class="keyword">for</span>(intj=i+<span class="number">1</span>;j&lt;a.length;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//在无序区中找到最小数据并保存其数组下标</span></div><div class="line">            <span class="keyword">if</span>(a[j]&lt;a[minIndex])</div><div class="line">            &#123;</div><div class="line">                minIndex=j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(minIndex!=i)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//如果不是无序区的最小值位置不是默认的第一个数据，则交换之。</span></div><div class="line">            temp=a[i];</div><div class="line">            a[i]=a[minIndex];</div><div class="line">            a[minIndex]=temp;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-2（C）"><a href="#示例代码-2（C）" class="headerlink" title="示例代码 2（C）"></a>示例代码 2（C）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">        <span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> length;</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> temp = L-&gt;r[i];</div><div class="line">     L-&gt;r[i]=L-&gt;r[j];</div><div class="line">     L-&gt;r[j]=temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList *L)</span></span>&#123;</div><div class="line">     <span class="keyword">int</span> i,j,min;</div><div class="line">     <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;L-&gt;length;i++)&#123;</div><div class="line">           min = i;</div><div class="line">           <span class="keyword">for</span>(j = i+<span class="number">1</span>; j&lt;=L-&gt;length;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(L-&gt;r[min]&gt;L-&gt;r[j])&#123;</div><div class="line">                      min = j;                                </div><div class="line">                &#125;                      </div><div class="line">           &#125; </div><div class="line">           <span class="keyword">if</span>(i!=min)</div><div class="line">              swap(L,i,min);</div><div class="line">     &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-3（C-）"><a href="#示例代码-3（C-）" class="headerlink" title="示例代码 3（C#）"></a>示例代码 3（C#）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void(int[]group)</div><div class="line">&#123;</div><div class="line">    int temp;</div><div class="line">    int pos=0;</div><div class="line">    for(int i=0;i&lt; group.Length-1;i++)</div><div class="line">    &#123;</div><div class="line">        pos=i;</div><div class="line">        for(intj=i+1;j&lt;group.Length;j++)</div><div class="line">        &#123;</div><div class="line">            if(group[j]&lt;group[pos])</div><div class="line">            &#123;</div><div class="line">                pos=j;</div><div class="line">            &#125;</div><div class="line">        &#125;//第i个数与最小的数group[pos]交换</div><div class="line">        temp=group[i];</div><div class="line">        group[i]=group[pos];</div><div class="line">        group[pos]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortselection1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/it_algorithm_sortselection2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：冒泡排序</title>
    <link href="https://hengxing0080.github.io/2017/07/08/it/Algorithm/SortBubble/"/>
    <id>https://hengxing0080.github.io/2017/07/08/it/Algorithm/SortBubble/</id>
    <published>2017-07-08T11:12:32.000Z</published>
    <updated>2017-07-15T11:22:23.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbubble1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortbubble2.gif" alt="UML图"><br><img src="/images/it_algorithm_sortbubble3.gif" alt="UML图"><br><!-- http://www.oschina.net/code/snippet_103482_14730 --></p>
<a id="more"></a>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>冒泡排序（Bubble Sort）<br>是一种计算机科学领域的较简单的排序算法。<br>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。</p>
<p>它是一种交换排序。<br>利用交换数据元素的位置进行排序的方法称为交换排序。<br>常用的交换排序算法主要有冒泡排序和快速排序。</p>
<p>基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>冒泡排序算法的运作如下：（从后往前）<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n^2）</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(1)  (用于交换)</p>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>稳定</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.“编程复杂度”很低，很容易写出代码；<br>2.具有稳定性，这里的稳定性是指原序列中相同元素的相对顺序仍然保持到排序后的序列，</p>
<h2 id="冒泡排序和选择排序的特点"><a href="#冒泡排序和选择排序的特点" class="headerlink" title="冒泡排序和选择排序的特点"></a>冒泡排序和选择排序的特点</h2><p>比较两个数据项<br>交换两个数据项或复制其中一项。<br>就是每种算法的具体实现细节有所不同。</p>
<hr>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><hr>
<h2 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span></div><div class="line"> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j])</div><div class="line">                &#123;</div><div class="line">                    temp = a[j];</div><div class="line">                    a[j] = a[j + <span class="number">1</span>];</div><div class="line">                    a[j + <span class="number">1</span>] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-2（JavaScript）"><a href="#示例代码-2（JavaScript）" class="headerlink" title="示例代码 2（JavaScript）"></a>示例代码 2（JavaScript）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = arr.length, j;</div><div class="line">    <span class="keyword">var</span> tempExchangVal;</div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</div><div class="line">                tempExchangVal = arr[j];</div><div class="line">                arr[j] = arr[j + <span class="number">1</span>];</div><div class="line">                arr[j + <span class="number">1</span>] = tempExchangVal;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        i--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>];</div><div class="line"><span class="keyword">var</span> arrSorted = bubbleSort(arr);</div><div class="line"><span class="built_in">console</span>.log(arrSorted);</div><div class="line">alert(arrSorted);</div></pre></td></tr></table></figure>
<h2 id="示例代码-3（C-）"><a href="#示例代码-3（C-）" class="headerlink" title="示例代码 3（C#）"></a>示例代码 3（C#）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">namespace 数组排序</div><div class="line">&#123;</div><div class="line">    class Program</div><div class="line">    &#123;</div><div class="line">        static void Main(string[] args)</div><div class="line">        &#123;</div><div class="line">            int temp = 0;</div><div class="line">            int[] arr = &#123;23, 44, 66, 76, 98, 11, 3, 9, 7&#125;;</div><div class="line">            #region该段与排序无关</div><div class="line">            Console.WriteLine(&quot;排序前的数组：&quot;);</div><div class="line">            foreach (intiteminarr)</div><div class="line">            &#123;</div><div class="line">                Console.Write(item + &quot;&quot;);</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine();</div><div class="line">            #endregion</div><div class="line">            for (int i = 0; i &lt; arr.Length - 1; i++)</div><div class="line">            &#123;</div><div class="line">                #region将大的数字移到数组的arr.Length-1-i</div><div class="line">                for (int j = 0; j &lt; arr.Length - 1 - i; j++)</div><div class="line">                &#123;</div><div class="line">                    if (arr[j] &gt; arr[j + 1])</div><div class="line">                    &#123;</div><div class="line">                        temp = arr[j + 1];</div><div class="line">                        arr[j + 1] = arr[j];</div><div class="line">                        arr[j] = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            #endregion</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine(&quot;排序后的数组：&quot;);</div><div class="line">            foreach (int item in arr)</div><div class="line">            &#123;</div><div class="line">                Console.Write(item+&quot;&quot;);</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine();</div><div class="line">            Console.ReadKey();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码-4（C）"><a href="#示例代码-4（C）" class="headerlink" title="示例代码 4（C）"></a>示例代码 4（C）</h2><h3 id="示例代码1"><a href="#示例代码1" class="headerlink" title="示例代码1"></a>示例代码1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 8</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j, temp;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - j; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                temp = a[i];</div><div class="line">                a[i] = a[i + <span class="number">1</span>];</div><div class="line">                a[i + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> number[SIZE] = &#123;<span class="number">95</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">51</span>, <span class="number">24</span>, <span class="number">12</span>&#125;;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    bubble_sort(number, SIZE);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, number[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码2（算法优化）"><a href="#示例代码2（算法优化）" class="headerlink" title="示例代码2（算法优化）"></a>示例代码2（算法优化）</h3><p>对冒泡排序算法进行简单的优化，用一个标记来记录在一趟的比较过程中是否存在交换，如果不存在交换则整个数组已经有序退出排序过程，反之则继续进行下一趟的比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status; </div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];   <span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></div><div class="line">    <span class="keyword">int</span> length;         <span class="comment">/* 用于记录顺序表的长度 */</span></div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 交换L中数组r的下标为i和j的值 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(SqList *L,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> temp=L-&gt;r[i]; </div><div class="line">    L-&gt;r[i]=L-&gt;r[j]; </div><div class="line">    L-&gt;r[j]=temp; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 用于打印结果 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(SqList L)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L.length;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d,"</span>,L.r[i]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,L.r[i]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作改进优化冒泡算法 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    Status flag=TRUE;                <span class="comment">/* flag用来作为标记 */</span></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag;i++) <span class="comment">/* 若flag为true说明有过数据交换，否则停止循环 */</span></div><div class="line">    &#123;</div><div class="line">        flag=FALSE;                  <span class="comment">/* 初始为False */</span></div><div class="line">        <span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i;j--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(L-&gt;r[j]&gt;L-&gt;r[j+<span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                 swap(L,j,j+<span class="number">1</span>); <span class="comment">/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span></div><div class="line">                 flag=TRUE;     <span class="comment">/* 如果有数据交换，则flag为true */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="其他博文推荐"><a href="#其他博文推荐" class="headerlink" title="其他博文推荐"></a>其他博文推荐</h1><hr>
<p><a href="http://blog.csdn.net/cjf_iceking/article/details/7911027" target="_blank" rel="external">太阳落雨–冒泡排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbubble1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/it_algorithm_sortbubble2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/it_algorithm_sortbubble3.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;&lt;!-- http://www.oschina.net/code/snippet_103482_14730 --&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>全球开发者调查统计报告（StackOverflow)</title>
    <link href="https://hengxing0080.github.io/2017/06/22/it/Statistics/RankingsDeveloper/"/>
    <id>https://hengxing0080.github.io/2017/06/22/it/Statistics/RankingsDeveloper/</id>
    <published>2017-06-22T02:35:15.000Z</published>
    <updated>2017-06-22T03:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/statistics_stackoverflow_logo.jpg" alt="LOGO"></p>
<p>信息来源官网：<a href="https://stackoverflow.com/" target="_blank" rel="external">StackOverflow</a><br>国外原地址传送门：<a href="https://insights.stackoverflow.com/survey/2017" target="_blank" rel="external">https://insights.stackoverflow.com/survey/2017</a><br>国内转载地址传送门：<a href="https://www.suilengea.com/show/xaimhemhxa.html" target="_blank" rel="external">StackOverflow 2017开发者调查报告（全译文）</a></p>
<p>Stack Overflow 发布了 2017 开发者调查报告，此次有超过 64,000 名开发人员参与调查，分别对其技能、工具、学习趋势等数据进行了统计！<br>详情请查看上面的地址！</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/statistics_stackoverflow_logo.jpg&quot; alt=&quot;LOGO&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息来源官网：&lt;a href=&quot;https://stackoverflow.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow&lt;/a&gt;&lt;br&gt;国外原地址传送门：&lt;a href=&quot;https://insights.stackoverflow.com/survey/2017&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://insights.stackoverflow.com/survey/2017&lt;/a&gt;&lt;br&gt;国内转载地址传送门：&lt;a href=&quot;https://www.suilengea.com/show/xaimhemhxa.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StackOverflow 2017开发者调查报告（全译文）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stack Overflow 发布了 2017 开发者调查报告，此次有超过 64,000 名开发人员参与调查，分别对其技能、工具、学习趋势等数据进行了统计！&lt;br&gt;详情请查看上面的地址！&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 统计调查" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式GOF之5 —— 原型模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/15/it/DesignPattern/5.Prototype/"/>
    <id>https://hengxing0080.github.io/2017/06/15/it/DesignPattern/5.Prototype/</id>
    <published>2017-06-15T05:21:32.000Z</published>
    <updated>2017-06-22T02:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：原型模式<br>英文名：Prototype<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_prototype1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍<br> ● Client：客户端用户。<br> ● Prototype：抽象类或者接口，声明具备clone能力。<br> ● ConcretePrototype：具体的原型类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p>
<h1 id="各种解释"><a href="#各种解释" class="headerlink" title="各种解释"></a>各种解释</h1><p>其实就是从一个对象在创建另外一个可定制的对象，而且不需知道任何创建的细节。</p>
<p>在系统中要创建大量的对象，这些对象之间具有几乎完全相同的功能，只是在细节上有一点儿差别。</p>
<p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这即隐藏了对象创建的细节。又对性能是大大的提高。<br>是不用重新初始化对象，而是动态地获得对象运行时的状态。</p>
<p>通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。</p>
<p>原型模式本质上就是对象拷贝，与C++中的拷贝构造函数有些类似，他们之间容易出现的问题也都是深拷贝，浅拷贝。使用原型模式可以解决构造复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。<br>还有一个重要的用途就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个只读对象修改，通常可以返回一个对象拷贝的形式实现只读的限制。</p>
<p>原型二字表明了该模式应用有一个样板示例，用户从这个样板对象中复制出一个内部属性一直的对象，这个过程也就是我们俗称的“克隆”。<br>被复制的实例就是我们锁称的“原型”，这个原型是可定制的。<br>原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经负载的实例可使程序运动更高效。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体验其优点。<br>new对象之所以效率低，是因为每New一次，都需要执行一次构造函数，如果构造函数的执行时间很长，那么多次的执行这个初始化操作就实在太低效了。<br>所以一般在初始化的信息不发生变化的情况下，克隆是最好的方法。<br>这即隐藏了对象创建的细节，又对性能是大大的提高，何乐而不为。</p>
<p>缺点：<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要在实际应用时考虑。<br>缺点是每一个类都必须配备一个克隆方法。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>1.类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗。<br>2.用过new产生一个对象需要非常繁琐的数据准备或访问权限，这是可以使用原型模式。<br>3.一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。<br>　需要注意的是，通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者成本较高时，通过clone方法才能够获得效率上的提升。<br>　因此，在使用Cloneable时需要考虑构建对象的成本以及做一些效率上的测试。<br>　当然，实现原型模式也不一定非要实现Cloneable接口，也有其他的实现方式，本章将会一一说明。</p>
<h1 id="使用方式和注意事项："><a href="#使用方式和注意事项：" class="headerlink" title="使用方式和注意事项："></a>使用方式和注意事项：</h1><h2 id="浅拷贝-影子拷贝-浅复制"><a href="#浅拷贝-影子拷贝-浅复制" class="headerlink" title="浅拷贝/影子拷贝/浅复制"></a>浅拷贝/影子拷贝/浅复制</h2><p>Object.clone方法是这样，<br>如果字段是值类型，则对字段执行逐位复制，<br>如果字段是引用类型，则复制引用但不复制引用对象，因此，原始对象及其复本引用同一对象。就是说如果有对象引用，那么引用的对象数据是不会被克隆过来的。<br>被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的应用都仍然指向原来的对象。</p>
<h2 id="深拷贝-深复制"><a href="#深拷贝-深复制" class="headerlink" title="深拷贝/深复制"></a>深拷贝/深复制</h2><p>把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。<br>就是把要复制的对象所引用的对象都复制一遍。</p>
<h1 id="2种使用方式"><a href="#2种使用方式" class="headerlink" title="2种使用方式"></a>2种使用方式</h1><p>1.Director<br>通过具有的Builder来构建产品对象，而Director封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<p>2.链式调用<br>值得注意点是，在现实开发过程中，Director角色经常会被忽略，而直接使用一个Builder来进行对象的组装，这个Builder通常为链式调用，<br>它的关键点是每个setter方法都返回自身，也就是retrun this，这样使得setter方法可以链式调用，代码大致如下：<br>New TestBuilder.setA(“A”).setB(“B”).create();<br>这样使得代码更简洁，易懂，例如下文示例代码中说到的ImageLoader就是通过ImageLoaderConfig进行配置，这就避免了目标类中被过多的接口污染。</p>
<h1 id="Android涉及到的抽象工厂设计模式"><a href="#Android涉及到的抽象工厂设计模式" class="headerlink" title="Android涉及到的抽象工厂设计模式"></a>Android涉及到的抽象工厂设计模式</h1><p>1.原型模式：比如我们需要一张Bitmap的几种不同格式：ARGB_8888、RGB_565、ARGB_4444、ALAPHA_8等。那我们就可以先创建一个ARGB_8888的Bitmap作为原型，在它的基础上，通过调用Bitmap.copy(Config)来创建出其它几种格式的Bitmap。<br>另外一个例子就是Java中所有对象都有的一个名字叫clone的方法，已经原型模式的代名词了</p>
<p>2.Intent</p>
<p>3.ArrayList的clone</p>
<h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><p>模式的简单实现</p>
<p>下面以简单的文档拷贝为例来演示一下简单的原型模式模式。<br>这个例子中首先创建了一个文档悐，即WorderdOCUMENT，这个文档中含有文字和图片。用户经过了长时间的内容编辑后，打算对该问的做进一步的编辑，但是，这个编辑后的当问是否会被才欧勇还不确定，因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 文档类型, 扮演的是ConcretePrototype角色，而cloneable是代表prototype角色</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文本</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String mText;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 图片名列表</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt;&lt;string&gt; mImages = <span class="keyword">new</span> ArrayList&lt;String&gt;&lt;string&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"----------- WordDocument构造函数 -----------"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 克隆对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</div><div class="line">            doc.mText = <span class="keyword">this</span>.mText;</div><div class="line">            doc.mImages = <span class="keyword">this</span>.mImages;</div><div class="line">            <span class="keyword">return</span> doc;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mText;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String mText)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mText = mText;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;string&gt; <span class="title">getImages</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mImages;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(String img)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mImages.add(img);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 打印文档内容</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"----------- Word Content Start -----------"</span>);</div><div class="line">        System.out.println(<span class="string">"Text : "</span> + mText);</div><div class="line">        System.out.println(<span class="string">"Images List: "</span>);</div><div class="line">        <span class="keyword">for</span> (String imgName : mImages) &#123;</div><div class="line">            System.out.println(<span class="string">"image name : "</span> + imgName);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"----------- Word Content End -----------"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过WordDocument类模拟了word文档中的基本元素，即文字和图片。<br>WordDocument的在该原型模式示例中扮演的角色为ConcretePrototype， 而Cloneable的角色则为Prototype。<br>WordDocument实现了clone方法以实现对象克隆。<br>注意，这个方法并不是Cloneable接口中的，而是Object中的方法。Cloneable也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现Cloneable接口却调用了clone()函数将抛出异常。<br>上面的代码中通过实现Clonable接口和覆写CLONE方法实现原型模式。<br>下面我们看看Client端的使用 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        WordDocument originDoc = <span class="keyword">new</span> WordDocument(); <span class="comment">//构造文档对象</span></div><div class="line">        originDoc.setText(<span class="string">"这是一篇文档"</span>);</div><div class="line">        originDoc.addImage(<span class="string">"图片1"</span>);</div><div class="line">        originDoc.addImage(<span class="string">"图片2"</span>);</div><div class="line">        originDoc.addImage(<span class="string">"图片3"</span>);</div><div class="line">        originDoc.showDocument();</div><div class="line"></div><div class="line">        WordDocument doc2 = originDoc.clone(); <span class="comment">//以原始文档为原型，拷贝一份副本</span></div><div class="line">        doc2.showDocument();</div><div class="line"></div><div class="line">        doc2.setText(<span class="string">"这是修改过的Doc2文本"</span>); <span class="comment">//修改文档副本，不会影响原始文档</span></div><div class="line">        doc2.showDocument();</div><div class="line">         </div><div class="line">        originDoc.showDocument();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/it_pattern_prototype2.jpg" alt="结果图"></p>
<p>可以看到，doc2是通过originDoc.clone()创建的，并且doc2第一次输出的时候和originDoc输出是一样的。即doc2是originDoc的一份拷贝，他们的内容是一样的，而doc2修改了文本内容以后并不会影响originDoc的文本内容。需要注意的是通过clone拷贝对象的时候并不会执行构造函数！</p>
<p>不过上述原型模式的实现实际上只是一个浅拷贝，这份拷贝实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段！</p>
<p>我们直接看下面的例子会出现的问题，将main函数的内容修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造文档对象（源）</span></div><div class="line">    WordDocument originDoc = <span class="keyword">new</span> WordDocument();</div><div class="line">    originDoc.setText(<span class="string">"这是一篇文档"</span>);</div><div class="line">    originDoc.addImage(<span class="string">"图片1"</span>);</div><div class="line">    originDoc.addImage(<span class="string">"图片2"</span>);</div><div class="line">    originDoc.addImage(<span class="string">"图片3"</span>);</div><div class="line">    originDoc.showDocument();</div><div class="line">    </div><div class="line">    <span class="comment">// 拷贝文档（副本）</span></div><div class="line">    WordDocument doc2 = originDoc.clone();</div><div class="line">    doc2.showDocument();</div><div class="line">    doc2.setText(<span class="string">"这是修改过的Doc2文本"</span>);</div><div class="line">    doc2.addImage(<span class="string">"哈哈.jpg"</span>);</div><div class="line">    doc2.showDocument();</div><div class="line">    </div><div class="line">    originDoc.showDocument();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/it_pattern_prototype3.jpg" alt="结果图"></p>
<p>细心的朋友可能发现了，最后两个文档信息输出是一致的。<br>我们在doc2添加了一张名为”哈哈.jpg”的照片，但是却也显示在originDoc中？这是怎么回事呢？<br>其实学习过C++的朋友都知道，这是因为上文中WordDocument的clone方法中只是简单的进行浅拷贝，引用类型的新对象doc2的mImages只是单纯的指向了this.mImages引用，而并没有进行拷贝。<br>doc2的mImages添加了新的图片，实际上也就是往originDoc里添加了新的图片，所以originDoc里面也有”哈哈.jpg” 。<br>那如何解决这个问题呢？ 那就是采用深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用的形式。clone方法修改如下 :</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 克隆对象</div><div class="line">  */</div><div class="line"> <span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</div><div class="line">         doc.mText = <span class="keyword">this</span>.mText;</div><div class="line">         <span class="comment">// doc.mImages = this.mImages;</span></div><div class="line">         doc.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</div><div class="line">         <span class="keyword">return</span> doc;</div><div class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         </div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>如上代码所示，将doc.mImages指向this.mImages的一份拷贝， 而不是this.mImages本身，这样在doc2添加图片时并不会影响originDoc，如图所示 :</p>
<p><img src="/images/it_pattern_prototype4.jpg" alt="结果图"></p>
<p>原型模式是非常简单的一个模式，它的核心问题就是对原始对象进行拷贝，在这个模式的使用过程中需要注意的多一点就是：深、浅拷贝的问题。<br>在开发过程中，建议使用该模式时尽量使用深拷贝，避免操作副本时影响原始对象的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：原型模式&lt;br&gt;英文名：Prototype&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_prototype1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之4 —— 建造者模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/08/it/DesignPattern/4.Builder/"/>
    <id>https://hengxing0080.github.io/2017/06/08/it/DesignPattern/4.Builder/</id>
    <published>2017-06-08T07:21:33.000Z</published>
    <updated>2017-06-22T02:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：建造者模式<br>别称：生成器模式<br>英文名：Builder<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_builder1.jpg" alt="UML图"><br><a id="more"></a><br>重要角色：<br>Build：为创建一个Product对象的各个部件指定的抽象接口。<br>ConcreteBuilder：具体建造者，实现Builder接口，构造和装配各个部件。<br>Product：具体的产品角色。<br>Director：指挥者，用它来控制统一组装建造过程，也用它来隔离用户与建造过程的关联。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>建造者模式是当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式.</p>
<p>将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。<br>建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>遵循单一职责、开闭原则</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点：<br>良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。<br>建造者独立，容易扩展。</p>
<p>缺点：<br>会产生多余的Builder对象以及Director对象，消耗内存。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>它主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。<br>相同的方法，不同的执行顺序，产生不同的事件结果时。<br>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。<br>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。</p>
<h1 id="2种使用方式"><a href="#2种使用方式" class="headerlink" title="2种使用方式"></a>2种使用方式</h1><p>1.Director<br>通过具有的Builder来构建产品对象，而Director封装了构建复杂产品对象的过程，对外隐藏构建细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<p>2.链式调用<br>值得注意点是，在现实开发过程中，Director角色经常会被忽略，而直接使用一个Builder来进行对象的组装，这个Builder通常为链式调用，<br>它的关键点是每个setter方法都返回自身，也就是retrun this，这样使得setter方法可以链式调用，代码大致如下：<br>New TestBuilder.setA(“A”).setB(“B”).create();<br>这样使得代码更简洁，易懂，例如下文示例代码中说到的ImageLoader就是通过ImageLoaderConfig进行配置，这就避免了目标类中被过多的接口污染。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><h2 id="1-组装电脑（Director方式）"><a href="#1-组装电脑（Director方式）" class="headerlink" title="1. 组装电脑（Director方式）"></a>1. 组装电脑（Director方式）</h2><p>计算机的组装过程较为复杂，并且组装顺序是不固定的，为了易于理解，我们把计算机组装的过程简化为构建主机、设置操作系统、设置显示器3个部分，然后通过Director和具体的Builder够构建计算机对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象产品类 - 计算机</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主板</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String mBoard;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 显示器</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String mDisplay;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 操作系统</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> String mOS;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置主板</div><div class="line">     * <span class="doctag">@param</span> board 主板类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoard</span><span class="params">(String board)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mBoard = board;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置显示器</div><div class="line">     * <span class="doctag">@param</span> display 显示器类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmDisplay</span><span class="params">(String display)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mDisplay = display;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置操作系统</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Computer&#123;"</span> +</div><div class="line">                <span class="string">"mBoard='"</span> + mBoard + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", mDisplay='"</span> + mDisplay + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", mOS='"</span> + mOS + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体产品类 - Macbook</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Macbook</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        mOS = <span class="string">"Mac OS X 10.10"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象Builder类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置主机</div><div class="line">     * <span class="doctag">@param</span> board 主机类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置显示器</div><div class="line">     * <span class="doctag">@param</span> display 显示器类型</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置操作系统</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建Computer</div><div class="line">     * <span class="doctag">@return</span> 返回一个完整的电脑</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体的Builder类，MacbookBuilder</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacbookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> Macbook();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span> </span>&#123;</div><div class="line">        mComputer.setBoard(board);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</div><div class="line">        mComputer.setDisplay(display);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        mComputer.setOS();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mComputer;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 导演类，负责构造Computer</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line"></div><div class="line">    Builder mBuilder = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mBuilder = builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构建对象</div><div class="line">     * <span class="doctag">@param</span> board</div><div class="line">     * <span class="doctag">@param</span> display</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String board, String display)</span> </span>&#123;</div><div class="line">        mBuilder.buildBoard(board);</div><div class="line">        mBuilder.buildDisplay(display);</div><div class="line">        mBuilder.buildOS();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 构建器</span></div><div class="line">        Builder builder = <span class="keyword">new</span> MacbookBuilder();</div><div class="line">        <span class="comment">// Director</span></div><div class="line">        Director pcDirector = <span class="keyword">new</span> Director(builder);</div><div class="line">        <span class="comment">// 封装构建过程，4核、内存2GB、Mac系统</span></div><div class="line">        pcDirector.construct(<span class="string">"英特尔主板"</span>, <span class="string">"Retina显示器"</span>);</div><div class="line">        <span class="comment">// 构建计算机，输出相关信息</span></div><div class="line">        System.out.println(<span class="string">"Computer Info: "</span> + builder.create().toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 输出结果</span></div><div class="line">Computer Info: Computer&#123;mBoard=<span class="string">'英特尔主板'</span>, mDisplay=<span class="string">'Retina显示器'</span>, mOS=<span class="string">'Mac OS X 10.10'</span>&#125;</div></pre></td></tr></table></figure>
<p>上述实例中，通过具体的MacbookBuilder来构建Macbook对象，而Director封装了构建复杂产品对象的过程，对外隐藏构建细节。<br>Builder与Director一起将一个复杂对象的构建过程与他的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<h2 id="2-配置ImageLoader（链式调用方式）"><a href="#2-配置ImageLoader（链式调用方式）" class="headerlink" title="2.配置ImageLoader（链式调用方式）"></a>2.配置ImageLoader（链式调用方式）</h2><p>还拿之前文章面向对象几大原则的中ImageLoader为例，随着不断的演进，这个库的可扩展性、灵活性越来越高，在带来用户关注的同时也需要开发一些新特性来满足用户的需求，比较典型的问题就是配置ImageLoader，<br>如设置图片再加载时ImageView显示的图片、加载失败后显示的图片、图片加载引擎线程数等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span></span>&#123;</div><div class="line">    <span class="comment">// 图片加载配置对象</span></div><div class="line">    <span class="keyword">private</span> ImageLoaderConfig mConfig;</div><div class="line"></div><div class="line">    <span class="comment">// 省略单例模式的代码</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化ImageLoader</div><div class="line">     * <span class="doctag">@param</span> config</div><div class="line">     */</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ImageLoaderConfig config)</span></span>&#123;</div><div class="line">         mConfig = config;</div><div class="line">         <span class="comment">// 检测配置的合法性，内部会根据配置做一些初始化操作</span></div><div class="line">         checkConfig();</div><div class="line">         <span class="comment">// 代码省略</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// 加载图片的函数</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String imageUrl, ImageView imageView)</span></span>&#123;</div><div class="line">         Bitmap bitmap = mImageCache.get(imageUrl);</div><div class="line">         <span class="keyword">if</span>(bitmap != <span class="keyword">null</span>)&#123;</div><div class="line">             imageView.setImageBitmap(bitmap);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 添加加载请求</span></div><div class="line">         submitLoadRequest(imageUrl,imageView);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitLoadRequest</span><span class="params">(<span class="keyword">final</span> String imageUrl, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">         <span class="comment">// 代码省略</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 把配置的代码基本上都封装到了ImageLoaderConfig和Builder对象中</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">public</span> class <span class="title">ImageLoaderConfig</span><span class="params">()</span></span>&#123;</div><div class="line">     </div><div class="line">     <span class="comment">// 图片缓存配置对象</span></div><div class="line">     BitmapCache bitmapCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">     <span class="comment">// 加载图片时的loading和加载失败的图片配置对象</span></div><div class="line">     DisplayConfig displayConfig = <span class="keyword">new</span> DisplayConfig();</div><div class="line">     <span class="comment">// 加载策略</span></div><div class="line">     LoadPlicy loadPolicy = <span class="keyword">new</span> SerialPolicy();</div><div class="line">     <span class="comment">// 线程数量，默认为CPU数量+1</span></div><div class="line">     <span class="keyword">int</span> threadCount = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</div><div class="line">     </div><div class="line">     <span class="comment">// 构造函数私有化</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="title">ImageLoaderConfig</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * 配置类的Builder</div><div class="line">      */</div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 图片缓存配置对象</div><div class="line">          */</div><div class="line">         BitmapCache bitmapCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 加载图片时的loading和加载失败的图片配置对象</div><div class="line">          */</div><div class="line">         DisplayConfig displayConfig = <span class="keyword">new</span> DisplayConfig();</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 加载策略</div><div class="line">          */</div><div class="line">         LoadPolicy loadPolicy = <span class="keyword">new</span> SerialPolicy();</div><div class="line">         <span class="comment">// 线程数量</span></div><div class="line">         <span class="keyword">int</span> threadCound = Runtime.getRuntime().availableProcessors()+<span class="number">1</span>;</div><div class="line">         <span class="comment">// 设置线程数量</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setThreadCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">             threadCount = Math.max(<span class="number">1</span>,count);</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置缓存</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setCache</span><span class="params">(BitmapCache cache)</span></span>&#123;</div><div class="line">             bitmapCache = cache;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置图片加载中显示的图片</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setLoadingPlacehoder</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">             displayConfig.loadingResId = resId;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置要加载的图片加载失败时显示的图片</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setNotFoundPlacehoder</span><span class="params">(<span class="keyword">int</span> resId)</span></span>&#123;</div><div class="line">             displayConfig.failedResId = resId;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">// 设置加载策略</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Builder <span class="title">setLoadPolicy</span><span class="params">(LoadPolicy policy)</span></span>&#123;</div><div class="line">             <span class="keyword">if</span>(policy != <span class="keyword">null</span>)&#123;</div><div class="line">                 loadPolicy = policy;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="function"><span class="keyword">void</span> <span class="title">applyConfig</span><span class="params">(ImageLoaderConfig config)</span></span>&#123;</div><div class="line">             config.bitmapCache = <span class="keyword">this</span>.bitmapCache;</div><div class="line">             config.displayConfig = <span class="keyword">this</span>.displayConfig;</div><div class="line">             config.loadPolicy = <span class="keyword">this</span>.loadPolicy;</div><div class="line">             config.threadCount = <span class="keyword">this</span>.threadCount;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">/**</span></div><div class="line">          * 根据已经设置好的属性创建配置对象</div><div class="line">          *</div><div class="line">          * <span class="doctag">@return</span> ImageLoaderConfig对象</div><div class="line">          */</div><div class="line">         <span class="function"><span class="keyword">public</span> ImageLoaderConfig <span class="title">create</span><span class="params">()</span></span>&#123;</div><div class="line">             ImageLoaderConfig config = <span class="keyword">new</span> ImageLoaderConfig();</div><div class="line">             <span class="comment">// 应用配置</span></div><div class="line">             applyConfig(config);</div><div class="line">             <span class="keyword">return</span> config;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>通过将ImageLoaderConfig的构造函数、字段私有化，使得外部不能访问内部属性，用户唯一能够设置属性的地方就是通过Builder对象了，也就是说用户只能通过Builder对象构造ImageLoaderConfig对象，这就是构建和表示相分离。</p>
<p>但是“使得相同的构造过程可以创建不用的表示”又是如何理解呢？在经典的Builder模式中海油一个Director和ConcreteBuilder角色，不同的ConcreteBuilder是可以创建不用的Product子类的，因此，也就是可以创建不用的表示。<br>我们这里并没有使用景点实现，以你，不做过多的描述。</p>
<p>下面看下客户端的使用代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageLoader</span><span class="params">()</span></span>&#123;</div><div class="line">    ImageLoaderConfig config = <span class="keyword">new</span> ImageLoaderConfig.Builder()</div><div class="line">     .setLoadingPlaceholder(R.drawable.loading)</div><div class="line">     .setNotFoundPlacehoder(R.drawable.not_found)</div><div class="line">     .setCache(<span class="keyword">new</span> DoubleCache(<span class="keyword">this</span>))</div><div class="line">     .setThreadCound(<span class="number">4</span>)</div><div class="line">     .setLoadPolicy(<span class="keyword">new</span> ReversePolicy()</div><div class="line">     .create());</div><div class="line">    <span class="comment">// 将配置初始化到ImageLoader中</span></div><div class="line">    ImageLoader.getInstance().init(config);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用init函数之后，ImageLoader就可以正常使用了，各种setter函数不会再用户调用ImageLoader方法时出现在视野中，他们已经被隔离到了Builder模式中。<br>API很清晰，简单！</p>
<h1 id="Android涉及到的抽象工厂设计模式"><a href="#Android涉及到的抽象工厂设计模式" class="headerlink" title="Android涉及到的抽象工厂设计模式"></a>Android涉及到的抽象工厂设计模式</h1><p>Builder模式在Anroid开发中也较为常用，通常作为配置类的构建器将配置的构建和表示分离开来，同事也是将配置从目标中隔离出来，避免过多的setter方法。</p>
<p>　1.Notification配置和创建过程如下：　<br>　　Notification noti = new Notification.Builder(this)<br>　　.setContentTitle(“标题”)<br>　　.setContentText(“文本内容”)<br>　　.setSmallIcon(R.drawable.ic_launcher_table)<br>　　.setLargeIcon(BitmapFactory.decodeResource<br>　　　　(getResources(), R.drawable.ic_launcher_table))　　<br>　　.build();<br>　　mNotificationManager.notify(0, noti);</p>
<p>　2.AlertDialog.Builder（可以分步地构造每一部分）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：建造者模式&lt;br&gt;别称：生成器模式&lt;br&gt;英文名：Builder&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_builder1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之3 —— 抽象工厂模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/04/it/DesignPattern/3.Abstract/"/>
    <id>https://hengxing0080.github.io/2017/06/04/it/DesignPattern/3.Abstract/</id>
    <published>2017-06-04T11:01:45.000Z</published>
    <updated>2017-06-22T02:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文吗：抽象工厂模式<br>英文名：Abstract Factory Pattern<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_abstract1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>虽然抽象工厂方法模式的类繁多，但是，主要还是分为4类：<br>　　AbstractFactory：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上述类图中的AbstractFactory中就定了两个方法，分别创建产品A和产品B。</p>
<p>　　ConcreteFactory：具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的ConcreteFactory1和CocreteFactory2.</p>
<p>　　AbstractProduct：抽象产品角色，它为每种产品声明接口，比如上述类中的AbstractProductA和AbstractProductB.</p>
<p>　　ConcreteProduct：具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象接口中声明的业务方法，如上述类图中的ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2.</p>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h1 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h1><p>工厂模式是对具体产品进行扩展，有的项目可能需要更多的扩展性，要对这个“工厂”也进行扩展，那就成了“抽象工厂模式”。</p>
<p>可以联想一下现实生活中的工厂肯定都是具体的，也就说每个工厂都会生产某一种具体的产品，那么抽象工厂意味着生产出来的产品是不确定的！<br>抽象工厂模式起源于以前对不用操作系统的图形化解决方案，如不同操作系统的按钮和文本框空间其实现不同，展示效果也不一样，对于每一个操作系统，其本身就构成一个产品类，而按钮与文本框空间也构成一个产品类，两种产品类两种变化，各自有自己的特性，如Android中的Button和TextView，Window Phone中的Button和TextView等。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>遵循单一职责、依赖倒置、开闭原则</p>
<h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><p>优点：<br>一个显著的优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活，容易。</p>
<p>缺点：<br>一是类文件的徒增（爆炸性增加），如果工厂类过多，势必导致类文件非常多，因此，在实际开发中一定要权衡慎用。<br>二是不太容易扩展新的产品类，因为每当我们增加一个产品类就需要修改抽象工厂，那么所有的具体工厂类均会被要做相应的修改。 </p>
<h1 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h1><p>一个对象族有相同的约束时可以使用抽象工厂模式。</p>
<p>举个例子，Android,IOS,Window Phone下都有短信软件和拨号软件，两者都属于Software软件的范畴，但是，它们所在的操作系统平台不一样，即便是同一家公司出品的软件，其代码的实现逻辑也是不同的，这时候可以考虑使用抽象工厂方法模式来产生android,ios,Window Phone下的短信软件和拨号软件。</p>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="示例1：车工厂造不同型号的车"><a href="#示例1：车工厂造不同型号的车" class="headerlink" title="示例1：车工厂造不同型号的车"></a>示例1：车工厂造不同型号的车</h2><blockquote>
<p>来源：《android源码设计模式解析与实战》————6.5</p>
</blockquote>
<p>语言：Java</p>
<p>案例描述：<br>以奥迪车工厂造奥迪车举例，虽然用到了之前的工厂方法模式，但是，后来发现一个问题，虽然Q3、Q5、Q7都是一个车系，但是三者之间的零部件差别确实很大，就拿Q3和Q7来说，Q3使用的发动机是国产的，而Q7的发动机是进口的；Q3的轮胎是普通的，Q7的轮胎是越野轮胎;还有Q3使用的是比较普通的制动系统，而Q7使用的是会自动性能极好的制动系统。<br>Q3、Q7对应的是一系列车，而发动机、轮胎、制动系统则对应的是一系列零部件，两者是两种不同的产品类型，这时候就可以将抽象工厂模式应用到其中，首先，骑车工厂需要生产轮胎、发动机、制动系统这3种部件。</p>
<p>抽象车厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</div><div class="line">    <span class="comment">// 生产轮胎  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ITire <span class="title">createTire</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// 生产发动机  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEngine <span class="title">createEngine</span><span class="params">()</span></span>;  </div><div class="line">    <span class="comment">// 生产制动系统  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBrake <span class="title">createBrake</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为每一种零部件产品定义一个接口，并分别创建两个不同的实现类表示不同的零部件产品。<br>轮胎相关类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITire</span> </span>&#123;  </div><div class="line">    <span class="comment">// 轮胎  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"普通轮胎"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUVTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"越野轮胎"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发动机相关类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEngine</span> </span>&#123;  </div><div class="line">    <span class="comment">// 发动机  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomesticEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"国产发动机"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"进口发动机"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>制动系统相关类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrake</span> </span>&#123;  </div><div class="line">    <span class="comment">// 发制动系统  </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"普通制动"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"高级制动"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于生产Q3的工厂，其使用的零部件不同，而生产Q7的工厂呢，其零部件也不同。<br>Q3工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalTire();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DomesticEngine();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createBrate</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Q7工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q7Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SUVTire();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImportEngine();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createBrate</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SeniorBrake();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端类模拟<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 生产一个Q3的工厂类  </span></div><div class="line">        CarFactory q3Factory3 = <span class="keyword">new</span> Q3Factory();  </div><div class="line">        carFactory3.createTire().tire();  </div><div class="line">        carFactory3.createEngine().engine();  </div><div class="line">        carFactory3.createBrake().brake();  </div><div class="line"></div><div class="line">        System.out.println(<span class="string">"================================="</span>);  </div><div class="line"></div><div class="line">        <span class="comment">// 生产一个Q7的工厂类  </span></div><div class="line">        CarFactory carFactory7 = <span class="keyword">new</span> Q7Factory();  </div><div class="line">        carFactory7.createTire().tire();  </div><div class="line">        carFactory7.createBrake().brake();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">普通轮胎</div><div class="line">国产发动机</div><div class="line">普通制动</div><div class="line">-----------------------------------------</div><div class="line">越野轮胎</div><div class="line">进口发动机</div><div class="line">高级制动</div></pre></td></tr></table></figure></p>
<h2 id="示例2：切换不同的数据库和使用不用的数据库表"><a href="#示例2：切换不同的数据库和使用不用的数据库表" class="headerlink" title="示例2：切换不同的数据库和使用不用的数据库表"></a>示例2：切换不同的数据库和使用不用的数据库表</h2><blockquote>
<p>来源：《大话设计模式》————15章</p>
</blockquote>
<p>语言：Java</p>
<p>案例描述：<br>有一个公司，是给一家去也做的电子商务网站，是用SQL Server作为数据库的。后来，这家公司接到另外一家公司类似需求的项目，但这家公司想省钱，租用一个空间，只能用Access，不能用SQL Server，于是乎，就需要程序员来改造原来那个项目的代码，但是发现数据库被写死了…</p>
<p>原客户端代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">        SqlServerUser su = <span class="keyword">new</span> SqlServerUser(); <span class="comment">// 与SQL Server耦合</span></div><div class="line">        su.insert(user);  </div><div class="line">        su.getUser(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之所以不能换数据库，原因就是在于SqlserverUser sql = new SqlserverUser()使得sql这个对象被锁死在SQL Server上了。<br>如果这里是灵活的，专业点的说法就是多态，<br>那么在执行sql.Insert(user);和sql.GetUser(1);时就不用考虑是在用SQL Server还是Access.</p>
<p>开始改造<br>先看下工厂方法模式实现（温习巩固一下）</p>
<h3 id="工厂方法模式实现"><a href="#工厂方法模式实现" class="headerlink" title="工厂方法模式实现"></a>工厂方法模式实现</h3><p>UML图例<br><img src="/images/it_pattern_abstract3.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IUser接口，用于客户端访问，解除与具体数据库访问的耦合</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;  </div><div class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// SqlserverUser类，用于访问SQL Server的User</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerUser</span> <span class="keyword">implements</span> <span class="title">IUser</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>&#123; </div><div class="line">        System.out.println(<span class="string">"在SQL Server中给User表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在SQL Server中根据ID得到User表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">// AccessUser类，用于访问Access的User  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessUser</span> <span class="keyword">implements</span> <span class="title">IUser</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中给User表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中根据ID得到User表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// IFactory接口，定义一个创建访问User表对象的抽象的工厂接口  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span>  </span>&#123;  </div><div class="line">    <span class="function">IUser <span class="title">createUser</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// SqlServerFactory类，实现IFactory接口，实例化SqlServerUser  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlServerUser();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// AccessFactory类，实现IFactory接口，实例化AccessUser  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessUser();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 客户端代码  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">  </div><div class="line">        <span class="comment">// IFactory factory = new AccessFactory();  </span></div><div class="line">        IFactory factory = <span class="keyword">new</span> SqlServerFactory();  </div><div class="line">  </div><div class="line">        IUser iu = factory.createUser();  </div><div class="line">  </div><div class="line">        iu.insert(user);  </div><div class="line">        iu.getUser(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若要改成Access数据库，只需要改为IFactory factory = new AccessFactory();<br>由于多态的关系，使得声明IUser接口的对象iu事先根本不知道是在访问哪个数据库，缺可以在运行时很好地完成工作，这就是所谓的业务逻辑与数据访问的解耦。</p>
<p>但是确定依然还在，<br>客户端代码还是有修改的地方（new SqlServerFactory())<br>还有数据库里不可能只有一个User表，很可能有其他表，比如增加部门表（Department表）<br>此时就需要用到抽象工厂模式了！</p>
<h3 id="抽象工厂模式实现"><a href="#抽象工厂模式实现" class="headerlink" title="抽象工厂模式实现"></a>抽象工厂模式实现</h3><p>UML图例<br><img src="/images/it_pattern_abstract2.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Department类  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     id;  </div><div class="line">    <span class="keyword">private</span> String  name;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> id;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.id = id;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// IDepartment接口，用于客户端访问，解除与具体数据库访问的耦合  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDepartment</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Department department)</span></span>;  </div><div class="line">    <span class="function">Department <span class="title">getDepartment</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// SqlServerDepartment类，用于访问SQL Server的Department  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerDepartment</span> <span class="keyword">implements</span> <span class="title">IDepartment</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Department department)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在SQL Server中给Deaprtment表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在SQL Server中根据ID得到Deaprtment表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// AccessDepartment类，用于访问Access的Department  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessDepartment</span> <span class="keyword">implements</span> <span class="title">IDepartment</span>  </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Department department)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中给Deaprtment表增加一条记录"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"在Access中根据ID得到Deaprtment表一条记录"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// IFactory接口，定义一个创建访问User表对象的抽象工厂接口  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span>  </span>&#123;  </div><div class="line">    <span class="function">IUser <span class="title">createUser</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// SqlServerFactory类，实现IFactory接口，实例化SqlServerUser和SqlServerDepartment  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlServerFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlServerUser();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlServerDepartment();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// AccessFactory类，实现IFactory接口，实例化AccessUser和AccessDepartment  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IUser <span class="title">createUser</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessUser();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span>  </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessDepartment();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 客户端代码  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span></div><div class="line">    &#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">        Department department = <span class="keyword">new</span> Department();  </div><div class="line">  </div><div class="line">        <span class="comment">// 只需确定实例化哪一个数据库访问对象给factory</span></div><div class="line">        <span class="comment">// IFactory factory = new SqlServerFactory();  </span></div><div class="line">        IFactory factory = <span class="keyword">new</span> AccessFactory();  </div><div class="line">  </div><div class="line">        <span class="comment">// 则此时已与具体的数据库访问解除了依赖</span></div><div class="line">        IUser iu = factory.createUser();  </div><div class="line">        iu.insert(user);  </div><div class="line">        iu.getUser(<span class="number">1</span>);  </div><div class="line">  </div><div class="line">        <span class="comment">// 同上（解决了依赖）</span></div><div class="line">        IDepartment id = factory.createDepartment();</div><div class="line">        id.insert(department);  </div><div class="line">        id.getDepartment(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果显示如下：</span></div><div class="line">在Access中给User表增加一条记录  </div><div class="line">在Access中根据ID得到User表一条记录  </div><div class="line">在Access中给Deaprtment表增加一条记录  </div><div class="line">在Access中根据ID得到Deaprtment表一条记录</div></pre></td></tr></table></figure>
<p>不过是个模式就会有缺点的，都有不适用的时候，要辩证地看待问题啊。抽象工厂模式可以很方便地切换两个数据库访问的代码，但是如果你的需求来自增加功能，比如我们现在要增加项目表Project，你要改动哪些地方？”<br>那就要至少增加三个类，Iproject、SqlServerProject、AccessProject，还需要更改IFactory、SqlServerFactory和AccessFactory才可以完全实现。一改就是三个类，有点糟糕。<br>还有啊，客户端程序类显然不会只有一啊，有很多地方都在使用IUser或IDepartment，而这样的设计，其实在每一个类的开始都需要声明IFactory factory = new SqlServerFactory()，如果我有100个调用数据库访问的类，是不是就要更改100次IFactory factory = new AccessFactory()这样的代码才行？</p>
<p>所以继续改造！</p>
<h3 id="用简单工厂改进抽象工厂"><a href="#用简单工厂改进抽象工厂" class="headerlink" title="用简单工厂改进抽象工厂"></a>用简单工厂改进抽象工厂</h3><p>去除IFactory、SqlServerFactory和AccessFactory三个工厂类，取而代之的是一个DataAccess类，用一个简单工厂模式来实现。</p>
<p>UML图例<br><img src="/images/it_pattern_abstract4.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DataAccess类  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String db  = <span class="string">"Sqlserver"</span>; <span class="comment">// 数据库名称，可替换成Acess</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        IUser result = <span class="keyword">null</span>;  </div><div class="line">        <span class="comment">// 由于db的实现设置，所以此处可以根据选择实例化出相应的对象</span></div><div class="line">        <span class="keyword">switch</span>(db)&#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Sqlserver"</span>:</div><div class="line">                result = <span class="keyword">new</span> SqlServerUser();  </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"Access"</span>:</div><div class="line">                result = <span class="keyword">new</span> AccessUser();  </div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>&#123;  </div><div class="line">        IDepartment result = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (<span class="string">"Sqlserver"</span>.equals(db))&#123;  </div><div class="line">            result = <span class="keyword">new</span> SqlServerDepartment();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Access"</span>.equals(db))  &#123;  </div><div class="line">            result = <span class="keyword">new</span> AccessDepartment();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> result;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 客户端代码  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        User user = <span class="keyword">new</span> User();  </div><div class="line">        Department department = <span class="keyword">new</span> Department();  </div><div class="line">        </div><div class="line">        <span class="comment">// 直接得到实际的数据库访问实例，而不存在任何依赖 </span></div><div class="line">        IUser iu = DataAccess.createUser(); </div><div class="line">        iu.insert(user);  </div><div class="line">        iu.getUser(<span class="number">1</span>);  </div><div class="line">        </div><div class="line">        <span class="comment">// 同上</span></div><div class="line">        IDepartment id = DataAccess.createDepartment();  </div><div class="line">        id.insert(department);  </div><div class="line">        id.getDepartment(<span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个设计表现在，与其用那么多的工厂类，不如直接用一个简单工厂来实现，直接抛弃了IFactory、SqlServerFactory和AccessFactory三个工厂类，取而代之的是DataAccess类，由于事先设置了db的值（Sqlserver或Access），所以简单工厂的方法都不需要输入参数，这样在客户端就只需要DataAccess.createUser()和DataAccess.createDepartment()来生成具体的数据库访问类实例，客户端没有出现任何一个SQL Server或Access的字样，达到了解耦合的目的。</p>
<p>不过还是不能得满分，原因是如果我需要增加Oracle数据库的访问，本来抽象工厂只增加一个OracleFactory工厂类就可以了，现在就比较麻烦了。<br>因为需在DataAccess类中每个方法的if分支语句里面增加了。</p>
<p>还是还得继续优化</p>
<h3 id="用反射-抽象工厂的数据访问程序"><a href="#用反射-抽象工厂的数据访问程序" class="headerlink" title="用反射+抽象工厂的数据访问程序"></a>用反射+抽象工厂的数据访问程序</h3><p>我们要考虑的就是可不可以不在程序里写明‘如果是Sqlserver就去实例化SQL Server数据库相关的类，如果是Access就去实例化Access相关的类’这样的语句，而是根据字符串db的值去某个地方找应该要实例化的类是哪一个。<br>这样，我们的if就可以对它说再见了。”</p>
<p>UML图例<br><img src="/images/it_pattern_abstract6.jpg" alt="UML图"></p>
<p>DataAccess类，用反射技术，取代IFactory、SqlserverFactory、AccessFactory．</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常规的写法  </span></div><div class="line">Iuser result = <span class="keyword">new</span> SqlServerUser();  </div><div class="line"></div><div class="line"><span class="comment">// 反射写法  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String db   = <span class="string">"SqlServer"</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String className  = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        className = db + <span class="string">"User"</span>;  </div><div class="line">        <span class="keyword">try</span>  &#123;  </div><div class="line">            <span class="keyword">return</span> (IUser) Class.forName(className).newInstance();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (InstantiationException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IllegalAccessException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>&#123;  </div><div class="line">        className = db + <span class="string">"Department"</span>;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            <span class="keyword">return</span> (IDepartment) Class.forName(className).newInstance();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (InstantiationException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IllegalAccessException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在如果我们增加了Oracle数据访问，相关的类的增加是不可避免的，这点无论我们用任何办法都解决不了，不过这叫扩展，<br>开放-封闭原则告诉我们，对于扩展，我们开放。但对于修改，我们应该要尽量关闭，<br>就目前而言，我们只需要更改private static final String  db  = “SqlServer”;为private static final String  db  = “Oracle”;<br>也就意味着(IUser) Class.forName(className).newInstance();这一句话发生了变化。<br>这样的结果就是DataAccess.createUser()本来得到的是SqlServerUser的实例，而现在变成了OracleUser的实例了。<br>那么如果我们需要增加Project产品时，如何做呢？<br>只需要增加三个与Project相关的类，再修改DataAccess，在其中增加一个public static IProject createProject()方法就可以了。</p>
<p>虽然比以前代码漂亮多了。<br>但总体感觉还是有缺憾，因为在更改数据库访问时，还是需要去改程序啊，改db这个字符串的值重编译，如果可以不改程序，那才是真正地符合开放-封闭原则。而且createUser()和createDepartment()的内部实现代码几乎是完全一致的。”</p>
<h3 id="用反射-配置文件实现数据访问程序（终极实现）"><a href="#用反射-配置文件实现数据访问程序（终极实现）" class="headerlink" title="用反射+配置文件实现数据访问程序（终极实现）"></a>用反射+配置文件实现数据访问程序（终极实现）</h3><p>我们可以复用配置文件来解决更改DataAccess的问题。<br>就是在配置文件中写明是SqlServer还是Access，这样就连DataAccess类也不用更改了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 添加一个app.properties文件。内容如下：</span></div><div class="line">DB = SqlServer</div><div class="line"></div><div class="line"><span class="comment">// 回到DataAccess</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataAccess</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String       DB          = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String       className   = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties   properties  = <span class="keyword">new</span> Properties();  </div><div class="line">  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            properties.load(DataAccess.class.getClassLoader()  </div><div class="line">                    .getResourceAsStream(<span class="string">"config/app.properties"</span>));  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IOException e)  &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        DB = properties.getProperty(<span class="string">"DB"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">create</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        className = DB + name;  </div><div class="line">        <span class="keyword">try</span>&#123;  </div><div class="line">            <span class="keyword">return</span> Class.forName(className).newInstance();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (InstantiationException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (IllegalAccessException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">catch</span> (ClassNotFoundException e)&#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUser <span class="title">createUser</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> (IUser) create(<span class="string">"User"</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDepartment <span class="title">createDepartment</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> (IDepartment) create(<span class="string">"Department"</span>);  </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基本上可以得个满分木有啥问题了。现在我们应用了反射+抽象工厂模式解决了数据库访问时的可维护、可扩展问题。<br>从这个角度上说，所有的用简单工厂的地方，都可以考虑用反射技术消除if或switch，解除分支判断带来的耦合。</p>
<h1 id="Android涉及到的抽象工厂设计模式"><a href="#Android涉及到的抽象工厂设计模式" class="headerlink" title="Android涉及到的抽象工厂设计模式"></a>Android涉及到的抽象工厂设计模式</h1><p>抽象工厂方法模式在Android开发中使用得并不多，大家看到源码中的应用其实也是极少的，主要是在开发过程中很多会出现多个产品种类的情况，大部分情况我们使用工厂模式即可解决。</p>
<p>1.DAO与Service的使用</p>
<p>2.Activity的onCreate，Service的onBind，如果从Framework的角度来看Activity和Service都可以看做是一个具体的工厂，这样看相当于一个丑熊工厂方法模式的雏形也没错。</p>
<p>3.Activity底层对MediaPlayer的创建</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文吗：抽象工厂模式&lt;br&gt;英文名：Abstract Factory Pattern&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_abstract1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之2 —— 工厂模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/02/it/DesignPattern/2.Factory/"/>
    <id>https://hengxing0080.github.io/2017/06/02/it/DesignPattern/2.Factory/</id>
    <published>2017-06-02T03:31:55.000Z</published>
    <updated>2017-06-22T02:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>英文名：    Factory Pattern<br>所属类型：  创建型模式<br>2种用法：  简单工厂模式和工厂方法模式<br>俗称：     实例化对象模式<br>本质：     工厂方法代替new操作<br>类别：     管理模式</p>
<a id="more"></a>
<hr>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><hr>
<p>英文名：Simple Factory Pattern<br>别称：静态工厂方法模式（Static Factory Method）</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p>
<h2 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h2><p>它是工厂方法模式的一个弱化版本<br>不属于23种GOF设计模式之一<br>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。<br>简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p>
<h2 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h2><p><img src="/images/it_pattern_factory1.jpg" alt="UML图"></p>
<h2 id="该模式中包含的角色及其职责"><a href="#该模式中包含的角色及其职责" class="headerlink" title="该模式中包含的角色及其职责"></a>该模式中包含的角色及其职责</h2><p>工厂（Creator）角色<br>　　简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</p>
<p>抽象产品（Product）角色<br>　　简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</p>
<p>具体产品（Concrete Product）角色<br>　　是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点<br>工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的，对于客户端来说，去除了与具体产品的依赖。保持了封装对象创建过程的优点。明确了各自的职责和权利，有利于整个软件体系结构的优化。</p>
<p>缺点<br>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。<br>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；<br>这些缺点在工厂方法模式中得到了一定的克服。<br>就拿计算器Demo来说，如果要加一个求M数的N次方功能，是一定需要给运算工厂类的方法里加’case’的分支条件，就是说需要修改原有的类，不过这等于说，不但对扩展开放了，对修改也开放了，这样就违背了开闭原则。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂类负责创建的对象比较少；<br>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；<br>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。</p>
<h2 id="示例代码（C-）"><a href="#示例代码（C-）" class="headerlink" title="示例代码（C#）"></a>示例代码（C#）</h2><blockquote>
<p>来源：大话设计模式（书籍）——第8章 工厂方法模式</p>
</blockquote>
<p>具有加减乘除的计算器的代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class OperationFactory&#123;</div><div class="line">    public static Operation createOperate(string operate)&#123;</div><div class="line">        Operation oper = null;</div><div class="line">        switch(operate)&#123;</div><div class="line">            case &quot;+&quot;:</div><div class="line">                oper = new OperationAdd();</div><div class="line">                break;</div><div class="line">            case &quot;-&quot;:</div><div class="line">                oper = new OperationSub();</div><div class="line">                break;</div><div class="line">            case &quot;*&quot;:</div><div class="line">                oper = new OperationMul();</div><div class="line">                break;</div><div class="line">            case &quot;/&quot;:</div><div class="line">                oper = new OperationDiv();</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">        return oper;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端的应用</div><div class="line">Operation oper;</div><div class="line">oper = OperationFactory.createOperate(&quot;+&quot;);</div><div class="line">oper.NumberA = 1;</div><div class="line">oper.NumberB = 2;</div><div class="line">double result = oper.GetResult();</div></pre></td></tr></table></figure>
<hr>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>中文名:工厂方法模式<br>英文名:Factory Method Pattern</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</p>
<h2 id="各种解释"><a href="#各种解释" class="headerlink" title="各种解释"></a>各种解释</h2><p>工厂方法模式是完全符合设计原则的，其降低了对象之间的耦合度，而且，工厂方法模式依赖于抽象的架构，其将实例化的任务交由子类去完成，有非常好的扩展性。</p>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>和简单工厂一样都是集中分装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与产品对象的耦合。<br>工厂方法模式是简单工厂模式的进一步抽象和推广，由于使用了多态性。工厂方法模式保持了简单工厂模式的有点，而且克服了它的缺点。<br>还有工厂方法克服了简单工厂违背开闭原则的缺点，又保持了封装对象创建过程的优点。</p>
<p>缺点：<br>是由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。<br>每次为工厂方法模式添加新的产品时就要编写一个新的产品类，同时还要引入抽象层，这必然会导致类结构的复杂化，所以，在某些情况比较简单时，是否要使用工厂模式，需要设计者权衡利弊了。</p>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂模式。</p>
<h2 id="UML结构图例"><a href="#UML结构图例" class="headerlink" title="UML结构图例"></a>UML结构图例</h2><p><img src="/images/it_pattern_factory3.jpg" alt="UML图"></p>
<h2 id="示例代码1（C-）"><a href="#示例代码1（C-）" class="headerlink" title="示例代码1（C#）"></a>示例代码1（C#）</h2><blockquote>
<p>来源：大话设计模式（书籍）——第8章 工厂方法模式</p>
</blockquote>
<p>还是拿计算器举例</p>
<p>UML结构图例<br><img src="/images/it_pattern_factory2.jpg" alt="UML图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// 先构建一个工厂接口</div><div class="line">interface IFactory&#123;</div><div class="line">    Operation CreateOperation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后加减乘除各建一个具体工厂去实现这个接口</div><div class="line">// 加法类工厂</div><div class="line">class AddFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationAdd();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 减法类工厂</div><div class="line">class SubFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationSub();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 乘法类工厂</div><div class="line">class MulFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationMul();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 除法类工厂</div><div class="line">class DivFactory : IFactory&#123;</div><div class="line">    public Operation CreateOperation()&#123;</div><div class="line">        return new OperationDiv();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端实现效果</div><div class="line">IFactory operFactory = new AddFactory();</div><div class="line">Operation oper = operFactory.CreateOperation();</div><div class="line">oper.NumberA = 1;</div><div class="line">oper.NumberB = 2;</div><div class="line">double result = oper.GetResult();</div></pre></td></tr></table></figure>
<h2 id="示例代码2（Java）"><a href="#示例代码2（Java）" class="headerlink" title="示例代码2（Java）"></a>示例代码2（Java）</h2><blockquote>
<p>来源：Android源码设计模式解析与实战（书籍）——第5章 应用最广泛的模式——工厂方法模式</p>
</blockquote>
<p>UML结构图例<br><img src="/images/it_pattern_factory4.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象产品类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 具体的产品类 继承 产品抽象类，实现方法</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体产品A"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"具体产品B"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 抽象工厂类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象工厂方法</div><div class="line">     * 具体生产什么由子类去实现</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 具体的产品对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</div><div class="line">        <span class="comment">//  return new ConcreteProductB(); // 如果想得到ConcreteProductB的实例，直接替换注释即可</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Factory factory = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product p = factory.createProduct();</div><div class="line">        p.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的几个角色都很简单，主要分为四大模块，<br>一是抽象工厂，其为工厂方法模式的核心;<br>二是具体工厂，其实现了具体的业务逻辑;<br>三是抽象产品，是工厂方法模式所创建的产品的父类;<br>四是具体产品，为实现抽象产品的某个具体产品的对象。</p>
<p>利用反射的方式更简洁地来生产具体产品对象，<br>此时，需要在工厂方法的参数列表中传入一个Class类来决定是哪一个产品类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 抽象工厂方法</div><div class="line">     * 具体生产什么由子类去实现</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> clz 产品对象类型</div><div class="line">     * <span class="doctag">@return</span> 具体的产品对象</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于具体的工厂类，则通过反射获取类的示例即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> &lt;T extends Product&gt;<span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; clz)</span></span>&#123;</div><div class="line">        Product p = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            p = (Product)Class.forName(clz.getName().newInstance());</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (T)p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端中的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Factory factory = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product p = factory.createProduct(ConcreteProductB.class);</div><div class="line">        p.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要哪一个类的对象就传入哪一个类的类型即可，这种方法比较简洁、动态！<br>如果你不喜欢这种方法，也可以尝试为每一个产品都定义一个具体的工厂，各司其职：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Factory factoryA = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product productA = factoryA.createProduct();</div><div class="line">        productA.method();</div><div class="line"></div><div class="line">        Factory factoryB = <span class="keyword">new</span> ConcreteFactory();</div><div class="line">        Product productB = factoryB.createProduct();</div><div class="line">        productB.method();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这样拥有多个工厂的方式我们成为多工厂方法模式</p>
<p>回到最初的那个工厂方法模式，当我们的工厂只有一个的时候，我们还是为工厂提供了一个抽象类，那么，我们是否可以将其简化，然后将对应的工厂方法改为静态方法即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CpmcreteProductB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>像这样的方法其实就是简单工厂模式（静态工厂模式），它是工厂方法模式的一个弱化版本。</p>
<h1 id="Android涉及到的工厂模式"><a href="#Android涉及到的工厂模式" class="headerlink" title="Android涉及到的工厂模式"></a>Android涉及到的工厂模式</h1><p>1.各个生命周期方法，以onCreate，它就可以看做是一个工厂方法，我们在其中可以构造我们的view并通过setContentView返回给framework处理等。</p>
<p>2.List和Set，他们都继承于Collection接口，而Collection接口继承于Iterable接口，Iterable接口很简单，就一个iterator方法<br>public interface Iterable<t>{<br>Iterator<t> iterator();<br>}<br>这意味着List和Set接口也会继承该方法，平时比较常用的两个间接实现类ArrayList和HashSet中iterator方法的实现就是构造并返回一个迭代器对象，其实就相当于一个工厂方法，专为new对象而生，这里iterator方法是构造并返回一个具体的迭代器。</t></t></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单工厂模式和工厂方法模式都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与产品对象的耦合。</p>
<p>简单工厂模式和工厂方法模式都有个最佳用法就是都可以避免修改客户端——考虑用反射技能来去除switch或if解除分支判断带来的耦合。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;英文名：    Factory Pattern&lt;br&gt;所属类型：  创建型模式&lt;br&gt;2种用法：  简单工厂模式和工厂方法模式&lt;br&gt;俗称：     实例化对象模式&lt;br&gt;本质：     工厂方法代替new操作&lt;br&gt;类别：     管理模式&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之1 —— 单例模式（创建型模式）</title>
    <link href="https://hengxing0080.github.io/2017/06/01/it/DesignPattern/1.Singleton/"/>
    <id>https://hengxing0080.github.io/2017/06/01/it/DesignPattern/1.Singleton/</id>
    <published>2017-06-01T01:41:25.000Z</published>
    <updated>2017-06-22T02:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名:单例模式<br>中文别名：单实例模式 / 单态模式<br>英文名:Singleton pattern<br>所属类型：创建型模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_singleton.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h1 id="各种解释"><a href="#各种解释" class="headerlink" title="各种解释"></a>各种解释</h1><p>单例模式确保某一个类在内存中只能有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。</p>
<p>解决一个类在内存只存在一个对象（正常情况下，一个类在内存中能new很多对象）。</p>
<p>想要保证对象唯一<br>1.为了避免其他程序过多建立该类对象，先禁止其他程序建立该类对象<br>2.还为了让其他程序可以访问到该类对象，只好在本类中自定义一个对象。<br>3.为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。<br>这三部怎么用代码体现呢？<br>1.将构造函数私有化。<br>2.在类中创建一个本类对象。<br>3.提供一个方法可以获取到该对象。<br>了解思想！对于事物该怎么描述，还怎么描述。<br>当需要将该事物的对象保证在内存中唯一时，就将以上的三步加上即可。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点<br>1.由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建，销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。<br>2.由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如肚脐配置，产生其他依赖对象时，则可以用过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。<br>3.单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对用一个资源文件的同时写操作。<br>4.单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例累，负者所有数据表的映射处理，</p>
<p>缺点<br>1.单例模式一般没有接口，扩展很苦难，若要扩展，除了修改代码基本上没有第二种途径可以实现。<br>2.单例对如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context.（android开发的朋友要注意）<br>3.单例模式上手容易，但是需要注意很多问题，最重要的就是多线程并发的情况下保证单例的唯一性。<br>4.单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。<br>对于创建开销较大的类可使用此方法，保证全局一个实例，在程序运行过程中该类不会因新建额外对象产生开销。<br>例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这是就要考虑使用单例模式。</p>
<p>单例模式只应在有真正的“单一实例”的需求时才可使用。</p>
<p>公共接口一定要考虑到代码重入的情况，能设计为单例就尽量用单例。</p>
<h1 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h1><p>1.Context类的getSystemService(String key)<br>2.LayoutInflater<br>3.Universal-Image-ImageLoader</p>
<blockquote>
<p>参考书籍：Android源码设计模式解析与实战——第2章 应用最广的模式——单例模式</p>
</blockquote>
<hr>
<h1 id="四种单例写法"><a href="#四种单例写法" class="headerlink" title="四种单例写法"></a>四种单例写法</h1><hr>
<p>由于在客户端通常没有高并发的情况，因此，选择哪些实现方式并不会有太大的区别。<br>即便如此，出于效率考虑，推荐用DoubleCheckLock(DCL)实现单例和静态内部类单例模式</p>
<h2 id="1-饿汉式-和-懒汉式"><a href="#1-饿汉式-和-懒汉式" class="headerlink" title="1.饿汉式 和 懒汉式"></a>1.饿汉式 和 懒汉式</h2><p>懒汉式和饿汉式的区别：（可用于面试题）<br>　1.懒汉式的特点：<br>　　　实例的延迟加载<br>　2.懒汉式实例的延迟加载有没有问题？：<br>　　　有，如果多线程访问时会出现安全隐患问题<br>　3.如果多线程访问时会出现安全问题怎么解决？：<br>　　　可以加同步解决：加同步的方式用同步代码块或者同步函数都行，但是稍微有些低效，不过可以用双从判断（double-check）的方式可以稍微解决低效！<br>　4.加同步的时候使用的锁是哪一个：<br>  　　该类所属的字节码文件对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 单例设计模式——饿汉式（特点：先创建对象）</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single instance = <span class="keyword">new</span> Single();   </div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125; </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 单例设计模式——懒汉式（特点：后创建对象）</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;   <span class="comment">// 注意，没有final</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">                s = <span class="keyword">new</span> Single(); <span class="comment">// 对象被延迟加载</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>getInstance方法添加了synchronized关键字，也就是getInstance是一个同步方法，这就是上面所说的在多线程情况下保证单例对象唯一性的手段。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>细想一下，大家可能会发现一个问题，即使instance已经被初始化（第一次调用时就会被初始化instance），每次调用getInatance方法都会进行同步，<br>这样会消耗不必要的资源，这就是懒汉单例模式存在的最大问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优点是只有在使用时才被会被实例化，在一定程序上节约了资源<br>缺点是第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。<br>这种模式一般不建议使用。</p>
<h2 id="2-Double-Check-Lock-DCL-实现单例"><a href="#2-Double-Check-Lock-DCL-实现单例" class="headerlink" title="2.Double Check Lock(DCL)实现单例"></a>2.Double Check Lock(DCL)实现单例</h2><blockquote>
<p>来源：Android源码设计模式解析与实战——2.6.2 Double Check Lock（DCL）实现单例</p>
</blockquote>
<p>DCL方式实现单例模式的优点是既能够在需要时才初始化单例，又能够保证线程安全，且单例对象初始化后调用getInstance不进行同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="comment">// 同步代码块 </span></div><div class="line">            <span class="comment">// 注意：静态里不能写this，所以写字节码所属对象</span></div><div class="line">            <span class="keyword">synchronized</span>(Single.class)&#123;</div><div class="line">                <span class="comment">// 用双从判断的形式来解决低效的问题，稍微提高了懒汉式的效率</span></div><div class="line">                <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</div><div class="line">                    s = <span class="keyword">new</span> Single(); <span class="comment">// 对象此时被延迟加载</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DCL失效问题"><a href="#DCL失效问题" class="headerlink" title="DCL失效问题"></a>DCL失效问题</h3><p>本程序的亮点自然都在getInstance方法上，可以看到getInstance方法中对instance进行了两次判空：<br>第一层判断主要是为了避免不必要的同步，<br>第二层的判断则是为了在null的情况下创建实例。</p>
<p>这是什么意思呢？是不是有点摸不着头脑，下面就一起来分析一下。</p>
<p>假设线程A执行到instance= new Singleton()语句，这里看起来是一句代码，但实际上它并不是一个原子操作，这句代码最终会被编译成多条汇编指令，它大致做了3件事情：<br>（1）给Singleton的实例分配内存；<br>（2）调用Singleton()的构造函数，初始化成员字段；<br>（3）将instance对象指向分配的内存空间(此时instance就不是null了)。</p>
<p>但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM（JavaMemory Model，即Java内存模型）中Cache、寄存器到主存回写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序可能是1-2-3也可能是1-3-2.如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行过了第三点，instance已经是非空了，所以，线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的错误很可能会隐藏很久。</p>
<p>在JDK1.5之后，SUN官方已经注意到这种问题，调整了JMM、具体化volatile关键字，因此，如果JDK是1.5或之后的版本，只需要将instance的定义改成private volatile static Singleton instance = null就可以保证instance对象每次都是从主存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile或多或少也会影响到性能，但考虑到程序的正确性，牺牲这点性能还是值得的。</p>
<h3 id="DCL优点"><a href="#DCL优点" class="headerlink" title="DCL优点"></a>DCL优点</h3><p>资源利用率高，第一个执行getInstance时单例对象才会被实例化，效率高。</p>
<h3 id="DCL缺点"><a href="#DCL缺点" class="headerlink" title="DCL缺点"></a>DCL缺点</h3><p>第一次加载时反应稍慢。<br>也由于Java内存模型的原因偶尔会失效，在高并发环境下也有一定的缺陷，虽然发生概率很小。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>DCL模式是使用最多的单例实现方式，它能够在需要时才实例化单例对象，并且能够在绝大多数场景下保证单例对象的唯一性，<br>除非你的代码在并发场景比较复杂或者低于JDK6版本下使用，否则，这种方式一般能够满足需求。</p>
<h2 id="3-静态内部类单例模式"><a href="#3-静态内部类单例模式" class="headerlink" title="3.静态内部类单例模式"></a>3.静态内部类单例模式</h2><blockquote>
<p>来源：<br>　<a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">如何在Android中避免创建不必要的对象</a><br>　Android源码设计模式解析与实战——2.6.3 静态内部类单例模式</p>
</blockquote>
<p>所以DCL虽然在一定程序上解决了资源消耗、多余的同步、线程安全等问题，<br>但是，它还是在某些情况下出现失效的问题。这个问题被称为双重检查锁定（DCL）失效，<br>在《Java兵法编程实践》一书的最后谈到了这个问题，并指出这种“优化”是丑陋的，不赞成使用。而建议使用如下的代码替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在Java中，类的静态初始化会在类被加载时触发，我们利用这个原理，可以实现利用这一特性，结合内部类，可以实现下面的代码，进行懒汉式创建实例。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceHolder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一次加载Singleton类时并不会初始化sInstance，只有在第一次调用Singleton的getInstance方法时才会导致sInstance被初始化。<br>因为，第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，<br>所以这是推荐使用的单例模式实现方式。</p>
<h2 id="4：枚举单例"><a href="#4：枚举单例" class="headerlink" title="4：枚举单例"></a>4：枚举单例</h2><blockquote>
<p>来源书籍——Android源码设计模式解析与实战——2.6.4 枚举单例</p>
</blockquote>
<p>更简单的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SimpleSingleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"doSomething"</span>);</div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// Call the method from Singleton:  </span></div><div class="line">SimpleSingleton.INSTANCE.doSomething();</div></pre></td></tr></table></figure>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.写法简单是枚举单例最大的有点，枚举在Java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法。</p>
<p>2.最重要是默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。</p>
<p>  为什么这么说呢？<br>  因为上述的集中单例模式实现中，在一个情况下它们会出现重新创建对象的情况，那就是<font color="#FF0000"><strong>反序列化</strong></font>。<br>  通过序列化可以将一个单例的实例对象写到磁盘，然后在读回来，从而有效地活得一个实例。<br>  即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该累的构造函数。<br>  反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的、被实例化的方法readResolve(),这个方法可以让开发人员控制对象的反序列化。<br>  例如：上述几个示例中如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入如下方法：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readReslove</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</div><div class="line">    <span class="keyword">return</span> sInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  例而在单例中，并不存在这个问题，因为即使反序列化它也不会重新生成新的实例。<br>  也就是在readResolve方法中将sInstance对象返回，而不是默认的重新生成一个新的对象。</p>
<h2 id="5：使用容器实现单例模式"><a href="#5：使用容器实现单例模式" class="headerlink" title="5：使用容器实现单例模式"></a>5：使用容器实现单例模式</h2><blockquote>
<p>参考书籍——Android源码设计模式解析与实战——2.6.5 使用容器实现单例模式</p>
</blockquote>
<p>一种另类的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonManager</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Object instance)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!objMap.containsKey(key))&#123;</div><div class="line">            objMap.put(key,instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getService</span><span class="params">(String key)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> objMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类型注入到一个统一的管理工具类中，在使用根据key获取对象对应类型的对象。<br>这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名:单例模式&lt;br&gt;中文别名：单实例模式 / 单态模式&lt;br&gt;英文名:Singleton pattern&lt;br&gt;所属类型：创建型模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_singleton.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>世界编程语言排行榜（Tiobe)</title>
    <link href="https://hengxing0080.github.io/2017/05/31/it/Statistics/RankingsProgrammingLanguage/"/>
    <id>https://hengxing0080.github.io/2017/05/31/it/Statistics/RankingsProgrammingLanguage/</id>
    <published>2017-05-31T08:35:15.000Z</published>
    <updated>2017-06-22T03:04:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/statistics_programminglanguage_logo.jpg" alt="LOGO"></p>
<p>信息来源官网：TIOBE<br>Tiobe实时编程排行榜传送门：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="external">https://www.tiobe.com/tiobe-index/</a></p>
<p>下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据</p>
<p>TIOBE Index for May 2017<br><img src="/images/Rankings.jpg" alt="UML图"></p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/statistics_programminglanguage_logo.jpg&quot; alt=&quot;LOGO&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息来源官网：TIOBE&lt;br&gt;Tiobe实时编程排行榜传送门：&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据&lt;/p&gt;
&lt;p&gt;TIOBE Index for May 2017&lt;br&gt;&lt;img src=&quot;/images/Rankings.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 统计调查" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>世界编程语言排行榜（Tiobe官网实时排名)</title>
    <link href="https://hengxing0080.github.io/2017/05/31/it/Statistics/Rankings/"/>
    <id>https://hengxing0080.github.io/2017/05/31/it/Statistics/Rankings/</id>
    <published>2017-05-31T08:35:15.000Z</published>
    <updated>2017-07-16T05:35:47.351Z</updated>
    
    <content type="html"><![CDATA[<p>信息来源：TIOBE<br>Tiobe实时编程排行榜传送门：<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="external">https://www.tiobe.com/tiobe-index/</a></p>
<p>下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据</p>
<p>TIOBE Index for May 2017<br><img src="/images/Rankings.jpg" alt="UML图"></p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信息来源：TIOBE&lt;br&gt;Tiobe实时编程排行榜传送门：&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面这个 ↓ 我是手动截取Tiobe最近的排名前20的图片，如忘记更新图片过期请进 ↑ Tiobe网站查看实时数据&lt;/p&gt;
&lt;p&gt;TIOBE Index for May 2017&lt;br&gt;&lt;img src=&quot;/images/Rankings.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 统计调查" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E8%B0%83%E6%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式汇总</title>
    <link href="https://hengxing0080.github.io/2017/05/01/it/DesignPattern/0.Info/"/>
    <id>https://hengxing0080.github.io/2017/05/01/it/DesignPattern/0.Info/</id>
    <published>2017-05-01T02:21:20.000Z</published>
    <updated>2017-07-15T09:56:28.664Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr>
<p>中文名：设计模式<br>外文名：Design pattern<br>四要素：模式名称、问题、解决方案、效果<br>提出者：GOF(“四人帮”，又称Gang of Four，即Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides四人)<br>来源书籍：《Design Patterns: Elements of Reusable Object-Oriented Software》（1995年出版）</p>
<p><img src="/images/it_pattern.jpg" alt="UML图"></p>
<a id="more"></a>
<hr>
<h1 id="各种解释和定义"><a href="#各种解释和定义" class="headerlink" title="各种解释和定义"></a>各种解释和定义</h1><hr>
<p>即,使代码编写真正工程化！</p>
<p>来源于建筑领域<br>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结.</p>
<p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性.<br>毫无疑问，设计模式于己于他人于系统都是多赢的.设计模式使代码编制真正工程化.<br>设计模式是软件工程的基石脉络，如同大厦的结构一样。</p>
<p>通过面向对象的分析设计编程思想,开始考虑通过封装,继承,多台把程序的耦合度降低.<br>用设计模式使得程序更加的灵活,容易修改,并且易于复用.</p>
<p>编程有一原则, 就是用尽可能的方法去避免重复.</p>
<p>让业务逻辑和界面逻辑分开, 让它们的耦合度下降。只有分离开，才可以达到容易维护或扩展.</p>
<p>设计模式代表了最佳的实践, 通常被有经验的面向对象的软件开发人员所采用.</p>
<p>解决某一类问题最行之有效的方法。</p>
<p>多个设计模式组成就是框架</p>
<hr>
<h1 id="设计框架"><a href="#设计框架" class="headerlink" title="设计框架"></a>设计框架</h1><hr>
<p>可复用面向对象软件系统一般划分为两大类：应用程序工具箱和框架（Framework），<br>我们平时开发的具体软件都是应用程序，<br>Java的API属于工具箱；<br>而框架是构成一类特定软件可复用设计的一组相互协作的类，EJB（EnterpriseJavaBeans）是Java应用于企业计算的框架。<br>框架通常定义了应用体系的整体结构类和对象的关系等等设计参数，以便于具体应用实现者能集中精力于应用本身的特定细节。<br>框架主要记录软件应用中共同的设计决策，框架强调设计复用，因此框架设计中必然要使用设计模式。<br>另外，设计模式有助于对框架结构的理解，成熟的框架通常使用了多种设计模式,如果你熟悉这些设计模式，<br>毫无疑问，你将迅速掌握框架的结构，我们一般开发者如果突然接触EJB、Spring等框架，会觉得特别难学、难掌握，那么转而先掌握设计模式，无疑是给了你剖析EJB或J2EE系统的一把利器。</p>
<hr>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><hr>
<p>为什么要提倡“Design Pattern呢？<br>根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？<br>面向对象有几个原则：<br>单一职责原则 （Single Responsiblity Principle SRP）<br>开闭原则（Open Closed Principle，OCP）、<br>里氏代换原则（Liskov Substitution Principle，LSP）、<br>依赖倒转原则（Dependency Inversion Principle，DIP）、<br>接口隔离原则（Interface Segregation Principle，ISP）、<br>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、<br>最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。<br>开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。<br>设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。</p>
<hr>
<h1 id="学习设计模式的方法"><a href="#学习设计模式的方法" class="headerlink" title="学习设计模式的方法"></a>学习设计模式的方法</h1><hr>
<p>面向对象才是王道！<br>我觉得每种模式花半个小时就可以学会了，然后在实际中找寻自己遇到的问题属于哪种模式，找准很重要，然后用一下就ok了。。。<br>设计模式不应该是去记忆，而应该是用的时候自然而然的用上。</p>
<hr>
<h1 id="设计模式分为三种类型-共23种"><a href="#设计模式分为三种类型-共23种" class="headerlink" title="设计模式分为三种类型(共23种)"></a>设计模式分为三种类型(共23种)</h1><hr>
<p>1.创建型模式：<br>　　单例模式<br>　　工厂模式<br>　　抽象工厂模式　<br>　　建造者模式<br>　　原型模式<br>2.结构型模式：<br>　　代理模式<br>　　装饰模式<br>　　享元模式<br>　　适配器模式<br>　　组合模式<br>　　外观模式<br>　　桥接模式<br>3.行为型模式：<br>　　观察者模式<br>　　策略模式<br>　　模版方法模式<br>　　迭代器模式<br>　　命令模式<br>　　状态模式<br>　　中介者模式<br>　　备忘录模式<br>　　解释器模式<br>　　职责链模式<br>　　访问者模式</p>
<hr>
<h1 id="按字典序排列简介如下"><a href="#按字典序排列简介如下" class="headerlink" title="按字典序排列简介如下"></a>按字典序排列简介如下</h1><hr>
<p>Abstract Factory（抽象工厂模式）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>Adapter（适配器模式）：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>Bridge（桥接模式）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p>Builder（建造者模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>Chain of Responsibility（责任链模式）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p>
<p>Command（命令模式）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</p>
<p>Composite（组合模式）：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</p>
<p>Decorator（装饰模式）：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</p>
<p>Facade（外观模式）：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>Factory Method（工厂模式）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</p>
<p>Flyweight（享元模式）：运用共享技术有效地支持大量细粒度的对象。</p>
<p>Interpreter（解析器模式）：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>
<p>Iterator（迭代器模式）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。</p>
<p>Mediator（中介模式）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>Memento（备忘录模式）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<p>Observer（观察者模式）：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</p>
<p>Prototype（原型模式）：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p>
<p>Proxy（代理模式）：为其他对象提供一个代理以控制对这个对象的访问。</p>
<p>Singleton（单例模式）：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是最简单的设计模式之一，但是对于Java的开发者来说，它却有很多缺陷。在九月的专栏中，David Geary探讨了单例模式以及在面对多线程（multi-threading）、类装载器（class loaders）和序列化（serialization）时如何处理这些缺陷。</p>
<p>State（状态模式）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</p>
<p>Strategy（策略模式）：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p>
<p>Template Method（模板方法模式）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>Visitor（访问者模式）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<hr>
<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><hr>
<p>书籍：<br>　<a href="http://baike.baidu.com/item/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/85262#viewPageContent" target="_blank" rel="external">大话设计模式(程杰)</a><br>　<a href="http://baike.baidu.com/link?url=eVruuT6qP0geZ8alh5Klt_jyDbozvvLV8MQI3H63WNe7iD02nc2aIHj7VajhgWgZhBe7c4VjZu4AdVq34j7GP91pUH5w1WFC5bwisGtCgd5nd3cL9I6ELsjPeOkFceRTwQpxrk_a7tdjLFwSBsFoNq" target="_blank" rel="external">大话设计模式(吴强)</a><br>　<a href="http://baike.baidu.com/item/Android%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98" target="_blank" rel="external">Android源码设计模式解析与实战</a><br>　<a href="http://baike.baidu.com/item/HeadFirst%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6153323" target="_blank" rel="external">HeadFirst深入浅出设计模式</a><br>　<a href="http://baike.baidu.com/item/%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%89%A9%E5%B1%95%EF%BC%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FC%23%E7%89%88%EF%BC%89/7993550" target="_blank" rel="external">模式——工程化实现及扩展（设计模式C#版）</a><br>　<a href="http://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E7%A7%98%E7%AC%88%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%82%A3%E7%82%B9%E4%BA%8B/1613459" target="_blank" rel="external">软件秘笈：设计模式那点事</a><br>　<a href="http://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85" target="_blank" rel="external">设计模式之禅</a><br>　<a href="http://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/7600072" target="_blank" rel="external">设计模式：可复用面向对象软件的基础</a></p>
<p>网络链接/博客文章：<br>　<a href="http://baike.baidu.com/link?url=65fqeAB4Nf8wK6zFFrmiUi5QmmHM8KRFPb_tsN_Jc9j7ac0yX1yCeekeMOz6kBHqWvSpLePqYqNf5LH58d-VY47rGR5Pf_jOSSE1P1FPdlwBz07qfdAw8z6XlN_9_HOL" target="_blank" rel="external">设计模式百度百科</a><br>　<a href="http://www.cnblogs.com/zuoxiaolong/p/pattern26.html" target="_blank" rel="external">设计模式大杂烩（24种设计模式的总结以及学习设计模式的几点建议）</a><br>　<a href="http://blog.csdn.net/column/details/pattern.html" target="_blank" rel="external">设计模式CSDN博客</a><br>　<a href="http://blog.csdn.net/wy634379160/article/details/43983469" target="_blank" rel="external">追MM和Java的23种设计模式</a><br>　<a href="http://www.cnblogs.com/jiqing9006/p/6014553.html" target="_blank" rel="external">设计模式与足球</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;中文名：设计模式&lt;br&gt;外文名：Design pattern&lt;br&gt;四要素：模式名称、问题、解决方案、效果&lt;br&gt;提出者：GOF(“四人帮”，又称Gang of Four，即Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides四人)&lt;br&gt;来源书籍：《Design Patterns: Elements of Reusable Object-Oriented Software》（1995年出版）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/it_pattern.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程其他原则：合成/聚合复用原则</title>
    <link href="https://hengxing0080.github.io/2017/04/20/it/OOP/7.CARP/"/>
    <id>https://hengxing0080.github.io/2017/04/20/it/OOP/7.CARP/</id>
    <published>2017-04-20T03:27:15.000Z</published>
    <updated>2017-07-15T09:55:25.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;<br>中文名：合成/聚合复用原则 或者 合成复用原则<br>英文名和简称：Composite/Aggregate Reuse Principle，CARP<br><a id="more"></a></p>
<h1 id="定义和解释"><a href="#定义和解释" class="headerlink" title="定义和解释"></a>定义和解释</h1><p>&nbsp;<br>合成（Composition，也有翻译成组合），聚合（Aggregation），他们都是关联的特殊种类。</p>
<p>聚合（Aggregation）表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象但B对象不是A对象的一部分。<br>合成（Composition）则是一种强的’拥有’关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。</p>
<p>合成/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。</p>
<p>就是说要少用继承，多用合成关系来实现。我曾经这样写过程序：有几个类要与数据库打交道，就写了一个数据库操作的类，然后别的跟数据库打交道的类都继承这个。结果后来，我修改了数据库操作类的一个方法，各个类都需要改动。“牵一发而动全身”！面向对象是要把波动限制在尽量小的范围。<br>在Java中，应尽量针对Interface编程，而非实现类。这样，更换子类不会影响调用它方法的代码。要让各个类尽可能少的跟别人联系，“不要与陌生人说话”。这样，城门失火，才不至于殃及池鱼。扩展性和维护性才能提高。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>&nbsp;<br>要尽量使用合成/聚合，尽量不要使用继承。</p>
<h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>&nbsp;<br>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。<br>这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p>
<h1 id="情景举例"><a href="#情景举例" class="headerlink" title="情景举例"></a>情景举例</h1><p>&nbsp;<br>大雁有两个翅膀，翅膀与大雁是部分和整体的关系，并且它们的生命周期是相同的，于是大雁和翅膀就是合成关系。<br>而大雁是群居动物，所以每只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。<br><img src="/images/it_oop_carp.jpg" alt="UML图"></p>
<hr>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><hr>
<blockquote>
<p>来源：书籍（大话设计模式：程杰）——22章 桥接模式——22.3合成/聚合复用原则</p>
</blockquote>
<h2 id="非-合成-聚合复用原则"><a href="#非-合成-聚合复用原则" class="headerlink" title="(非) 合成/聚合复用原则"></a>(非) 合成/聚合复用原则</h2><p>略（时间来不及，请看书籍了解）</p>
<h2 id="已-合成-聚合复用原则"><a href="#已-合成-聚合复用原则" class="headerlink" title="(已) 合成/聚合复用原则"></a>(已) 合成/聚合复用原则</h2><p>组合：<br>　手机是不同的品牌公司，各自做自己的软件，PC是硬件厂商做硬件，软件厂商做软件，组合起来才是可以用的机器。<br>　像游戏，通讯录，MP3音乐播放这些功能都是软件，如果我们可以让其分离与手机耦合，那么久可以大大减少面对新需求时改动过大的不合理情况。<br>　所以应有一个手机品牌抽象类和手机软件抽象，让不同的品牌和功能都分别继承于他们，这样要增加新的品牌或心的功能就不用影响其他类了。</p>
<p>聚合：<br>　手机品牌和手机软件之间的关系呢？<br>　手机品牌包含于手机软件，但软件并不是品牌的一部分，所以它们之间是聚合关系。</p>
<p>结构图：<br><img src="/images/it_oop_carp2.jpg" alt="UML图"></p>
<p>代码片段：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">// 手机软件抽象父类</div><div class="line">abstract class HandsetSoft&#123;</div><div class="line">    public abstract void Run();</div><div class="line">&#125;</div><div class="line">// 手机游戏具体实现子类</div><div class="line">class HandsetGame : HandsetSoft&#123;</div><div class="line">    public override void Run()&#123;</div><div class="line">        Console.WriteLine("运行手机游戏");</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 手机通讯录具体实现子类</div><div class="line">class HandsetAddressList : HandsetSoft&#123;</div><div class="line">    public override void Run()&#123;</div><div class="line">        Console.WriteLine("运行手机通讯录");</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 手机品牌抽象父类</div><div class="line">abstract class HandsetBrand&#123;</div><div class="line">    protected HandsetSoft soft;</div><div class="line">    // 设置手机软件</div><div class="line">    public void SetHandsetSoft(HandsetSoft soft)&#123;</div><div class="line">        this.soft = soft;</div><div class="line">    &#125;</div><div class="line">    // 运行</div><div class="line">    public abstract void Run()l</div><div class="line">&#125;</div><div class="line">// N品牌具体实现子类</div><div class="line">class HandsetBrandN : HandsetBrand&#123;</div><div class="line">    public override void Run()&#123;</div><div class="line">        soft.Run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// M品牌具体实现子类</div><div class="line">class HandsetBrandM : HandsetBrand&#123;</div><div class="line">    public override void Run()&#123;</div><div class="line">        soft.Run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端调用代码</div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    HandsetBrand ab;</div><div class="line">    ab = new HandsetBrandN();</div><div class="line"></div><div class="line">    ab.SetHandsetSoft(new HandsetGame());</div><div class="line">    ab.Run();</div><div class="line"></div><div class="line">    ab.SetHandsetSoft(new HandsetAddressList());</div><div class="line">    ab.Run();</div><div class="line"></div><div class="line">    ab = new HandsetBrandM();</div><div class="line">    ab.SetHandsetSoft(new HandsetGame());</div><div class="line">    ab.Run();</div><div class="line"></div><div class="line">    ab.setHandsetSoft(new HandsetAddressList());</div><div class="line">    ab.Run();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>增加功能很方便，比如加一个MP3功能，那么只要增加这个类就行了，不会影响其他任何类，类的个数增加也只是一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 手机MP3具体实现子类</div><div class="line">class HandsetMP3 : HandsetSoft&#123;</div><div class="line">    public override void Run()&#123;</div><div class="line">        Console.WriteLine(&quot;运行手机MP3&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是要增加S品牌，只需要增加一个品牌子类就可以了。个数也是一个，不会影响其他类的改动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 手机品牌S</div><div class="line">class HandsetBrandS : HandsetBrand&#123;</div><div class="line">    public override void Run()&#123;</div><div class="line">        soft.Run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这显然也符合开闭原则！<br>这样的设计显然不会修改原来的代码，而只是扩展类就行了。<br>所以要优先使用对象的合成或聚合，而不是类继承（很容易造成不必要的麻烦）。</p>
<p>为什么使用继承会造成麻烦？本质原因主要是什么？<br>继承是一种强耦合的结构。父类变，子类就必须要变。<br>所在在用继承时，一定要在是‘is-a’的关系时再考虑使用，而不是任何时间都去使用。</p>
<p>其实这个示例也是一个设计模式！<br>看刚刚上面的图，两个抽象类之间有一个聚合线，像一座桥。<br>没错，就是桥接模式！ </p>
<hr>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><hr>
<p>继承和聚集的区别<br>　继承<br>　　Is-a（谁是谁的一种/谁是谁中的一员是继承）<br>　聚集(也叫集合)<br>　　has a（谁里面有谁是聚集）<br>　　聚集分为2种<br>　　　组合(也叫合成)：<br>　　　　是一个强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。<br>　　　　事务的联系关系更紧密，如：手和心脏都是人身体的一部分，人身体少了它们就有事了。<br>　　　聚合：<br>　　　　聚合表示一个弱的拥有关系，体验的是A对象可以包含B对象，但B对象不是A对象的一部分。<br>　　　　如：球员和球队是聚合关系，球员是球队中的一个，球队里有球员，球队里少了一个球员没有事。</p>
<p>总结：一般用聚集比继承多一些，因为继承有好处也有弊端。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&lt;br&gt;中文名：合成/聚合复用原则 或者 合成复用原则&lt;br&gt;英文名和简称：Composite/Aggregate Reuse Principle，CARP&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程6大原则之6：迪米特法则</title>
    <link href="https://hengxing0080.github.io/2017/04/02/it/OOP/6.LOD/"/>
    <id>https://hengxing0080.github.io/2017/04/02/it/OOP/6.LOD/</id>
    <published>2017-04-02T03:27:15.000Z</published>
    <updated>2017-07-15T09:55:14.773Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><hr>
<p>含义：迪米特法则（Low Of Demeter 简写LOD ）<br>其他含义：又叫作最少知道原则/最少知识原则（Least Knowledge Principle 简写LKP）<br>提出时间和作者：1987年秋天由美国Northeastern University的Ian Holland提出</p>
<a id="more"></a>
<p>各种解释、定义与意义：<br>　就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。</p>
<p>　即一个类应该尽量不要知道其他类太多的东西，不要和陌生的类有太多接触。</p>
<p>　一个类应该对自己需要耦合或者调用的类知道的最少，类的内部如何实现与调用者或者依赖者没有关系，<br>　调用者或依赖者只需知道他需要的方法，其他可以一概不管。<br>　这样使得系统具有更低的耦合性与更好的稳定性和可扩展性。</p>
<p>　迪米特法则可以简单说成：talk only to your immediate friends（只与直接的朋友通信）<br>　什么叫做直接的朋友呢？<br>　每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，如组合、聚合、依赖等。</p>
<p>　对于OOD来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。<br>　每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。<br>　迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。<br>　因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，<br>　这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。<br>　有兴趣可以研究一下设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。<br>　值得一提的是，虽然Ian Holland对计算机科学的贡献也仅限于这一条法则，其他方面的建树不多，<br>　但是，这一法则却不仅仅局限于计算机领域，在其他领域也同样适用。<br>　比如，美国人就在航天系统的设计中采用这一法则。</p>
<hr>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><hr>
<blockquote>
<p>来源：书籍——Android源码设计模式解析与实战——第1章——1.6</p>
</blockquote>
<p>下面我们就以租房为例描述迪米特原则的应用：</p>
<p>在外工作的朋友比较了解，我们经常通过中介找房。我们设定的情况为：我只要求房间的面积和租金，其他的一概不管，中介将符合我要求的房子提供给我就可以。下面我们来看看这个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 房间</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> area;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">float</span> price;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">float</span> area, <span class="keyword">float</span> price)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.area = area;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Room [area="</span> + area + <span class="string">", price="</span> + price + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 中介</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</div><div class="line"></div><div class="line">    List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            mRooms.add(<span class="keyword">new</span> Room(<span class="number">10</span> + i, (<span class="number">10</span> + <span class="number">1</span>) * <span class="number">100</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Room&gt; <span class="title">getAllRooms</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mRooms;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 租户</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> roomArea;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> roomPrice;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffPrice = <span class="number">100.01f</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffArea = <span class="number">0.01f</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRomm</span><span class="params">(Mediator mediator)</span> </span>&#123;</div><div class="line">        List&lt;Room&gt; rooms = mediator.getAllRooms();</div><div class="line">        <span class="keyword">for</span> (Room room : rooms) &#123;</div><div class="line">            <span class="keyword">if</span> (isSuitable(room)) &#123;</div><div class="line">                System.out.println(<span class="string">"租到合适的房间啦!"</span> + room.toString());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(Room room)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (Math.abs(room.price - roomPrice) &lt; diffPrice)  &amp;&amp;  (Math.abs(room.area - roomArea) &lt; diffArea);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看到，Tenant依赖了Mediator类，还需要频繁的与Room类打交道。租户类的要求只是通过中介找到一间适合自己的房子罢了，如果把这些检测条件都放在Tenant类中，那么Mediator类的功能就会被弱化，而且导致Tenant与Room的耦合较高，因为Tenant必须知道许多关于Room的细节。当Room变化时Tenant也必须跟着变化。Tenant又与Mediator耦合，这就出现了许多纠缠不清的关系。这个时候我们需要分析谁是真正的“直接朋友”，在我们所说的情况下，显然是Mediator。<br>既然耦合太严重，我们就需要解耦。首先要明确的是，我们只和我们的朋友通信，就是指Mediator对象。必须将Room相关的操作从Tenant中移除，而这些操作应在属于Mediator。</p>
<p>为此，我们进行重构，重构前的UML图如下：<br><img src="/images/it_oop_lod.jpg" alt="UML图"></p>
<p>重构后的结构图如下：<br><img src="/images/it_oop_lod2.jpg" alt="UML图"></p>
<pre><code class="Java"><span class="comment">/**
 * 中介
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>{

    List&lt;Room&gt; mRooms = <span class="keyword">new</span> ArrayList&lt;Room&gt;();

    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span> </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
            mRooms.add(<span class="keyword">new</span> Room(<span class="number">10</span> + i, (<span class="number">10</span> + <span class="number">1</span>) * <span class="number">200</span>));
        }
    }

    <span class="function"><span class="keyword">public</span> Room <span class="title">rentOut</span><span class="params">(<span class="keyword">float</span> area,<span class="keyword">float</span> price)</span> </span>{
        <span class="keyword">for</span>(Room room : mRooms) {
            <span class="keyword">if</span> (isSuitable(room, price, area)) {
                <span class="keyword">return</span> room;
            }
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuitable</span><span class="params">(Room room, <span class="keyword">float</span> roomPrice, <span class="keyword">float</span> roomArea)</span> </span>{
        <span class="keyword">return</span> (Math.abs(room.price - roomPrice) &lt; Tenant.DIFF_PRICE) &amp;&amp; (Math.abs(room.area - roomArea) &lt; Tenant.DIFF_AREA);
    }
}

<span class="comment">/**
 * 租户
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> </span>{

    <span class="keyword">private</span> <span class="keyword">float</span> roomArea;
    <span class="keyword">private</span> <span class="keyword">float</span> roomPrice;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffPrice = <span class="number">100.01f</span>;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> diffArea = <span class="number">0.01f</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentRomm</span><span class="params">(Mediator mediator)</span> </span>{
        System.out.println(<span class="string">"租到合适的房子了： "</span> + mediator.rentOut(roomArea, roomPrice).toString());
    }
}
</code></pre>
<p>只是将对于Room的判定操作移动了Mediator类中，这本应该是Mediator的职责，根据租户设定的条件查找符合要求的房子，并且将结果交给租户就可以了。<br>租户既然找中介了就并不需要知道太多关于Room的细节，比如与房东签合同，房东的房产证是不是真的，房内的设施坏了之后要招谁维修等等。<br>当我们通过“朋友”——中介租了房之后，所有的事情直接与中介沟通就好了，房东，维修师傅等这些角色并不是我们直接的“朋友”。<br>“只与直接的朋友通信”这简单的几个字就能够将我们从复杂的关系网中抽离出来，使程序耦合度更低、稳定性更好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;含义：迪米特法则（Low Of Demeter 简写LOD ）&lt;br&gt;其他含义：又叫作最少知道原则/最少知识原则（Least Knowledge Principle 简写LKP）&lt;br&gt;提出时间和作者：1987年秋天由美国Northeastern University的Ian Holland提出&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程6大原则之5：接口隔离原则</title>
    <link href="https://hengxing0080.github.io/2017/04/01/it/OOP/5.ISP/"/>
    <id>https://hengxing0080.github.io/2017/04/01/it/OOP/5.ISP/</id>
    <published>2017-04-01T13:32:12.000Z</published>
    <updated>2017-07-15T09:55:03.952Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><hr>
<p>中文含义：接口隔离原则<br>英文缩写：ISP<br>英文全称：Interface Segregation Principle</p>
<a id="more"></a>
<p>各种解释和定义：<br>　系统有更高的灵活性</p>
<p>　不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。</p>
<p>　也称接口最小化原则，强调的是一个接口拥有的行为应该尽可能的小。<br>　每一个接口应该是一种角色，不多不少，不干不该干的事，该干的事都要干。</p>
<p>　客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>　类间的依赖关系应该建立在最小的接口上，将庞大、臃肿的接口拆分成更小的、更具体的接口。目的是系统的解耦，从而更容易重构、更改和重新部署。</p>
<p>　“不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。”这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。</p>
<hr>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><hr>
<blockquote>
<p>来源：书籍——Android源码设计模式解析与实战——第1章——1.5</p>
</blockquote>
<p>在Java6以及之前的JDK版本，有个非常讨厌的问题，那就是使用了OutputStream或者其他可关闭的对象之后，我们必须保证他们最终被关闭了，我们的SD卡缓存类中就有这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将图片缓存到内存中  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url,Bitmap bmp)</span></span>&#123;  </div><div class="line">    FileOutputStream fileOutputStream = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">        fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);  </div><div class="line">        bmp.compress(Bitmap.CompressFormat.PNG,<span class="number">100</span>,fileOutputStream);  </div><div class="line">    &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;  </div><div class="line">        e.printStackTrace();  </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">        <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>)&#123;  </div><div class="line">            <span class="keyword">try</span>&#123;  </div><div class="line">                fileOutputStream.close();  </div><div class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125; <span class="comment">// end if</span></div><div class="line">    &#125;<span class="comment">// end if finally</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到的这段代码可读性非常差，各种try…catch嵌套都是些简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。大家应该对这类代码也非常反感，那我们看看如何解决这类问题。<br>我们可能知道Java中有一个Closeable借口，该借口表示了一个可关闭的对象，它只有一个close方法。<br>我们讲的FileOutputStream类就实现了这个接口。看了文档后发现有100多个类实现了Closeable这个接口，这意味着，在关闭着100多个类型的对象时，都需要写出像put方法中finally代码段那样的代码。这还了得！！<br>所以需要换个方式，既然都是实现了Closeable接口，那只要建一个工具类方法统一来关闭这些对象不就可以了么！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseUtils</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CloseUtils</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 关闭Closeable对象  </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeQuietly</span><span class="params">(Cloneable closeable)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != closeable)&#123;  </div><div class="line">            <span class="keyword">try</span>&#123;  </div><div class="line">                closeable.close();  </div><div class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个工具类方法用到上述的put方法中看看效果如何：</p>
<pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url,Bitmap bmp)</span></span>{  
    FileOutputStream fileOutputStream = <span class="keyword">null</span>;  
    <span class="keyword">try</span>{  
        fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);  
        bmp.compress(Bitmap.CompressFormat.PNG, <span class="number">100</span>, fileOutputStream);  
    }<span class="keyword">catch</span> (FileNotFoundException e){  
        e.printStackTrace();  
    } <span class="keyword">finally</span> {  
        <span class="comment">// 啥也不用管，直接扔进去</span>
        CloseUtils.closeQuietly(fileOutputStream);  
    }  
}
</code></pre>
<p>代码立马简洁了很多！ 而且这个closeQuietyly方法可以运动到各类可关闭的对象中，保证了代码的重用性。<br>closeQuietyly方法的基本原理就是依赖于Closeable抽象而不是具体实现，并且建立在最小化依赖原装的基础上，它只需要知道这个对象时可关闭，其他的一概不关心，这就是接口隔离原则。</p>
<hr>
<h1 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h1><hr>
<p>Bob大叔（Robert C martin）在21世纪早期将单一职责、开闭原则、里氏替换、接口隔离以及依赖倒置5个原则定位为SOLID原则，作为面向对象编程的5个基本原则。<br>当这些原则被一起应用时，它们使得一个软件系统更清晰、简单，最大程序地拥抱变化。<br>SOLID被典型地应用在测试驱动开发商，并且是敏捷开发以及自适应软件开发基本原则的重要组成部分。<br>经过这前5个原则的学习，发现这几大原则最终就可以化为几个关键词：抽象、单一职责、最小化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;中文含义：接口隔离原则&lt;br&gt;英文缩写：ISP&lt;br&gt;英文全称：Interface Segregation Principle&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程6大原则之4：依赖倒置原则</title>
    <link href="https://hengxing0080.github.io/2017/03/26/it/OOP/4.DIP/"/>
    <id>https://hengxing0080.github.io/2017/03/26/it/OOP/4.DIP/</id>
    <published>2017-03-26T02:30:38.000Z</published>
    <updated>2017-07-15T09:54:48.183Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><hr>
<p>中文含义：依赖倒置原则<br>中文其他含义：依赖反转原则<br>英文缩写：DIP<br>英文全称：The Dependency Inversion Principle</p>
<a id="more"></a>
<p>各种解释和定义：<br>　让项目拥有变化的能力<br>　让程序都依赖抽象,而不是相互依赖.<br>　抽象不应该依赖于细节,细节应该依赖于抽象.</p>
<p>　这个原则描述的是高层模块不该依赖于低层模块，二者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>　A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。<br>　B.抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p>
<hr>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><hr>
<blockquote>
<p>来源：书籍——Android源码设计模式解析与实战——第1章——1.4</p>
</blockquote>
<p>如果类与类直接依赖于细节，那么它们之间就有直接的耦合，当具体实现需要变化时，意味着要用时修改依赖者的代码，这就限制了系统的可扩展性。<br>在下面的Demo中，ImageLoader直接依赖于MemoryCache，这个MemoryCache是一个具体实现，而不是一个抽象类或接口。这导致了ImageLoader直接依赖了具体细节，当Memory不能满足ImageLoader而需要被其他缓存实现替换时，此时就要必须修改ImageLoader的代码。<br>出现问题场景：随着产品的升级，用户发现MemoryCache已经不能满足需要，用户需要作者的ImageLoader可以将图片同时缓存到内存和SD卡中，或者可以让用户自定义实现缓存。<br>另外，用户需要自定义缓存实现时还必须继承自MemoryCache，而用户的缓存实现可不一定与内存缓存有关，这在命名上的限制也让用户体验不好。</p>
<h2 id="非依赖倒置原则"><a href="#非依赖倒置原则" class="headerlink" title="非依赖倒置原则"></a>非依赖倒置原则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 内存缓存（直接依赖于细节（细节就是具体的实现类））</span></div><div class="line">    MemoryCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    <span class="comment">// SD卡缓存（仍然依赖于细节）</span></div><div class="line">    <span class="comment">// DiskCache mDiskCache = new DiskCache();</span></div><div class="line">    <span class="comment">// 双缓存（无论怎么改都是依赖于细节）</span></div><div class="line">    <span class="comment">// DoubleCache mDoubleCache = new DoubleCache();</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">        Bitmap bmp = = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span>(bmp != <span class="keyword">null</span>)&#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            downloadImage(url, imageView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="遵循依赖倒置原则"><a href="#遵循依赖倒置原则" class="headerlink" title="遵循依赖倒置原则"></a>遵循依赖倒置原则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片缓存抽象</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="function">Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 图片缓存类，依赖于抽象，并且有一个默认的实现类</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> MemoryCache();</div><div class="line"></div><div class="line">    <span class="comment">// 设置缓存策略，依赖于抽象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span></span>&#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(String url, ImageView imageView)</span></span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        <span class="keyword">if</span>(bitmap != <span class="keyword">null</span>)&#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            downloadImageAsync(url,imageView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，我们建立了ImageCache抽象，并且让ImageLoader依赖于抽象而不是具体细节。<br>当需求发生变化时，我们只需要实现ImageCache累或者继承其他已有的ImageCache子类完成相应的缓存功能，然后将具体的实现注入到ImageLoader即可实现缓存功能的替换，这就保证了缓存系统的高可扩展性，有了拥抱变化的能力，这就是依赖倒置原则。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前4个原则是息息相关的，用一张图总结一下！<br><img src="/images/it_oop_info3.jpg" alt="UML图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;中文含义：依赖倒置原则&lt;br&gt;中文其他含义：依赖反转原则&lt;br&gt;英文缩写：DIP&lt;br&gt;英文全称：The Dependency Inversion Principle&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程6大原则之3：里氏替换原则</title>
    <link href="https://hengxing0080.github.io/2017/03/25/it/OOP/3.LSP/"/>
    <id>https://hengxing0080.github.io/2017/03/25/it/OOP/3.LSP/</id>
    <published>2017-03-25T14:30:45.000Z</published>
    <updated>2017-07-15T09:54:40.651Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><hr>
<p>中文含义：里氏替换原则<br>英文缩写：LSP<br>英文全称：The Liskov Substitution Principle<br>提出者：Barbara Liskov<br>提出时间：1987年<br><a id="more"></a><br>各种解释和定义：<br>　构建扩展性更好的系统<br>　子类型必须能够替换掉它们的基类型。</p>
<p>　这个原则表达的意思是一个子类应该可以替换掉父类并且可以正常工作。</p>
<p>　所有引用父类的地方，必须能使用子类的对象。简单地说就是将父类替换为他的子类是不会出现问题，反之，未必可以。<br>　那么里氏替换原则就是依赖于面向对象语言的继承与多态。核心原理是抽象。</p>
<p>　这里列举一下继承的优缺点：<br>　优点：<br>　（1）代码重用，减少创建类的成本，每个子类都拥有父类的方法与属性。<br>　（2）子类与父类基本相似，但与父类又有所区别。<br>　（3）提高代码的可扩展性。<br>　缺点：<br>　（1）继承是侵入性的，只要继承就必须拥有父类所有的属性与方法。<br>　（2）可能造成子类代码冗余、灵活性降低。<br>　开闭原则和里氏替换原则是生死相依的、不离不弃的。他们都强调了抽象这一重要的特性。</p>
<p>　里氏是作者名（Liskov），Liskov于1987年提出了一个关于继承的原则“继承必须确保超类所拥有的性质在子类中仍然成立。”<br>　也就是说，当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。<br>　该原则称为Liskov Substitution Principle——里氏替换原则。也可以理解为“老鼠的儿子会打洞”。^_^</p>
<hr>
<h1 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h1><hr>
<blockquote>
<p>来源：书籍——Android源码设计模式解析与实战——第1章——1.3</p>
</blockquote>
<p>UML图如下：<br><img src="/images/it_oop_ocp.jpg" alt="UML图"></p>
<p>上述图很好地反应了里氏替换原则，即MemoryCache,DiskCache,DoubleCache都有可以替换ImageCache的工作，并且能够保证行为的正确性。<br>ImageCache建立了获取缓存图片、保存缓存图片的接口规范，MemoryCache等根据接口规范实现了相应的功能，用户只需要在使用指定具体的缓存对象就可以动态替换ImageLoader中的缓存策略。<br>这就使ImageLoader的缓存系统具有了无限的可能性，也就是保证了可扩展性。</p>
<p>想象一种情况，当ImageLoader中的setImageCache（ImageCache cache）中的cache对象不能够被子类所替换，那么用户如何设置不同的缓存对象，以及用户如何自定义自己的缓存实现，通过之前的文章<a href="https://hengxing0080.github.io/2017/05/23/it/2.OOP_OCP/">开放闭合原则</a>中的isUseDishCache方法来一个一个判断吗？ 显然不行，这个原则就为这类问题提供了指导原则，也就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保证系统的扩展性、灵活性。<br>开闭原则和里氏替换原则往往是生死相依、不弃不离的，通过里氏替换来达到对扩展开放，对修改关闭的效果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;中文含义：里氏替换原则&lt;br&gt;英文缩写：LSP&lt;br&gt;英文全称：The Liskov Substitution Principle&lt;br&gt;提出者：Barbara Liskov&lt;br&gt;提出时间：1987年&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程6大原则之2：开放闭合原则</title>
    <link href="https://hengxing0080.github.io/2017/03/14/it/OOP/2.OCP/"/>
    <id>https://hengxing0080.github.io/2017/03/14/it/OOP/2.OCP/</id>
    <published>2017-03-14T02:00:51.000Z</published>
    <updated>2017-07-15T09:54:25.606Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><hr>
<p>中文含义：开放闭合原则<br>中文简称：开闭原则<br>英文缩写：OCP<br>英文全称：Open Close Principle<br>提出者：Bertrand Meyer</p>
<a id="more"></a>
<p>各种解释：<br>　让程序更稳当,更灵活.<br>　修改原有代码说明设计不够好.<br>　软件实体应该是可以扩展的,但是不可修改.</p>
<p>　软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。</p>
<p>　对修改关闭，对扩展开放。<br>　用抽象构建框架，用细节实现扩展。<br>　遵循开闭原则的最重要手段就是通过抽象。</p>
<p>　当软件需要变化时，我们应该尽量通过扩展的方式实现变化，而不是通过修改原有的代码来实现。<br>　因为直接的修改，可能会影响已有的正常代码。不利于出现错误时排除问题。<br>　当然实际开发中，修改原有代码与扩展代码是同时存在的。但应尽量以扩展为主。</p>
<hr>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><hr>
<blockquote>
<p>来源：书籍——Android源码设计模式解析与实战——第1章——1.2</p>
</blockquote>
<p>是接着上一篇的单一职责，虽然内存缓存解决了每次从网络加载图片的问题，随着用户的增多，有些问题也暴露出来了，Android应用的内存很有限，且具有丢失性，即当应用重新启动之后，原来已经加载过的图片将会丢失，这个重启之后就需要重新下载！这又会导致加载缓慢、耗费用户流量的问题。</p>
<h2 id="非开闭原则"><a href="#非开闭原则" class="headerlink" title="非开闭原则"></a>非开闭原则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> *</div><div class="line"> * 分析弊端：</div><div class="line"> *      每次加新的缓存方法时都要让用户选择使用哪种缓存，</div><div class="line"> *      因此，就使得在ImageLoader中存在各种if-else盘点语句，通过这些判断来确定使用哪种缓存，</div><div class="line"> *      随着这些逻辑的引入，代码变得越来越复杂、脆弱，</div><div class="line"> *      如果一不小心写错了某个if条件（条件太多，这是很容易出现的），那就需要更多的时间来排除，整个ImageLoader累也会变得越来越臃肿。</div><div class="line"> *      最重要的是，用户不能自己实现缓存注入到ImageLoader中，可扩展性差，可扩展性可是框架的最重要特性之一，</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 内存缓存</span></div><div class="line">    MemoryCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    <span class="comment">// SD卡缓存</span></div><div class="line">    DiskCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line">    <span class="comment">// 双缓存</span></div><div class="line">    DoubleCache mDoubleCache = <span class="keyword">new</span> DoubleCache();</div><div class="line">    <span class="comment">// 使用SD卡缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDishCache = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 使用双缓存</span></div><div class="line">    <span class="keyword">boolean</span> isUseDoubleCache = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDiskCache</span><span class="params">(<span class="keyword">boolean</span> useDiskCache)</span></span>&#123;</div><div class="line">        isUseDishCache = useDiskCache;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDoubleCache</span><span class="params">(<span class="keyword">boolean</span> useDoubleCache)</span></span>&#123;</div><div class="line">        isUseDoubleCache = useDoubleCache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">        Bitmap bmp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(isUseDoubleCache)&#123;</div><div class="line">            bmp = mDoubleCache.get(url);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isUseDishCache)&#123;</div><div class="line">            bmp = mDiskCache.get(url);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            bmp = mMemoryCache.get(url);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(bmp != <span class="keyword">null</span>)&#123;</div><div class="line">            imageView.setImageBitmap(bmp);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="comment">// 图片没缓存，提交到线程池中下载图片</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内存缓存类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemeryCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化LRU缓存</span></div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">        <span class="comment">// 取四分之一的可用内存为缓存内存</span></div><div class="line">        <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mMemeryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize)&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mMemeryCache.get(url);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">        mMemeryCache.put(url,bmp);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 本地SD卡缓存类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> String cacheDir = <span class="string">"sdcard/cache/"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 从缓存中获取图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> BitmapFactory.decodeFile(cacheDir + url); <span class="comment">// 从本地文件中获取该图片</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将图片缓存到内存中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span></span>&#123;</div><div class="line">        <span class="comment">// 将Bitmao写入文件中</span></div><div class="line">        FileOutputStream fileOutputStream = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            fileOutputStream = <span class="keyword">new</span> FileOutputStream(cacheDir + url);</div><div class="line">            bitmap.compress(Bitmap.CompressFormat.PNG,<span class="number">100</span>,fileOutputStream);</div><div class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">if</span> (fileOutputStream != <span class="keyword">null</span>)&#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    fileOutputStream.close();</div><div class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 双缓存类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCache</span> <span class="keyword">implements</span> <span class="title">ImageCache</span></span>&#123;</div><div class="line"></div><div class="line">    ImageCache mMemoryCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    ImageCache mDiskCache = <span class="keyword">new</span> DiskCache();</div><div class="line"></div><div class="line">    <span class="comment">// 先从内存缓存中获取图片，如果没有，再从SD卡中获取</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>&#123;</div><div class="line">        Bitmap bitmap = mMemoryCache.get(url);</div><div class="line">        <span class="keyword">if</span>(bitmap == <span class="keyword">null</span>)&#123;</div><div class="line">            bitmap = mDiskCache.get(url);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将图片缓存到内存和SD卡中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bitmap)</span></span>&#123;</div><div class="line">        mDiskCache.put(url, bitmap);</div><div class="line">        mMemoryCache.put(url, bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="遵循开闭原则"><a href="#遵循开闭原则" class="headerlink" title="遵循开闭原则"></a>遵循开闭原则</h2><p>UML图如下：<br><img src="/images/it_oop_ocp.jpg" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片缓存抽象类</div><div class="line"> *</div><div class="line"> * 简单定义了获取，缓存图片两个函数，</div><div class="line"> * 接下的类（内存缓存，SD卡缓存，双缓存都实现了该接口）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="function">Bitmap <span class="title">get</span><span class="params">(String url)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span></span>; <span class="comment">// 缓存的key是图片的url，值是图片本身</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> * 经过这次重构，没有了那么多的if-else语句，没有了各种各样的缓存实现对象，不二变量，代码清晰简单了很多</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> MemoryCache();</div><div class="line">    <span class="comment">// 线程池，线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorServer = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    <span class="comment">// 注入缓存实现</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageCache</span><span class="params">(ImageCache cache)</span></span>&#123;</div><div class="line">        mImageCache = cache;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        <span class="keyword">if</span>(bitmap != <span class="keyword">null</span>)&#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 图片没缓存，提交到线程池中下载图片</span></div><div class="line">        submitLoadRequest(url,imageView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitLoadRequest</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span> </span>&#123;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorServer.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span>(bitmap == <span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(imageView.getTag().equals(url))&#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url,bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span></span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 因为ImageLoader类增加了一个setImageCache(ImaeCache cache)函数，用户可以通过该函数设置缓存实现，也就是通常说的依赖注入。</div><div class="line"> * 下面就看看用户是如何设置缓存实现的：</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ImageLoader imageLoader = <span class="keyword">new</span> ImageLoader();</div><div class="line">        <span class="comment">// 使用内存缓存</span></div><div class="line">        imageLoader.setImageCache(<span class="keyword">new</span> MemoryCache());</div><div class="line">        <span class="comment">// 使用sd卡缓存</span></div><div class="line">        imageLoader.setImageCache(<span class="keyword">new</span> DiskCache());</div><div class="line">        <span class="comment">// 使用双缓存</span></div><div class="line">        imageLoader.setImageCache(<span class="keyword">new</span> DoubleCache());</div><div class="line">        <span class="comment">// 使用自定义缓存</span></div><div class="line">        imageLoader.setImageCache(<span class="keyword">new</span> ImageCache() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">/*从缓存中获取图片*/</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url, Bitmap bmp)</span> </span>&#123;</div><div class="line">                <span class="comment">// 缓存图片</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="comment">//imageLoader.displayImage(url,ivimg);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，通过setImageCache(ImageCache cache)方法注入不同的缓存实现，这样不仅能够使ImageLoader更简单、健壮，也使得ImageLoader的可扩展性、灵活性更高。<br>MemoryCache、DiskCache、DoubleCache缓存图片的具体实现完全不一样，但是，他们的一个特点是，都实现了ImageCache接口。<br>当用户需要自定义实现缓存策略时，只需要新建一个实现ImageCache接口的类，然后构造该类的对象，并且通过setImageCahce(ImageCache cache)注入到ImageLoader中，这样LoageLoader就实现了千变万化的缓存策略，且扩展这些缓存策略并不回导致ImageLoader类的修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;中文含义：开放闭合原则&lt;br&gt;中文简称：开闭原则&lt;br&gt;英文缩写：OCP&lt;br&gt;英文全称：Open Close Principle&lt;br&gt;提出者：Bertrand Meyer&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程6大原则之1：单一职责原则</title>
    <link href="https://hengxing0080.github.io/2017/03/05/it/OOP/1.SRP/"/>
    <id>https://hengxing0080.github.io/2017/03/05/it/OOP/1.SRP/</id>
    <published>2017-03-05T08:52:51.000Z</published>
    <updated>2017-07-15T09:54:14.473Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h1 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h1><hr>
<p>中文含义：单一职责原则<br>中文其他释义：单一责任原则，单一功能原则<br>英文缩写：SRP<br>英文全称：The Single Responsibility Principle<br><a id="more"></a><br>各种解释：<br>　它是优化代码的第一步。<br>　针对一个类而言，应该仅有一个引起它变化的原因。</p>
<p>　简单的说就是：一个类中应该是一组相关性很高的函数、数据的封装。两个不一样的功能不应该放在一个类中。<br>　这个原则没有具体的划分界限，需要根据个人经验，具体业务逻辑而定。<br>　试想一下，如果所有的功能写在一个类里，那么这个类会越来越大，越来越复杂，越不易修改维护。那么根据功能，各自独立拆分出来，岂不是逻辑会清晰些。</p>
<p>　描述的意思是每个类都只负责单一的功能，切不可太多，并且一个类应当尽量的把一个功能做到极致。<br>　单一职责原则并不是一个孤立的面向对象设计原则，它是早期面向对象设计五个基本原则（SOLID）之一。这些原则被一起应用时可以使一个软件系统更易被维护和扩展。</p>
<hr>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><hr>
<blockquote>
<p>来源：书籍——Android源码设计模式解析与实战——第1章——1.1</p>
</blockquote>
<p>实现图片加载，并且要将图片缓存起来。</p>
<h2 id="非单一职责原则"><a href="#非单一职责原则" class="headerlink" title="非单一职责原则"></a>非单一职责原则</h2><p>在这个Demo中，这个ImageLoader严重耦合，简直没有设计可言，更别说扩展性和灵活性了，因为把所有的功能都写到一个类里了，这样随着功能的增多，ImageLoader累会越来越大，代码也越来越复杂，图片加载系统就会越来越脆弱……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    LruCache&lt;String,Bitmap&gt; mImageCache;</div><div class="line">    <span class="comment">// 线程池，线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorServer = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">()</span></span>&#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>)(Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">        <span class="comment">// 取四分之一的可用内存作为缓存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mImageCache = <span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        <span class="keyword">if</span>(bitmap != <span class="keyword">null</span>)&#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorServer.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span>(bitmap == <span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(imageView.getTag().equals(url))&#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url,bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span></span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="遵循单一职责原则"><a href="#遵循单一职责原则" class="headerlink" title="遵循单一职责原则"></a>遵循单一职责原则</h2><p>UML图如下：<br><img src="/images/it_oop_srp.jpg" alt="UML图"></p>
<p>已把ImageLoader拆分和重构，单独抽取出ImageCache成一个类，各个功能已独立出来，满足单一职责。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 图片加载类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片缓存</span></div><div class="line">    ImageCache mImageCache = <span class="keyword">new</span> ImageCache();</div><div class="line">    <span class="comment">// 线程池，线程数量为CPU的数量</span></div><div class="line">    ExecutorService mExecutorServer = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</div><div class="line">    <span class="comment">// 加载图片</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayImage</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> ImageView imageView)</span></span>&#123;</div><div class="line">        Bitmap bitmap = mImageCache.get(url);</div><div class="line">        <span class="keyword">if</span>(bitmap != <span class="keyword">null</span>)&#123;</div><div class="line">            imageView.setImageBitmap(bitmap);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        imageView.setTag(url);</div><div class="line">        mExecutorServer.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                Bitmap bitmap = downloadImage(url);</div><div class="line">                <span class="keyword">if</span>(bitmap == <span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(imageView.getTag().equals(url))&#123;</div><div class="line">                    imageView.setImageBitmap(bitmap);</div><div class="line">                &#125;</div><div class="line">                mImageCache.put(url,bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">downloadImage</span><span class="params">(String imageUrl)</span></span>&#123;</div><div class="line">        Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL url = <span class="keyword">new</span> URL(imageUrl);</div><div class="line">            <span class="keyword">final</span> HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">            bitmap = BitmapFactory.decodeStream(conn.getInputStream());</div><div class="line">            conn.disconnect();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bitmap;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于处理图片缓存</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</div><div class="line">    <span class="comment">// 图片LRU缓存</span></div><div class="line">    LruCache&lt;String,Bitmap&gt; mImageCache;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageCache</span><span class="params">()</span></span>&#123;</div><div class="line">        initImageCache();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initImageCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 计算可使用的最大内存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>)(Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</div><div class="line">        <span class="comment">// 取四分之一的可用内存作为缓存</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">4</span>;</div><div class="line">        mImageCache = <span class="keyword">new</span> LruCache&lt;String,Bitmap&gt;(cacheSize)&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String url,Bitmap bitmap)</span></span>&#123;</div><div class="line">        mImageCache.put(url,bitmap);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">get</span><span class="params">(String url)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> mImageCache.get(url);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述的例子中我们能体会到，单一职责所表达的用意就是“单一”二字。<br>如果划分一个类，一个函数的职责，每个人都有自己的看法，这需要根据个人经验，具有的业务逻辑而定。<br>两个完全不一样的功能就不应该放在一个类中。一个类中应该是一组相关性很高的函数，数据的封装。<br>工程师可以不断地审视自己的代码，根据具体的业务，功能对累进行相应的拆分，这是程序员优化代码迈出的第一步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;正文：&quot;&gt;&lt;a href=&quot;#正文：&quot; class=&quot;headerlink&quot; title=&quot;正文：&quot;&gt;&lt;/a&gt;正文：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;中文含义：单一职责原则&lt;br&gt;中文其他释义：单一责任原则，单一功能原则&lt;br&gt;英文缩写：SRP&lt;br&gt;英文全称：The Single Responsibility Principle&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 面向对象编程原则" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
