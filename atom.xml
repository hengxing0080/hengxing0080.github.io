<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹空间</title>
  <subtitle>时空在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-08-30T10:41:01.141Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式GOF之7 —— 代理模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/12/it/DesignPattern/7.Proxy/"/>
    <id>https://hengxing0080.github.io/2017/08/12/it/DesignPattern/7.Proxy/</id>
    <published>2017-08-12T03:22:47.000Z</published>
    <updated>2017-08-30T10:41:01.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 代理模式<br>外文名 Proxy Pattern<br>又名 委托模式 | 第三方模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_proxy1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为其他对象提供一种代理以控制对这个对象的访问。<br>在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>跟MM在网上聊天，一开头总是“hi，你好”，“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 </p>
<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。  </p>
<p>代理模式一个非常重要的模式，而且学起来很简单！</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象实现相同的接口。</p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>（1）抽象角色：通过接口或抽象类声明真实角色实现的业务方法。<br>（2）代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。<br>（3）真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>（1）装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2）装饰对象包含一个真实对象的引用（reference）<br>（3）装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4）装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>（1）职责清晰<br>真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。<br>（2）代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。<br>（3）高扩展性</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>几乎没有什么缺点而言，它是细分化至很小的一种模式，要真找缺点，那么就是所有涉及模式的通病：对类的增加，不过在这种孰优孰劣的局势下，就算对类的稍微增加又何妨呢？</p>
<h1 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h1><p>一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理<br>对象实现同一个接口,先访问代理类再访问真正要访问的对象。</p>
<p>代理模式分为静态代理、动态代理。</p>
<p>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。</p>
<h1 id="代理模式的2种方式"><a href="#代理模式的2种方式" class="headerlink" title="代理模式的2种方式"></a>代理模式的2种方式</h1><h2 id="从Code方面"><a href="#从Code方面" class="headerlink" title="从Code方面"></a>从Code方面</h2><p>1.1.静态代理<br>如下述示例那样，代理者的代理又程序员自己或通过一些自动化工具生成固定的代理在对其进行编译。也就是说在我们的代理运行前代理类的class编译文件就已存在。</p>
<p>需求：小明以前在公司上班时，就遇到过被老板拖欠工资甚至克扣工资的情况，这种情况下小明还是通过法律途径来解决问题，一旦小明选择了走法律途径解决该纠纷，那么不可避免地就需要请一个律师来作为自己的诉讼代理人，我们将诉讼的流程抽象在一个接口类中。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 诉讼接口类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="comment">// 提交申请</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 进行举证</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 开始辩护</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 诉讼完成</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 具体诉讼人</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMin</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“老板·拖欠工资！特此申请仲裁！”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“这是合同书和过去一年的银行工资流水”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“证据确凿！不需要说什么了！”);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(“诉讼成功！判决老板即日起七天内结算工资”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 代理律师类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lawyer</span> <span class="keyword">implements</span> <span class="title">ILawsuit</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> ILawsuit mLawsuit;  <span class="comment">// 持有一个具体被代理者的引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lawyer</span><span class="params">(ILawsult lawsuit)</span></span>&#123;</div><div class="line">        mLawsuit = lawsit;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.submit();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">burden</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.burden();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defend</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.defend();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</div><div class="line">        mLawsult.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 客户类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造一个小明</span></div><div class="line">        ILawsuit xiaoming = <span class="keyword">new</span> XiaoMin();</div><div class="line">        <span class="comment">// 构造一个代理律师并将小明作为构造参数传递进去</span></div><div class="line">        ILawsuit lawyer = <span class="keyword">new</span> Lawyer(xiaoming);</div><div class="line">        <span class="comment">// 律师提交诉讼申请</span></div><div class="line">        lawyer.submit();</div><div class="line">        <span class="comment">// 律师进行举证</span></div><div class="line">        lawyer.burden();</div><div class="line">        <span class="comment">// 完成诉讼</span></div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.2.动态代理<br>动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们在code阶段压根就不需要知道代理谁，代理谁我们将会在执行阶段决定。<br>而Java也给我们提供了一个便捷的动态代理接口InvocationHandler，实现该接口需要重写其调用方法invoke<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0,Method args1, Object[] args2)</span><span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过invoke方法来调用具体的被代理方法，也就是真实的方法。<br>动态代理可以使我们的代理逻辑更简洁</p>
<p>优化代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHander</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 被代理的类引用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line">    &#125; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 调用被代理类对象的方法</span></div><div class="line">        Object result = method.invoke(obj, args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 构造一个小明</span></div><div class="line">        ILawsuit xiaoming = <span class="keyword">new</span> XiaoMin();</div><div class="line">        <span class="comment">// 构造一个动态代理</span></div><div class="line">        DynamicProxy proxy = <span class="keyword">new</span> DynamicProxy(xiaomin);</div><div class="line">        <span class="comment">// 获取被代理类小明的ClassLoader</span></div><div class="line">        ClassLoader loader = xiaoming.getClass().getClassLoader();</div><div class="line">        <span class="comment">// 动态构造一个代理者律师</span></div><div class="line">        ILawsuit lawyer = (ILawsuit)Proxy.newProxyInstance(loader,<span class="keyword">new</span> Class[] &#123; ILawsuit.class&#125;,proxy);</div><div class="line">        <span class="comment">// 律师提交诉讼申请</span></div><div class="line">        lawyer.submit();</div><div class="line">        <span class="comment">// 律师进行举证</span></div><div class="line">        lawyer.burden();</div><div class="line">        <span class="comment">// 律师代替小明进行辩护</span></div><div class="line">        lawyer.defend();</div><div class="line">        <span class="comment">// 完成诉讼</span></div><div class="line">        lawyer.finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果和以前一致。<br>由此可见动态代理通过一个代理类来代理N多被代理类，其实质是对代理者与被代理者进行解耦，使两者直接没有直接的耦合关系。<br>相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么久需要重新定义不同代理类，较为复杂，但是静态代理更符合面向对象原则。<br>在开发时具体使用哪种方式来实现代理，就看自己的偏好了。</p>
<h2 id="从适用范围区别几种不同类型的代理实现"><a href="#从适用范围区别几种不同类型的代理实现" class="headerlink" title="从适用范围区别几种不同类型的代理实现"></a>从适用范围区别几种不同类型的代理实现</h2><p>1.远程代理（Remote Proxy）：为某个对象在不同的内存地址空间提供局部代理。使系统可以将Server部分的实现隐藏，以便Client可以不必考虑Server的存在。<br>2.虚拟代理（Virtual Proxy）：使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。<br>3.保护代理（Protection Proxy）：使用代理控制对原始对象的访问。该类型的代理常被用于原始对象又不同访问权限的情况。<br>4.智能引用（Smart Reference）：在访问原始对象时执行一些自己的附加操作并对指向原始对象的引用计数。<br>这里要注意的是，静态和动态代理都可以应用于上述4种情形，两者是各自独立的变化。</p>
<h1 id="代理模式实战场景"><a href="#代理模式实战场景" class="headerlink" title="代理模式实战场景"></a>代理模式实战场景</h1><p>1.NotificationManager的notify方法发送通知（详情看android源码设计模式解析与实战—18.8代理模式实战）</p>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>1.Binder跨进程通信机制与AIDL<br>代理模式：类似于ios开发的delegate委托模式，所有的AIDL都一个代理模式的例子。假设一个Activity A去绑定一个Service S，那么A调用S中的每一个方法其实都是通过系统的Binder机制的中转，然后调用S中的对应方法来做到的。Binder机制就起到了代理的作用。<br>简介：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>2.子线程委托主线程的handler调用它的handlemessage来更新UI，类似代理设计模式</p>
<p>3.ActivityManagerProxy代理类</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名 代理模式&lt;br&gt;外文名 Proxy Pattern&lt;br&gt;又名 委托模式 | 第三方模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_proxy1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式GOF之6 —— 装饰模式（结构型模式）</title>
    <link href="https://hengxing0080.github.io/2017/08/10/it/DesignPattern/6.Decorator/"/>
    <id>https://hengxing0080.github.io/2017/08/10/it/DesignPattern/6.Decorator/</id>
    <published>2017-08-10T00:11:22.000Z</published>
    <updated>2017-08-30T10:27:33.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中文名 装饰模式<br>外文名 Decorator Pattern<br>又名 装饰者模式 | 包装模式</p>
<h1 id="UML图例"><a href="#UML图例" class="headerlink" title="UML图例"></a>UML图例</h1><p><img src="/images/it_pattern_decorator1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>角色介绍<br> ● Client：客户端用户。<br> ● Prototype：抽象类或者接口，声明具备clone能力。<br> ● ConcretePrototype：具体的原型类。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>动态地给一个对象添加一些额外的职责。<br>就增加功能来说，装饰模式相比生成子类更加灵活。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。<br>其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。</p>
<p>装饰模式是为已有功能动态地添加更多功能的一种方式。<br>这个模式还是算很好理解！</p>
<h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>Java IO 流是典型的装饰模式。</p>
<h1 id="现实中使用"><a href="#现实中使用" class="headerlink" title="现实中使用"></a>现实中使用</h1><p>人需要各式各样的衣着，不管你穿着怎么样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式，装饰物也各不相同但是装饰的对象本质是不变的。</p>
<h1 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h1><p>以下情况使用Decorator模式<br>（1） 需要扩展一个类的功能，或给一个类添加附加职责。<br>（2） 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。<br>（3） 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。<br>（4） 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>（1） 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。<br>（2） 装饰对象包含一个真实对象的引用（reference）<br>（3） 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。<br>（4） 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>（1）Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。<br>（2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。<br>（3）把类中的装饰功能从类中搬移去除，这样可以简化原有的类。 有效的把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复装饰逻辑。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>（1）这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。<br>（2）装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。<br>（3）装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul>
<li>多用组合，少用继承。<ul>
<li>利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。</li>
<li>然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</li>
</ul>
</li>
<li>类应设计的对扩展开放，对修改关闭。 </li>
</ul>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>需要透明且动态地扩展类的功能时。</p>
<h1 id="装饰模式和代理模式的区别"><a href="#装饰模式和代理模式的区别" class="headerlink" title="装饰模式和代理模式的区别"></a>装饰模式和代理模式的区别</h1><p>装饰模式和代理模式有点类型，有时甚至容易混淆，倒不是把代码当成装饰，而容易将装饰看成代理，所以要注意！<br>装饰模式是亿对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，儿代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有对象的引用。<br>装饰模式应该为所装饰的对象增强·功能，代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>
<h1 id="装饰模式与适配者模式的区别"><a href="#装饰模式与适配者模式的区别" class="headerlink" title="装饰模式与适配者模式的区别"></a>装饰模式与适配者模式的区别</h1><p>1.关于新职责：适配器也可以在转换时增加新的职责，但主要目的不在此。装饰者模式主要是给被装饰者增加新职责的。<br>2.关于原接口：适配器模式是用新接口来调用原接口，原接口对新系统是不可见或者说不可用的。装饰者模式原封不动的使用原接口，系统对装饰的对象也通过原接口来完成使用。（增加新接口的装饰者模式可以认为是其变种–“半透明”装饰者）<br>3.关于其包裹的对象：适配器是知道被适配者的详细情况的（就是那个类或那个接口）。装饰者只知道其接口是什么，至于其具体类型（是基类还是其他派生类）只有在运行期间才知道。</p>
<h1 id="模式简化的2种方式"><a href="#模式简化的2种方式" class="headerlink" title="模式简化的2种方式"></a>模式简化的2种方式</h1><ol>
<li>如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。</li>
<li>如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。</li>
</ol>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">// Conponent类</div><div class="line">abstract class Compnent&#123;</div><div class="line">    public abstract void Operation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteComponent类</div><div class="line">class ConcreteComponent : Component&#123;</div><div class="line">    public override void Operation()&#123;</div><div class="line">        Console.WriteLine(“具体对象的操作”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Decorator类</div><div class="line">abstract class Decorator :Conponent&#123;</div><div class="line">    protected Conponent component;</div><div class="line">    public void SetComponent(Component component)&#123;</div><div class="line">        this.component = component;	</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Operation()&#123;</div><div class="line">        if(component != null_&#123;</div><div class="line">            component.Operation();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteDecoratorA类</div><div class="line">class ConcreteDecoratorA : Decorator&#123;</div><div class="line">    private string addedState; // 本类的独有功能，以区别于ConcreteDecoratorB</div><div class="line">    public override void Operation()&#123;</div><div class="line">        base.Operation();</div><div class="line">        addedState = “New State”;</div><div class="line">        Conscole.WriteLine(“具体装饰对象A的操作”);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ConcreteDecoratorB类</div><div class="line">class ConcreteDecoratorB : Decorator&#123;</div><div class="line">    public override void Operation()&#123;</div><div class="line">        base.Operation();</div><div class="line">        AddedBehavior();</div><div class="line">        Conscole.WriteLine(“具体装饰对象A的操作”);</div><div class="line">    &#125;</div><div class="line">    private void AddedBehavior()&#123;  // 本类独有的方法，以区别于ConcreteDecoratorB</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 客户端代码</div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    ConcreteConponent c = new ConcrtetComponent();</div><div class="line">    ConcreteDecoratorA d1 = new ConcreteDecoratorA();</div><div class="line">    ConcreteDecoratorB d2 = new ConcreteDecoratorB();;</div><div class="line"></div><div class="line">    // 装饰的方法是：首先用ConcreteComponent实例化对象c，然后用ConcreteDecoratorA的实例化对象d1来包装c，再用ConcreteDecoratorB的对象d2包装d1，最终执行d2的Operation();</div><div class="line">    d1.SetComponent(c);</div><div class="line">    d2.SetComponent(d1);</div><div class="line">    d2.Operation();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰模式就是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就喝如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。</p>
<p>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。<br>同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</p>
<p>优化代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">// Person类（ConcreteComponent）</div><div class="line">class Person&#123;</div><div class="line">    public Person()&#123;&#125;</div><div class="line">    public Person(string name)&#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line">    public virtual void Show()&#123;</div><div class="line">        Console.WriteLine(“装扮的&#123;0&#125;”,name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 服饰类（Decorator）</div><div class="line">class Finery : Person&#123;</div><div class="line">    protected Person component;</div><div class="line"></div><div class="line">    // 打扮</div><div class="line">    public void Decorate(Person component)&#123;</div><div class="line">        this.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public override void Show()&#123;</div><div class="line">        if(component != null)&#123;</div><div class="line">            component.Show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 具体服饰类（ConcreteDecorator）</div><div class="line">class TShirts : Finery&#123;</div><div class="line">    public override void Show()&#123;</div><div class="line">        Console.Write(“大T血”);</div><div class="line">        Base.Show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class BigTrouser: Finery&#123;</div><div class="line">    public override void Show()&#123;</div><div class="line">        Console.Write(“大裤子”);</div><div class="line">        Base.Show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 其余类类似，省略......</div><div class="line"></div><div class="line">static void Main(string[] args)&#123;</div><div class="line">    Person xc = new Person(“小明”);</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第一种装扮:“);</div><div class="line">    Sneakers pqx = new Sneakers();</div><div class="line">    BigTrouser kk = new BigTrouser();</div><div class="line">    TShirts dtx = new TShirts();</div><div class="line">    pqx.Decorate(xc);</div><div class="line">    kk.Decorate(pqx);</div><div class="line">    dtx.Decorate(kk);</div><div class="line">    dtx.Show();</div><div class="line"></div><div class="line">    Console.WriteLine(“\n第二种装扮:“);</div><div class="line">    LeatherShoes px= new LeatherShoes ();</div><div class="line">    Tie ld = new Tie ();</div><div class="line">    Suit xz= new Suit ();</div><div class="line">    px.Decorate(xc);</div><div class="line">    kk.Decorate(pqx);</div><div class="line">    xz.Decorate(kk);</div><div class="line">    xz.Show();</div><div class="line"></div><div class="line"></div><div class="line">    Console.WriteLine(“\n第三种装扮:“);</div><div class="line">    Sneakers pqx2= new Sneakers();</div><div class="line">    LeatherShoes px2= new LeatherShoes ();</div><div class="line">    BigTrouser kk2= new BigTrouser();</div><div class="line">    Tie ld2 = new Tie ();</div><div class="line">    pqx2.Decorate(xc);</div><div class="line">    px2.Decorate(pqx2);</div><div class="line">    kk2.Decorate(px2);</div><div class="line">    ld2 .Decorate(kk2);</div><div class="line">    ld2 .Show();</div><div class="line"></div><div class="line">    Console.Read();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Android涉及到的设计模式"><a href="#Android涉及到的设计模式" class="headerlink" title="Android涉及到的设计模式"></a>Android涉及到的设计模式</h1><p>1.Context与ContextImpl<br>2.Activity的onCreate方法中一些相关的初始化操作。<br>装饰模式其实并不负责，就是一种类间的封装。在平时的开发过程中也经常会不经意地使用类似的概念，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> classs DecoratorActivity extends Activity&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        <span class="comment">// 初始化数据</span></div><div class="line">        initData();</div><div class="line">        <span class="comment">// 初始化控件</span></div><div class="line">        initViews();</div><div class="line">        <span class="comment">// 初始化事件</span></div><div class="line">        initEvent();</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 初始化数据</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 初始化控件</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span></span>&#123;</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">        *初始化事件</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initEvent</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实如上的一些新增方法的调用就类似装饰模式中的装饰者的职责，只不过这里没有保持对组件累的引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;中文名 装饰模式&lt;br&gt;外文名 Decorator Pattern&lt;br&gt;又名 装饰者模式 | 包装模式&lt;/p&gt;
&lt;h1 id=&quot;UML图例&quot;&gt;&lt;a href=&quot;#UML图例&quot; class=&quot;headerlink&quot; title=&quot;UML图例&quot;&gt;&lt;/a&gt;UML图例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/it_pattern_decorator1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 面向对象和设计模式 - 设计模式" scheme="https://hengxing0080.github.io/categories/IT-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象和设计模式" scheme="https://hengxing0080.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表</title>
    <link href="https://hengxing0080.github.io/2017/08/01/it/DataStructure/LinearList/"/>
    <id>https://hengxing0080.github.io/2017/08/01/it/DataStructure/LinearList/</id>
    <published>2017-08-01T01:50:23.000Z</published>
    <updated>2017-08-26T06:10:47.364Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_linearlist1.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>线性表：零个或多个具有相同类型的数据元素的有限序列</p>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>线性表是由n（ｎ＞＝０）个数据元素（结点）组成的有限序列</p>
<p>是像线一样的性质的表。<br>就是排好队伍<br>最常用最简单的一种结构。</p>
<p>一年里的星座列表，也是线性表<br>星座通常都是白羊座打头，双鱼座收尾，当中的星座都有前驱和后继，而且一共也只有12个，所以它完全符合线性表的定义。</p>
<h1 id="线性表特点"><a href="#线性表特点" class="headerlink" title="线性表特点"></a>线性表特点</h1><p>１.有且仅有一个开始结点<br>２.有且仅有一个终结结点<br>３.内部结点都有且仅有一个直接前驱结点和一个直接后继结点</p>
<h1 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ADT List</div><div class="line">Data</div><div class="line">    线性表的数据对象集合为｛a1,a2,...,an｝,每个元素的类型均为DataType.</div><div class="line">    其中，</div><div class="line">    除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</div><div class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</div><div class="line">    数据元素直接是一对一的关系。</div><div class="line">Operation</div><div class="line">    InitList(*L);//初始化操作，建立一个空的线性表</div><div class="line">    ListEmpty(L);//若线性表为空，返回true,否则返回false</div><div class="line">    ClearList(*L);//清空线性表</div><div class="line">    GetElem(L,i,*e);//查找线性表中的第i个位置的元素值，并赋值给e</div><div class="line">    LocateElem(L,e);//查找线性表L中与给定值e相等的元素，如果查找成功，则返回第一个相同的元素在L</div><div class="line">                   //中的下标；否则，返回0表示失败</div><div class="line">    ListInsert(*L,i,e);//在线性表L的第i个位置插入元素e</div><div class="line">    ListDelete(*L,i,*e);//删除线性表L中第i个位置元素，并用e返回其值</div><div class="line">    ListLength();//返回线性表L的长度</div><div class="line">end ADT</div></pre></td></tr></table></figure>
<h1 id="线性表的2种表现形式"><a href="#线性表的2种表现形式" class="headerlink" title="线性表的2种表现形式"></a>线性表的2种表现形式</h1><p>1.顺序表（顺序存储结构）<br>2.链表（链式存储结构）<br>　2.1.单链表<br>　2.2.静态链表<br>　2.3.循环链表<br>　3.4.双向链表<br>　3.5.跳跃链表</p>
<hr>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><hr>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>顺序表就是线性表的顺序存储方式。<br>也称为向量存储，可以看做是一维数组存储。<br>计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.使用连续的内存单元存放线性表的数据元素。<br>2.数据元素在内存中的物理存储次序与他们在线性表中逻辑次序相同。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>存储密度大<br>无须为表示表中元素之间的逻辑关系而增加额外的存储空间<br>可以快速地存取表中任一位置的元素</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>插入，删除等其他运算不方便。（需要移动大量元素，显然很耗费时间）<br>当线性表长度变化较大时，难以确定存储空间的容量。<br>造成存储空间的碎片</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="结构代码"><a href="#结构代码" class="headerlink" title="结构代码"></a>结构代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20 <span class="comment">/* 存储空间初始分配量 */</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;          <span class="comment">/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;        <span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">	ElemType data[MAXSIZE];  <span class="comment">/* 数组，存储数据元素 */</span></div><div class="line">	<span class="keyword">int</span> length;              <span class="comment">/* 线性表当前长度 */</span></div><div class="line">&#125;SqList;</div></pre></td></tr></table></figure>
<h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>对于线性表的顺序存储结构来说，如果我们要实现GetElem操作，即将线性表L中的第i个位置元素值返回，其实是非常简单的。<br>就程序而言，只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></div><div class="line">Typedef <span class="keyword">int</span> Status;</div><div class="line"><span class="comment">/*Status是函数的类型，其值是函数结果状态代码，如OK等*/</span></div><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L)  */</span></div><div class="line"><span class="comment">/*操作结果：用e返回L中第i个数据元素的值 */</span></div><div class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i, Elemtype *e)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span> || i&lt; <span class="number">1</span> || i &gt; L.length)</div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    *e = L.data[i<span class="number">-1</span>];</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入算法的思路：<br>●如果插入位置不合理，抛出异常；<br>●如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；<br>●从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置;<br>●将要插入元素填入位置i处；<br>●表长加1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L), */</span></div><div class="line"><span class="comment">/*操作结果：在L中第i个位置之前插入新的数据元素e,L的长度加1*/</span></div><div class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L, <span class="keyword">int</span> i ,ElemType e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">if</span>(L -&gt; length == MAXSIZE)   <span class="comment">/*顺序线性表已经满*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt;L-&gt; length+<span class="number">1</span>)   <span class="comment">/*当i不在范围内时*/</span></div><div class="line">    reuturn ERROR;</div><div class="line">    <span class="keyword">if</span>(i&lt;= L -&gt;length)  <span class="comment">/*若插入数据位置不在表尾 */</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">for</span>(k=L-&gt;length <span class="number">-1</span> ;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/*将要插入位置后数据元素向后移动一位*/</span></div><div class="line">    L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</div><div class="line">    &#125;</div><div class="line">    L-&gt;data[i<span class="number">-1</span>]=e;</div><div class="line">    L-&gt;length++;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：<br>●如果删除位置不合理，抛出异常;<br>●取出删除元素;<br>●从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置;<br>●表长减1.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span></div><div class="line"><span class="comment">/*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/</span></div><div class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L, <span class="keyword">int</span> i,ElemType *e)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> k;</div><div class="line">    <span class="keyword">if</span>(L -&gt;length == <span class="number">0</span>)   <span class="comment">/*线性表为空*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)   <span class="comment">/*删除位置不正确*/</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">    *e = L-&gt;data[i<span class="number">-1</span>];</div><div class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length)   <span class="comment">/*如果删除不是最后位置*/</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)  <span class="comment">/*将删除位置后继元素前移*/</span></div><div class="line">    L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k]l;</div><div class="line">    &#125;</div><div class="line">    L-&gt;length--；</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="插入和删除的时间复杂度"><a href="#插入和删除的时间复杂度" class="headerlink" title="插入和删除的时间复杂度"></a>插入和删除的时间复杂度</h3><p>最好情况：O（1）<br>最坏情况：O（n）<br>平静情况：O（n）</p>
<p>在存，读数据时，不管是1哪个位置，时间复杂度都是O（1）<br>而插入或删除时，时间复杂度都是O（n）<br>说明，线性表的顺序存储结构，比较适合元素个数不太变化，而更多是存储数据的应用。</p>
<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><hr>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>由于顺序存储结构的插入和删除操作不方便，引出了链式存储结构。<br>它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。</p>
<p>之前在顺序结构中，每个数据元素只需要存数据元素信息就可以了。现在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。</p>
<p>链式存储用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置上不一定相邻，必须采用附加信息表示数据元素之间的关系，即用指针体现结点之间的逻辑关系。</p>
<p>单线索，无分支。</p>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。</p>
<h2 id="数据域和指针域"><a href="#数据域和指针域" class="headerlink" title="数据域和指针域"></a>数据域和指针域</h2><p>一般是在链表中的结点，数据域存放数据，指针域存放指向下一个结点的指针，以实现链表彻底线型结构。</p>
<h2 id="线性表类型——1-单链表"><a href="#线性表类型——1-单链表" class="headerlink" title="线性表类型——1.单链表"></a>线性表类型——1.单链表</h2><p>链式存储的线性表又分为几种，常见常用的是单链表，循环链表和双链表链表！<br>先看看单链表！</p>
<h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>并且它不是闭环的，是一条链状结构，因此才被称为单链表。<br>单链表是最简单的链式存储的线性表，他就像一条链子。<br>它的每个结点都可以分为两部分，一个是数据域（nodeValue），一个是指针域（next）<br>数据域存储结点的数据，指针域向下一个结点的内存存储地址</p>
<h3 id="头指针和尾-空指针"><a href="#头指针和尾-空指针" class="headerlink" title="头指针和尾/空指针"></a>头指针和尾/空指针</h3><p>对于单链表，我们还需要知道2个概念，头指针和尾/空指针。<br><img src="/images/it_datastructure_linearlist3.png" alt="UML图"></p>
<p>头指针：<br>是一个指针，它指向单链表第一结点存储的位置。整个单链表的存储必须从头指针开始，常用head表示，<br>链表中第一个结点的存储位置叫做头指针。</p>
<p>尾指针：<br>线性链表的最后一个结点指针为‘空’（通常用NULL或“^”符号表示）</p>
<h3 id="头指针和头结点的异同点"><a href="#头指针和头结点的异同点" class="headerlink" title="头指针和头结点的异同点"></a>头指针和头结点的异同点</h3><p>头指针<br>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。<br>头指针具有标识作用，所以常用头指针冠以链表的名字。<br>无论链表是否为空，头指针均不为空。尾指针是链表的必要元素。</p>
<p>头结点<br>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）、<br>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了。<br>头结点不一定是链表。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。</p>
<h3 id="单链表结构-与-顺序存储结构-优缺点"><a href="#单链表结构-与-顺序存储结构-优缺点" class="headerlink" title="单链表结构 与 顺序存储结构 优缺点"></a>单链表结构 与 顺序存储结构 优缺点</h3><p><img src="/images/it_datastructure_linearlist2.jpg" alt="UML图"></p>
<p>通过上面对比，得出一些经验性结论：<br>1.若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。<br>若需要频繁插入和删除时，宜采用单链表结构。比如说游戏开发中，用于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时采用顺序存储就不太合适了，单链表结构就可以大展拳脚。<br>当然，这是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。<br>2.当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。<br>而如果事先知道线性表的大致长度，如何一年12个月，一周就是星期一至星期日共七天，这样用顺序存储结构效率会高很多。</p>
<p>总之，线性表的顺序存储结构和单链表结构各有优缺点，不能简单的说哪个好，哪个不好，需要根据实际情况，来综合平衡采用哪个数据结构更能满足和达到需求和性能。</p>
<h3 id="如何将一个单向链表反转？"><a href="#如何将一个单向链表反转？" class="headerlink" title="如何将一个单向链表反转？"></a>如何将一个单向链表反转？</h3><p>递归</p>
<h2 id="线性表类型——2-静态链表"><a href="#线性表类型——2-静态链表" class="headerlink" title="线性表类型——2.静态链表"></a>线性表类型——2.静态链表</h2><h3 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h3><p>C语言是个好东西，它具有的指针能力，使得它可以非常容易地操作内存中的地址和数据，这比其他高级语言更加灵活方便。<br>后来的面向对象语言，如Java，C#等，虽不使用指针，但因为启用了对象引用机制，从某种角度也间接实现了指针的某些作用，但对于一些语言，如Basic，Fortran等早期的编程高级语言，由于没有指针，链表结构结构按照前面的讲法，它就没发实现了，怎么办？<br>有人想出来用数组来代替指针，来描述单链表。<br>首先我们让数据的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。<br>数据域data，用来存放数据元素，也就是通常我们要处理的数据，<br>而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。<br>我们把这种用数据描述的链表叫做静态链表，这种描述方法还有起名叫游标实现法。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>1.在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了再顺序存储结构中的插入和删除操作需要移动大量元素的缺点<br>缺点：<br>2.没有解决连续存储分配带来的表长难以确定的问题<br>3.失去了顺序存储结构随机存取的特性.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>若不使用指针如何处理链表结构的静态链表方法。<br>静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。<br>尽管大家不一定会用得上，但这样的思考方式是非常巧妙的，应该理解其思想，以备不时之需。</p>
<h2 id="线性表类型——3-循环链表"><a href="#线性表类型——3-循环链表" class="headerlink" title="线性表类型——3.循环链表"></a>线性表类型——3.循环链表</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）</p>
<p>对于单链表，由于每个结点只存储了向后的指针，到了尾标志就停止向后链的操作，这样，当中某一结点就无法找到它的前驱结点了，这就意味着无法回头。</p>
<p>循环链表是线性表的另外一种链式存储结构，他在单链表的基础上，将表尾结点的指针域指向表头结点，整个链表行成环状结构。</p>
<h3 id="循环链表的空链表"><a href="#循环链表的空链表" class="headerlink" title="循环链表的空链表"></a>循环链表的空链表</h3><p>循环链表也有head属性，head属性是一个指针，它单独指向头结点。<br>判断一个循环链表是不是空链表的条件就是head == head &gt;next<br>也就是head指向结点的下一个结点还是head指针，这就说明循环链表里没有结点。</p>
<p>循环链表带有头结点的空链表如图<br><img src="/images/it_datastructure_linearlist4.png" alt="UML图"></p>
<p>非空的循环链表<br><img src="/images/it_datastructure_linearlist5.png" alt="UML图"></p>
<h3 id="循环链表和单链表的主要差异"><a href="#循环链表和单链表的主要差异" class="headerlink" title="循环链表和单链表的主要差异"></a>循环链表和单链表的主要差异</h3><ul>
<li><p>循环的判断条件<br>就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。</p>
</li>
<li><p>时间复杂度<br>在单链表中，有了头结点时，我们可以用O（1）的时间访问第一个结点，但对于要访问到最后一个结点，却需要O(n)时间，因为我们需要将单链表全部扫描一遍。<br>不过有方法用O（1）的时间由链表指针访问到最后一个结点<br>需要改造一下循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端阶段都很方便了<br><img src="/images/it_datastructure_linearlist6.png" alt="UML图"><br>从上图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O（1），而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂度也为O（1）</p>
</li>
</ul>
<h3 id="如何检测一个链表有环？"><a href="#如何检测一个链表有环？" class="headerlink" title="如何检测一个链表有环？"></a>如何检测一个链表有环？</h3><p><a href="http://blog.csdn.net/qishouzhang/article/details/47007177" target="_blank" rel="external">http://blog.csdn.net/qishouzhang/article/details/47007177</a></p>
<h2 id="线性表类型——4-双链表"><a href="#线性表类型——4-双链表" class="headerlink" title="线性表类型——4.双链表"></a>线性表类型——4.双链表</h2><h3 id="理解-3"><a href="#理解-3" class="headerlink" title="理解"></a>理解</h3><p>双向链表跟循环链表类似，都是在单链表基础上做了复杂化处理的结构。</p>
<p>在单链表中，有了next指针，这就使得我们要查找下一节点的时间复杂度为O(1),<br>可是我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。</p>
<p>为了克服单向性这一缺点，老科学家们设计出了双向链表。</p>
<p>双向链表（double linked list）是在单链表的每个结点中，在设置一个指向其前驱结点的指针域。<br>所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>&#123;</span></div><div class="line">    ElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span>  <span class="comment">/*直接前驱指针*/</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span>   <span class="comment">/*直接后继指针*/</span></div><div class="line">&#125;DulNode, *DuLinkList;</div></pre></td></tr></table></figure>
<p>既然单链表也可以有循环链表，那么双向链表当然也可以是循环表。</p>
<p>双向链表的循环带头结点的空链表<br><img src="/images/it_datastructure_linearlist7.png" alt="UML图"></p>
<p>非空的循环的带头结点的双向链表<br><img src="/images/it_datastructure_linearlist8.png" alt="UML图"></p>
<p>由于这是双向链表，那么对于链表中的某一个结点p，它的后继的前驱是谁？当然还是它自己。<br>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next<br>这就如同上海的下一站是苏州，那么上海的下一站的前一站是哪里？  哈哈</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>双向链表相对于单链表来说，要更复杂一些，毕竟它多了prior指针，对于插入和删除时，需要格外小心。<br>另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过，由于它良好的对称性，使得对某个节点的前后节点的操作，带来了方便，可以有效提高算法的时间性能。说白了就是用空间来换时间。</p>
<h2 id="线性表类型——5-跳跃链表"><a href="#线性表类型——5-跳跃链表" class="headerlink" title="线性表类型——5.跳跃链表"></a>线性表类型——5.跳跃链表</h2><p>待学….</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_linearlist1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：计数排序</title>
    <link href="https://hengxing0080.github.io/2017/07/31/it/Algorithm/SortCounting/"/>
    <id>https://hengxing0080.github.io/2017/07/31/it/Algorithm/SortCounting/</id>
    <published>2017-07-31T14:02:57.000Z</published>
    <updated>2017-08-13T08:30:46.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 计数排序<br>外文名 Counting sort<br>提出人  Harold H. Seward<br>提出时间 1954<br>定义 非基于比较的排序算法<br>类别 分配式排序<br><a id="more"></a></p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>是一种稳定的线性时间排序算法。</p>
<p>运行时间θ(n)，是稳定不是原地排序，需要占用很大的内存空间，当然这是一种牺牲空间换取时间的做法。</p>
<p>但是计数排序有个缺点，要排序的数必须是一个小范围内的数，在实践中，当k=O(n)时，常采用计数排序。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>数据结构：数组<br>最坏时间复杂度：O ( n + k )<br>最优时间复杂度：O ( n + k )<br>平均时间复杂度：O ( n + k )<br>空间复杂度：O ( n + k )<br>是否稳定：稳定</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260299.html" target="_blank" rel="external">经典排序算法 - 计数排序Counting sort</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h1&gt;&lt;p&gt;中文名 计数排序&lt;br&gt;外文名 Counting sort&lt;br&gt;提出人  Harold H. Seward&lt;br&gt;提出时间 1954&lt;br&gt;定义 非基于比较的排序算法&lt;br&gt;类别 分配式排序&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：桶排序</title>
    <link href="https://hengxing0080.github.io/2017/07/30/it/Algorithm/SortBucket/"/>
    <id>https://hengxing0080.github.io/2017/07/30/it/Algorithm/SortBucket/</id>
    <published>2017-07-30T11:01:33.000Z</published>
    <updated>2017-08-13T08:09:44.186Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbucket.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 桶排序<br>又名     箱排序<br>英文名 Bucket sort<br>类别   分配式排序 </p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>有时也称为盒子排序（Bin Sort），来源于邮局使用的盒子信件分发方法</p>
<p>桶排序是计数排序的变种，把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p>
<p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。<br>桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ(n)）。<br>但桶排序并不是比较排序，他不受到O(n log n)下限的影响。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>桶排序以下列程序进行：<br>1.设置一个定量的数组当作空桶子。<br>2.寻访序列，并且把项目一个一个放到对应的桶子去。<br>3.对每个不是空的桶子进行排序。<br>4.从不是空的桶子里把项目再放回原来的序列中。</p>
<p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function bucket-sort(array, n) is</div><div class="line">    buckets ← new array of n empty lists</div><div class="line">    for i = 0 to (length(array)-1) do</div><div class="line">        insert array[i] into buckets[msbits(array[i], k)]</div><div class="line">    for i = 0 to n - 1 do</div><div class="line">        next-sort(buckets[i])</div><div class="line">    return the concatenation of buckets[0], ..., buckets[n-1]</div></pre></td></tr></table></figure></p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>数据结构：数组 </p>
<p>最坏时间复杂度：O ( n 2 )<br>平均时间复杂度：O ( n + k )<br>空间复杂度：O ( n ∗ k ) </p>
<p>是否稳定：桶排序是稳定的</p>
<p>优缺点：<br>桶排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法，如果待排序的数有10亿，总不能准备10亿个桶吧？</p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * <span class="doctag">@param</span> a 待排序数组元素</div><div class="line">  * <span class="doctag">@param</span> step 步长(桶的宽度/区间),具体长度可根据情况设定</div><div class="line">  * <span class="doctag">@return</span> 桶的位置/索引</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> step)</span></span>&#123;</div><div class="line">     <span class="keyword">return</span> a/step;</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</div><div class="line"></div><div class="line">     <span class="keyword">int</span> max=arr[<span class="number">0</span>],min=arr[<span class="number">0</span>];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> a:arr) &#123;</div><div class="line">         <span class="keyword">if</span> (max&lt;a)</div><div class="line">             max=a;</div><div class="line">         <span class="keyword">if</span> (min&gt;a)</div><div class="line">             min=a;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//该值也可根据实际情况选择</span></div><div class="line">     <span class="keyword">int</span> bucketNum=max/<span class="number">10</span>-min/<span class="number">10</span>+<span class="number">1</span>;</div><div class="line">     List buckList=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">     <span class="comment">//create bucket</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=bucketNum;i++)&#123;</div><div class="line">         buckList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//push into the bucket</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">         <span class="keyword">int</span> index=indexFor(arr[i],<span class="number">10</span>);</div><div class="line">         ((ArrayList&lt;Integer&gt;)buckList.get(index)).add(arr[i]);</div><div class="line">     &#125;</div><div class="line">     ArrayList&lt;Integer&gt; bucket=<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">int</span> index=<span class="number">0</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)&#123;</div><div class="line">         bucket=(ArrayList&lt;Integer&gt;)buckList.get(i);</div><div class="line">         insertSort(bucket);</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k : bucket) &#123;</div><div class="line">             arr[index++]=k;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"> <span class="comment">//把桶内元素插入排序</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(List&lt;Integer&gt; bucket)</span></span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;bucket.size();i++)&#123;</div><div class="line">         <span class="keyword">int</span> temp=bucket.get(i);</div><div class="line">         <span class="keyword">int</span> j=i-<span class="number">1</span>;</div><div class="line">         <span class="keyword">for</span> (; j&gt;=<span class="number">0</span> &amp;&amp; bucket.get(j)&gt;temp;j--)&#123;</div><div class="line">             bucket.set(j+<span class="number">1</span>,bucket.get(j));</div><div class="line">         &#125;</div><div class="line">         bucket.set(j+<span class="number">1</span>,temp);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbucket.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：基数排序</title>
    <link href="https://hengxing0080.github.io/2017/07/29/it/Algorithm/SortRadix/"/>
    <id>https://hengxing0080.github.io/2017/07/29/it/Algorithm/SortRadix/</id>
    <published>2017-07-29T03:52:09.000Z</published>
    <updated>2017-08-13T06:50:02.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortradix.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>中文名 基数排序<br>外文名 Radix sort<br>类别   分配式排序<br>别称   “桶子法”<br>方法   最高位优先法和最低位优先<br>发明者 赫尔曼·何乐礼 </p>
<h1 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h1><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，<br>顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，</p>
<p>是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。<br>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。<br>然后，从最低位开始，依次进行一次排序。<br>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><p>第一步<br>　以LSD为例，假设原来有一串数值如下所示：<br>　73, 22, 93, 43, 55, 14, 28, 65, 39, 81<br>　首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中：<br>　0<br>　1 81<br>　2 22<br>　3 73 93 43<br>　4 14<br>　5 55 65<br>　6<br>　7<br>　8 28<br>　9 39<br>第二步<br>　接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>　81, 22, 73, 93, 43, 14, 55, 65, 28, 39<br>　接着再进行一次分配，这次是根据十位数来分配：<br>　0<br>　1 14<br>　2 22 28<br>　3 39<br>　4 43<br>　5 55<br>　6 65<br>　7 73<br>　8 81<br>　9 93<br>第三步<br>　接下来将这些桶子中的数值重新串接起来，成为以下的数列：<br>　14, 22, 28, 39, 43, 55, 65, 73, 81, 93<br>　这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。</p>
<p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>
<p>数据结构       数组<br>最坏时间复杂度  O ( k N )<br>空间复杂度      O ( k + N )</p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> d)</span> <span class="comment">//d表示最大的数有多少位</span></span></div><div class="line">    &#123;</div><div class="line">        intk = <span class="number">0</span>;</div><div class="line">        intn = <span class="number">1</span>;</div><div class="line">        intm = <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位</span></div><div class="line">        <span class="keyword">int</span>[][]temp = newint[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9</span></div><div class="line">        <span class="keyword">int</span>[]order = newint[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数</span></div><div class="line">        <span class="keyword">while</span>(m &lt;= d)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; number.length; i++)</div><div class="line">            &#123;</div><div class="line">                intlsd = ((number[i] / n) % <span class="number">10</span>);</div><div class="line">                temp[lsd][order[lsd]] = number[i];</div><div class="line">                order[lsd]++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(order[i] != <span class="number">0</span>)</div><div class="line">                    <span class="keyword">for</span>(intj = <span class="number">0</span>; j &lt; order[i]; j++)</div><div class="line">                    &#123;</div><div class="line">                        number[k] = temp[i][j];</div><div class="line">                        k++;</div><div class="line">                    &#125;</div><div class="line">                order[i] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            n *= <span class="number">10</span>;</div><div class="line">            k = <span class="number">0</span>;</div><div class="line">            m++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span>[]data = &#123;<span class="number">73</span>, <span class="number">22</span>, <span class="number">93</span>, <span class="number">43</span>, <span class="number">55</span>, <span class="number">14</span>, <span class="number">28</span>, <span class="number">65</span>, <span class="number">39</span>, <span class="number">81</span>, <span class="number">33</span>, <span class="number">100</span>&#125;;</div><div class="line">        RadixSort.sort(data, <span class="number">3</span>);</div><div class="line">        <span class="keyword">for</span>(inti = <span class="number">0</span>; i &lt; data.length; i++)</div><div class="line">        &#123;</div><div class="line">            System.out.print(data[i] + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortradix.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序算法总结</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortAlgorithm/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortAlgorithm/</id>
    <published>2017-07-28T15:01:02.000Z</published>
    <updated>2017-08-13T05:49:49.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sort0.png" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="排序定义和理解"><a href="#排序定义和理解" class="headerlink" title="排序定义和理解"></a>排序定义和理解</h1><hr>
<p>常用的场景工作中，一旦建立了一个重要的数据库后，就可能根据某些需求对数据进行不同的排序，比如对姓名按字母排序，对学习按年级排序等等。<br>由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题，而且人们的确已经研究出一些非常成熟的方法。<br>如冒泡排序和选择排序。</p>
<p>排序是一种操作，将无序的序列调整为有序的序列。</p>
<p>注意我们在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p>
<p>如何排序：<br>计算机程序却不能像人这样通览所有数据。<br>它只能根据计算机的‘比较’操作原理，在同一时间内对两个队员进行比较。<br>算法的这种原理将是一个反复出现的问题。<br>在人类看来很简单的事情，计算机的算法却不能看到全景，因此只能一步一步地解决具体问题和遵循一些简单的规则。</p>
<p>按照算法的复杂度分为两大类：<br>冒泡排序，简单选择排序和直接插入排序属于简单算法。<br>希尔排序，堆排序，归并排序，快速排序属于改进算法。</p>
<p>内排序和外排序：<br>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p>内排序：<br>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。<br>内排序分为：插入排序，交换排序，选择排序和归并排序。<br>内排序算法的性能主要是受3个方面影响：<br>1.时间性能<br>2.辅助空间<br>3.算法的复杂性</p>
<p>外排序：<br>外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p>
<hr>
<h1 id="7种算法总结"><a href="#7种算法总结" class="headerlink" title="7种算法总结"></a>7种算法总结</h1><hr>
<p>根据将排序记录是否全部被放置到内存中，将排序分为内排序和外排序两种，外排序需要在内外存之间多次交换数据才能进行。<br>我们讲内排序分为：插入排序，交换排序，选择排序，归并排序4类<br>算法类文章介绍的其中7种排序法，就分别是各种分类的代表算法。<br><img src="/images/it_algorithm_sort1.png" alt="UML图"></p>
<p>7种算法的各种指标进行对比<br><img src="/images/it_algorithm_sort2.png" alt="UML图"></p>
<p>从算法的简单性来看，我们将7种算法分为两类：<br>1.简单算法：冒泡，简单选择，直接插入<br>2.改进算法：希尔，堆，归并，快速</p>
<p>从平均情况来看<br>显然最后3种改进算法要胜过希尔排序，并远远胜过前3种简单算法。</p>
<p>从最好情况看<br>反而冒泡和直接插入排序要更胜一筹，也就是说，如果你的待排序序列总是基本有序，反而不应该考虑后4种复杂的改进算法。<br>　　<br>从最坏情况看<br>堆排序与归并排序又强过快速排序以及其他简单排序。<br>　　<br>从这三组时间复杂度的数据对比中，我们可以得出这样一个认识。<br>堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。<br>而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。<br>但是他们如果都来比赛计算个位数的加减法，它们反而算不过成绩极普通的冒泡和直接插入。</p>
<p>从空间复杂度来说<br>归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少时，选择归并排序和快速排序就不是一个较好的决策了。</p>
<p>从稳定性来看<br>归并排序独占鳌头，我们前面也说过，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p>
<p>从待排序记录的个数上来说<br>待排序的个数n越小，采用简单排序方法越合适。反之，n越大，采用改进排序方法越合适。这也就是我们为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p>
<p>从7种算法的各种指标（上图）的数据中，似乎简单选择排序在3种简单排序中性能最差<br>其实也不完全是，比如，如果记录的关键字本身信息量比较大（例如，关键字都是数十位的数字），此时表明其占用存储空间很大，这样移动记录所花费的时间也就越多，我们给出3种简单排序算法的移动次数比较，如图所示。<br><img src="/images/it_algorithm_sort3.png" alt="UML图"><br>你会发现，此时简单选择排序就变得非常有优势，原因也就在于，它是通过大量比较后选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p>
<p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合我们也应该考虑使用不同的算法来应对它。</p>
<hr>
<h1 id="推荐排序方式"><a href="#推荐排序方式" class="headerlink" title="推荐排序方式"></a>推荐排序方式</h1><hr>
<p>开发时如果用数据量就用快速排序(递归排序)，数据量小用简单插入排序。</p>
<p>最重要还是要根据上面总结的场景来使用正确的排序方式。</p>
<hr>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><hr>
<p><a href="http://blog.csdn.net/wangwei890702/article/details/8197597" target="_blank" rel="external">7种常用排序算法总结</a><br><a href="http://blog.csdn.net/sgn132/article/details/47279511" target="_blank" rel="external">GIF演示排序算法</a><br><a href="http://www.cnblogs.com/ytb-wpq/p/6479240.html" target="_blank" rel="external">常用算法js版(冒泡/选择/插入/希尔/归并/快速/堆/计数/桶/基数)</a><br><a href="http://blog.csdn.net/litong09282039/article/details/46332127" target="_blank" rel="external">超级详细解读基本排序算法（不看后悔，带排序演示动画）</a><br><a href="http://blog.csdn.net/chivalrousman/article/details/51585639" target="_blank" rel="external">详解五大排序算法</a><br><a href="http://blog.csdn.net/cjf_iceking/article/details/7953637" target="_blank" rel="external">九种常用排序的性能分析总结</a><br><a href="http://blog.jobbole.com/11745/" target="_blank" rel="external">视觉直观感受7种常用的排序算法</a><br><a href="http://blog.sina.com.cn/s/blog_8898a00d0102whmd.html" target="_blank" rel="external">中国MOOC大学-程序设计基础-6.问题解决和算法基础3</a><br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="external">6分钟演示15种排序算法</a><br><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">可视化排序</a><br><a href="http://www.cnbeta.com/articles/tech/202221.htm" target="_blank" rel="external">[视频]程序员的艺术：排序算法舞蹈</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sort0.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：快速排序</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortQuick/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/Algorithm/SortQuick/</id>
    <published>2017-07-28T13:35:12.000Z</published>
    <updated>2017-07-29T15:32:33.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortquick1.gif" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>快速排序（Quick Sort）<br>快速排序采用“分而治之、各个击破”的观念，使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>作者为Tony Hoare，图领奖获得者，上世纪最伟大的计算机科学家之一。 在1962年提出。</p>
<p>很牛，20世纪十大算法之一。排序算法王者，要好好研究并掌握它。</p>
<p>快速排序其实就是前面认为的最慢的冒泡排序的升级，它们都属于交换排序类。<br>即它也是通过不断比较和移动交换来实现排序的，只不过它的实现，增大了记录的比较和移动的距离，将关键字较大的记录从前面直接移动到后面，关键字较小的记录从·后面直接移动到前面，从而减少了总的比较次数和移动交换次数。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>基本思想：<br>通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对着两份记录进行排序，整个排序过程可以递归进行，以达到整个序列有序的目的。</p>
<p>步骤为：<br>1.从数列中挑出一个元素，称为”基准”（pivot），<br>2.重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>3.递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p>在简单的伪代码中，此算法可以被表示为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function quicksort(q)&#123;</div><div class="line">    var list less, pivotList, greater</div><div class="line">    if length(q) ≤ 1 &#123;</div><div class="line">        return q</div><div class="line">    &#125; else &#123;</div><div class="line">        select a pivot value pivot from q</div><div class="line">        for each x in q except the pivot element</div><div class="line">            if x &lt; pivot then add x to less</div><div class="line">            if x ≥ pivot then add x to greater</div><div class="line">        add pivot to pivotList</div><div class="line">        return concatenate(quicksort(less), pivotList, quicksort(greater))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="未优化代码"><a href="#未优化代码" class="headerlink" title="未优化代码"></a>未优化代码</h2><p>其中Partition函数是最关键的，它要做的，就是先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，将这样的关键字称为枢轴（pivot）<br>通过下面代码的模拟，可以看到Partition函数，其实就是将选取的pivotkey不断交换，将比它小的换到它的左边，比它大的换到它的右边，它也在交换中不断更改自己的位置，知道完全满足这个要求为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置 */</span></div><div class="line"><span class="comment">/* 此时在它之前(后)的记录均不大(小)于它。 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivotkey;</div><div class="line"></div><div class="line">    pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></div><div class="line">    <span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">            high--;</div><div class="line">        swap(L,low,high);<span class="comment">/* 将比枢轴记录小的记录交换到低端 */</span></div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">            low++;</div><div class="line">        swap(L,low,high);<span class="comment">/* 将比枢轴记录大的记录交换到高端 */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L中的子序列L-&gt;r[low..high]作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivot;</div><div class="line">    <span class="keyword">if</span>(low&lt;high)</div><div class="line">    &#123;</div><div class="line">            pivot=Partition(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></div><div class="line">            QSort(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></div><div class="line">            QSort(L,pivot+<span class="number">1</span>,high);		<span class="comment">/*  对高子表递归排序 */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    QSort(L,<span class="number">1</span>,L-&gt;length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="优化快速排序代码"><a href="#优化快速排序代码" class="headerlink" title="优化快速排序代码"></a>优化快速排序代码</h2><p>上面的快速排序有不少可以改进的地方，来看一些优化方案。</p>
<p>1.优化选取枢轴<br>2.优化不必要的交换<br>3.优化小数组时的排序方案<br>4.优化递归操作</p>
<p>（具体优化细节描述请查看大数数据结构——422页）</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 改进后快速排序******************************** */</span></div><div class="line"><span class="comment">/* 快速排序优化算法 */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivotkey;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> m = low + (high - low) / <span class="number">2</span>; <span class="comment">/* 计算数组中间的元素的下标 */</span>  </div><div class="line">    <span class="keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])			</div><div class="line">        swap(L,low,high);	<span class="comment">/* 交换左端与右端数据，保证左端较小 */</span></div><div class="line">    <span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[high])</div><div class="line">        swap(L,high,m);	<span class="comment">/* 交换中间与右端数据，保证中间较小 */</span></div><div class="line">    <span class="keyword">if</span> (L-&gt;r[m]&gt;L-&gt;r[low])</div><div class="line">        swap(L,m,low);		<span class="comment">/* 交换中间与左端数据，保证左端较小 */</span></div><div class="line">    </div><div class="line">    pivotkey=L-&gt;r[low]; <span class="comment">/* 用子表的第一个记录作枢轴记录 */</span></div><div class="line">    L-&gt;r[<span class="number">0</span>]=pivotkey;  <span class="comment">/* 将枢轴关键字备份到L-&gt;r[0] */</span></div><div class="line">    <span class="keyword">while</span>(low&lt;high) <span class="comment">/*  从表的两端交替地向中间扫描 */</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[high]&gt;=pivotkey)</div><div class="line">            high--;</div><div class="line">        L-&gt;r[low]=L-&gt;r[high];</div><div class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;L-&gt;r[low]&lt;=pivotkey)</div><div class="line">            low++;</div><div class="line">        L-&gt;r[high]=L-&gt;r[low];</div><div class="line">    &#125;</div><div class="line">    L-&gt;r[low]=L-&gt;r[<span class="number">0</span>];</div><div class="line">    <span class="keyword">return</span> low; <span class="comment">/* 返回枢轴所在位置 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort1</span><span class="params">(SqList *L,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">int</span> pivot;</div><div class="line">    <span class="keyword">if</span>((high-low)&gt;MAX_LENGTH_INSERT_SORT)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(low&lt;high)</div><div class="line">        &#123;</div><div class="line">            pivot=Partition1(L,low,high); <span class="comment">/*  将L-&gt;r[low..high]一分为二，算出枢轴值pivot */</span></div><div class="line">            QSort1(L,low,pivot<span class="number">-1</span>);		<span class="comment">/*  对低子表递归排序 */</span></div><div class="line">            <span class="comment">/* QSort(L,pivot+1,high);		/*  对高子表递归排序 */</span></div><div class="line">            low=pivot+<span class="number">1</span>;	<span class="comment">/* 尾递归 */</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        InsertSort(L);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作快速排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort1</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">    QSort1(L,<span class="number">1</span>,L-&gt;length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏时间复杂度  O( n 2 )<br>最优时间复杂度  O( n log n )<br>平均时间复杂度  O( n log n ) </p>
<p>快速排序的时间性能取决于排序递归的深度，可以用递归树来描述递归算法的执行情况。<br>如下图所示，它是{50,10,90,30,70,40,80,60,20}在快速排序过程中递归过程。<br>由于第一个关键字是50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。<br><img src="/images/it_algorithm_sortquick2.png" alt="UML图"></p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>主要是递归造成的栈空间的使用<br>最好情况：递归树的深度为log2n，其空间复杂度为O( n log n )<br>最坏情景：需要进行n-1递归调用，起空间复杂度为O（n）<br>平均情况：O ( n log n ) </p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>不稳定<br>由于关键字的比较和交换是跳跃进行的，因此它是一种不稳定的排序的排序方法。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>事实上目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越，它也存在排序不稳定，需要大量辅助空间，对少量数据排序无优势等不足。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortquick1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网络 —— 协议：HTTP</title>
    <link href="https://hengxing0080.github.io/2017/07/28/it/NetworkProtocol/HTTP/"/>
    <id>https://hengxing0080.github.io/2017/07/28/it/NetworkProtocol/HTTP/</id>
    <published>2017-07-28T09:11:55.000Z</published>
    <updated>2017-07-28T10:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_http.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名 　超文本传输协议<br>外文名 　HTTP（HyperText Transfer Protocol）</p>
<hr>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><hr>
<p>定义了浏览器(万维网客户进程)怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器.<br>从层次的角度看,HTTP是面向(transaction-oriented)应用层协议，它是万维网上能够可靠地交换文件，(包括文本,声音,图像等各种多媒体文件)的重要基础。         </p>
<p>通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）来标识。<br>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。<br>就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。<br>当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。<br>浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<p>简单的理解就是：<br>基于TCP，只不过封装了一些东西。<br>Http协议用于加载以 http:// 开头的普通远程网站的HTML网页。不加密。</p>
<hr>
<h1 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h1><hr>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>Web服务器根据接收到的请求后，向客户端发送响应信息。<br>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<p>HTTP三点注意事项：<br>1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>2.HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>3.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
<p>HTTP协议，你只需要稍微了解一些就足够了，它的工作原理特别的简单，就是客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理就可以了。<br>是不是非常简单？<br>一个浏览器的基本工作原理也就是如此了。<br>比如Android里使用到的WebView控件，其实也就是我们向百度的服务器发起了一条HTTP请求，接着服务器分析出我们想要访问的是百度的首页，于是会把该网页的HTML代码进行返回，然后WebView再调用手机浏览器的内核对返回的HTML代码进行解析，最终将页面展示出来。</p>
<p>http协议是用在应用层的协议，他是基于tcp协议的，http协议建立链接也必须要有三次握手才能发送信息。<br>http链接分为短链接，长链接，短链接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response。长链接是在一定的期限内保持链接。保持TCP连接不断开。客户端与服务器通信，必须要有客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</p>
<hr>
<h1 id="HTTP版本历史"><a href="#HTTP版本历史" class="headerlink" title="HTTP版本历史"></a>HTTP版本历史</h1><hr>
<blockquote>
<p>超文本传输协议已经演化出了很多版本，它们中的大部分都是向下兼容的.</p>
</blockquote>
<ul>
<li><p>HTTP/0.9　<br>已过时。<br>只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。<br>由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。</p>
</li>
<li><p>HTTP/1.0　<br>这是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。</p>
</li>
<li><p>HTTP/1.1<br>当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。<br>还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。<br>版本1.0和1.1 的区别:<br>　1 缓存处理<br>　2 带宽优化及网络连接的使用<br>　　在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。<br>　　HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。<br>　3 错误通知的管理<br>　4 消息在网络中的发送<br>　5 互联网地址的维护<br>　6 安全性及完整性</p>
</li>
</ul>
<p>想要提交数据到数据器，必须和它要接口（url, method请求方式, param参数，header消息头）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_http.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：归并排序</title>
    <link href="https://hengxing0080.github.io/2017/07/27/it/Algorithm/SortMerging/"/>
    <id>https://hengxing0080.github.io/2017/07/27/it/Algorithm/SortMerging/</id>
    <published>2017-07-27T12:47:32.000Z</published>
    <updated>2017-07-29T15:20:29.982Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortmerging1.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortmerging2.jpg" alt="UML图"></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>归并排序（Merging Sort）是建立在归并操作上的一种有效的排序算法<br>发明者为约翰·冯·诺伊曼<br>该算法是采用分治法（Divide and Conquer）实现快速排序<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>归并的就是合并，并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。<br>就是利用归并的思想实现的排序方法。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>回想上一个讲的堆排序充分利用了完全二叉树的深度是[log2n]+1的特性，所以效率比较高。<br>不过堆结构的设计本身是比较复杂的，那么有没有更直接简单的办法利用完全二叉树来排序呢？ 有，归并排序。</p>
<p>看图所示，将无序的数组序列{16,7,13,10,9,15,3,2,5,8,12,1,11,4,6,14}，通过两两合并排序后在合并，最终获得了一个有序的数组。<br>注意它的形状，它像极了一颗导致的完全二叉树，通常涉及到完全二叉树结构的排序算法，效率一般都不低的<br><img src="/images/it_algorithm_sortmerging3.png" alt="UML图"></p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n] */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> i,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> j,k,l;</div><div class="line">     <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++)	<span class="comment">/* 将SR中记录由小到大地并入TR */</span></div><div class="line">     &#123;</div><div class="line">         <span class="keyword">if</span> (SR[i]&lt;SR[j])</div><div class="line">             TR[k]=SR[i++];</div><div class="line">         <span class="keyword">else</span></div><div class="line">             TR[k]=SR[j++];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(i&lt;=m)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=m-i;l++)</div><div class="line">             TR[k+l]=SR[i+l];		<span class="comment">/* 将剩余的SR[i..m]复制到TR */</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span>(j&lt;=n)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;=n-j;l++)</div><div class="line">             TR[k+l]=SR[j+l];		<span class="comment">/* 将剩余的SR[j..n]复制到TR */</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/* 将SR[s..t]归并排序为TR1[s..t] */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR1[],<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> m;</div><div class="line">     <span class="keyword">int</span> TR2[MAXSIZE+<span class="number">1</span>];</div><div class="line">     <span class="keyword">if</span>(s==t)</div><div class="line">         TR1[s]=SR[s];</div><div class="line">     <span class="keyword">else</span></div><div class="line">     &#123;</div><div class="line">         m=(s+t)/<span class="number">2</span>;			<span class="comment">/* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */</span></div><div class="line">         MSort(SR,TR2,s,m);		<span class="comment">/* 递归地将SR[s..m]归并为有序的TR2[s..m] */</span></div><div class="line">         MSort(SR,TR2,m+<span class="number">1</span>,t);	<span class="comment">/* 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] */</span></div><div class="line">         Merge(TR2,TR1,s,m,t);	<span class="comment">/* 将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t] */</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/* 对顺序表L作归并排序 */</span></div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(SqList *L)</span></span></div><div class="line"> &#123; </div><div class="line">     MSort(L-&gt;r,L-&gt;r,<span class="number">1</span>,L-&gt;length);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h2><p>因为递归的方式尽管在代码中比较清晰，容易理解，但这会造成时间和空间上的性能损耗。<br>我们排序追求的就是笑了，有没有可能将递归转化成迭代呢？ 结论当然是有的，经过改动之后，性能上进一步提高了。看看下面代码！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 将SR[]中相邻长度为s的子序列两两归并到TR[] */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span> SR[],<span class="keyword">int</span> TR[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> j;</div><div class="line">	<span class="keyword">while</span>(i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span>)</div><div class="line">	&#123;<span class="comment">/* 两两归并 */</span></div><div class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);</div><div class="line">		i=i+<span class="number">2</span>*s;        </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(i&lt;n-s+<span class="number">1</span>) <span class="comment">/* 归并最后两个序列 */</span></div><div class="line">		Merge(SR,TR,i,i+s<span class="number">-1</span>,n);</div><div class="line">	<span class="keyword">else</span> <span class="comment">/* 若最后只剩下单个子序列 */</span></div><div class="line">		<span class="keyword">for</span>(j =i;j &lt;= n;j++)</div><div class="line">			TR[j] = SR[j];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代的做法更加直接了当，从最小的序列开始归并直至完成。不需要像归并的递归算法一样，需要先拆分递归，在归并退出递归。<br>迭代的做法避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此空间复杂度为O（n），并且避免递归也在时间性能上有一定的提升，应该说，使用归并排序时，尽量考虑用非递归方法。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好，最坏，平均的时间性能为O(nlogn)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O（n+logn）<br>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为log2n的栈空间，所以空间复杂度为O（n+logn）</p>
<h2 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h2><p>稳定<br>通过示例代码中的Merge函数中有if(SR[i] &lt; SR[j])语句，这就说明它需要两两比较，不存在跳跃，所以是一种稳定的稳定的算法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
<p>推荐使用迭代方式实现归并排序</p>
<p>该算法速度仅次于快速排序</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortmerging1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：堆排序</title>
    <link href="https://hengxing0080.github.io/2017/07/26/it/Algorithm/SortHeap/"/>
    <id>https://hengxing0080.github.io/2017/07/26/it/Algorithm/SortHeap/</id>
    <published>2017-07-26T11:52:08.000Z</published>
    <updated>2017-07-24T12:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortheap1.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortheap2.gif" alt="UML图"></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法。<br>它是选择排序的一种（是简单选择排序的一种改进）。</p>
<p>它利用数组的特点快速定位指定索引的元素。<br>堆分为大根堆和小根堆，是完全二叉树。<br>大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。<br>在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</p>
<h1 id="算法起源"><a href="#算法起源" class="headerlink" title="算法起源"></a>算法起源</h1><p>堆排序算法是斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd）和威廉姆斯(J．Williams）在1964年共同发明的。<br>同时，他们发明了“堆”这样的数据结构。（类似叠罗汉运动）</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p>例如图所示，<br>图1是一个大顶堆，90为最大值，将90与20（末尾元素）互换，<br>如图2所示，此时90就成了整个堆序列的最后一个元素，将20经过调整，使得除90以外的节点继续满足大顶堆定义（所有结果都大于等于其子孩子），见图3，然后在考虑将30与80互换……<br><img src="/images/it_algorithm_sortheap3.png" alt="UML图"><br><img src="/images/it_algorithm_sortheap4.png" alt="UML图"></p>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><p>上面明白堆排序的基本思想了，不过要实现它还需要解决两个问题：<br>1.如何由一个无需序列构建成一个堆？<br>2.如果在输出堆顶元素后，调整剩余元素成为一个新的堆？<br>先看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*  对顺序表L进行堆排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=L-&gt;length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;  <span class="comment">/* 把L中的r构建成一个大根堆 */</span></div><div class="line">		 HeapAdjust(L,i,L-&gt;length);</div><div class="line">&#125;</div><div class="line">	<span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</div><div class="line">	&#123; </div><div class="line">		 swap(L,<span class="number">1</span>,i);  <span class="comment">/* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */</span></div><div class="line">		 HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);  <span class="comment">/* 将L-&gt;r[1..i-1]重新调整为大根堆 */</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中能看出，整个排序过程分为两个for循环。<br>第一个循环要完成是将显著的待排序序列构建成一个大顶堆。<br>第二个循环要完成的就是逐步将每个最大值的根节点与末尾元素交换，并且要调整其成为大顶堆。</p>
<p>然后在看看关键的HeapAdjust（堆调整）函数是如何实现的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 已知L-&gt;r[s..m]中记录的关键字除L-&gt;r[s]之外均满足堆的定义， */</span></div><div class="line"><span class="comment">/* 本函数调整L-&gt;r[s]的关键字,使L-&gt;r[s..m]成为一个大顶堆 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(SqList *L,<span class="keyword">int</span> s,<span class="keyword">int</span> m)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span> temp,j;</div><div class="line">	temp=L-&gt;r[s];</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">2</span>*s;j&lt;=m;j*=<span class="number">2</span>) <span class="comment">/* 沿关键字较大的孩子结点向下筛选 */</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</div><div class="line">			++j; <span class="comment">/* j为关键字中较大的记录的下标 */</span></div><div class="line">		<span class="keyword">if</span>(temp&gt;=L-&gt;r[j])</div><div class="line">			<span class="keyword">break</span>; <span class="comment">/* rc应插入在位置s上 */</span></div><div class="line">		L-&gt;r[s]=L-&gt;r[j];</div><div class="line">		s=j;</div><div class="line">	&#125;</div><div class="line">	L-&gt;r[s]=temp; <span class="comment">/* 插入 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>过程有点复杂，多试着模拟计算机执行的方式走几遍，应该就可以理解其原理。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>最坏时间复杂度    O(n\log n)<br>最优时间复杂度    O(n\log n)[1]<br>平均时间复杂度    θ (n\log n)</p>
<p>分析下堆排序的效率<br>它的运行时间主要是消耗在初始构建堆和重建堆时的反复筛选上。<br>在构建堆的过程中，因为我们是完全二叉树从最下层最右边的非终端结点开始构建，将它和其孩子进行比较和若有必要的交换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为0（n）</p>
<h2 id="空间复杂度-："><a href="#空间复杂度-：" class="headerlink" title="空间复杂度    ："></a>空间复杂度    ：</h2><p>O(n) total, O(1) auxiliary</p>
<h2 id="是否稳定："><a href="#是否稳定：" class="headerlink" title="是否稳定："></a>是否稳定：</h2><p>不稳定<br>它只有一个用来交换的暂存单元，也非常的不错。<br>不过由于记录的比较与交换是跳跃式进行，所以不稳定。</p>
<h2 id="其他注意："><a href="#其他注意：" class="headerlink" title="其他注意："></a>其他注意：</h2><p>因为初建堆所需的比较次数较多，因此它并不适合待排序序列个数较少的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortheap1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：臭皮匠排序（最漂亮）</title>
    <link href="https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortStooge/"/>
    <id>https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortStooge/</id>
    <published>2017-07-23T12:47:32.000Z</published>
    <updated>2017-07-30T06:17:35.572Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortstooge1.gif" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>Stooge排序又名臭皮匠排序<br>该算法得名于三个臭皮匠，每个臭皮匠都打其他两个。<br>在《算法导论》第二版第7章（快速排序）的思考题中被提到，是由Howard、Fine等教授提出的所谓“漂亮的”排序算法。<br>代码很漂亮但是很耗时<br>该排序是一种低效的递归排序算法，不仅慢于一般的有效排序算法（如：插入排序，合并排序，堆排序和快速排序），甚至慢于冒泡排序。<br>所以相比于经典的排序算法，STOOGE算法具有非常差的性能。</p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>如果最后一个值小于第一个值，则交换它们<br>如果当前子集元素数量大于等于3：<br>　1.使用Stooge排序前2/3的元素<br>　2.使用Stooge排序后2/3的元素<br>　3.再次使用Stooge排序前2/3的元素</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>O(n^log(3/2)3)<br>O（n^2.7）<br>可见此算法效率相当的低下，比选择、插入、冒泡排序更差！</p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">StooGe_sort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[left]&gt;<span class="built_in">array</span>[right])  </div><div class="line">    &#123;  </div><div class="line">        ExchangeAB(<span class="built_in">array</span>[left],<span class="built_in">array</span>[right]);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (left+<span class="number">1</span> &gt;= right)         <span class="comment">// 数组不多于2个元素 返回  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">return</span> ;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">int</span> k=(right-left+<span class="number">1</span>)/<span class="number">3</span>;  </div><div class="line">    StooGe_sort(<span class="built_in">array</span>,left,right-k);  </div><div class="line">    StooGe_sort(<span class="built_in">array</span>,left+k,right);  </div><div class="line">    StooGe_sort(<span class="built_in">array</span>,left,right-k);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stooge_sort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (a[l]&gt;a[r]) swap(a[l],a[r]);</div><div class="line">    <span class="keyword">if</span> (l+<span class="number">1</span>&gt;=r) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> k=(r-l+<span class="number">1</span>)/<span class="number">3</span>;</div><div class="line">    stooge_sort(a,l,r-k);</div><div class="line">    stooge_sort(a,l+k,r);</div><div class="line">    stooge_sort(a,l,r-k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><hr>
<p><a href="http://blog.sina.com.cn/s/blog_51cea4040100fcl6.html" target="_blank" rel="external">【OI杂记】神奇的地球之Stooge排序 </a><br><a href="http://blog.csdn.net/zhaogang1993/article/details/43601831" target="_blank" rel="external">排序算法(四)：Stooge排序</a><br><a href="http://www.cnblogs.com/cpoint/p/3367362.html" target="_blank" rel="external">Stooge 排序 </a><br><a href="http://www.bubuko.com/infodetail-201471.html" target="_blank" rel="external">排序算法之stooge排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortstooge1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：猴子排序（最慢）</title>
    <link href="https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortBogo/"/>
    <id>https://hengxing0080.github.io/2017/07/23/it/Algorithm/SortBogo/</id>
    <published>2017-07-23T03:21:02.000Z</published>
    <updated>2017-07-30T06:17:01.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortbogo1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p>Bogo排序(Bogo-sort)，又被称为猴子排序，是一种恶搞排序算法。<br>其算法就是坑爹的将元素随机打乱，然后紧紧检查其是否符合排列顺序，若否，则继续进行随机打乱，继续检查结果，直到符合排列顺序。</p>
<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>运气！！！！！！！！<br>Bogo排序算是一个恶搞排序，它将一切交给了上帝。Bogo排序每一趟都在检测待排序序列是否有序，如果有序，结束。如果无序，将待排序序列随机打乱（随机打乱！！！！！），重新检测。 </p>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>是个既不实用又原始的排序算法，其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，否则就再抛一次。</p>
<p>“猴子排序”的名字出自“无限猴子定理”——让一只猴子在打字机上随机地按键，当按键时间达到无穷时，几乎必然能够打出任何给定的文字，比如莎士比亚的全套著作。——只要时间足够，猴子排序一定能得出正确的答案</p>
<p>猴子排序结合无限猴子定理考虑的话，最终的答案就是只要你愿意等足够久的时间，最终一定能得到有序序列.</p>
<p>不过，其实猴子排序也不一定是最慢的排序，未来可以利用量子计算机的力量（当今传统计算机的几百亿倍速度来秒杀猴子排序）。<br>引入一段：<br>量子Bogo排序<br>计算机科学家之间的一个笑话说：量子计算机能够以 O(n) 的复杂度更有效地实现Bogo排序。这将使用真正的量子的随机性来随机打乱列表。根据量子物理学的多世界诠释，量子的随机性分别在无限的宇宙序列中展开，其中的一些将会提供一个排好序的列表。这个列表接着就被测试出来（需要[ i ]n-1次比较），如果顺序不对，这个宇宙就被毁灭掉。因此最后只剩下得出正确顺序的宇宙。</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>平均时间复杂度是O(n·n!)<br>最坏时间复杂度为 O(∞)（所需时间是无限）<br>所以有Bogo排序的一辈子也不能输出排序结果。</p>
<h2 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h2><p>它并非一个稳定的算法。（好像是废话…..）</p>
<hr>
<h1 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h1><hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function">BOOL <span class="title">BogoSort</span><span class="params">(datatype *<span class="built_in">array</span>, <span class="keyword">int</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i, j;</div><div class="line">    <span class="keyword">int</span> tag;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> FALSE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(TRUE) &#123;</div><div class="line">        tag = TRUE;</div><div class="line">        <span class="comment">//检测</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[i<span class="number">-1</span>]) &#123;</div><div class="line">                tag = FALSE;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果有序，则排序完成</span></div><div class="line">        <span class="keyword">if</span>(tag) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//随机打乱</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">            j = rand() % size;</div><div class="line">            Swap(<span class="built_in">array</span> + i, <span class="built_in">array</span> + j);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><hr>
<p>示例来源博客：<br><a href="http://blog.csdn.net/u010647471/article/details/50171511" target="_blank" rel="external">排序算法之Bogo排序</a></p>
<p>算法效果请看以下网址：<br><a href="http://www.bilibili.com/video/av685670/" target="_blank" rel="external">6分钟演示15种排序算法</a><br><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">ソートアルゴリズムを映像化してみた - jsdo.it - Share JavaScript, HTML5 and CSS</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortbogo1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：希尔排序</title>
    <link href="https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShell/"/>
    <id>https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShell/</id>
    <published>2017-07-22T09:47:22.000Z</published>
    <updated>2017-07-22T10:33:40.354Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortshell2.gif" alt="UML图"><br><a id="more"></a><br><img src="/images/it_algorithm_sortshell1.gif" alt="UML图"></p>
<hr>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><hr>
<p>中文名 希尔排序<br>外文名 Shell Sort<br>别名   缩小增量排序<br>类别：插入排序的一种<br>提出者和时间：该方法因设计者希尔（DL．Shell）于1959年提出而得名</p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>首先，大家能都理解，优秀排序算法的首要条件就是速度<sup>24</sup>，但是之前提到的冒泡，选择和插入的时间复杂度都是O(n2)，似乎没法超越了<sup>25</sup>。直到终于有一天，当一位科学家发布超越了O(n<sup>2</sup>)的排序算法，并把内排序算法的时间复杂度提升到了O(nlogn)。<br>在这之前排序算法的时间复杂度基本都是O(n<sup>2</sup>)的，希望排序算法是突破这个时间复杂度的第一批算法之一。</p>
<p>之前写的直接插入排序，其实它的效率在某些时间是很高的。<br>比如，我们的记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很搞笑。<br>还有就是记录数比较少时，直接插入的优势也比较明显。<br>可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。</p>
<p>所以希尔排序可以是直接插入排序改进后的版本，可以增加效率。</p>
<p>希尔排序不同之处就是采取跳跃分割的策略：<br>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</p>
<p>基本有序：<br>就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，像{2,1,3,5,4,7,5,8,9}这样可以成为基本有序了。<br>但像{1,5,9,3,7,8,2,4,6}这样的9在第3位，2在倒数第3位就谈不上基本有序。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>先将整个待排序序列分割成若干子序列，每个子序列由相差一定长度的数据元素组成（这个相差的长度称为增量），然后我们分别对这些子序列<br>进行直接插入排序，一轮排序再取第二个增量，以此类推，需要注意的是，对于希尔排序中增量的确定没有统一的规定，通常的做法是：第一个增量为待排序序列长度的二分之一（取整），然后逐渐减半（取整），知道等于1为止。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p>
<p>希尔排序实质上是一种分组插入的方法！​<br>希尔排序说白了就是把距离不断缩小的插入排序。<br>希尔排序是实现简单但是分析极其困难的一个算法的例子.</p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>O(nlogn)<br>O(n<sup>3/2</sup>), 要好于直接排序的O（n<sup>2</sup>）.</p>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些</p>
<h2 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h2><p>另外由于记录是跳跃式的移动，希尔排序并不是一个稳定的排序算法。</p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度都O(n2)），之后。相应的更为高效的排序算法也就相继出现了。</p>
<hr>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><hr>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>代码来源：大话数据结构——9.6希尔排序 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 对顺序表L作希尔排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i,j,k=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> increment=L-&gt;length;</div><div class="line">	<span class="keyword">do</span></div><div class="line">	&#123;</div><div class="line">		increment=increment/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">/* 增量序列 */</span></div><div class="line">		<span class="keyword">for</span>(i=increment+<span class="number">1</span>;i&lt;=L-&gt;length;i++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i-increment])<span class="comment">/*  需将L-&gt;r[i]插入有序增量子表 */</span> </div><div class="line">			&#123; </div><div class="line">				L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/*  暂存在L-&gt;r[0] */</span></div><div class="line">				<span class="keyword">for</span>(j=i-increment;j&gt;<span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>]&lt;L-&gt;r[j];j-=increment)</div><div class="line">					L-&gt;r[j+increment]=L-&gt;r[j]; <span class="comment">/*  记录后移，查找插入位置 */</span></div><div class="line">				L-&gt;r[j+increment]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/*  插入 */</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"	第%d趟排序结果: "</span>,++k);</div><div class="line">		print(*L);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(increment&gt;<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，增量序列的最后一个增量值必须等于1才行。</p>
<p>通过这段代码的剖析，能看到希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。<br>这里的增量的选取就非常关键了，这里用increment=increment/3+1的方式选取增量的。<br>可究竟应该选取什么样的增量才是最好，目前还是一个数学难题，迄今为止还没有人找到一种最好的增量序列。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><img src="/images/it_algorithm_sortshaker3.png" alt="UML图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="comment">//int[] data = &#123;9,2,5,15,66,4,37,3,7,55,8,0,6,21&#125;;</span></div><div class="line">     <span class="keyword">int</span>[] data = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">66</span>&#125;;</div><div class="line">     <span class="keyword">int</span> length = data.length;</div><div class="line">     System.out.print(<span class="string">"排序前："</span>);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">         System.out.print(data[i]+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     System.out.println();</div><div class="line"></div><div class="line">     shellSort(data,length);</div><div class="line">     System.out.print(<span class="string">"排序后："</span>);</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</div><div class="line">         System.out.print(data[i]+<span class="string">" "</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">     <span class="keyword">int</span> temp;            <span class="comment">// 临时变量</span></div><div class="line">     <span class="keyword">int</span> pointer;         <span class="comment">// 进行比较的下表位置</span></div><div class="line">     <span class="keyword">int</span> len = index / <span class="number">2</span>; <span class="comment">// 设置步长增量，分割集合的间隔长度，初始值为数组长度的一半</span></div><div class="line">     <span class="keyword">while</span> (len != <span class="number">0</span>)&#123; <span class="comment">// 1.按每次减半划分步长，直到步长为1</span></div><div class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;index;i++)&#123;  <span class="comment">// 2.对各个集合进行处理（根据步长，设置每轮循环次数）</span></div><div class="line">             pointer = i-len; <span class="comment">// 计算要和当前值进行比较的数的位置</span></div><div class="line">             temp = arr[i];</div><div class="line">             <span class="keyword">while</span>(temp &lt; arr[pointer])&#123; <span class="comment">// 3.将临时变量与集合内的数进行比较（按照步长距离，将临时变量里的值和集合内数值依次进行比较）</span></div><div class="line">                 arr[pointer+len] = arr[pointer];</div><div class="line">                 pointer = pointer - len;</div><div class="line">                 <span class="keyword">if</span>(pointer &lt; <span class="number">0</span>)&#123;  <span class="comment">// 如果当前下标位置大于或等于当前步长则继续循环，按步长与前面所有的数进行比较，直到遇到比当前临时变量小的数为止</span></div><div class="line">                     <span class="keyword">break</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             arr[pointer + len] = temp;<span class="comment">// 把临时变量赋值到当前下标所在位置</span></div><div class="line">         &#125;</div><div class="line">         len = len/<span class="number">2</span>;<span class="comment">//每次递减一半</span></div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h1 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h1><p><a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="external">百度百科-希尔排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortshell2.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：鸡尾酒排序</title>
    <link href="https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShaker/"/>
    <id>https://hengxing0080.github.io/2017/07/22/it/Algorithm/SortShaker/</id>
    <published>2017-07-22T04:21:30.000Z</published>
    <updated>2017-07-30T06:16:47.322Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortshaker1.gif" alt="UML图"></p>
<a id="more"></a>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>这个算法有好多名称，以下就是收集的名称，这里用鸡尾酒排序来作为本篇文章的正统名称。<br>Shaker排序 (Shaker Sort)<br>鸡尾酒排序 (Cocktail Sort)<br>双向冒泡排序 (Bidirectional Bubble Sort)<br>波浪排序 (Ripple Sort)<br>摇曳排序 (Shuffle Sort)<br>飞梭排序 (Shuttle Sort)<br>欢乐时光排序 (Happy Hour Sort)</p>
<p>其实它是改良的冒泡排序的轻微变形。<br>不同的地方在于，鸡尾酒排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。<br>他可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。</p>
<p>以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。<br>但是在乱数序列状态下，鸡尾酒排序与冒泡排序的效率都很差劲，<br>优点只有原理简单这一点。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>1、 气泡排序的双向进行，先让气泡排序由左向右进行，再来让气泡排序由右往左进行，如此完成一次排序的动作<br>2、 使用left与right两个旗标来记录左右两端已排序的元素位置。</p>
<p>排序过程：<br>先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端<br>再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端<br>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O（n^2）</p>
<h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><h3 id="示例代码1（Java）"><a href="#示例代码1（Java）" class="headerlink" title="示例代码1（Java）"></a>示例代码1（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShakerSort</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, left = <span class="number">0</span>, </div><div class="line">               right = number.length - <span class="number">1</span>, </div><div class="line">               shift = <span class="number">0</span>; </div><div class="line"></div><div class="line">        <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">            <span class="comment">// 向右进行气泡排序 </span></div><div class="line">            <span class="keyword">for</span>(i = left; i &lt; right; i++) &#123; </div><div class="line">                <span class="keyword">if</span>(number[i] &gt; number[i+<span class="number">1</span>]) &#123; </div><div class="line">                    swap(number, i, i+<span class="number">1</span>); </div><div class="line">                    shift = i; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            right = shift; </div><div class="line"></div><div class="line">            <span class="comment">// 向左进行气泡排序 </span></div><div class="line">            <span class="keyword">for</span>(i = right; i &gt; left; i--) &#123; </div><div class="line">                <span class="keyword">if</span>(number[i] &lt; number[i-<span class="number">1</span>]) &#123; </div><div class="line">                    swap(number, i ,i-<span class="number">1</span>); </div><div class="line">                    shift = i; </div><div class="line">                &#125; </div><div class="line">            &#125; </div><div class="line">            left = shift; </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t; </div><div class="line">        t = number[i]; </div><div class="line">        number[i] = number[j]; </div><div class="line">        number[j] = t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码2（JavaScript）"><a href="#示例代码2（JavaScript）" class="headerlink" title="示例代码2（JavaScript）"></a>示例代码2（JavaScript）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shakerSort</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> length = array.length,</div><div class="line">        left = <span class="number">0</span>,</div><div class="line">        right = length - <span class="number">1</span>,</div><div class="line">        lastSwappedLeft = left,</div><div class="line">        lastSwappedRight = right,</div><div class="line">        i,</div><div class="line">        j;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">        <span class="comment">// 从左到右</span></div><div class="line">        lastSwappedRight = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</div><div class="line">                swap(array, i, i + <span class="number">1</span>);</div><div class="line">                lastSwappedRight = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        right = lastSwappedRight;</div><div class="line">        <span class="comment">// 从右到左</span></div><div class="line">        lastSwappedLeft = length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (j = right; left &lt; j; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</div><div class="line">                swap(array, j - <span class="number">1</span>, j)</div><div class="line">                lastSwappedLeft = j</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        left = lastSwappedLeft;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码3（C）"><a href="#示例代码3（C）" class="headerlink" title="示例代码3（C）"></a>示例代码3（C）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAP(x,y) &#123;int t; t = x; x = y; y = t;&#125; </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shakersort</span><span class="params">(<span class="keyword">int</span>[])</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> number[MAX] = &#123;<span class="number">0</span>&#125;; </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line"></div><div class="line">    srand(time(<span class="literal">NULL</span>)); </div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"排序前："</span>); </div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) &#123; </div><div class="line">        number[i] = rand() % <span class="number">100</span>; </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    shakersort(number); </div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shakersort</span><span class="params">(<span class="keyword">int</span> number[])</span> </span>&#123; </div><div class="line">    <span class="keyword">int</span> i, left = <span class="number">0</span>, right = MAX - <span class="number">1</span>, shift = <span class="number">0</span>; </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(left &lt; right) &#123; </div><div class="line">        <span class="comment">// 向右进行气泡排序 </span></div><div class="line">        <span class="keyword">for</span>(i = left; i &lt; right; i++) &#123; </div><div class="line">            <span class="keyword">if</span>(number[i] &gt; number[i+<span class="number">1</span>]) &#123; </div><div class="line">                SWAP(number[i], number[i+<span class="number">1</span>]); </div><div class="line">                shift = i; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        right = shift; </div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n往右排序："</span>); </div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line"></div><div class="line">        <span class="comment">// 向左进行气泡排序 </span></div><div class="line">        <span class="keyword">for</span>(i = right; i &gt; left; i--) &#123; </div><div class="line">            <span class="keyword">if</span>(number[i] &lt; number[i<span class="number">-1</span>]) &#123; </div><div class="line">                SWAP(number[i], number[i<span class="number">-1</span>]); </div><div class="line">                shift = i; </div><div class="line">            &#125; </div><div class="line">        &#125; </div><div class="line">        left = shift; </div><div class="line"></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n向左排序："</span>); </div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++) </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, number[i]); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考推荐"><a href="#参考推荐" class="headerlink" title="参考推荐"></a>参考推荐</h2><p><a href="http://blog.csdn.net/xushuaic/article/details/8615253" target="_blank" rel="external">算法 Shaker排序法 - 改良的气泡排序</a><br><a href="https://www.kancloud.cn/kancloud/sort-algorithm/46565" target="_blank" rel="external">鸡尾酒排序 (Cocktail Sort/Shaker Sort)</a><br><a href="http://blog.csdn.net/vivitue/article/details/38716575" target="_blank" rel="external">算法之路 - 双向冒泡排序之Shaker</a><br><a href="http://www.cnblogs.com/wuweiblog/archive/2011/07/11/2103325.html" target="_blank" rel="external">冒泡排序与鸡尾酒排序</a><br><a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Shaker/Shaker.php" target="_blank" rel="external">[演算法] 搖晃排序法(Shaker Sort)</a><br><a href="https://www.codingunit.com/cocktail-sort-algorithm-or-shaker-sort-algorithm" target="_blank" rel="external">Cocktail Sort Algorithm or Shaker Sort Algorithm</a><br><a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" target="_blank" rel="external">SORTING ALGORITHMS: THE COCKTAIL SORT</a><br><a href="http://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科-鸡尾酒排序</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortshaker1.gif&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 排序系列：插入排序</title>
    <link href="https://hengxing0080.github.io/2017/07/21/it/Algorithm/SortInsert/"/>
    <id>https://hengxing0080.github.io/2017/07/21/it/Algorithm/SortInsert/</id>
    <published>2017-07-21T09:47:22.000Z</published>
    <updated>2017-07-21T10:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_sortInsert4.gif" alt="UML图"><br>过程类似插入扑克牌的过程（一边摸牌，一边理牌）<br><a id="more"></a></p>
<hr>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><hr>
<p>插入排序（Insertion Sorting）</p>
<p>简单定义就是直接插入排序过程需要将带插入的元素和当前有序序列中所有数据进行比较</p>
<p>每次将一个待排序的数据元素，按照其关键字大小插入到前面已排好序的有序序列的适当位置，使插入以后的数据序列仍然为一个有序序列，直到整个序列成为有序的序列为止。</p>
<p>它是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<hr>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><hr>
<p>从第一个元素开始，该元素可以认为已经被排序.<br>取出下一个元素，在已经排序的元素序列中从后向前扫描.<br>如果该元素（已排序）大于新元素，将该元素移到下一位置.<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置.<br>将新元素插入到该位置中.<br>重复步骤2.</p>
<p>下面是各种插入排序图示流程↓<br><img src="/images/it_algorithm_sortInsert1.gif" alt="UML图"><br><img src="/images/it_algorithm_sortInsert3.gif" alt="UML图"><br><img src="/images/it_algorithm_sortInsert2.gif" alt="UML图"></p>
<hr>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O（n^2）<br>不过能看出来，同样的复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。</p>
<h2 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h2><p>稳定</p>
<hr>
<h1 id="算法的2种分类"><a href="#算法的2种分类" class="headerlink" title="算法的2种分类"></a>算法的2种分类</h1><hr>
<blockquote>
<p>它有两个形式：直接插入排序，二分插入排序</p>
</blockquote>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>Straight Insertion Sort<br>基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表。<br><img src="/images/it_algorithm_sortInsert5.png" alt="UML图"></p>
<h3 id="示例代码-1（Java）"><a href="#示例代码-1（Java）" class="headerlink" title="示例代码 1（Java）"></a>示例代码 1（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">int</span> currentData = arr[i]; <span class="comment">// 用for循环在数组中提取数据并赋值给currentData</span></div><div class="line">        <span class="keyword">int</span> temp = i;</div><div class="line">        <span class="comment">// 用while循环盘点数组第一个元素是否大于取出的第二个元素，如果大于数组向右移动</span></div><div class="line">        <span class="keyword">while</span> ((temp &gt; <span class="number">0</span>) &amp;&amp; (arr[temp - <span class="number">1</span>] &gt; currentData)) &#123;  </div><div class="line">            arr[temp] = arr[temp - <span class="number">1</span>]; <span class="comment">// 实现了数组的向右移动</span></div><div class="line">            temp--; <span class="comment">// temp为0，while循环结束</span></div><div class="line">        &#125;</div><div class="line">        arr[temp] = currentData; <span class="comment">// 交换数据（将取出的第二个元素赋值给数组中第一个元素）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] data = &#123;<span class="number">23</span>, <span class="number">45</span>, <span class="number">16</span>, <span class="number">7</span>, <span class="number">42</span>&#125;; <span class="comment">// 定义无序数组data</span></div><div class="line">    insertSort(data);</div><div class="line">    <span class="comment">// 页面打印</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:data)&#123;</div><div class="line">        System.out.print(x+<span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="示例代码-2（C）"><a href="#示例代码-2（C）" class="headerlink" title="示例代码 2（C）"></a>示例代码 2（C）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10000  <span class="comment">/* 用于要排序数组个数最大值，可根据需要修改 */</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> r[MAXSIZE+<span class="number">1</span>];	<span class="comment">/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span></div><div class="line">	<span class="keyword">int</span> length;			<span class="comment">/* 用于记录顺序表的长度 */</span></div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">/* 对顺序表L作直接插入排序 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList *L)</span></span></div><div class="line">&#123; </div><div class="line">	<span class="keyword">int</span> i,j;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=L-&gt;length;i++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (L-&gt;r[i]&lt;L-&gt;r[i<span class="number">-1</span>]) <span class="comment">/* 需将L-&gt;r[i]插入有序子表 */</span></div><div class="line">		&#123;</div><div class="line">			L-&gt;r[<span class="number">0</span>]=L-&gt;r[i]; <span class="comment">/* 设置哨兵 */</span></div><div class="line">			<span class="keyword">for</span>(j=i<span class="number">-1</span>;L-&gt;r[j]&gt;L-&gt;r[<span class="number">0</span>];j--)</div><div class="line">				L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[j]; <span class="comment">/* 记录后移 */</span></div><div class="line">			L-&gt;r[j+<span class="number">1</span>]=L-&gt;r[<span class="number">0</span>]; <span class="comment">/* 插入到正确位置 */</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>又称 折半插入排序</p>
<p>折半插入排序算法是对直接插入排序算法的一种改进。<br>在直接插入排序算法中，向有序序列中插入一个元素1，插入位置是把待插入元素关键字与有序序列中元素的关键字逐个比较得到的。</p>
<p>它是将待插入数据与当前有序序列中的平分位置的关键字数据进行比较，从而确定了下一步要平分的子序列，以此类推直到找到合适的插入位置为止。<br><img src="/images/it_algorithm_sortInsert6.png" alt="UML图"></p>
<p>折半插入排序算法的基本思想是：<br>向有序序列中插入元素，那么插入位置可以不断地平分有序序列，并把带插入的元素的关键字与平分有序序列得到的关键字比较，以确定下一步要平分的子序列，直到找到合适的插入位置为止。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] data = &#123;<span class="number">7</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">1</span>&#125;;    <span class="comment">//排序后：1, 7, 16, 23, 42, 45</span></div><div class="line">    <span class="comment">//int[] data2 = &#123;7, 16, 23, 42, 45, 45&#125;;//排序后：7, 16, 23, 42, 45, 45</span></div><div class="line">    BInsertSort(data);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:data)&#123;</div><div class="line">        System.out.print(x+<span class="string">"  "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len = arr.length;  <span class="comment">// 获取数组长度</span></div><div class="line">    <span class="keyword">int</span> insertData = arr[len - <span class="number">1</span>]; <span class="comment">// 待插入元素</span></div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> hign = len - <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span> (low &lt;= hign) &#123;</div><div class="line">        <span class="keyword">int</span> middle = (low + hign) / <span class="number">2</span>; <span class="comment">// 获取数组中间元素下标</span></div><div class="line">        <span class="keyword">if</span>(insertData &lt; arr[middle])&#123;</div><div class="line">            hign = middle - <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            low = middle +<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = len - <span class="number">1</span>;j&gt;hign+<span class="number">1</span>;j--)&#123;</div><div class="line">        arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    arr[hign+<span class="number">1</span>] = insertData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_sortInsert4.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;过程类似插入扑克牌的过程（一边摸牌，一边理牌）&lt;br&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 排序" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：串</title>
    <link href="https://hengxing0080.github.io/2017/07/20/it/DataStructure/String/"/>
    <id>https://hengxing0080.github.io/2017/07/20/it/DataStructure/String/</id>
    <published>2017-07-20T11:31:51.000Z</published>
    <updated>2017-07-20T11:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_string0.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名 串/字符串<br>英文名 String</p>
<p>串是由零个或多个字符组成的有限序列，又名叫字符串。它也是一种数据结构。<br>（所谓的序列，说明串的相邻字符之间具有前驱和后继的关系）</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>&nbsp;<br>本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找，替换等操作。</p>
<p>一般记为s=”a1a2…….an”(n≥0)，其中s是串的名称，用双引号（有些书里是单引号）括起来的字符序列是串的值，注意单引号不属于串的内容。</p>
<h1 id="各种关键词"><a href="#各种关键词" class="headerlink" title="各种关键词"></a>各种关键词</h1><ul>
<li><p>空串：<br>零个字符串的串称为空串（null string），它的长度为零，可以直接用两双引号””表示，也可以用希腊字母Φ来表示。</p>
</li>
<li><p>空格串：<br>是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</p>
</li>
<li><p>子串与主串：<br>串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。<br>子串在主串中的位置就是子串的第一个字符在主串中的序号。<br>“over”,”end”,”lie”其实可以认为是”lover”,”friend”,”believe”这些单词字符串的子串</p>
</li>
</ul>
<h1 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h1><ul>
<li><p>比较两个串相等<br>必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等。<br>即给定两个串：s=”a1a2….an”, t=”b2b2….bm”, 当且仅当n=m, 且a1=b1,a2=b2,……,an=bm时，我们认为s=t.</p>
</li>
<li><p>比较两个串不相等<br>给定两个串：s=”a1a2……an”, t=”b2b2…..bm”, 当满足以下条件之一时，s&lt;t<br>1.n&lt;m，且a1=b1(i=1,2,…..,n) .<br>例如如s=”hap”,t=”happy”,就有s&lt;t。因此t比s多出了两个字母。<br>2.存在某个k≤min(m,n)，使得ai=bi (i=1,2,…..,k-1),ak&lt;bk .<br>例如当s=”happen”,t=”happy”,因为两串的前4个字母均相同，而两串第5个字母（k值），字母e的ASCII码是101，而字母y的ASCII码是121，显然e&lt;y,所以s&lt;t.</p>
</li>
<li><p>例子<br>纸质英语词典：通常都是上万个单词的有序排列。就大小而言，前面的单词比后面的要小，你在查找单词的过程，其实就是在比较字符串大小的过程。<br>电子词典：查找单词实现的原理，其实就是字符串这种数据结构的典型应用。</p>
</li>
</ul>
<hr>
<h1 id="串的存储结构（顺序和链式）"><a href="#串的存储结构（顺序和链式）" class="headerlink" title="串的存储结构（顺序和链式）"></a>串的存储结构（顺序和链式）</h1><hr>
<blockquote>
<p>串的存储结构与线性表相同，分为两种。</p>
</blockquote>
<h2 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h2><p>是用一组地址连续的存储单元来存储串中的字符序列的。<br>按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。<br>一般是定长数组来定义。</p>
<p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的0下标位置，有的书中也会定义存储在数组的最后一个下标位置。</p>
<p>但也有些编程语言不想这么干，觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如“\o”来表示串值的终结，这个时候，你要想知道此时的串长度，就需要遍历计算一下才知道了，其实这还是需要占用一个空间。</p>
<p><img src="/images/it_datastructure_string1.png" alt="UML图"></p>
<p>刚才讲的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接Concat、新串的插入Strlnsert、以及字符串的替换Replace，都有可能使得串序列的长度超过了数组的长度MaxSize。</p>
<p>也就是说，串的顺序存储结构的缺点是字符串的截断，截断就是超过预定义长度的串值被舍去。<br>于是对于串的顺序存储，有一些变化，串值的存储空间可在程序执行过程中动态分配而得。比如在计算机中存在一个自由存储区，叫做“堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理。</p>
<h2 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h2><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用’#”或其他串值字符补全，如图↓<br><img src="/images/it_datastructure_string2.png" alt="UML图"></p>
<p>当然，这里一个结点存多少字符才合适就变得很重要，这回直接影响着处理的效率，需要根据实际情况作出选择。</p>
<p>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_string0.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 算法：递归</title>
    <link href="https://hengxing0080.github.io/2017/07/19/it/Algorithm/Recursion/"/>
    <id>https://hengxing0080.github.io/2017/07/19/it/Algorithm/Recursion/</id>
    <published>2017-07-19T03:26:49.000Z</published>
    <updated>2017-07-19T10:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_recursion1.jpg" alt="UML图"></p>
<blockquote>
<p>递归属于<a href="http://www.hengxing.me/2017/07/18/it/DataStructure/Stack/" target="_blank" rel="external">栈</a>的经典应用方式之一。</p>
</blockquote>
<a id="more"></a>
<h1 id="递归的解释和定义"><a href="#递归的解释和定义" class="headerlink" title="递归的解释和定义"></a>递归的解释和定义</h1><p>&nbsp;<br>递归作为一种算法在程序设计语言中广泛应用。<br>是指函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象。<br>递归是计算机科学的一个重要概念，递归的方法是程序设计中有效的方法，采用递归编写程序能使程序变得简洁和清晰。</p>
<p>简单理解其实就是函数自己调用自己。<br>是指在定义自身的过程中又直接或间接调用自身的一种算法。</p>
<p>在高级语言中，调用自己和其他函数并没有本质的不同。<br>我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</p>
<p>递归算法所有解决的问题都是一个问题可以分割为使用相同算法结局的若干子问题。</p>
<h1 id="递归的特点"><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h1><p>&nbsp;<br>一个问题可以被分解成若按简单的子问题<br>子问题和其上层的解决方案一致<br>外层问题的解决依赖于子问题的解决</p>
<h1 id="递归的工作方式"><a href="#递归的工作方式" class="headerlink" title="递归的工作方式"></a>递归的工作方式</h1><p>&nbsp;<br>一个对象函数调用自己的复制品，复制品函数在执行的过程再次复制出一个复制品继续调用，一直继续下去，知道遇到某个条件停止循环递归调用，然后逐层返回，这个过程就是递归的工作方式。</p>
<h1 id="使用递归算法有2个要素注意"><a href="#使用递归算法有2个要素注意" class="headerlink" title="使用递归算法有2个要素注意"></a>使用递归算法有2个要素注意</h1><p>&nbsp;<br>1.至少有一个停止条件，不能无限递归下去，那就是死循环。<br>2.要计算递归方法的当前值，需要重复调用自身，直至达到停止条件。</p>
<h1 id="递归的视觉"><a href="#递归的视觉" class="headerlink" title="递归的视觉"></a>递归的视觉</h1><p>&nbsp;<br><a href="http://baike.baidu.com/link?url=i5jUc80R_n8xl63Hc8pMTNuRRyE_3VNEndFj-CqlT-LpFfRNK_RhLcZhTkhnx6cDYZPC-ORWKKi8aX1_s8uKw4iICH_WW13Kp8VQ7tLwsqCTM6mh6azLIZ9Cr-7WWSNuqV9TBTvaGAaYVq7sQj9EZ_" target="_blank" rel="external">德罗斯特效应</a>是递归的一种视觉形式，它能在视觉上描述递归算法。 效果类似如下↓<br><img src="/images/it_algorithm_recursion2.jpg" alt="UML图"><br>想看更多德罗斯特效应，请<a href="http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94" target="_blank" rel="external">搜索图片</a></p>
<hr>
<h1 id="递归示例1：兔子繁殖问题"><a href="#递归示例1：兔子繁殖问题" class="headerlink" title="递归示例1：兔子繁殖问题"></a>递归示例1：兔子繁殖问题</h1><hr>
<blockquote>
<p>兔子繁殖问题也称兔子数列，属于斐波那契数列，是个很经典的递归例子。</p>
</blockquote>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>先说下 斐波那契数列（Fibonacci）</p>
<p>用递归和非递归算法列出Fibonacci数列的前n项几乎是所有程序员都经历过的过程。</p>
<p>特点是数列中的每一项都是前两项的（最前两项都是1）和，即F（n）=F（n-1）+F（n-2）。</p>
<p>斐波那契数列又因意大利数学家列昂纳多·斐波那契（Fibonacci leonardo，约1170-1250）以兔子繁殖为例子而引入，故又称为“兔子数列”。<br>这个数列是意大利中世纪数学家斐波那契在&lt;算盘全书&gt;中提出的。</p>
<p>他在1202年提出了下面的问题描述如下：<br>兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。如果所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p>
<h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><p>我们不妨拿新出生的一对小兔子分析一下：</p>
<p>第一个月小兔子没有繁殖能力，所以还是一对<br>两个月后，生下一对小兔对数共有两对<br>三个月以后，老兔子又生下一对，因为小兔子还没有繁殖能力，所以一共是三对</p>
<p>依次类推可以列出下表：<br><img src="/images/it_algorithm_recursion3.jpg" alt="UML图"></p>
<p>幼仔对数=前月成兔对数<br>成兔对数=前月成兔对数+前月幼仔对数<br>总体对数=本月成兔对数+本月幼仔对数</p>
<p>如果1到12个月的个数，那么结果为<br>1　1　2　3　5　8　13　21　34　55　89　144</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">月份      不成熟兔子       成熟兔子        数量</div><div class="line">1         1                              1</div><div class="line">2                         1              1</div><div class="line">3         1               1              2</div><div class="line">4         1               2              3</div><div class="line">5         2               3              5  </div><div class="line">6         3               5              8</div><div class="line">7         5               8              13</div><div class="line">8         8               13             21    </div><div class="line">9         13              21             34</div><div class="line">10        21              34             55</div><div class="line">11        34              55             89</div><div class="line">12        55              89             144</div></pre></td></tr></table></figure>
<p>可以看出幼仔对数、成兔对数、总体对数都构成了一个数列。</p>
<p>这个数列有关十分明显的特点，那是：前面相邻两项之和，构成了后一项。</p>
<h2 id="图示效果"><a href="#图示效果" class="headerlink" title="图示效果"></a>图示效果</h2><p><img src="/images/it_algorithm_recursion4.png" alt="UML图"><br><img src="/images/it_algorithm_recursion5.png" alt="UML图"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 迭代方式（For循环）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</div><div class="line">            res = x + y;</div><div class="line">            x = y;</div><div class="line">            y = res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 递归方式</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fRecur</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n== <span class="number">1</span> || n == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> fRecur(n-<span class="number">2</span>)+fRecur(n-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(fFor(<span class="number">6</span>));</div><div class="line">        System.out.println(fRecur(<span class="number">6</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123; </div><div class="line">            System.out.println(fRecur(i)+<span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">迭代和递归的区别是：</div><div class="line">迭代使用的是循环结构，递归使用的是选择结构。</div><div class="line">但是大量的递归调用会简历函数的副本，会耗费大量的时间和内存。</div><div class="line">迭代则不需要反复调用函数和占用额外的内存。</div><div class="line">因此应该视不同情况选择不同的代码实现方式。</div><div class="line">*/</div></pre></td></tr></table></figure>
<hr>
<h1 id="递归示例2：猴子吃桃问题"><a href="#递归示例2：猴子吃桃问题" class="headerlink" title="递归示例2：猴子吃桃问题"></a>递归示例2：猴子吃桃问题</h1><hr>
<p>猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。<br>第二天早上又将剩下的桃子吃掉一半，又多吃了一个。<br>以后每天早上都吃了前一天剩下的一半零一个。<br>到第10天早上想再吃时，见只剩下一个桃子了。<br>求第一天共摘了多少？或者说第1天到10天每天桃子的数量是多少？</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>第10天~第1天的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1       // 第10天：因为上面说了第10天就剩1个了</div><div class="line">4       // 第9天：1*2+1=3+1=4</div><div class="line">10      // 第8天：4*2+1=9+1=10</div><div class="line">22      // 第7天：10*2+1=21+1=22</div><div class="line">46      // 第6天：22*2+1=45+1=46</div><div class="line">94      // 第5天：46*2+1=93+1=94</div><div class="line">190     // 第4天：94*2+1=189+1=190</div><div class="line">382     // 第3天：190*2+1=381+1=382</div><div class="line">766     // 第2天：382*2+1=765+1=766</div><div class="line">1534    // 第1天：766*2+1=1533+1=1534</div></pre></td></tr></table></figure>
<h2 id="示例代码1（迭代算法）"><a href="#示例代码1（迭代算法）" class="headerlink" title="示例代码1（迭代算法）"></a>示例代码1（迭代算法）</h2><p>当然，do while和if都是类似的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> day=<span class="number">10</span>,x1=<span class="number">0</span>,x2=<span class="number">1</span>,eatNum;</div><div class="line">    <span class="keyword">for</span>(;day&gt;<span class="number">0</span>;day--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(day==<span class="number">10</span>)&#123;</div><div class="line">           x1 = <span class="number">1</span>;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"猴子在第 %d 天有 %d 个桃子。\n"</span>,day, x1);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">           x1=(x2+<span class="number">1</span>)*<span class="number">2</span>;  <span class="comment">// 每前一天的桃子数都等一现在剩余的桃子数加一在乘以二  </span></div><div class="line">           x2=x1;</div><div class="line">           eatNum = x1/<span class="number">2</span>+<span class="number">1</span>;</div><div class="line">           <span class="built_in">printf</span>(<span class="string">"猴子在第 %d 天有 %d 个桃子，当天吃了 %d 个桃子。\n"</span>,day,x1, eatNum);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果<br><img src="/images/it_algorithm_recursion6.jpg" alt="UML图"></p>
<h2 id="示例代码2-1（递归算法：C）"><a href="#示例代码2-1（递归算法：C）" class="headerlink" title="示例代码2.1（递归算法：C）"></a>示例代码2.1（递归算法：C）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">if</span> (d == <span class="number">10</span>)        </div><div class="line">        sum = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(d&lt;<span class="number">10</span>)   </div><div class="line">        sum = <span class="number">2</span> * (num(d + <span class="number">1</span>) + <span class="number">1</span>);  </div><div class="line">    <span class="keyword">return</span> sum;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">main() &#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> day = <span class="number">10</span>;</div><div class="line">    <span class="keyword">while</span>(day&gt;<span class="number">0</span>)&#123;</div><div class="line">         sum = num(day);  </div><div class="line">         day--;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"猴子一共摘了 %d 个桃子。\n"</span>, sum);  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="示例代码2-2（递归算法：Java）"><a href="#示例代码2-2（递归算法：Java）" class="headerlink" title="示例代码2.2（递归算法：Java）"></a>示例代码2.2（递归算法：Java）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> day = <span class="number">10</span>;</div><div class="line">        <span class="keyword">while</span>(day &gt; <span class="number">0</span>)&#123;</div><div class="line">            System.out.println(<span class="string">"猴子第"</span>+day+<span class="string">"天的桃子数量："</span>+getTotalNum(day));</div><div class="line">            day--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">10</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (getTotalNum(n + <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_recursion1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归属于&lt;a href=&quot;http://www.hengxing.me/2017/07/18/it/DataStructure/Stack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;栈&lt;/a&gt;的经典应用方式之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 算法 - 各种" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95-%E5%90%84%E7%A7%8D/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：栈和队列的总结</title>
    <link href="https://hengxing0080.github.io/2017/07/18/it/DataStructure/StackAndQueue/"/>
    <id>https://hengxing0080.github.io/2017/07/18/it/DataStructure/StackAndQueue/</id>
    <published>2017-07-18T12:50:39.000Z</published>
    <updated>2017-07-18T12:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_stackandqueue1.png" alt="UML图"></p>
<a id="more"></a>
<p>1.它们都是特殊的线性表，只不过对插入和删除操作做了限制：<br>栈：限定仅在表尾进行插入和删除操作的线性表。<br>队列：只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>2.栈和队列的顺序存储结构：<br>它们都可以用线性表的顺序存储结构实现，但都存在着顺序存储的一些弊端，因此它们各自有一些技巧解决这个问题。<br>对于栈来说，如果两个相同数据类型的栈，则可以用数组的两端作栈底的方法让两个栈共享数据，最大化利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，引入循环队列，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p>
<p>3.栈和队列的链式存储结构：<br>栈和队列的链式存储结构的实现原理和线性表的实现原理基本上相同。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_stackandqueue1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法 —— 线性表：栈</title>
    <link href="https://hengxing0080.github.io/2017/07/18/it/DataStructure/Stack/"/>
    <id>https://hengxing0080.github.io/2017/07/18/it/DataStructure/Stack/</id>
    <published>2017-07-18T09:28:23.000Z</published>
    <updated>2017-07-18T12:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_datastructure_stack1.png" alt="UML图"></p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;<br>中文名 栈<br>英文名 Stack<br>又名   堆栈</p>
<h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><p>&nbsp;<br>栈是限定仅在表尾进行插入和删除操作的线性表</p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>&nbsp;<br>它是一种运算受限的线性表。<br>其限制是仅允许在表的一端进行插入和删除运算。<br>访问栈中的元素时，遵守后进先出的运算规则。<br>因此，栈也成为后进先出表（Last In First Out的线性表），简称LIFO。</p>
<p>它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。<br>这也就使得：栈底是固定的，最先进栈的只能在栈底。<br><img src="/images/it_datastructure_stack2.png" alt="UML图"></p>
<h1 id="情景比喻"><a href="#情景比喻" class="headerlink" title="情景比喻"></a>情景比喻</h1><p>&nbsp;<br>中文解释是存储货物或供旅客住宿的房屋。</p>
<p>如同一个杯子，水桶。<br>水桶相当于栈，往水桶里倒水就是进栈，相反，把水桶里的水导出来就是出栈。<br>水桶的底部就是栈底，水桶的顶部就是栈顶。<br>由于后进先出规则，先导入水桶的水当我们倒出的时间肯定是最后才倒出来。</p>
<h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><p>&nbsp;<br>空栈：不包含任何数据元素的栈称为空栈。　<br>栈顶和栈底：我们把允许插入和删除的一段称为栈顶（top），另一端称为栈底（botton）<br>栈顶元素和栈底元素：存储在栈底位置的数据元素称为栈底元素，反之，在栈顶的叫栈顶元素。<br>进栈入栈/压栈：push（压），插入的操作，类似子弹压入（入弹夹）<br>出栈/退栈：pop（弹），删除的操作，类似弹夹的子弹弹出（出夹）</p>
<h1 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h1><p>&nbsp;<br>由于栈本身就是一个线性表，那么线性表的顺序存储和链式存储，对于栈也是同样适用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ADT 栈(stack)  </div><div class="line">Data  </div><div class="line">    同线性表。元素具有相同的类型，相邻元素具有前驱和后堆关系。  </div><div class="line">Operation  </div><div class="line">    InitStack ( *S )：初始化操作.建立一个空栈S。  </div><div class="line">    DestroyStack ( *S )：若栈存在，則销毁它。  </div><div class="line">    ClearStack (*S)：将栈清空。  </div><div class="line">    StackEmpty ( S ):若栈为空，返回true,否則返回 false。  </div><div class="line">    GetTop (S,*e)：若栈存在且非空，用e返回S的栈顶元素。  </div><div class="line">    Push (*S,e)：若栈S存在，插入新元素e到栈S中并成为栈頂元素。  </div><div class="line">    Pop (*S,*e)：删除栈S中栈顶元素，并用e返回其值。  </div><div class="line">    StackLength (S)：返回回栈S的元素个数。  </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h1 id="栈的两种存储方式"><a href="#栈的两种存储方式" class="headerlink" title="栈的两种存储方式"></a>栈的两种存储方式</h1><p>&nbsp;<br>栈的种类分为顺序栈和链栈</p>
<hr>
<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><hr>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>栈的顺序存储结构简称顺序栈。<br>顺序栈用一组连续的存储单元依次存放从栈底到栈顶的数据元素。同时用一个指针top指示栈顶元素在顺序栈中的位置。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.数据元素存放在连续的存储地址中。<br>2.栈底位置固定不变。<br>3.栈顶位置随进栈，出栈操作而变化。 </p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>很方便，因为它只准栈顶进出元素，所以不存在线性表插入和删除时移动元素的问题。</p>
<h3 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h3><p>必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。</p>
<h3 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h3><p>空栈：top == -1<br>满栈：top == MAXSIZE -1</p>
<h3 id="栈的结构定义"><a href="#栈的结构定义" class="headerlink" title="栈的结构定义"></a>栈的结构定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType; <span class="comment">/* SElemType类型根据实际情况而定，这里假设为int */</span></div><div class="line"></div><div class="line"><span class="comment">/* 顺序栈结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">        SElemType data[MAXSIZE];</div><div class="line">        <span class="keyword">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></div><div class="line">&#125;SqStack;</div></pre></td></tr></table></figure>
<p>若现在有一个栈，StackSize是5，则栈普通情况，空栈和栈满的情况示意图</p>
<p><img src="/images/it_datastructure_stack3.png" alt="UML图"></p>
<h3 id="进出栈操作"><a href="#进出栈操作" class="headerlink" title="进出栈操作"></a>进出栈操作</h3><p>两者没有涉及任何循环语句，因此时间复杂度是O(1)<br>进栈图示<br><img src="/images/it_datastructure_stack4.png" alt="UML图"></p>
<p>进栈代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *S,SElemType e)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>) <span class="comment">/* 栈满 */</span></div><div class="line">        &#123;</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        &#125;</div><div class="line">        S-&gt;top++;		   <span class="comment">/* 栈顶指针增加一 */</span></div><div class="line">        S-&gt;data[S-&gt;top]=e; <span class="comment">/* 将新插入元素赋值给栈顶空间 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出栈代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *S,SElemType *e)</span></span></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        *e=S-&gt;data[S-&gt;top];	<span class="comment">/* 将要删除的栈顶元素赋值给e */</span></div><div class="line">        S-&gt;top--;			<span class="comment">/* 栈顶指针减一 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>对于与一个栈，我们也只能尽量考虑周全，设计出合适大小的数组来处理，但对于与两个相同类似的栈，我们可以做到最大限度的利用其事先开辟的存储空间来进行操作。</p>
<p>比如数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标0处，另一个栈为栈的末端，即下标为数组长度n-1处。<br>这样，两个栈如果增加元素，就是两端点向中间延伸.</p>
<p>关键思路：它们是数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈可以一直使用。</p>
<p>这里可以分析出来<br>栈1为空时：top1 == -1<br>栈2为空时：top2 == n<br>栈满情况1：若栈2是空栈，栈1的top1 == n -1，就是栈1满了<br>栈满情况2：反之，栈1为空栈时，top2 == 0，为栈2满<br>栈满情况3：两个栈见面之时，就是指针之间相差1时，即top1+1 == top2为栈满</p>
<h4 id="两栈共享空间的结构"><a href="#两栈共享空间的结构" class="headerlink" title="两栈共享空间的结构"></a>两栈共享空间的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 两栈共享空间结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></div><div class="line">&#123;</div><div class="line">        SElemType data[MAXSIZE];</div><div class="line">        <span class="keyword">int</span> top1;	<span class="comment">/* 栈1栈顶指针 */</span></div><div class="line">        <span class="keyword">int</span> top2;	<span class="comment">/* 栈2栈顶指针 */</span></div><div class="line">&#125;SqDoubleStack;</div></pre></td></tr></table></figure>
<h4 id="两栈共享空间的push方法"><a href="#两栈共享空间的push方法" class="headerlink" title="两栈共享空间的push方法"></a>两栈共享空间的push方法</h4><p>除了要插入元素值参数外，还需要有一个判断是栈1还是栈2的栈号参数stackNumber</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="keyword">int</span> stackNumber)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (S-&gt;top1+<span class="number">1</span>==S-&gt;top2)	<span class="comment">/* 栈已满，不能再push新元素了 */</span></div><div class="line">                <span class="keyword">return</span> ERROR;	</div><div class="line">        <span class="keyword">if</span> (stackNumber==<span class="number">1</span>)			<span class="comment">/* 栈1有元素进栈 */</span></div><div class="line">                S-&gt;data[++S-&gt;top1]=e; <span class="comment">/* 若是栈1则先top1+1后给数组元素赋值。 */</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)	<span class="comment">/* 栈2有元素进栈 */</span></div><div class="line">                S-&gt;data[--S-&gt;top2]=e; <span class="comment">/* 若是栈2则先top2-1后给数组元素赋值。 */</span></div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为在开始已经判断了是否有栈满的情况，所以后面的top1+1或top2-1是不用担心溢出问题的</p>
<h4 id="两栈共享空间的pop方法"><a href="#两栈共享空间的pop方法" class="headerlink" title="两栈共享空间的pop方法"></a>两栈共享空间的pop方法</h4><p>参数就只是判断栈1栈2的参数stackNumber</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="keyword">int</span> stackNumber)</span></span></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span> (stackNumber==<span class="number">1</span>) </div><div class="line">        &#123;</div><div class="line">                <span class="keyword">if</span> (S-&gt;top1==<span class="number">-1</span>) </div><div class="line">                        <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈1已经是空栈，溢出 */</span></div><div class="line">                *e=S-&gt;data[S-&gt;top1--]; <span class="comment">/* 将栈1的栈顶元素出栈 */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber==<span class="number">2</span>)</div><div class="line">        &#123; </div><div class="line">                <span class="keyword">if</span> (S-&gt;top2==MAXSIZE) </div><div class="line">                        <span class="keyword">return</span> ERROR; <span class="comment">/* 说明栈2已经是空栈，溢出 */</span></div><div class="line">                *e=S-&gt;data[S-&gt;top2++]; <span class="comment">/* 将栈2的栈顶元素出栈 */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是针对两个具有数据类型的栈的一个设计上的技巧，如果是不同数据类型的栈，这种办法不但不能更好处理问题，反而使问题变得更复杂，所以要注意这个前提。</p>
<hr>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><hr>
<p>栈的链式存储结构</p>
<p><img src="/images/it_datastructure_stack5.png" alt="UML图"></p>
<h3 id="链栈的栈满"><a href="#链栈的栈满" class="headerlink" title="链栈的栈满"></a>链栈的栈满</h3><p>不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统面临死机崩溃的情况，而不是这个链栈是否溢出的问题。</p>
<h3 id="链栈的空栈"><a href="#链栈的空栈" class="headerlink" title="链栈的空栈"></a>链栈的空栈</h3><p>因链表定义是头指针指向空，那么链栈的空其实就是top=NULL </p>
<h3 id="链栈的结构代码"><a href="#链栈的结构代码" class="headerlink" title="链栈的结构代码"></a>链栈的结构代码</h3><p>链栈的操作绝大部分和单链表类似，只是在插入和删除上特殊一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 链栈结构 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></div><div class="line">&#123;</div><div class="line">        SElemType data;</div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></div><div class="line">&#125;StackNode,*LinkStackPtr;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line">&#123;</div><div class="line">        LinkStackPtr top;</div><div class="line">        <span class="keyword">int</span> count;</div><div class="line">&#125;LinkStack;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">visit</span><span class="params">(SElemType c)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,c);</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链栈的进栈操作"><a href="#链栈的进栈操作" class="headerlink" title="链栈的进栈操作"></a>链栈的进栈操作</h3><p>假设元素值为e的新结点是s，top为栈顶指针。<br>图示↓<br><img src="/images/it_datastructure_stack6.png" alt="UML图"></p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 插入元素e为新的栈顶元素 */</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span></div><div class="line">&#123;</div><div class="line">        LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode)); </div><div class="line">        s-&gt;data=e; </div><div class="line">        s-&gt;next=S-&gt;top;	<span class="comment">/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */</span></div><div class="line">        S-&gt;top=s;         <span class="comment">/* 将新的结点s赋值给栈顶指针，见图中② */</span></div><div class="line">        S-&gt;count++;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="链栈的出栈操作"><a href="#链栈的出栈操作" class="headerlink" title="链栈的出栈操作"></a>链栈的出栈操作</h3><p>假设变量p用来存储要删除的栈顶节点，将栈顶指针下移一位，最后释放p即可。<br>图示↓<br><img src="/images/it_datastructure_stack7.png" alt="UML图"></p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span></div><div class="line">&#123; </div><div class="line">        LinkStackPtr p;</div><div class="line">        <span class="keyword">if</span>(StackEmpty(*S))</div><div class="line">                <span class="keyword">return</span> ERROR;</div><div class="line">        *e=S-&gt;top-&gt;data;</div><div class="line">        p=S-&gt;top;	      <span class="comment">/* 将栈顶结点赋值给p，见图中③ */</span></div><div class="line">        S-&gt;top=S-&gt;top-&gt;next;  <span class="comment">/* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span></div><div class="line">        <span class="built_in">free</span>(p);              <span class="comment">/* 释放结点p */</span>        </div><div class="line">        S-&gt;count--;</div><div class="line">        <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="顺序栈与链栈的对比"><a href="#顺序栈与链栈的对比" class="headerlink" title="顺序栈与链栈的对比"></a>顺序栈与链栈的对比</h3><p>进出栈都很简单，没有任何循环操作，时间复杂度均为0(1)<br>对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。<br>所以他没的区别和线性表讨论的一样，如果栈的使用过程元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果变化在可控范围内，建议使用顺序栈会更好一些。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_datastructure_stack1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 数据结构与算法 - 数据结构 - 线性表" scheme="https://hengxing0080.github.io/categories/IT-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法" scheme="https://hengxing0080.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
