<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恒星的轨迹</title>
  <subtitle>时间在流逝...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hengxing0080.github.io/"/>
  <updated>2017-11-10T10:06:54.143Z</updated>
  <id>https://hengxing0080.github.io/</id>
  
  <author>
    <name>恒星</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android —— 异步任务机制 &amp; 消息通知机制</title>
    <link href="https://hengxing0080.github.io/2017/10/09/it/1.Android/Handler/"/>
    <id>https://hengxing0080.github.io/2017/10/09/it/1.Android/Handler/</id>
    <published>2017-10-09T10:08:33.000Z</published>
    <updated>2017-11-10T10:06:54.143Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_handler_logo.gif" alt="UML图"><br><a id="more"></a></p>
<p>在Android中实现异步任务机制有两种方式：Handler和AsyncTask</p>
<p>Handler模式需要为每一个任务创建一个新的线程，任务完成后通过Handler实例向UI线程发送消息，完成界面的更新，这种方式对于整个过程的控制比较精细，但也是有缺点的，例如代码相对臃肿，在多个任务同时执行时，不易对线程进行精确的控制。</p>
<p>AsyncTask任务由计算运行在后台线程上，其结果发表在UI线程上。<br>它有三种参数类型：Params, Progress and Result 和四个步骤：onPreExecute, doInBackground, onProgressUpdate 和 onPostExecute。</p>
<hr>
<h1 id="Handler消息处理模型"><a href="#Handler消息处理模型" class="headerlink" title="Handler消息处理模型"></a>Handler消息处理模型</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主线程和子线程的各种名称：<br>主线程/UI线程/UI Thread/Main Thread/Activity Thread/Single Thread<br>子线程/工作线程/工作者线程/异步线程/Work Thread</p>
<p>主线程简介：<br>它管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)<br>并根据AMS的要求（通过IApplicationThread接口，AMS为Client、ActivityThread.ApplicationThread为Server）负责调度和执行activities、broadcasts和其它操作。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前提知识：<br>所有使用UI界面的操作系统，后台都在运行着一个死循环。<br>它在不停地监听和接收用户发出的指令，一旦接收到指令就马上执行。</p>
<p>当前应用程序一启动的时候，系统就会给应用程序提供Looper(轮询器)。<br>子线程在需要修改UI界面的时候，给handler发送一个消息（Message），handler接收到消息后会把消息放到Looper内部维护的消息队列中，Looper内部维护的死循环会不停的从消息队列中取消息，一旦取到消息就会发送给handler，然后handler再去修改UI界面。</p>
<p>Handler是android给我们提供用来更新UI的一套机制，也是一套消息处理的机制，我们可以通过它发送消息，也可以通过它处理消息。</p>
<p>Android在设计的时候，就封装了一套创建，传递，处理机制，如果不遵循这样的机制的话就没有办法更新UI信息的，就会抛出异常信息。</p>
<p>当应用程序启动时，android首先会开启一个主线程（UI线程），主线程为管理界面中的UI控件，进行事件分发。<br>如果此时需要一个耗时的操作，例如：联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象，如果5秒钟还没有完成的话，会收到Android系统的一个错误提示“强制关闭”</p>
<p>只有创建视图（创建UI界面的那个线程）的那个线程才能修改视图。<br>只有主线程（UI线程）才能修改UI界面。<br>子线程不能直接修改UI界面，所以有了Handler消息处理机制。</p>
<h2 id="消息模型图示"><a href="#消息模型图示" class="headerlink" title="消息模型图示"></a>消息模型图示</h2><p><img src="/images/it_android_handler.jpg" alt="UML图"></p>
<h2 id="消息模型组成"><a href="#消息模型组成" class="headerlink" title="消息模型组成"></a>消息模型组成</h2><p>1.Handler<br>消息处理器(运行在主线程, 生成，发送，处理消息)<br>常用方法:<br>handleMessage(Message)<br>覆盖此方法，做UI的处理消息结果( 运行在主线程里, 去更新UI)</p>
<p>2.Message 和 Message Queue<br>Message：消息(数据载体)<br>Message Queue：存储消息的队列(FIFO)，容器，单链表，会按时间排序，它被封装到Looper里面。</p>
<p>4.Looper<br>信息的轮询器，轮询取消息，linux底层管道通讯<br>运行在主线程（主线程一启动就有默认的Looper，如果在子线程肯定没有轮询器，得需要额外new）<br>用来轮询MessageQueue，调用Message中的数据<br>里面写死循环<br>它有start方法，开始轮询</p>
<p>细节:<br>在主线程new handler，就自动有了轮询器和消息队列<br>在子线程new handler，就得手动new轮询器</p>
<p>总结：<br>handler负责发送消息<br>MessageQueue就是一个存储消息的容器<br>Looper负责接收handler发送的消息，并直接将消息回传给Handler自己</p>
<p>他们三者的关系是：<br>MessageQueue和Looper是一一对应的<br>一个Looper可以对应多个Handler<br>同时这里还有一个角色就是线程Thread.当然Thread和Looper的关系也是一一对应的。</p>
<p>他们三者配合的最大好处：<br>Looper Handler Message 基本上可以应付多线程编程</p>
<h2 id="消息模型目地"><a href="#消息模型目地" class="headerlink" title="消息模型目地"></a>消息模型目地</h2><p>负责Android系统的主线程安全，别的线程不可以修改ui线程的界面。<br>如果子线程里面想去更新ui，必须采用消息机制处理子线程更新ui的步骤  </p>
<h2 id="子线程更新UI的几种方式"><a href="#子线程更新UI的几种方式" class="headerlink" title="子线程更新UI的几种方式"></a>子线程更新UI的几种方式</h2><p>–不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的</p>
<p>1.消息机制(Handler)<br>（1）.Handler.post(Runnable r), Handler.postAtTime(Runnable, long), Handler.postDelayed(Runnable, long)<br>（2）.handler.sendMessage(Meaaage msg) </p>
<p>2: Activity的runOnUiThread方法  </p>
<p>3.View<br>View.post(Runnable)<br>View.postDelayed(Runnable, long)</p>
<h2 id="自定义子线程更新UI"><a href="#自定义子线程更新UI" class="headerlink" title="自定义子线程更新UI"></a>自定义子线程更新UI</h2><p><a href="http://blog.csdn.net/jiangwei0910410003/article/details/17021809" target="_blank" rel="external">http://blog.csdn.net/jiangwei0910410003/article/details/17021809</a></p>
<h3 id="使用Handle的sendMessage修改UI界面"><a href="#使用Handle的sendMessage修改UI界面" class="headerlink" title="使用Handle的sendMessage修改UI界面"></a>使用Handle的sendMessage修改UI界面</h3><p>步骤：<br>1.在主线程里面声明handler，并重写handler的方法处理消息<br>private Handler handler = new Handler(){} ;<br>    public void handleMessage(Message msg) {<br>        // 运行在主线程，更新ui</p>
<pre><code>};
</code></pre><p>2.子线程想去更新ui，利用消息机制,系统内部有消息队列和looper，轮询到消息，交给handler去处理<br>Message msg = new Message();<br>msg.what 消息类型<br>msg.obj 具体消息携带的数据<br>handler.sendMessage(msg); // 给主线程发送一个消息，表示我要修改UI界面了</p>
<p>3.线程授权handler，hanlder的修改UI界面（handleMessage方法执行具体逻辑）</p>
<p>Handler sendMessage的代码模板：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">	main thread&#123;</div><div class="line">	TextView tv=(TextView) findViewById(.....);</div><div class="line">	<span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">			<span class="keyword">switch</span>(msg.what)&#123;</div><div class="line">				<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">					String text = (String)msg.obj;</div><div class="line">					tv.setText(text);</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			String s = <span class="string">"haha"</span>;</div><div class="line">			<span class="comment">// 只想刷新UI</span></div><div class="line">			Message msg = Message.obtain();</div><div class="line">			msg.what=<span class="number">0</span>;</div><div class="line">			msg.obj = s；</div><div class="line">			handler.sendMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;)	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Handler的handleMessage方法可以在子线程执行吗？<br>可以，取决于looper，默认的时候用的是系统的looper，默认在主函数，就是主线程执行</p>
<h3 id="使用Handler的post-方法修改UI界面"><a href="#使用Handler的post-方法修改UI界面" class="headerlink" title="使用Handler的post()方法修改UI界面"></a>使用Handler的post()方法修改UI界面</h3><p>如果常见Handler对象时，没有覆盖handleMessage(Message mg)方法时，只能通过post（）方法发送Runable对象传递消息，当调用post方法时，自动调用Runnable对象的run（）方法，Runnable对象只是作为一个封装了操作的对象被传递，并未产生新线程。</p>
<p>关于handler.post方法和handler.sendmessage方法的区别：<br>相关文章：<br><a href="http://blog.csdn.net/u012534831/article/details/52212239" target="_blank" rel="external">handler.post方法的终极最直观的理解与解释</a></p>
<p>Handler post的代码模板：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">main thread&#123;</div><div class="line">	TextView tv=(TextView) findViewById(.....);</div><div class="line">	<span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;&#125;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">				String s = <span class="string">"haha"</span>;</div><div class="line">				handler.post(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">					<span class="comment">//只想刷新UI</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">						<span class="comment">//这段代码就是在主线程中执行的</span></div><div class="line">						tv.setText(s);</div><div class="line">					&#125;					</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">		&#125;)	</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然写法上相差很多，但是原理是完全一样的，我们在Runnable对象的run()方法里更新UI，效果完全等同于在handleMessage()方法中更新UI。</p>
<h3 id="使用Activity-runOnUiThread方法修改UI界面"><a href="#使用Activity-runOnUiThread方法修改UI界面" class="headerlink" title="使用Activity.runOnUiThread方法修改UI界面"></a>使用Activity.runOnUiThread方法修改UI界面</h3><p>运行在主线程，内部使用线程合并技术Join</p>
<p>用法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		tv_result.setText(result); <span class="comment">// 修改界面</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;  </div><div class="line">        mHandler.post(action);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        action.run();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果当前的线程不等于UI线程(主线程)，<br>就去调用Handler的post()方法，<br>否则就直接调用Runnable对象的run()方法。</p>
<p>注意：<br>主线程里注意别写runOnUiThread，而且里面还写了耗时操作<br>看源码得知它的内部实现原理是handler发消息给主线程，主线程得到消息就把runnable逻辑又给主线程<br>这么写就白给了，还是在主线程执行耗时的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 耗时操作</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="使用View-post方法修改UI界面"><a href="#使用View-post方法修改UI界面" class="headerlink" title="使用View.post方法修改UI界面"></a>使用View.post方法修改UI界面</h3><p>post源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;  </div><div class="line">    Handler handler;  </div><div class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;  </div><div class="line">        handler = mAttachInfo.mHandler;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        ViewRoot.getRunQueue().post(action);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> handler.post(action);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实就是调用了Handler中的post()方法</p>
<h2 id="Handler对象传递的几种方式"><a href="#Handler对象传递的几种方式" class="headerlink" title="Handler对象传递的几种方式"></a>Handler对象传递的几种方式</h2><p>android多个Activity可以共用一个handler进行发送消息吗？</p>
<p>1.整个主UI ，只创建一个handler,即全局的handler.然后多个activity共享这一个handler,发送消息。<br>优点： 只用一个消息循环，比较能提高性能。<br>缺点： 发送消息时，传递数据不方便。需要将activity的 各变量值打包 传递给这个全局的handler. </p>
<p>2.每一个Activity创建一个handler,当前Activity就用它自己的handler变量来发送消息。<br>优点：发送消息时，传递数据很方便，因为就利用当前activity类里的变量值。<br>缺点：创建了多个消息队列，容易忘掉释放，影响性能。 </p>
<h3 id="1-创建一个HandlerManager管理工具类"><a href="#1-创建一个HandlerManager管理工具类" class="headerlink" title="1.创建一个HandlerManager管理工具类"></a>1.创建一个HandlerManager管理工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">在不同的类中实现同一个Handler处理，可以通过Handler对象传递的方式来解决，</div><div class="line">实现原理：通过ThreadLocal来存储Handler对象，通过线程id来查找指定线程上的变量。</div><div class="line">创建一个HandlerManager管理工具类，将要传递的Handler对象保存到该类下进行管理，然后在其他类中获得Handler对象即可传递消息。</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerManager</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Handler&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Handler&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> threadLocal.get();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putHandler</span><span class="params">(Handler value)</span> </span>&#123;</div><div class="line">		threadLocal.set(value);<span class="comment">// UiThread  id</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-Application全局共享和利用广播机制"><a href="#2-Application全局共享和利用广播机制" class="headerlink" title="2.Application全局共享和利用广播机制"></a>2.Application全局共享和利用广播机制</h3><p>相关文章：<br><a href="http://blog.csdn.net/jason0539/article/details/18055259" target="_blank" rel="external">android之在activity中控制另一个activity的UI更新_如何在activity之间传递handler</a><br><a href="http://blog.csdn.net/jason0539/article/details/18075293" target="_blank" rel="external">android之如何在两个activity之间传递handler_利用broadcast广播机制</a></p>
<h2 id="Handler用法注意"><a href="#Handler用法注意" class="headerlink" title="Handler用法注意"></a>Handler用法注意</h2><p>1.在 Activity 中尽可能少的创建 Handler 对象，创建一个主线程 Handler，一个后台 HandlerThread 就可以了。</p>
<p>2.Handler机制有一个特点是不会随着Activity、Service的生命周期结束而结束。<br>也就是说，如果你Post了一个Delay的Runnable，然后在Runnable执行之前退出了Activity，Runnable到时间之后还是要执行的。如果Runnable里面包含更新View的操作，程序崩溃了。</p>
<p>3.不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突</p>
<p>4.Handler 发两个消息导致主线程阻塞<br>注意，Handler发2个消息会挂<br>Message msg = Message.obtain();<br>hanlder.sendMessage(msg);<br>looper轮询器处理消息，msg处理完，销毁（把msg所有属性重置为默认值，并不是回收对象）</p>
<h2 id="Handler其他面试题"><a href="#Handler其他面试题" class="headerlink" title="Handler其他面试题"></a>Handler其他面试题</h2><p>1.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</p>
<p>谷歌为防止多个子线程更新UI混乱，把安卓的界面显示做成了单线程模型</p>
<p>子线程委托主线程的handler调用它的handlemessage来更新UI，类似代理设计模式</p>
<p>Activity是一个UI线程，运行于主线程中，Android系统在启动的时候会为Activity创建一个消息队列和消息循环（Looper）。</p>
<p>UI线程（主线程）定义了一个集合（Message queue）消息队列<br>主线程里有一个Looper，一旦它调用了loop方法，loop内部是死循环，它会不停的获取message queue里的消息<br>这个死循环是个阻塞式死循环，类似socket监听端口就停在这了，并不是停止，而是等待，一旦有消息到来，就接消息就处理下<br>Loop执行的方式和socket很像，没消息就停留等待，有消息就取消息执行<br>举例：Thread A和ThreadB拿到主线程里面的handler（它把消息放在message queue里）一放进来，looper就发现有消息到来了，就执行loop方法获取消息，就调用handlemessage方法来更新UI（因为looper和message queue都在主线程，所以能更新UI）</p>
<p>2.对android主线程的运用和理解</p>
<p>只要与图像相关的，主线程都是死循环（阻塞式死循环，有消息接收，没消息等待）<br>4大组件都是通过消息机制操作的</p>
<p>主ui线程不能执行耗时的操作,<br>主线程也不能阻塞太长时间会导致内容提供者r和广播接受者处理不了<br>主线程不仅负责UI的更新，还有系统事件，所以必须要保留一个较高的优先级，<br>假设有事件到来就得立刻处理，所以尽量不要再主线程执行耗时的操作<br>只是觉得代码执行时间多就放在子线程里</p>
<p>3.一个线程怎样把消息放入主线程的消息队列呢？<br>答案是通过Handle对象，只要Handler对象以主线程的Looper创建，那么调用Handler的sendMessage等接口，将会把消息放入队列都将是放入主线程的消息队列。并且将会在Handler主线程中调用该handler的handleMessage接口来处理消息。</p>
<p>4.Handler的作用<br>是把消息加入特定的（Looper）消息队列中，并分发和处理该消息队列中的消息。<br>构造Handler的时候可以指定一个Looper对象，如果不指定则利用当前线程的Looper创建。</p>
<p>5.直接在子线程中创建Handler为什么会报错</p>
<p>在子线程中创建handler时会报以下错误<br>Can’t create handler inside thread that has not called Looper.prepare()</p>
<p>总结一下就是在主线程中可以直接创建Handler对象<br>而在子线程中需要先调用Looper.prepare()才能创建Handler对象。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/jay1on/article/details/52988689" target="_blank" rel="external">Android 直接在子线程中创建Handler为什么会报错</a></p>
<h2 id="Handler其他使用场景"><a href="#Handler其他使用场景" class="headerlink" title="Handler其他使用场景"></a>Handler其他使用场景</h2><p>handler能与Looper配合实现经典的Pipeline Thread(流水线线程)模式。<br><a href="http://blog.csdn.net/runninglion/article/details/40627381" target="_blank" rel="external">Android Guts: Intro to Loopers and Handlers</a></p>
<h2 id="Handler内存泄露"><a href="#Handler内存泄露" class="headerlink" title="Handler内存泄露"></a>Handler内存泄露</h2><p>注意：<br>避免使用非静态内部类</p>
<p>解决方案：<br>1.使用显形的引用<br>1.1.静态内部类<br>1.2.放在外部类(单独的类文件)</p>
<p>2.使用弱引用 WeakReference<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * Handler：静态内部类的方式避免内存泄漏</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_2 = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_3 = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mHandler.sendMessageDelayed(Message.obtain(), <span class="number">60000</span>);</div><div class="line">        finish();<span class="comment">// just finish this activity</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;HandlerActivity2&gt; mActivity;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</div><div class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            System.out.println(msg);</div><div class="line">            <span class="keyword">if</span> (mActivity.get() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mActivity.get().todo();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span> </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>还没完，上面这样就可以了吗？No</p>
<p>3.Activity onStop或者onDestroy,取消掉该Handler对象的Message和Runnable。 通过查看Handler的API，它有几个方法：<br>removeCallbacks(Runnable r)和removeMessages(int what)等。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一切都是为了不要让mHandler拖泥带水</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    mHandler.removeMessages(MESSAGE_1);</div><div class="line">    mHandler.removeMessages(MESSAGE_2);</div><div class="line">    mHandler.removeMessages(MESSAGE_3);</div><div class="line">    <span class="comment">// ... ...</span></div><div class="line">    mHandler.removeCallbacks(mRunnable);</div><div class="line">    <span class="comment">// ... ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果上面觉的麻烦，也可以如下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//  If null, all callbacks and messages will be removed.</span></div><div class="line">    mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/" target="_blank" rel="external">Android中Handler引起的内存泄露</a><br><a href="http://www.open-open.com/lib/view/open1455981510995.html" target="_blank" rel="external">Android内存泄露之Handler</a></p>
<h2 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h2><p>Handler的上层源码分析：<br><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a><br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/17021809" target="_blank" rel="external">Android中的Handler,Looper,Message机制</a></p>
<p>Handler工作机制的底层原理：<br>Handler发消息的时候会往管道里写字符串“W”来唤醒主线程<br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/39692607" target="_blank" rel="external">Android中对消息机制(Handler)的再次解读</a></p>
<h2 id="关于Message"><a href="#关于Message" class="headerlink" title="关于Message"></a>关于Message</h2><p>在线API：<br><a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="external">https://developer.android.google.cn/reference/android/os/Message.html</a></p>
<p>概述：<br>Message被放在MessageQueue中<br>一个MessageQueue中可以包含多个Message对象<br>每个Message对象可以通过Message.Obtain()或Handler.ObtainMessage()方法获得。</p>
<p>注意：<br>1)使用Message类的属性可以携带int数据，如果要携带其他类型的数据，可以先将要携带的数据保存到Bundle对象中，然后通过Message类的setData方法将添加到Message中。<br>2)尽管Message有public的默认构造函数，但是通常情况下需要使用Message.obtain()或Handler.obainMessage()方法来从消息池中获得空消息对象，以节省资源<br>3)尽可能使用Message.what来表示信息，以使用不同处理Message</p>
<h3 id="获取Message的三种方式"><a href="#获取Message的三种方式" class="headerlink" title="获取Message的三种方式"></a>获取Message的三种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.Message msg = <span class="keyword">new</span> Message();    </div><div class="line"><span class="comment">// 不推荐</span></div><div class="line"></div><div class="line"><span class="number">2</span>.Message msg = Message.obtain();  </div><div class="line"><span class="comment">// 复用Message对象，去池子里取，节省创建和销毁事件，节省资hanlder.sendMessage(msg);</span></div><div class="line"></div><div class="line"><span class="number">3</span>.Message msg = handler.obtainMessage(); </div><div class="line"><span class="comment">// 和上面的区别就是这个msg已经和handler绑定</span></div><div class="line"><span class="comment">// msg.sendToTarget();	搭配这个方法使用可以连续调用，如</span></div><div class="line"><span class="comment">// handler.obtainMessage(GET_USERS_DATA_OK, users).sendToTarget();</span></div><div class="line"><span class="comment">// 在给Handler发送消息的时候没必要每次都new Message()，而是使用handler.obtainMessage()，它会先看看消息队列里面有没有没用的消息，如果有可以复用消息对象。</span></div></pre></td></tr></table></figure>
<h2 id="关于Looper"><a href="#关于Looper" class="headerlink" title="关于Looper"></a>关于Looper</h2><p>在线API：<br><a href="https://developer.android.google.cn/reference/android/os/Looper.html" target="_blank" rel="external">https://developer.android.google.cn/reference/android/os/Looper.html</a></p>
<h3 id="Looper的开启和关闭"><a href="#Looper的开启和关闭" class="headerlink" title="Looper的开启和关闭"></a>Looper的开启和关闭</h3><p>在写Looper.loop()之后代码不会执行，该方法内部是一个循环<br>当调用Handler.getLooper().quit()方法后，loop（）等等才会终止，之后的代码才能运行。</p>
<h3 id="一个线程中，能有几个Looper和Handler"><a href="#一个线程中，能有几个Looper和Handler" class="headerlink" title="一个线程中，能有几个Looper和Handler?"></a>一个线程中，能有几个Looper和Handler?</h3><p>在一个线程中<br>只能有一个Looper和MessageQueue<br>但是可以有多个Handler，而且这些Handler可以共享同一个Looper和MessageQueue。<br><img src="/images/it_android_handler_loop1.png" alt="UML图"></p>
<h3 id="Loop能不能在子线程中定义"><a href="#Loop能不能在子线程中定义" class="headerlink" title="Loop能不能在子线程中定义"></a>Loop能不能在子线程中定义</h3><p>loop不是共享的，可以在子线程中定义.</p>
<h3 id="在非主线程中创建Handler对象，需要手动New-Looper吗？"><a href="#在非主线程中创建Handler对象，需要手动New-Looper吗？" class="headerlink" title="在非主线程中创建Handler对象，需要手动New Looper吗？"></a>在非主线程中创建Handler对象，需要手动New Looper吗？</h3><p>在android中，一个线程对应一个Looper对象，而一个Looper对象又对应一个MessageQueue（消息队列），<br>MessageQueue用于存放Message（消息），在MessageQueue中存放的消息按照FIFO（先进先出）原则执行，<br>由于MessageQueue被封装到Looper（轮询器）里面。<br>Looper对象用来为一个线程开启一个消息循环，从而操作MessageQueue。<br>默认情况下，android中新创建线程是没有开启消息循环的，但是主线程除外，系统自动为主线程创建Looper对象，开启消息循环，所以，当在主线程中创建Handler对象时不会产生异常。<br>如果要在非主线程中创建Handler对象，首先需要使用Looper类的prepare（）方法来初始化一个Looper对象，然后创建该Handler对象，使用Looper类的loop（）方法启动Looper，从消息队列中获取和处理消息。</p>
<hr>
<h1 id="HandlerThread消息处理器线程"><a href="#HandlerThread消息处理器线程" class="headerlink" title="HandlerThread消息处理器线程"></a>HandlerThread消息处理器线程</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>在线API：<a href="http://www.android-doc.com/reference/android/os/HandlerThread.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/os/HandlerThread.html</a></p>
<p>名称：消息处理器线程 类</p>
<p>作用：代替不停new Thread开子线程的重复体力写法</p>
<p>概述：<br>Android提供了一个封装好的带有looper的线程类，即为HandlerThread</p>
<p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p>
<p>单一线程 + 任务队列 处理轻量的异步任务 </p>
<p>确实比较适合单线程+异步队列的场景，比如应用刚进入时的数据初始化操作，如果开启多个线程同时执行，有可能争夺UI线程的CPU执行时间，造成卡顿，这个使用单线程+一异步队列模型，设置优先级之后，就可以将同步工作顺序执行，而又不影响UI的初始化</p>
<p>Handler会关联一个单独的线程和消息队列。Handler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。如果要在其他线程执行，可以使用HandlerThread。<br>HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>封装一个轻量级的任务处理器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightTaskManager</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Handler mHandler;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LightTaskManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        HandlerThread workerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"LightTaskThread"</span>);</div><div class="line">        <span class="comment">// 设置优先级(后台线程建议设置这个优先级，值为10)</span></div><div class="line">        <span class="comment">// HandlerThread workerThread = new HandlerThread("LightTaskThread", Process.THREAD_PRIORITY_BACKGROUND);</span></div><div class="line"></div><div class="line">        workerThread.start();</div><div class="line">        mHandler = <span class="keyword">new</span> Handler(workerThread.getLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable run)</span> </span>&#123;</div><div class="line">        mHandler.post(run);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">        mHandler.postAtFrontOfQueue(runnable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable runnable, <span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        mHandler.postDelayed(runnable, delay);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postAtTime</span><span class="params">(Runnable runnable, <span class="keyword">long</span> time)</span> </span>&#123;</div><div class="line">        mHandler.postAtTime(runnable, time);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="http://blog.csdn.net/double2hao/article/details/58598171" target="_blank" rel="external">HandlerThread的使用以及原理</a><br><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/" target="_blank" rel="external">详解 Android 中的 HandlerThread</a></p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://www.infoq.com/cn/articles/android-worker-thread" target="_blank" rel="external">关于Android中工作者线程的思考</a><br><a href="http://www.3lian.com/edu/2012/11-19/44762.html" target="_blank" rel="external">详解 Android 中的 HandlerThread</a><br><a href="http://www.3lian.com/edu/2012/11-19/44762.html" target="_blank" rel="external">HandlerThread，Handler，Thread使用方法</a></p>
<hr>
<h1 id="AsyncTask异步任务"><a href="#AsyncTask异步任务" class="headerlink" title="AsyncTask异步任务"></a>AsyncTask异步任务</h1><hr>
<h2 id="AsyncTask简介"><a href="#AsyncTask简介" class="headerlink" title="AsyncTask简介"></a>AsyncTask简介</h2><p>所属包：android.os<br>在线API：<a href="http://www.android-doc.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/os/AsyncTask.html</a></p>
<p>Protected Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">onPreExecute()</div><div class="line">onPostExecute(Bitmap result)</div><div class="line">onProgressUpdate(Progress...params)</div><div class="line">doInBackground(Void... params) </div><div class="line">publishProgress(Progress... values)</div><div class="line">onCancelled(Result result) </div><div class="line">onCancelled()</div></pre></td></tr></table></figure></p>
<p>Public Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span>	<span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">execute</span><span class="params">(Runnable runnable)</span></div><div class="line"><span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt;	<span class="title">execute</span><span class="params">(Params... params)</span></div><div class="line"><span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt;	<span class="title">executeOnExecutor</span><span class="params">(Executor exec, Params... params)</span></div><div class="line"><span class="keyword">final</span> Result	<span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></div><div class="line"><span class="keyword">final</span> Result	<span class="title">get</span><span class="params">()</span></div><div class="line"><span class="keyword">final</span> AsyncTask.Status	<span class="title">getStatus</span><span class="params">()</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span>	<span class="title">isCancelled</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>AsyncTask三个参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AsyncTask&lt;Params, Progress, Result&gt;</div><div class="line"><span class="number">1</span>.Params 启动任务执行的传输的参数，比如HTTP请求的URL</div><div class="line"><span class="number">2</span>.Progress 下载相关的，进度提示（Integer，Float）</div><div class="line"><span class="number">3</span>.Result 后台执行任务最终返回的结果，比如String,Integer</div></pre></td></tr></table></figure></p>
<p>AsyncTask执行的四个步骤：<br>每一步都对应一个回调方法，开发者需要实现这些方法：<br>1)继承AsyncTask<br>2)实现AsyncTask中定义的下面一个或几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">onPreExecute()</div><div class="line">该方法将在执行实际的后台操作前被UI 线程调用。</div><div class="line">可以在该方法中做一些准备工作，如在界面上显示一个进度条，或者一些控件的实例化，这个方法可以不用实现。</div><div class="line"></div><div class="line">doInBackground(Params... params)</div><div class="line">将在onPreExecute 方法执行后马上执行，该方法运行在后台线程中。</div><div class="line">这里将主要负责执行那些很耗时的后台处理工作。</div><div class="line">可以调用 publishProgress方法来更新实时的任务进度。</div><div class="line">该方法是抽象方法，子类必须实现。</div><div class="line"></div><div class="line">onPostExecute(Result)</div><div class="line">在doInBackground 执行完成后，onPostExecute 方法将被UI 线程调用，</div><div class="line">后台的计算结果将通过该方法传递到UI 线程，并且在界面上展示给用户.</div><div class="line"></div><div class="line">onProgressUpdate(Progress...params)</div><div class="line">在publishProgress方法被调用后，</div><div class="line">UI 线程将调用这个方法从而在界面上展示任务的进展情况，例如通过一个进度条进行展示。</div><div class="line"></div><div class="line">onCancelled()</div><div class="line">在用户取消线程操作的时候调用，运行在UI线程中。</div><div class="line">在主线程中调用onCancelled()的时候回调该方法。</div></pre></td></tr></table></figure></p>
<p>历史：<br>Android API 3（1.5 Cupcake）开始，AsyncTask被引入用来帮助开发者更简单地管理线程。<br>实际上在Android 1.0和1.1也是有类似的实现，那就是UserTask。UserTask和AsyncTask有着相同的API及实现，但是由于由于1.0和1.1的设备份额微乎其微，这里的概念就不会涉及到UserTask。</p>
<p>使用场景：<br>1.handler能用的地方也是他使用的地方（UI更新）<br>2.做耗时操作时，需要开线程去执行，执行完成后，ui更新<br>3.和ui打交道</p>
<p>使用关键点：<br>使用AsyncTask需要确保AsyncTask正确地取消</p>
<p>注意：<br>不同API版本的AsyncTask实现不一样，有的是可以同时执行多个任务，有的API中只能同时执行一个线程，所以在程序中同时执行多个AsyncTask时有可能遇到一个AsyncTask的excute方法后很久都没有执行。</p>
<p>为了正确的使用AsyncTask类，以下是几条必须遵守的准则：<br>1) Task的实例必须在UI 线程中创建<br>2) execute方法必须在UI 线程中调用<br>3) 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法，需要在UI线程中实例化的task来调用。<br>4) 该task只能被执行一次，否则多次调用时将会出现异常<br>5）executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)，如果操作的线程过多，会出现线程等待现象，可以使用该方法来避免。</p>
<p>常见问题：<br>调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案：<br><a href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html" target="_blank" rel="external">http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html</a></p>
<p>推荐替换方案：<br>Loaders</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Android中的线程池技术</p>
<p>用于异步任务处理</p>
<p>异步任务是一个简单的异常调用的框架，把需求抽象成了模板，<br>做操作之前更新一下UI（onPreExecute）<br>后台有一个耗时的任务（doInBackGroup），<br>耗时的任务做完了就要更新界面了（onPostExecute）<br>这些方法定义成模板，留一些抽象的代码让人去实现，这就是框架</p>
<p>Android消息机制的UI线程时不安全的，如果想要在子线程里进行UI操作，就需要借助android的异步消息处理机制。<br>为了更加方便在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它可以非常灵活方便地从子线程切换到UI线程</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TextView    tv;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        tv = (TextView) findViewById(R.id.tv);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickStart</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        <span class="comment">// 异步任务</span></div><div class="line">        <span class="comment">// 执行顺序 onPreExecute --》 doInBackground --》 onPostExecute</span></div><div class="line">        <span class="comment">// 参数：</span></div><div class="line">        <span class="comment">// 1: 执行任务传人的参数,doInBackground的参数</span></div><div class="line">        <span class="comment">// 2: 执行的进度 onProgressUpdated的参数</span></div><div class="line">        <span class="comment">// 3: 执行结果参数，是doInBackground的返回值，是onPostExecute的参数</span></div><div class="line">        AsyncTask&lt;String, Integer, Long&gt; task = <span class="keyword">new</span> AsyncTask&lt;String, Integer, Long&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 主线程中执行，准备执行耗时操作前（用于在执行后台任务前做一些UI操作)</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span></span>&#123; </div><div class="line">                <span class="keyword">super</span>.onPreExecute();</div><div class="line">                tv.setText(<span class="string">"开始加载"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 是在子线程（线程池）中执行的，执行耗时的操作（异步任务）,不可在此方法内修改UI  </span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(String... params)</span></span>&#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</div><div class="line">                    <span class="keyword">try</span>&#123;</div><div class="line">                        Thread.sleep(<span class="number">100</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    publishProgress(i); <span class="comment">// 公布进度,最后onProgressUpdate方法将被执行   </span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="number">1000l</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 主线程中执行,用于更新进度信息，如果想触发他，需要调用publishProgress()</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span></span>&#123; </div><div class="line">                <span class="keyword">super</span>.onProgressUpdate(values)</div><div class="line">                tv.setText(values[<span class="number">0</span>] + <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 主线程中执行，耗时操作完成后的回调，用于在执行完后台任务后更新UI,显示结果 </span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span></span>&#123;   </div><div class="line">                <span class="keyword">super</span>.onPostExecute(result);</div><div class="line">                tv.setText(<span class="string">""</span> + result);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//用于在取消执行中的任务时更改UI  </span></div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;  </div><div class="line">                Log.i(TAG, <span class="string">"onCancelled()"</span>);  </div><div class="line">                tv.setText(<span class="string">"cancelled"</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 版本适配</span></div><div class="line">        <span class="comment">// 2.3和3.0以后的异步任务有什么区别？</span></div><div class="line">        <span class="comment">// android3.0之前是多线程的（new 多少个AsyncTask就开启多少个线程）</span></div><div class="line">        <span class="comment">// android3.0之后是单线程队列的(new多个AsyncTask时，一个接一个的开启线程，有先后顺序，需要排列，就是队列)</span></div><div class="line">        <span class="comment">// 当实际开发中需要多个AsyncTask的同时开启时，就需要版本控制来解决</span></div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.HONEYCOMB)&#123; 		</div><div class="line">        <span class="comment">// Build.VERSION.SDK_INT返回当前手机内的版本号</span></div><div class="line">		<span class="comment">// Build.VERSION_CODES.HONEYCOMB  android3.0版本</span></div><div class="line">            task.executeOnExecutor(Executors.newFixedThreadPool(<span class="number">3</span>));<span class="comment">// 3.0以上是单线程队列的</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            task.execute(); <span class="comment">// 3.0之前是多线程的</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不同版本出现的各种问题"><a href="#不同版本出现的各种问题" class="headerlink" title="不同版本出现的各种问题"></a>不同版本出现的各种问题</h2><p>参考文章：<br><a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/" target="_blank" rel="external">技术小黑屋——Android中糟糕的AsyncTask</a></p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>关于AsyncTask存在一个这样广泛的误解，很多人认为一个在Activity中的AsyncTask会随着Activity的销毁而销毁。然后事实并非如此。AsyncTask会一直执行doInBackground()方法直到方法执行结束。一旦上述方法结束，会依据情况进行不同的操作。</p>
<p>如果cancel(boolean)调用了，则执行onCancelled(Result)方法<br>如果cancel(boolean)没有调用，则执行onPostExecute(Result)方法<br>AsyncTask的cancel方法需要一个布尔值的参数，参数名为mayInterruptIfRunning,意思是如果正在执行是否可以打断,如果这个值设置为true，表示这个任务可以被打断，否则，正在执行的程序会继续执行直到完成。如果在doInBackground()方法中有一个循环操作，我们应该在循环中使用isCancelled()来判断，如果返回为true，我们应该避免执行后续无用的循环操作。</p>
<p>总之，我们使用AsyncTask需要确保AsyncTask正确地取消。</p>
<h3 id="不好好工作的cancel"><a href="#不好好工作的cancel" class="headerlink" title="不好好工作的cancel()"></a>不好好工作的cancel()</h3><p>简而言之的答案，有时候起作用。</p>
<p>如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义。</p>
<h3 id="结果丢失"><a href="#结果丢失" class="headerlink" title="结果丢失"></a>结果丢失</h3><p>另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。</p>
<h3 id="串行还是并行"><a href="#串行还是并行" class="headerlink" title="串行还是并行"></a>串行还是并行</h3><p>关于AsyncTask时串行还是并行有很多疑问，这很正常，因为它经过多次的修改。如果你并不明白什么时串行还是并行，可以通过接下来的例子了解，假设我们在一个方法体里面有如下两行代码</p>
<p>new AsyncTask1().execute();<br>new AsyncTask2().execute();</p>
<p>上面的两个任务时同时执行呢，还是AsyncTask1执行结束之后，AsyncTask2才能执行呢？实际上是结果依据API不同而不同。</p>
<p>在1.6(Donut)之前:<br>在第一版的AsyncTask，任务是串行调度。一个任务执行完成另一个才能执行。由于串行执行任务，使用多个AsyncTask可能会带来有些问题。所以这并不是一个很好的处理异步（尤其是需要将结果作用于UI试图）操作的方法。</p>
<p>从1.6到2.3(Gingerbread):<br>后来Android团队决定让AsyncTask并行来解决1.6之前引起的问题，这个问题是解决了，新的问题又出现了。很多开发者实际上依赖于顺序执行的行为。于是很多并发的问题蜂拥而至。</p>
<p>3.0（Honeycomb）到现在:<br>好吧，开发者可能并不喜欢让AsyncTask并行，于是Android团队又把AsyncTask改成了串行。当然这一次的修改并没有完全禁止AsyncTask并行。你可以通过设置executeOnExecutor(Executor)来实现多个AsyncTask并行。</p>
<p>看下源码看看AsyncTask的执行原理：<br>AsyncTask默认自己维护一个静态的线程池，而该线程池只允许同时执行一个线程，也就是说，不管多少个AsyncTask,只要是调用execute()方法，都是共享这个默认进程池的，你的任务必须在之前的任务执行完以后，才能执行。可以理解为，默认情况下，所有的AsyncTask在一个独立于UI线程的线程中执行，任务需要排队，先execute的先执行，后面的只能等。<br>当然，这是串行的源码，后期变成并行，乃至可串可并..不过核心还是线程池.</p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><p>核心底层原理：<br>里面封装了线程池和handle（但是不完全代替handler，handler可创建在子线程，asyncTask只能在主线程）<br>核心线程数5个<br>最大线程池128个</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="external">Android AsyncTask完全解析，带你从源码的角度彻底理解</a></p>
<hr>
<h1 id="Loader加载器机制"><a href="#Loader加载器机制" class="headerlink" title="Loader加载器机制"></a>Loader加载器机制</h1><hr>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>相关文章：<br><a href="http://www.jianshu.com/p/385327e35711" target="_blank" rel="external">Android 深入理解Loader机制 让APP轻装上阵</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2014/0325/1602.html" target="_blank" rel="external">android 加载器loader详解</a></p>
<p>中文名：<br>加载器，装载机</p>
<p>历史：<br>android 3.0之后才被引入，它简化了在activity和fragment中异步加载数据的步骤，优雅的实现了异步加载</p>
<p>特点：<br>适用于每个activity和fragment异步加载数据，无需重新启动一个线程来执行数据加载.<br>提供异步加载的实现方法<br>实时更新数据，监听数据源的一举一动，在数据发生变更时自动返回新的结果<br>当由于配置改变而被重新创建后，它们自动重连到上一个加载器的游标，所以不必重新查询数据<br>异步加载也可以用asyncTask, 但是loader自带数据结果监听机制，可以方便优雅的进行UI更新<br>在Activity配置发生变化（如横竖屏切换）时不避免数据重复加载</p>
<p>作用：<br>主要完成单线程耗时数据异步装载功能，并在数据有更新自动通知UI刷新的作用</p>
<p>使用前提：<br>overLoad一般是由于开发者在主线程操作耗时操作，导致程序变慢 甚至出现的anr的现象<br>那么android早已为这种现象提供完美的解决方案：Loader机制</p>
<p>使用情景：<br>普通展现某个android手机有多少应用程序，加载已安装app时候，其实loader就能排上用场。</p>
<h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><p>使用loader的过程中可能会遇到这些类和接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.LoaderManager</div><div class="line">一个与activity和fragment相关联的抽象类，它管理一个或多个loader实例，</div><div class="line">帮助一个应用管理那些与Activity或Fragment的生命周期相关的长时间运行的的操作。</div><div class="line">最常见的方式是与一个CursorLoader一起使用，然而应用也可以自己写一个加载其他数据类型或者数据源的loader。</div><div class="line">每个activity或fragment只有一个LoaderManager。但是一个LoaderManager可以拥有多个加载器。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/app/LoaderManager.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/app/LoaderManager.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">2</span>.LoaderManager.LoaderCallbacks	</div><div class="line">一个用于客户端与LoaderManager交互的回调接口。</div><div class="line">例如，你使用回调方法onCreateLoader()来创建一个新的加载器。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/app/LoaderManager.LoaderCallbacks.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">3</span>.Loader	</div><div class="line">一个执行异步数据加载的抽象类。它是加载器的基类。</div><div class="line">你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。</div><div class="line">一旦加载器被激活，它们将监视它们的数据源并且在数据改变时发送新的结果。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/content/Loader.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/content/Loader.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">4</span>.AsyncTaskLoader	</div><div class="line">提供一个AsyncTask来执行异步加载工作的抽象类。</div><div class="line">可用来所有异步加载</div><div class="line">AsyncTaskLoader继承了Loader,</div><div class="line">除了拥有loader的功能，还有executePendingTask()， dispatchOnCancelled（），onLoadInBackground()等方法</div><div class="line">最神奇的是他拥有AsyncTask的实例，并且实现Runnable,这是他能进行异步的原因所在。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/content/AsyncTaskLoader.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/content/AsyncTaskLoader.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">5</span>.CursorLoader	</div><div class="line">AsyncTaskLoader的子类，主要负责数据库查询的异步加载</div><div class="line">它查询ContentResolver然后返回一个Cursor。</div><div class="line">这个类为查询cursor以标准的方式实现了加载器的协议，</div><div class="line">它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞界面。</div><div class="line">使用这个加载器是从一个ContentProvider异步加载数据的最好方式。</div><div class="line">相比之下，通过fragment或activity的API来执行一个被管理的查询就不行了。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/content/CursorLoader.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/content/CursorLoader.html</span></div></pre></td></tr></table></figure></p>
<p>上面所列的类和接口们是你在你的应用中要实现加载器时的核心组件。<br>你的每个加载器并不一定需要所有的组件，但是你总是需要引用LoaderManager来初始化一个加载器。</p>
<h2 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h2><p>底层原理：<br>当然自身轮询和通信是离不开Handler的<br>因为整个android的通讯就是建立在Handler（底层binder）基础上</p>
<p>相关文章：<br><a href="http://blog.csdn.net/yanbober/article/details/48861457" target="_blank" rel="external">Android应用Loaders全面详解及源码浅析</a></p>
<hr>
<h1 id="IntentService-异步意图服务"><a href="#IntentService-异步意图服务" class="headerlink" title="IntentService 异步意图服务"></a>IntentService 异步意图服务</h1><hr>
<h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>所属包：android.add<br>在线API：<a href="http://www.android-doc.com/reference/android/app/IntentService.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/app/IntentService.html</a></p>
<p>一句话描述：<br>一个可以干完活后自己去死且不需要我们去管理子线程的Service。</p>
<p>Public Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">IBinder	<span class="title">onBind</span><span class="params">(Intent intent)</span></span></div><div class="line"><span class="keyword">void</span>	<span class="title">onCreate</span><span class="params">()</span></div><div class="line"><span class="keyword">void</span>	<span class="title">onDestroy</span><span class="params">()</span></div><div class="line"><span class="keyword">void</span>	<span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span></div><div class="line"><span class="keyword">int</span>	    <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></div><div class="line"><span class="keyword">void</span>	<span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></div></pre></td></tr></table></figure></p>
<p>Protected Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span>	<span class="title">onHandleIntent</span><span class="params">(Intent intent)</span></span></div></pre></td></tr></table></figure></p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>框架包装好的服务<br>一个方便我们处理业务流程的类，它是一个Service，但是比Service更智能。</p>
<p>普通的service, 默认运行在主线程<br>Sdk给我们提供的方便的,带有异步处理的Service类,<br>OnHandleIntent() 处理耗时的操作，内部开了子线程</p>
<p>几个常用生命周期方法（开启完就自动销毁了）<br>onCreate<br>onHandleIntent<br>onDestroy</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>IntentService是继承于Service并处理异步请求的一个类<br>有一个工作线程来处理耗时操作<br>启动IntentService的方式和启动传统Service一样<br>同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。<br>可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p>
<p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。<br>在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p>
<p>该服务提供了一个onBind()方法的默认实现，它返回null</p>
<p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我们省去了在Service中手动开线程的麻烦<br>当操作完成时，我们不用手动停止Service。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>IntentService不能并行处理多个job，只能依次处理，一个接一个</p>
<h2 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h2><p>1.非阻塞式的聊天软件，后台有耗时操作，取消息的时候可能会用到它</p>
<p>2.用于天气预报的应用，获取天气信息<br>开一个服务，在服务的方法onHandleIntent获取天气<br>服务获取完天气就自动onDestroy，销毁掉</p>
<h2 id="Service与IntentService耗时操作的区别"><a href="#Service与IntentService耗时操作的区别" class="headerlink" title="Service与IntentService耗时操作的区别"></a>Service与IntentService耗时操作的区别</h2><p>Service中如果有耗时的操作，要开启一个Thread来做。<br>IntentService是在独立的线程中，所以可以进行一些耗时操作。</p>
<h2 id="AsyncTask与Service的使用区别"><a href="#AsyncTask与Service的使用区别" class="headerlink" title="AsyncTask与Service的使用区别"></a>AsyncTask与Service的使用区别</h2><p>如果是全后台的工作，使用Service，结果的提示可以使用Notification。<br>如果是异步工作，工作结束后需要更新UI，那么最好使用Thread或者AsyncTask。</p>
<h2 id="IntentService中显示Toast"><a href="#IntentService中显示Toast" class="headerlink" title="IntentService中显示Toast"></a>IntentService中显示Toast</h2><p><a href="https://zhidao.baidu.com/question/617440918557008172.html" target="_blank" rel="external">Service和IntentService中显示Toast的区别</a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestService</span><span class="params">()</span></span>&#123; <span class="comment">// 必须要有空参数构造函数，不然运行时异常</span></div><div class="line">        <span class="keyword">super</span>(<span class="string">"haha"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onBind"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onBind(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"oncreate"</span>);</div><div class="line">        System.out.println(<span class="string">"服务线程name:"</span>+Thread.currentThread().getName());</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onStart"</span>);</div><div class="line">        <span class="keyword">super</span>.onStart(intent, startId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onStartCommand"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"setIntentRedelivery"</span>);</div><div class="line">        <span class="keyword">super</span>.setIntentRedelivery(enabled);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123; <span class="comment">// Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务</span></div><div class="line">        System.out.println(<span class="string">"onHandleIntent"</span>);</div><div class="line">        System.out.println(<span class="string">"服务线程onHandleIntent name:"</span>+Thread.currentThread().getName());</div><div class="line"></div><div class="line">        String action = intent.getExtras().getString(<span class="string">"param"</span>);</div><div class="line">        <span class="keyword">if</span> (action.equals(<span class="string">"oper1"</span>)) &#123;</div><div class="line">            System.out.println(<span class="string">"Operation1"</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">"oper2"</span>)) &#123;</div><div class="line">            System.out.println(<span class="string">"Operation2"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 面试题：</span></div><div class="line">        <span class="comment">// 如天气app，onHandleIntent里放网络请求去查是否最新气象信息，</span></div><div class="line">        <span class="comment">// 但是onHandleIntent执行完就要onDestroy，但是请求的是异步任务，服务都销毁了如何回调呢？</span></div><div class="line">        <span class="comment">// 解决方案：睡眠定时，时间可比网络请求的超时时间长一些，然后回调函数通知页面刷新</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-----"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onDestroy"</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，别忘了配置Service，因为它继承于Service，所以，它还是一个Service，一定要配置，否则是不起作用的，开始我就是忘了，结果半天没反应。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=".IntentServiceDemo"&gt;</div><div class="line">      &lt;intent-filter &gt;</div><div class="line">          &lt;action android:name="com.test.intentservice"/&gt;</div><div class="line">      &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure></p>
<h2 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="http://www.jb51.net/article/76490.htm" target="_blank" rel="external">IntentService工作原理及源码解析</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IntentService可以在工作线程中完成工作而不阻塞主线程，<br>但是IntentService不能并行处理多个job，只能依次处理，一个接一个，<br>当所有的job完成后，会自动执行onDestroy方法而无需我们自己调用stopSelf()或stopSelf(startId)方法。<br>IntentService并不神秘，只是Android对一种常见开发方式的封装，便于开发人员减少开发工作量。<br>IntentService是个助手类，如果Android没有提供该类也没什么，我们自己也可以写一个类似的。<br>IntentService之余Service，类似于HandlerThread之于Handler。</p>
<h2 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.tuicool.com/articles/zeMFFvB" target="_blank" rel="external">Android中IntentService详解</a></p>
<hr>
<h1 id="接口回调机制"><a href="#接口回调机制" class="headerlink" title="接口回调机制"></a>接口回调机制</h1><hr>
<h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>监听器接口的回调函数（CallBack）</p>
<p>回调就是一件事件产生后给我们返回来的通知<br>回调就是我不想干，让别人去干这件事，就定义接口<br>方法带on….都是回调</p>
<p>如果写业务逻辑的时候，如果不关心它内部的是如何实现的，留下一个模板，就写一个接口，方法定义成抽象，然后把参数暴露出去<br>这种写法就叫回调函数（CallBack）</p>
<p>抽取接口定义回调函数（重要）<br>通过接口定义回调函数<br>回调函数就是不是我们的代码实现，而是由别的代码去实现。</p>
<p>对数据的异步处理的几个方法,他们都是通知机制<br>Handler机制<br>AsyncTask<br>IntentService<br>接口回调</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>1.单纯的通知<br>2.通知+传值</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.定义接口,以及接口方法<br>2.定义接口对象<br>3.在某一个地方.接口对象调用接口方法<br>4.暴露接口对象(构造方法,setter方法)</p>
<h2 id="接口回调实例"><a href="#接口回调实例" class="headerlink" title="接口回调实例"></a>接口回调实例</h2><h3 id="备份短信的进度条"><a href="#备份短信的进度条" class="headerlink" title="备份短信的进度条"></a>备份短信的进度条</h3><p>1.暴露接口<br>所谓接口无非就是一方在使用接口一方实现接口<br>这里以手机短信备份来讲<br>怎么在备份的工具类中得到短信的总条数和已经备份过的条数来供自己的程序使用呢(如设置<code>progressBar</code>显示备份进度等)    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsUtils</span> </span>&#123;</div><div class="line">    <span class="comment">// 在自己的程序中定义一个接口，并提供相应方法</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackUpStatusListener</span></span>&#123; <span class="comment">//在类中定义一个接口</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 在备份短信之前 max 总的进度</div><div class="line">        * <span class="doctag">@param</span> max</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">beforeBackup</span><span class="params">(<span class="keyword">int</span> max)</span></span>; </div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 正在备份的进度.</div><div class="line">        * <span class="doctag">@param</span> process</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onBackUpProcess</span><span class="params">(<span class="keyword">int</span> process)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 备份短信的工具方法</div><div class="line">     * <span class="doctag">@param</span> context 上下文</div><div class="line">     * <span class="doctag">@param</span> fos 备份到哪个文件输出流里面.</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backUp</span><span class="params">(Context context,FileOutputStream fos,BackUpStatusListener listener)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//在自己的方法中使用接口</span></div><div class="line">        ContentResolver resolver = context.getContentResolver();</div><div class="line">        Uri uri = Uri.parse(<span class="string">"content://sms/"</span>);</div><div class="line">        XmlSerializer serializer = Xml.newSerializer();</div><div class="line">        serializer.setOutput(fos, <span class="string">"utf-8"</span>);</div><div class="line">        serializer.startDocument(<span class="string">"utf-8"</span>, <span class="keyword">true</span>);</div><div class="line">        serializer.startTag(<span class="keyword">null</span>, <span class="string">"smss"</span>);</div><div class="line">        Cursor cursor = resolver.query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">"address"</span>,<span class="string">"date"</span>,<span class="string">"type"</span>,<span class="string">"body"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// pd.setMax(cursor.getCount());//设置初始化的总长度</span></div><div class="line">        listener.beforeBackup(cursor.getCount()); <span class="comment">// 调用接口中的方法，将短信的总条数传给接口的参数</span></div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(cursor.moveToNext())&#123;</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"sms"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"address"</span>);</div><div class="line">            String address = cursor.getString(<span class="number">0</span>);</div><div class="line">            serializer.text(address);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"address"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"date"</span>);</div><div class="line">            String date = cursor.getString(<span class="number">1</span>);</div><div class="line">            serializer.text(date);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"date"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"type"</span>);</div><div class="line">            String type = cursor.getString(<span class="number">2</span>);</div><div class="line">            serializer.text(type);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"type"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"body"</span>);</div><div class="line">            String body = cursor.getString(<span class="number">3</span>);</div><div class="line">            serializer.text(body);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"body"</span>);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"sms"</span>);</div><div class="line">            fos.flush();</div><div class="line">            total++;</div><div class="line">            <span class="comment">//pd.setProgress(total);</span></div><div class="line">            listener.onBackUpProcess(total);</div><div class="line">            <span class="comment">// 调用接口中的方法将已经备份了的短信数传递给相应方法的参数</span></div><div class="line">            <span class="comment">// 由于这个接口的实现类是由调用者实现的，这里是多态，真正执行的接口的方法是调用者实现的方法</span></div><div class="line">            <span class="comment">// 这里讲短信的数量传递给方法的参数，所以调用者就能再实现类的方法中通过参数得到短信数</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">        serializer.endTag(<span class="keyword">null</span>, <span class="string">"smss"</span>);</div><div class="line">        serializer.endDocument();</div><div class="line">        fos.flush();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.实现接口并实现相应的方法，直接就通过回调方法中的参数得到相应的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SmsUtils.backUp(getApplicationContext(), fos, <span class="keyword">new</span> BackUpStatusListener() &#123;</div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackUpProgress</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line">        pd.setProgress(process);<span class="comment">//通过方法中的参数我们就能得到数据</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeBackUp</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</div><div class="line">        pd.setMax(max);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义控件的点击事件"><a href="#自定义控件的点击事件" class="headerlink" title="自定义控件的点击事件"></a>自定义控件的点击事件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public interface OnYouKuItemClickedListener&#123;</div><div class="line">    public void onItemClicked(int viewid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MenuView&#123;</div><div class="line">    // 声明接口传递进来的实现类</div><div class="line">    private OnYouKuItemClickedListener mOnYouKuItemClickedListener;</div><div class="line"></div><div class="line">    // 暴露一个方法设置接口实现类</div><div class="line">    public void setOnYouKuItenClickedListener(OnYouKuItemClickedListener mOnYouKuItemClickedListener)&#123;</div><div class="line">        this.mOnYouKuItemClickedListener = mOnYouKuItenClickedListener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void OnClick(View v)&#123;</div><div class="line">        if(mOnYouKuItemClickedListener != null)&#123; // 做判断，如果没初始化会空指针</div><div class="line">            mOnYouKuItemClickedListener.onItemClicked(v.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">public class MainActivity extends Activity&#123;</div><div class="line">    private MenuView mMenuView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protexted void onCreate(Bundle savedInstanceState)&#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.ativity_main);</div><div class="line">        mMenuView = (Menu)findVieById(R.id.menuview);</div><div class="line">        mMenuView.setOnYouKuItemClickedListener(new OnYoukuItemClickedListener())&#123;</div><div class="line">            @Override</div><div class="line">            public void onItemClicked(int viewid)&#123;</div><div class="line">                switch(viewid)&#123;</div><div class="line">                    case R.id.iv_channel1:</div><div class="line">                        Toast.makeText(getApplicationContext(),"频道1被点击了”，0).show();</div><div class="line">                        break;</div><div class="line">                    case R.id.iv_channel2:</div><div class="line">                        Toast.makeText(getApplicationContext(),"频道2被点击了”，0).show();</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="用接口实现广播通知"><a href="#用接口实现广播通知" class="headerlink" title="用接口实现广播通知"></a>用接口实现广播通知</h3><p><a href="http://download.csdn.net/download/csm_qz/8797507" target="_blank" rel="external">用接口实现广播通知</a></p>
<h1 id="总结：各种界面不同的刷新UI方式和其它通知方式"><a href="#总结：各种界面不同的刷新UI方式和其它通知方式" class="headerlink" title="总结：各种界面不同的刷新UI方式和其它通知方式"></a>总结：各种界面不同的刷新UI方式和其它通知方式</h1><p>子线程不能直接更新UI, 要更新UI有2种方式<br>1.消息机制(Handler)<br>　HandlerThread<br>　AsyncTask<br>　IntentService<br>2: Activity的runOnUiThread方法 (更简单) </p>
<p>接口回调函数<br>广播通知<br>SharedPreferences的OnSharedPreferenceChangeListener</p>
<p>View：<br>　1.invalidate<br>　　主线程（UI线程）<br>　　旗下子类都继承此方法<br>　　如：<br>　　TextView<br>　　ViewDragHelper<br>　2.postInvalidate<br>　　子线程（非UI线程）</p>
<p>BaseAdapter：<br>　notifyDataSetChanged</p>
<p>PagerSlidingTabStrip：<br>　notifyDataSetChanged<br>　updateTabStyles</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_handler_logo.gif&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android —— Touch事件分发传递机制的总结</title>
    <link href="https://hengxing0080.github.io/2017/10/05/it/1.Android/Touch/"/>
    <id>https://hengxing0080.github.io/2017/10/05/it/1.Android/Touch/</id>
    <published>2017-10-05T08:48:13.000Z</published>
    <updated>2017-11-10T09:52:35.021Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_touch_logo.png" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="事件分发机制流程"><a href="#事件分发机制流程" class="headerlink" title="事件分发机制流程"></a>事件分发机制流程</h1><hr>
<h2 id="Touch的Down的传递的3个方法"><a href="#Touch的Down的传递的3个方法" class="headerlink" title="Touch的Down的传递的3个方法"></a>Touch的Down的传递的3个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatchTouchEvent       分发触摸事件（是否分发） （第一个调用）</div><div class="line">onInterceptTouchEvent    拦截触摸事件（是否拦截（打断）） （注意View没有此方法，ViewGroup有）</div><div class="line">onTouchEvent             响应触摸事件（是否消费）</div></pre></td></tr></table></figure>
<p>注意：<br>ViewGroup有3种方法<br>View只有2种方法（没有拦截触摸事件）</p>
<h2 id="默认事件传递"><a href="#默认事件传递" class="headerlink" title="默认事件传递"></a>默认事件传递</h2><p>是当产生了触摸事件之后，先给了最外层的布局，最外层的布局就把事件传给了第一个孩子，第一个孩子又再次传给里面的孩子<br>里面的孩子处理完之后就还给它父亲，父亲在传给父亲<br>就是从外到内，从内到外<br><img src="/images/it_android_touch1.png" alt="UML图"></p>
<p>注意：<br>触摸事件有2次：ACTION_UP，ACTION_DOWN<br>所以会打印2次</p>
<p>详细流程图例请查看最上面头图</p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/touch-event-delivery-mechanism/" target="_blank" rel="external">Android Touch事件传递机制</a></p>
<hr>
<h1 id="点击事件和触摸事件"><a href="#点击事件和触摸事件" class="headerlink" title="点击事件和触摸事件"></a>点击事件和触摸事件</h1><hr>
<p>现在的图形界面应用程序，都是通过事件来实现人机交互的。<br>事件就是用户对图形界面的操作，在android手机和平板电脑上主要包括键盘事件和触摸事件两大类。<br>键盘事件包括按下，弹起等，触摸事件包括按下，弹起，滑动，双击等。</p>
<p>对于一个标准的android设备，包含了多个能够触发事件的物理按键：<br>KEYCODE_POWER：电源键–启动或唤醒设备，将界面切换到锁定的屏幕<br>KEYCODE_BACK：后退键–返回到当前一个界面<br>KEYCODE_MENU：菜单键–显示当前应用的可用菜单<br>KEYCODE_HOME：Home键–返回到Home界面<br>KEYCODE_VOLUME_UP：   音量键–控制当前上文的音量<br>KEYCODE_VOLUME_DOWN： 音量键–控制当前下文的音量</p>
<p>键盘事件：<br>Android中控件在处理物理按键事件时，提供的回调方法有onKeyUp(),onKeyDown()和onKeyLongPress();</p>
<p>触摸事件：<br>目前，主流的手机都以较大的屏幕取代了外置键盘，平板电脑也没有提供键盘，这些设备都需要通过触摸来操作。<br>对于触摸屏上的按钮，可以使用onClickListener和onLongClickListener监听器分别处理用户短时间单击（按住按钮一段时间）事件。<br>View类是其他android控件的分类。<br>在该类中，定义了setOntouchListener()方法用来为控件设置触摸事件监听。</p>
<h2 id="点击事件的6种实现方式"><a href="#点击事件的6种实现方式" class="headerlink" title="点击事件的6种实现方式"></a>点击事件的6种实现方式</h2><p>1.设置按钮的单击事件的监听器，创建匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">bt_call.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">		<span class="comment">// 拨打电话号码</span></div><div class="line">		String phone = et_phone.getText().toString().trim();</div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(); </div><div class="line">		intent.setAction(Intent.ACTION_CALL);</div><div class="line">		System.out.println(<span class="string">"phone="</span>+phone);</div><div class="line">		intent.setData(Uri.parse(<span class="string">"tel://"</span>+phone));</div><div class="line">		startActivity(intent);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>2.创建一个内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyOnClickListener</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">		String phone = et_phone.getText().toString().trim();</div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(); </div><div class="line">		intent.setAction(Intent.ACTION_CALL);</div><div class="line">		System.out.println(<span class="string">"phone="</span>+phone);</div><div class="line">		intent.setData(Uri.parse(<span class="string">"tel://"</span>+phone));</div><div class="line">		startActivity(intent);			</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按钮添加一个单击事件的监听器</span></div><div class="line">bt_call.setOnClickListener(<span class="keyword">new</span> MyOnClickListener());</div></pre></td></tr></table></figure></p>
<p>3.在布局文件中给按钮添加一个单击事件的响应方法，然后在代码中实现这个方法<br>(3.1)在布局文件中给按钮添加一个单击事件的响应方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Button </div><div class="line">   android:layout_width=<span class="string">"match_parent"</span></div><div class="line">   android:layout_height=<span class="string">"wrap_content"</span></div><div class="line">   android:text=<span class="string">"拨打"</span></div><div class="line">   android:id=<span class="string">"@+id/bt_call"</span></div><div class="line">   android:onClick=<span class="string">"call"</span></div><div class="line">  /&gt;</div></pre></td></tr></table></figure></p>
<p>(3.2)在代码中实现这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(View view)</span></span>&#123;</div><div class="line">	String phone = et_phone.getText().toString().trim();</div><div class="line">	Intent intent = <span class="keyword">new</span> Intent(); </div><div class="line">	intent.setAction(Intent.ACTION_CALL);</div><div class="line">	System.out.println(<span class="string">"phone="</span>+phone);</div><div class="line">	intent.setData(Uri.parse(<span class="string">"tel://"</span>+phone));</div><div class="line">	startActivity(intent);		</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.实现OnClickListener接口，重写onClick方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;  </div><div class="line">     <span class="keyword">private</span> Button button;  </div><div class="line">     <span class="meta">@Override</span>  </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">          <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">          setContentView(R.layout.activity_main);  </div><div class="line">          button = (Button)findViewById(R.id.button1);  </div><div class="line">          button.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">     &#125;  </div><div class="line">  </div><div class="line">     <span class="meta">@Override</span>  </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">          Toast.makeText(getApplication(), <span class="string">"OnClick"</span>, Toast.LENGTH_LONG).show();  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.写在成员变量上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">     <span class="keyword">private</span> Button button;  </div><div class="line">     <span class="keyword">private</span> OnClickListener clickListener = <span class="keyword">new</span> OnClickListener() &#123;  </div><div class="line">          <span class="meta">@Override</span>  </div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">  </div><div class="line">          &#125;  </div><div class="line">     &#125;;  </div><div class="line">     <span class="meta">@Override</span>  </div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">          <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">          button = (Button)findViewById(R.id.button1);  </div><div class="line">          button.setOnClickListener(clickListener);    </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.XUtils的注入（事件绑定）</p>
<p>取消了之前使用方法名绑定事件的方式，使用id绑定不受混淆影响<br>支持绑定多个id @OnClick({R.id.id1, R.id.id2, R.id.id3}) or @OnClick(value={R.id.id1, R.id.id2, R.id.id3}, parentId={R.id.pid1, R.id.pid2, R.id.pid3})</p>
<p>更多事件支持参见ViewCommonEventListener类和com.lidroid.xutils.view.annotation.event。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OnClick</span>(R.id.item_category_item_1)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickItem1</span><span class="params">(View view)</span></span>&#123;</div><div class="line">    Toast.makeText(UIUtils.getContext(),mData.name1,Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@OnClick</span>(R.id.item_category_item_2)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickItem2</span><span class="params">(View view)</span></span>&#123;</div><div class="line">    Toast.makeText(UIUtils.getContext(),mData.name2,Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@OnClick</span>(R.id.item_category_item_3)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickItem2</span><span class="params">(View view)</span></span>&#123;</div><div class="line">    Toast.makeText(UIUtils.getContext(),mData.name3,Toast.LENGTH_SHORT).show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><h3 id="模板写法"><a href="#模板写法" class="headerlink" title="模板写法"></a>模板写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">iv.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当触摸到这控件时会调用这个方法</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> action = event.getAction();</div><div class="line">        <span class="comment">// int action = event.getAction()&amp;MotionEvent.ACTION_MASK;  // 多点触控的情况下这么写</span></div><div class="line">		<span class="keyword">switch</span> (action) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: <span class="comment">// 按下的事件类型</span></div><div class="line">                showMsg(<span class="string">"ACTION_DOWN"</span> + action);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: <span class="comment">// 移动的事件类型</span></div><div class="line">                <span class="keyword">int</span> newX = (<span class="keyword">int</span>) event.getX();  <span class="comment">// 获取相对与拖动组件的坐标</span></div><div class="line">                <span class="keyword">int</span> newY = (<span class="keyword">int</span>) event.getY();</div><div class="line">        </div><div class="line">                <span class="comment">//event.getRawX(); //获取相对与屏幕的坐标</span></div><div class="line"></div><div class="line">                showMsg(<span class="string">"ACTION_MOVE"</span> + action);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: <span class="comment">// 离开的事件类型</span></div><div class="line">                showMsg(<span class="string">"ACTION_UP"</span> + action);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:</div><div class="line">                showMsg(<span class="string">"ACTION_POINTER_UP"</span> + action);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN:</div><div class="line">                showMsg(<span class="string">"ACTION_POINTER_DOWN"</span> + action);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: <span class="comment">// 手指松开</span></div><div class="line">                showMsg(<span class="string">"ACTION_CANCEL"</span> + action);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 如果返回true表示当前事件已经消费掉了</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;    </div><div class="line">        <span class="comment">// return super.onTouchEvent(event);  // 默认的情况下返回false</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="多点触控"><a href="#多点触控" class="headerlink" title="多点触控"></a>多点触控</h3><p>ACTION_MASK在Android中是应用于多点触摸操作，字面上的意思大概是动作掩码的意思。</p>
<p>在onTouchEvent(MotionEvent event)中<br>使用switch (event.getAction())可以处理ACTION_DOWN和ACTION_UP事件；<br>使用switch (event.getAction() &amp; MotionEvent.ACTION_MASK)，就可以处理处理多点触摸的ACTION_POINTER_DOWN和ACTION_POINTER_UP事件。 </p>
<p>ACTION_DOWN和ACTION_UP就是单点触摸屏幕，按下去和放开的操作；</p>
<p>ACTION_POINTER_DOWN和ACTION_POINTER_UP就是多点触摸屏幕，当有一只手指按下去的时候，另一只手指按下和放开的动作捕捉；</p>
<p>原理是用AND位运算</p>
<p>首先来看看这些常量的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ACTION_MASK     <span class="number">0x000000ff</span></div><div class="line"></div><div class="line">ACTION_DOWN     <span class="number">0x00000000</span>         </div><div class="line">ACTION_UP      <span class="number">0x00000001</span>      </div><div class="line"></div><div class="line">ACTION_MOVE      <span class="number">0x00000002</span></div><div class="line"></div><div class="line">ACTION_POINTER_DOWN       <span class="number">0x00000005</span>            </div><div class="line">ACTION_POINTER_UP        <span class="number">0x00000006</span></div><div class="line"></div><div class="line">ACTION_POINTER_1_DOWN     <span class="number">0x00000005</span>            </div><div class="line">ACTION_POINTER_1_UP      <span class="number">0x00000006</span></div><div class="line"></div><div class="line">ACTION_POINTER_2_DOWN     <span class="number">0x00000105</span>            </div><div class="line">ACTION_POINTER_2_UP      <span class="number">0x00000106</span></div></pre></td></tr></table></figure></p>
<p>例如：ACTION_MASK &amp; ACTION_POINTER_2_DOWN 即0x000000ff &amp; 0×00000105=0x0000005</p>
<p>可以看到，and运算的结果总是小于等于0x000000ff，那就是说and之后，无论你多少根手指加进来，都是会ACTION_POINTER_DOWN或者ACTION_POINTER_UP</p>
<p>相关文章：<br><a href="http://blog.csdn.net/fancylovejava/article/details/38582983" target="_blank" rel="external">android多点触控统一的原理(使用 event.getAction()&amp;MotionEvent.ACTION_MASK的原因)</a><br><a href="http://blog.csdn.net/lsmfeixiang/article/details/42213893" target="_blank" rel="external">多点触控事件处理 ev.getAction() &amp; MotionEvent.ACTION_MASK</a></p>
<h3 id="OnTouchListener-OnClickListener和OnLongClickListener的关系"><a href="#OnTouchListener-OnClickListener和OnLongClickListener的关系" class="headerlink" title="OnTouchListener,OnClickListener和OnLongClickListener的关系"></a>OnTouchListener,OnClickListener和OnLongClickListener的关系</h3><p>在Android中，一切事件处理的开始都是从Down事件开始的，如何你处理了Down事件，其他的事件就都收不到了</p>
<p>Touch事件的ACTION_DOWN -&gt; ACTION_UP -&gt; OnClick/OnLongClick。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/liyuchong2537631/article/details/48463169" target="_blank" rel="external">Android中事件传递机制的总结（onTouch、onClick、onLongClick等）</a><br><a href="Android OnTouchListener，OnClickListener和OnLongClickListener的关系">Android OnTouchListener，OnClickListener和OnLongClickListener的关系</a><br><a href="Android onTouchEvent, onClick及onLongClick的调用机制">Android onTouchEvent, onClick及onLongClick的调用机制</a></p>
<h3 id="判断该事件是滑动事件还是点击事件"><a href="#判断该事件是滑动事件还是点击事件" class="headerlink" title="判断该事件是滑动事件还是点击事件"></a>判断该事件是滑动事件还是点击事件</h3><p><a href="http://blog.csdn.net/zdb1193452522/article/details/41893041" target="_blank" rel="external">Android中onTouch事件、onClick事件、onLongClick事件区别以及联系</a></p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="http://blog.csdn.net/guolin_blog/article/details/11100327" target="_blank" rel="external">Android多点触控技术实战，自由地对图片进行缩放和移动</a></p>
<hr>
<h1 id="View的滑动原理及效果"><a href="#View的滑动原理及效果" class="headerlink" title="View的滑动原理及效果"></a>View的滑动原理及效果</h1><hr>
<p><a href="http://www.jianshu.com/p/4c7aa2eff9c6" target="_blank" rel="external">[Android] 滑动操作的原理及处理</a></p>
<h2 id="View的滑动返回"><a href="#View的滑动返回" class="headerlink" title="View的滑动返回"></a>View的滑动返回</h2><p>方式1：GestureDetector<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.声明一个手势识别器</span></div><div class="line"><span class="keyword">private</span> GestureDetector mGestureDetector;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"> 	initGesture();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGesture</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">// 2.初始化手势识别器（在内存中new个对象）</span></div><div class="line">    mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener()&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 滑行 滑翔 (手指在屏幕上滑动) e1 / e2:手指的事件</div><div class="line">         * e1:手指第一次触摸屏幕</div><div class="line">         * e2:手指离开屏幕的一瞬间 velocityX / elocityY:水平和竖直方向速度 单位px/s (每秒多少像素)</div><div class="line">         */</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>&#123;</div><div class="line">            <span class="keyword">if</span> (Math.abs(e1.getRawY() - e2.getRawY()) &gt; <span class="number">100</span>)&#123; <span class="comment">//大于100才滑动，竖着滑动无效</span></div><div class="line">                ToastUtil.show(OwnInfoGenderActivity.<span class="keyword">this</span>, <span class="string">"动作不合法"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (e1.getRawX() - e2.getRawX() &gt; <span class="number">150</span>)&#123; <span class="comment">// 从右向左滑动150个像素(这样才认为是个有效的动作),显示下一个界面</span></div><div class="line">                finish();</div><div class="line">                overridePendingTransition(R.anim.trans_pre_in, R.anim.trans_pre_out);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;*</div><div class="line">            <span class="keyword">if</span> (e2.getRawX() - e1.getRawX() &gt; <span class="number">150</span>) &#123; <span class="comment">// 从左向右滑动150个像素,显示上一个界面</span></div><div class="line">                finish();</div><div class="line">                overridePendingTransition(R.anim.trans_pre_in_back, R.anim.trans_pre_out_back);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onFling(e1, e2, velocityX, velocityY);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.使用手势识别器识别用户的动作（只要Activity被触摸，都会调用这个方法）</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</div><div class="line">    mGestureDetector.onTouchEvent(event); <span class="comment">//关键代码</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方式2：<br><a href="http://blog.csdn.net/hanhailong726188/article/details/46433229" target="_blank" rel="external">Android-通过SlidingPaneLayout高仿微信6.2最新版手势滑动返回(一)</a><br><a href="http://blog.csdn.net/hanhailong726188/article/details/46453627" target="_blank" rel="external">Android-通过SlidingMenu高仿微信6.2最新版手势滑动返回(二)</a></p>
<h2 id="View的弹性滑动"><a href="#View的弹性滑动" class="headerlink" title="View的弹性滑动"></a>View的弹性滑动</h2><p>待整理</p>
<h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><p>待整理</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_touch_logo.png&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android —— 开放云平台篇</title>
    <link href="https://hengxing0080.github.io/2017/10/04/it/1.Android/OpenColud/"/>
    <id>https://hengxing0080.github.io/2017/10/04/it/1.Android/OpenColud/</id>
    <published>2017-10-04T07:11:16.000Z</published>
    <updated>2017-11-08T13:55:03.858Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_opencloud_logo1.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>开放平台（Open Platform）<br>在软件业和网络中，开放平台是指软件系统通过公开其应用程序编程接口（API）或函数（function)来使外部的程序可以增加该软件系统的功能或使用该软件系统的资源，而不需要更改该软件系统的源代码。</p>
<p>开发平台的作用:提供功能,提供资源</p>
<p><img src="/images/it_android_opencloud_logo2.png" alt="UML图"></p>
<h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><ul>
<li><p>OSS<br>Open Source Software，开源软件（开放源代码软件）</p>
</li>
<li><p>bucket<br>Bucket是OSS上的命名空间，也是计费、权限控制、日志记录等高级功能的管理实体；Bucket名称在整个OSS服务中具有全局唯一性，且不能修改；<br>存储在OSS上的每个Object必须都包含在某个Bucket中。<br>一个应用，例如图片分享网站，可以对应一个或多个Bucket。<br>一个用户最多可创建10个Bucket，但每个Bucket中存放的Object的数量和大小总和没有限制，用户不需要考虑数据的可扩展性。<br>命名规范<br>Bucket的命名有以下规范：<br>只能包括小写字母，数字，短横线（-）<br>必须以小写字母或者数字开头<br>长度必须在3-63字节之间</p>
</li>
<li><p>appid<br>软件的ID编号<br>标记你的开发者账号的, 是你的用户id, 这个id 在数据库添加检索, 方便快速查找<br>简化的场景:省去 app_id, 他默认每一个用户有且仅有一套权限配置, 所以直接将 app_id = app_key , 然后外加一个app_secret就够了. </p>
</li>
<li><p>appkey<br>调用服务所需要的密钥。<br>一个用户只有一个appkey，可以调用平台所有即用服务.<br>app_key 和 app_secret 是一对出现的账号, 同一个 app_id 可以对应多个 app_key+app_secret, 这样 平台就可以分配你不一样的权限, 比如 app_key1 + app_secect1 只有只读权限 但是 app_key2+app_secret2 有读写权限.. 这样你就可以把对应的权限 放给不同的开发者.  其中权限的配置都是直接跟app_key 做关联的, app_key 也需要添加数据库检索, 方便快速查找<br>简化的场景:省去app_id 和 app_key,  相当于 app_id = app_key = app_secret,  通常用于开放性接口的地方, 特别是很多地图类api 都采用这种模式, 这种模式下, 带上app_id 的目的仅仅是统计 某一个用户调用接口的次数而已了.</p>
</li>
<li><p>appsecret<br>签名的密钥<br>至于为什么 要有app_key + app_secret 这种成对出现的机制呢, 因为 要加密, 通常 在首次验证(类似登录场景) , 你需要用 app_key(标记要申请的权限有哪些) + app_secret(密码, 表示你真的拥有这个权限) 来申请一个token, 就是我们经常用到的 access_token, 之后的数据请求, 就直接提供access_token 就可以验证权限了.</p>
</li>
<li><p>accessToken<br>是啥,干嘛用?<br>形象解释:申请调兵–&gt;皇帝同意–&gt;兵符–&gt;开始调兵<br>拿到用户在第三方平台的唯一的标识;<br>获取用户的nickname,头像,邮箱等其他信息;</p>
</li>
</ul>
<hr>
<h1 id="即时通讯（IM）"><a href="#即时通讯（IM）" class="headerlink" title="即时通讯（IM）"></a>即时通讯（IM）</h1><hr>
<p>即时通讯原理：<br>永远是客户端与服务器主动建立一个长连接，客户端和服务器就连在一起了，<br>客户端1发给服务器，然后服务器转给客户端2<br>这样2个通路保持畅通了</p>
<p>他们都是使用了长连接，心跳包等</p>
<p>长连接的建立：TCP或UDP</p>
<p>数据流向：<br>展示在手机上的数据都是在服务器上提供的<br>第一步就是向服务器发请求</p>
<p>客户端（Client）： 手机端，PC端<br>服务端（Server）： Web端</p>
<p>家里上网，还有手机的IP是动态分配的（连着wifi，分配一个动态公网的IP）<br>服务器不一样，IP是固定的</p>
<p>即时通讯相关的优化服务：负载均衡<br>客户端1先去连接务器1，不过服务器1已经饱和了，所有服务器1又把数据转给服务器2，由服务器2发给客户端2<br>不过客户端一开始不知道哪个服务器饱和了<br>所以去连接服务器之前先去访问负载均衡服务器（它负载轮询所有的socket服务器，定时去访问各个服务器看看谁饱和了（谁闲，谁忙），<br>然后这个数据返回给负载均衡服务器，然后它排列个优先级看看谁最高）去问问服务器哪台没有饱和（负载最小）<br>这样的话因为先问过负载均衡服务器已经得到结果，客户端1去访问服务器1，客户端2去访问服务器2</p>
<h2 id="相关云服务商"><a href="#相关云服务商" class="headerlink" title="相关云服务商"></a>相关云服务商</h2><h3 id="阿里悟空"><a href="#阿里悟空" class="headerlink" title="阿里悟空"></a>阿里悟空</h3><p>已倒闭</p>
<h3 id="阿里融云"><a href="#阿里融云" class="headerlink" title="阿里融云"></a>阿里融云</h3><p>地址：<a href="http://www.rongcloud.cn/" target="_blank" rel="external">http://www.rongcloud.cn/</a></p>
<h3 id="环信"><a href="#环信" class="headerlink" title="环信"></a>环信</h3><p>地址：<a href="https://www.easemob.com/" target="_blank" rel="external">https://www.easemob.com/</a></p>
<h3 id="网易云信"><a href="#网易云信" class="headerlink" title="网易云信"></a>网易云信</h3><p>地址：<a href="http://netease.im/" target="_blank" rel="external">http://netease.im/</a></p>
<h3 id="极光IM"><a href="#极光IM" class="headerlink" title="极光IM"></a>极光IM</h3><p>地址：<a href="https://www.jiguang.cn/im" target="_blank" rel="external">https://www.jiguang.cn/im</a></p>
<h3 id="容联云通讯"><a href="#容联云通讯" class="headerlink" title="容联云通讯"></a>容联云通讯</h3><p>地址：<a href="http://www.yuntongxun.com/" target="_blank" rel="external">http://www.yuntongxun.com/</a></p>
<h1 id="消息推送（Push）"><a href="#消息推送（Push）" class="headerlink" title="消息推送（Push）"></a>消息推送（Push）</h1><h2 id="消息推送机制简介"><a href="#消息推送机制简介" class="headerlink" title="消息推送机制简介"></a>消息推送机制简介</h2><p>外文名push</p>
<p>所谓信息推送，就是”web广播”，是通过一定的技术标准或协议，在互联网上通过定期传送用户需要的信息来减少信息过载的一项新技术。推送技术通过自动传送信息给用户，来减少用于网络上搜索的时间。它根据用户的兴趣来搜索、过滤信息，并将其定期推给用户，帮助用户高效率地发掘有价值的信息。</p>
<p>常见的新闻客户端应用用Noticifcations发来的消息，就是服务器把数据推到手机里来了，APP中在网络获取所有的操作都是客户端发数据给服务器，然后服务器返回数据<br>客户端是主动的，想要就发信息要<br>但是，消息推送是相反的，客户端不想要，服务器主动把消息发给你客户端<br>就是说现在服务器是主动方<br>理论上服务器有固定IP，客户端没有固定IP无法访问<br>就是说服务器一旦断了客户端就找不到了，因为手机的IP是动态改变的（一会wifi，一会3G网络）</p>
<p>相关文章：<br><a href="http://www.jianshu.com/p/584707554ed7" target="_blank" rel="external">Android推送技术研究</a></p>
<h2 id="消息推送原理"><a href="#消息推送原理" class="headerlink" title="消息推送原理"></a>消息推送原理</h2><p>长连接（即时通讯和消息推送的原理都是这个）<br>手机推送服务的原理很简单，就是通过建立一条手机与服务器的连接链路，当有消息需要发送到手机时，通过此链路发送即可。 </p>
<p>首先主动方客户端先发请求到极光推送的服务端，和它保持一个长连接（不会断的连接），这时手机的相关信息已经和它绑在一起了<br>服务端想发新闻给客户端，不过它会先发给极光推送服务器，告诉它给某个手机发消息，<br>找到对应绑定的手机通过长连接在把信息推送给客户端<br>发给连接的主动方永远是客户端，发给长连接就是和极光服务器保持了连接，新闻数据就会通过连接的管道传给客户端<br>就是靠第三方做了下周转</p>
<p>如果没有极光推送的服务器，就是客户端和服务端保持长连接，也能用极光推送，但是不能保持消息实时到达，可能会延迟一段时间</p>
<h3 id="IOS消息推送过程"><a href="#IOS消息推送过程" class="headerlink" title="IOS消息推送过程"></a>IOS消息推送过程</h3><p>Android推送服务的使用流程虽然略有差别但是大致都和IOS的APNS相似<br>1、首先是应用程序注册消息推送。<br>2、 IOS跟APNS Server要deviceToken。应用程序接受deviceToken。<br>3、应用程序将deviceToken发送给PUSH服务端程序。<br>4、 服务端程序向APNS服务发送消息。<br>5、APNS服务将消息发送给iPhone应用程序Push service方案评价标准</p>
<p>相关术语：</p>
<ul>
<li><p>长连接<br>使用socket请求时, 服务端和客户端都不主动关闭输入输出流, 从而实现长连接</p>
</li>
<li><p>心跳包<br>客户端每隔一段时间(比如1分钟)向服务器发送一段极短的数据,称为心跳包. 服务器收到数据, 就证明客户端还活着, 就会保持连接,向客户端推送消息. 否则断开</p>
</li>
<li><p>XMPP协议<br>一种基于TCP/IP的应用层协议, 专门用于消息推送, 数据格式为xml（其实xmpp协议就是一个xml格式的数据）。<br>如我之前写的通信的协议是公司按照xmpp开放协议的基础上修改的，</p>
</li>
<li><p>GCM<br>google cloud message  负责长连接，Google 的原生推送（C2DM，现在的 GCM），在中国被屏蔽了，由于种种原因不能正常使用，当时的 Android 开发者使用各种办法来解决这个问题，其中就包括 Android 手机厂商开发出自己的推送方案。</p>
</li>
</ul>
<h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><p>为什么用云平台实现？<br>后台推送的原理都是相同的，就是让客户端和服务器保持一个长连接，当服务器想要推送的时候，就发送一条消息到指定客户端就可以了。<br>虽说原理相同，但Android的推送要更加复杂一些，因为iOS系统中已经内置好了推送功能，只需要使用提供好的API就能简单地完成推送功能。而Android虽说也提供了类似的GCM服务，但由于在国内使用受到很多限制，所以推送还是要自己做的。<br>不过目前国内也有一些第三方的推送平台，使用它们的话也可以很简单地完成推送功能。</p>
<p>推送心跳包是TCP包还是UDP包或者HTTP包？<br>心跳包的实现是调用了socket.sendUrgentData(0xFF)这句代码实现的，所以，当然是TCP包。<br>相关文章：android 心跳的分析</p>
<h2 id="相关云平台"><a href="#相关云平台" class="headerlink" title="相关云平台"></a>相关云平台</h2><h3 id="极光推送（JPush）"><a href="#极光推送（JPush）" class="headerlink" title="极光推送（JPush）"></a>极光推送（JPush）</h3><p>地址：<a href="https://www.jpush.cn/" target="_blank" rel="external">https://www.jpush.cn/</a></p>
<p>极光推送的集成步骤:<br>1.看文档：<a href="https://www.jpush.cn/" target="_blank" rel="external">https://www.jpush.cn/</a></p>
<p>2.步骤<br>2.1. 注册Jpush账户<br>2.2. 新建应用<br>2.3. sdk的下载<br>2.4. 导入 SDK 开发包到你自己的应用程序项目<br>2.5. 配置 AndroidManifest.xml</p>
<p>3.功能<br>3.1. 发送通知<br>3.2. 自定义的消息</p>
<p>看它的开发文档得知是用服务做长连接：<br><img src="/images/it_android_opencloud1.png" alt="UML图"></p>
<p>官方图示：<br><img src="/images/it_android_opencloud2.png" alt="UML图"></p>
<h3 id="腾讯信鸽（XG-Push）"><a href="#腾讯信鸽（XG-Push）" class="headerlink" title="腾讯信鸽（XG Push）"></a>腾讯信鸽（XG Push）</h3><p>官方首页<br><a href="http://xg.qq.com/xg" target="_blank" rel="external">http://xg.qq.com/xg</a></p>
<p>下载SDK<br><a href="http://xg.qq.com/xg/ctr_index/download" target="_blank" rel="external">http://xg.qq.com/xg/ctr_index/download</a></p>
<p>官方文档：<br><a href="http://developer.qq.com/wiki/xg/Android%E6%8E%A5%E5%85%A5/Android%20SDK%E5%BF%AB%E9%80%9F%E6%8E%A5%E5%85%A5/Android%20SDK%E5%BF%AB%E9%80%9F%E6%8E%A5%E5%85%A5.html" target="_blank" rel="external">http://developer.qq.com/wiki/xg/Android%E6%8E%A5%E5%85%A5/Android%20SDK%E5%BF%AB%E9%80%9F%E6%8E%A5%E5%85%A5/Android%20SDK%E5%BF%AB%E9%80%9F%E6%8E%A5%E5%85%A5.html</a></p>
<p>管理推送<br><a href="http://xg.qq.com/xg/apps/ctr_app/index" target="_blank" rel="external">http://xg.qq.com/xg/apps/ctr_app/index</a></p>
<h3 id="百度推送"><a href="#百度推送" class="headerlink" title="百度推送"></a>百度推送</h3><p>地址：<a href="http://push.baidu.com/" target="_blank" rel="external">http://push.baidu.com/</a></p>
<h3 id="小米推送"><a href="#小米推送" class="headerlink" title="小米推送"></a>小米推送</h3><p>地址：<a href="https://dev.mi.com/console/" target="_blank" rel="external">https://dev.mi.com/console/</a></p>
<h3 id="云巴推送"><a href="#云巴推送" class="headerlink" title="云巴推送"></a>云巴推送</h3><p>地址：<a href="https://yunba.io/" target="_blank" rel="external">https://yunba.io/</a></p>
<p>专注于为需要实时数据交换的产品提供完美解决方案<br>基于发布者/订阅者(publisher/subscriber)模式，集成简单</p>
<h3 id="个推"><a href="#个推" class="headerlink" title="个推"></a>个推</h3><p>地址：<a href="http://www.getui.com/cn/index.html" target="_blank" rel="external">http://www.getui.com/cn/index.html</a></p>
<h3 id="LeanCloud"><a href="#LeanCloud" class="headerlink" title="LeanCloud"></a>LeanCloud</h3><p>国内产品，这个没实际用过，身边朋友反馈很好。</p>
<h3 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h3><p>国外产品，FB也在用，30qps免费限制，一般中小应用够用。</p>
<hr>
<h1 id="移动支付（Pay）"><a href="#移动支付（Pay）" class="headerlink" title="移动支付（Pay）"></a>移动支付（Pay）</h1><hr>
<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><p>地址：<a href="https://pay.weixin.qq.com/" target="_blank" rel="external">https://pay.weixin.qq.com/</a></p>
<h2 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h2><p>地址：<a href="https://open.alipay.com/platform/home.htm" target="_blank" rel="external">https://open.alipay.com/platform/home.htm</a></p>
<h2 id="payssion"><a href="#payssion" class="headerlink" title="payssion"></a>payssion</h2><p>国外产品，专业做海外跨境收款的，能省很多事。</p>
<h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping++"></a>Ping++</h2><p>地址：<a href="https://www.pingxx.com/" target="_blank" rel="external">https://www.pingxx.com/</a></p>
<h2 id="汇付宝（heepay）"><a href="#汇付宝（heepay）" class="headerlink" title="汇付宝（heepay）"></a>汇付宝（heepay）</h2><p>地址：<a href="https://www.heepay.com/" target="_blank" rel="external">https://www.heepay.com/</a></p>
<h2 id="威富通（swiftpass）"><a href="#威富通（swiftpass）" class="headerlink" title="威富通（swiftpass）"></a>威富通（swiftpass）</h2><p>地址：<a href="http://www.swiftpass.cn/" target="_blank" rel="external">http://www.swiftpass.cn/</a></p>
<hr>
<h1 id="地图定位（Map）"><a href="#地图定位（Map）" class="headerlink" title="地图定位（Map）"></a>地图定位（Map）</h1><hr>
<h2 id="百度地图"><a href="#百度地图" class="headerlink" title="百度地图"></a>百度地图</h2><p>地址：<a href="http://developer.baidu.com/map/" target="_blank" rel="external">http://developer.baidu.com/map/</a></p>
<h2 id="高德地图"><a href="#高德地图" class="headerlink" title="高德地图"></a>高德地图</h2><p>地址：<a href="http://lbs.amap.com/" target="_blank" rel="external">http://lbs.amap.com/</a></p>
<p>GPS+基站+wifi的混合定位方式<br>接入简单</p>
<hr>
<h1 id="第三方登录（Auth）"><a href="#第三方登录（Auth）" class="headerlink" title="第三方登录（Auth）"></a>第三方登录（Auth）</h1><hr>
<h2 id="OAuth授权机制"><a href="#OAuth授权机制" class="headerlink" title="OAuth授权机制"></a>OAuth授权机制</h2><p>英文名：Open Authorization<br>本质：一种开放的协议<br>对象：第三方可以使用OAUTH认证服务<br>语言：PHP、JavaScript，Java<br>特点：安全的、开放而又简易<br>类似协议：Flickr Auth</p>
<p>如果要完成授权之类的东西就用这个协议</p>
<p>OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。<br>目前最新版本是OAuth2.0</p>
<p>Oauth的产生背景<br><img src="/images/it_android_opencloud3.png" alt="UML图"></p>
<p>Oauth2.0授权流程<br>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器(比如qq登录,那就是腾讯)申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
<p>Oauth2.0涉及的角色<br>（1）Third-party application：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。<br>（2）HTTP service：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。<br>（3）Resource Owner：资源所有者，本文中又称”用户”（user）。<br>（4）User Agent：用户代理，本文中就是指浏览器。<br>（5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。<br>（6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
<p>相关文章：<br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="external">理解OAuth 2.0</a></p>
<h2 id="正常登录"><a href="#正常登录" class="headerlink" title="正常登录"></a>正常登录</h2><p>核心是会话的维持（维持一个登录状态）</p>
<p>Javaweb中如何去维持登录状态：<br>1.登录后 信息放入 session中<br>2.页面内验证session中是否有登录信息<br>3.如果有,不需要再次登录<br>4.如果没有,跳转登录页面<br>5.如果登录后点击注销,删除session中登录信息,并清除页面缓存(必要的)</p>
<p>Javaweb中哪些情况我们的session会过期:<br>1.过期–&gt;很长时间没有去访问网站<br>2.主动关闭–&gt;用处注销<br>3.切换浏览器</p>
<p>手机端如何维持登录状态:<br>登录成功之后,在成功的结果里面会附加一个sessionKey/tokenKey的字段;<br>登录协议都会返回sessionKey，<br>前端如果没有这个，相当于没有走webview<br>没有cookie是怎么维持登录状态的，就是这个sessionKey（或者叫token）<br>客户端登录状态是怎么维持的，就是上面这些，<br>怎么去用是下面4种情况<br>1.登录登录.需要保存sessionKey到sp–&gt;保存sessionkey<br>2.判断sessionKey是否存在sp中,存在,服务器判断是否过期,过期,要求用户重新登录;<br>3.判断sessionKey是否存在sp中,存在,服务器判断是否过期,不过期,继续走流程;<br>4.判断sessionKey是否存在sp中,不存在,要求用户登录,登录完成保存sessionkey;</p>
<p>验证 码登录/注册 流程：<br>1.用户填写手机号,点击发送验证码,发送请求把手机号传到server<br>2.server调用短信平台的接口知道 发送内容和发送对象,完成短信的发送<br>3.用户收到短信,得到验证码,填写验证码,发送请求把 手机号和验证码 上传到server<br>4.server判断我们的验证码是否正确和验证是否过期,根据不同的判断,返回不同的结果<br><img src="/images/it_android_opencloud4.png" alt="UML图"></p>
<h2 id="第三方登录简介"><a href="#第三方登录简介" class="headerlink" title="第三方登录简介"></a>第三方登录简介</h2><p>用qq号/微信号/微博号去登录自己的应用<br>核心:就是拿到access token，上传到我们的服务器，只要拿到access token就能访问它的<br>实际开发第三方登录的协议:<br><a href="http://xxx?token=&gt;xxx&amp;type=x,token就是我们授权之后返回的accessToken,type是为了区分不同登录渠道" target="_blank" rel="external">http://xxx?token=&gt;xxx&amp;type=x,token就是我们授权之后返回的accessToken,type是为了区分不同登录渠道</a>;<br><img src="/images/it_android_opencloud5.png" alt="UML图"></p>
<p>app步骤:<br>app做的事情,实际开发,我们能把我这里的几个步骤,就可以完成开发工作<br>1.发起授权请求,让用户授权 ok<br>2.用户输入账号密码,用户授权成功 ok<br>3.处理授权结果.拿到accessToken ok<br>4.调用第三方登录协议(自己公司定义的).完成第三方登录 自己server定义的协议和腾讯没有关系  </p>
<h2 id="第三方登录云服务商"><a href="#第三方登录云服务商" class="headerlink" title="第三方登录云服务商"></a>第三方登录云服务商</h2><h3 id="微信登录认证"><a href="#微信登录认证" class="headerlink" title="微信登录认证"></a>微信登录认证</h3><p>地址：<br><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN</a></p>
<h3 id="QQ登录认证"><a href="#QQ登录认证" class="headerlink" title="QQ登录认证"></a>QQ登录认证</h3><p>地址：<br><a href="http://wiki.open.qq.com/wiki/%E3%80%90QQ%E7%99%BB%E5%BD%95%E3%80%91%E6%8E%A5%E5%85%A5%E8%A7%84%E8%8C%83" target="_blank" rel="external">http://wiki.open.qq.com/wiki/%E3%80%90QQ%E7%99%BB%E5%BD%95%E3%80%91%E6%8E%A5%E5%85%A5%E8%A7%84%E8%8C%83</a></p>
<p>集成步骤(移动应用接入流程)：<br>1.注册成为开发者,登录;<br>2.点击申请加入,创建应用;–&gt;会分配appId,appKey<br>　APP ID:110407209311<br>　APP KEY:PzMWIM4GYZvxGRjdaa<br>3.完善信息;<br>4.下载demo.运行看效果;<br>5.集成开发;<br>　webview方式(老方式):授权的时候是跳到了一个webview上去授权<br>　sso方式:如果手机里面装了qq.那就是单点登录的形式.如果没有装qq,就是跳到webview这种老方式;<br>　sso:单点登录</p>
<p>QQ第三方登录流程图：<br><img src="/images/it_android_opencloud6.png" alt="UML图"><br>记住第三方登录的核心就是拿到accessToken</p>
<p>QQ第三方登录服务的流程图：(锦上添花的了解一下)<br>accessToken传递到后台,后台的处理逻辑图示：<br><img src="/images/it_android_opencloud7.png" alt="UML图"><br>Server步骤：<br>1.使用accessToken拿到用户在第三方平台的唯一ID;<br>　1.1.判断<code>第三方平台的唯一ID</code>是否存在我们的用户信息表中;<br>　　1.1.1.存在:(之前使用qq号登陆过自己的系统)返回当前用户的用户信息<br>　　1.1.2.不存在:(用户还没有使用过此qq登陆过我们的系统)<br>2.调用相关的接口,拿到nickname,邮箱,头像(需要什么拿取什么);</p>
<h3 id="微博登录认证"><a href="#微博登录认证" class="headerlink" title="微博登录认证"></a>微博登录认证</h3><p>地址：<a href="http://open.weibo.com/development/mobile" target="_blank" rel="external">http://open.weibo.com/development/mobile</a></p>
<p>微博第三方登录步骤：<br>1.注册成为开发者<br>2.创建应用:微博创建应用流程稍微麻烦一点.需要重点讲一下<br>　需要上传我们keystore的签名信息,使用签名工具获取,和微信支付类似;<br>　授权回调页:随便写一个就可以<br>3.运行demo,查看一下.<br>4.集成微博第三方登录.<br>　4.1.拷贝jar包,或者关联lib工程<br>　4.2.查看androidMinfest.xml<br>　4.3.寻找关键代码</p>
<hr>
<h1 id="第三方分享（Share）"><a href="#第三方分享（Share）" class="headerlink" title="第三方分享（Share）"></a>第三方分享（Share）</h1><hr>
<h2 id="微信分享"><a href="#微信分享" class="headerlink" title="微信分享"></a>微信分享</h2><h3 id="填坑经验"><a href="#填坑经验" class="headerlink" title="填坑经验"></a>填坑经验</h3><p>填坑1：<br>调取微信加载页面后马上又退出APP，呼起微信失败<br>需要正式签名（记住，凡是微信系列几乎都需要正式签名，包括微信登录，微信支付，微信分享等待）<br>相关文章：<a href="http://bbs.csdn.net/topics/390790614" target="_blank" rel="external">http://bbs.csdn.net/topics/390790614</a></p>
<p>填坑2：<br>微信分享后没有回调<br>注意：回调类名是WXEntryActivity,千万别和微信支付的WXPayEntryActivity的类名弄混淆了，不是一个类<br>记得配清单文件<br>微信分享配置回调Activity中android:exported=”true”的一个坑<br>Android利用微信SDK分享到微信教程，回调分享结果错误解决和注意点，androidsdk<br>社会化登录分享：微信SDK接入</p>
<h2 id="QQ分享"><a href="#QQ分享" class="headerlink" title="QQ分享"></a>QQ分享</h2><h3 id="踩坑经验"><a href="#踩坑经验" class="headerlink" title="踩坑经验"></a>踩坑经验</h3><p>踩坑1.分享必须要有头图banner，否则调不起来QQ，参数不能为null或””<br><img src="/images/it_android_opencloud8.png" alt="UML图"></p>
<p>踩坑2.分享后没有回调<br>特别注意<br>应用调用Andriod_SDK接口时，如果要成功接收到回调，需要在调用接口的Activity的onActivityResult方法中增加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">    Tencent.onActivityResultData(requestCode,resultCode,data,listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中onActivityResultData接口中的listener为当前调用的Activity所实现的相应回调UIListener。<br>相关文章：<br><a href="http://wiki.open.qq.com/wiki/%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83" target="_blank" rel="external">http://wiki.open.qq.com/wiki/%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83</a></p>
<h2 id="ShareSDK"><a href="#ShareSDK" class="headerlink" title="ShareSDK"></a>ShareSDK</h2><p>地址：<a href="http://mob.com/" target="_blank" rel="external">http://mob.com/</a></p>
<p>特点：专业做社交分享的平台</p>
<p>步骤：<br>1.注册账号 (mob.com)<br>2.创建应用<br>3.下载sdk<br>4.SDK 导入配置<br>5.代码配置</p>
<h2 id="DeepShare"><a href="#DeepShare" class="headerlink" title="DeepShare"></a>DeepShare</h2><p>地址：<a href="http://deepshare.io/" target="_blank" rel="external">http://deepshare.io/</a></p>
<p>特点：<br>DeepShare:一键跳转内容, 打破App壁垒<br>通过 Deeplink 技术帮助开发者实现从外部网页到 App 内页的直接跳转, 有效提升流量转化效率和用户下单率.</p>
<hr>
<h1 id="云服务器（Server）"><a href="#云服务器（Server）" class="headerlink" title="云服务器（Server）"></a>云服务器（Server）</h1><hr>
<p>用途：移动后端云服务，负载均衡,CDN加速等等</p>
<p>基于BaaS（后端即服务：Backend as a Service）模式</p>
<h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>地址：<a href="https://www.aliyun.com/" target="_blank" rel="external">https://www.aliyun.com/</a></p>
<p>常见服务：</p>
<ul>
<li><p>ECS<br>云服务器，可以简单理解为咱普通用的服务器</p>
</li>
<li><p>SLB<br>（Server Load Balancer）是负载均衡，购买两台阿里云服务器就可以免费开启，是用来应对大流量。</p>
</li>
<li><p>OSS<br>静态存储（开放存储服务）， 专门用来存放静态文件。</p>
</li>
<li><p>OCS<br>开放式缓存（开放缓存服务），是大数据请求下，将重复计算的的数据放在缓存中。</p>
</li>
<li><p>CDN</p>
</li>
<li><p>云盾</p>
</li>
<li><p>云监控</p>
</li>
</ul>
<h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><p>地址：<a href="https://www.qcloud.com/" target="_blank" rel="external">https://www.qcloud.com/</a></p>
<ul>
<li>负载均衡<br><a href="https://www.qcloud.com/product/clb" target="_blank" rel="external">https://www.qcloud.com/product/clb</a></li>
</ul>
<h2 id="百度云（bae）"><a href="#百度云（bae）" class="headerlink" title="百度云（bae）"></a>百度云（bae）</h2><h2 id="新浪云（sae）"><a href="#新浪云（sae）" class="headerlink" title="新浪云（sae）"></a>新浪云（sae）</h2><h2 id="金山云"><a href="#金山云" class="headerlink" title="金山云"></a>金山云</h2><h2 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h2><h2 id="亚马逊云服务-AWS"><a href="#亚马逊云服务-AWS" class="headerlink" title="亚马逊云服务(AWS)"></a>亚马逊云服务(AWS)</h2><h2 id="原子云"><a href="#原子云" class="headerlink" title="原子云"></a>原子云</h2><h2 id="Bmob后端云"><a href="#Bmob后端云" class="headerlink" title="Bmob后端云"></a>Bmob后端云</h2><h2 id="AVOS-Cloud-（万象云）"><a href="#AVOS-Cloud-（万象云）" class="headerlink" title="AVOS Cloud （万象云）"></a>AVOS Cloud （万象云）</h2><h2 id="Kinvey"><a href="#Kinvey" class="headerlink" title="Kinvey"></a>Kinvey</h2><p>StackMob </p>
<hr>
<h1 id="网络优化（Network）"><a href="#网络优化（Network）" class="headerlink" title="网络优化（Network）"></a>网络优化（Network）</h1><hr>
<p>用途：弱网环境优化</p>
<p>相关：<br><a href="https://www.zhihu.com/question/29466887/answer/74161769" target="_blank" rel="external">Android开发如何进行网络优化？</a></p>
<h2 id="腾讯-维纳斯"><a href="#腾讯-维纳斯" class="headerlink" title="腾讯-维纳斯"></a>腾讯-维纳斯</h2><p>弱网络环境下提升连通率，在2G网络、电梯、地下停车场等网络较差的地方，连通成功率99.9%，达到与QQ、微信同等的连通率</p>
<h2 id="TwinPrime"><a href="#TwinPrime" class="headerlink" title="TwinPrime"></a>TwinPrime</h2><p>国外：TwinPrime, 颇具特色的网络优化服务，<br>国内：除了腾讯-维纳斯，暂时还没发现同类产品，不过TwinPrime理论上是支持全球的。</p>
<hr>
<h1 id="图片存储服务（Image）"><a href="#图片存储服务（Image）" class="headerlink" title="图片存储服务（Image）"></a>图片存储服务（Image）</h1><hr>
<p>用途：图床/图片上传/图片下载/图片压缩</p>
<h2 id="七牛云存储"><a href="#七牛云存储" class="headerlink" title="七牛云存储"></a>七牛云存储</h2><p>官网：<a href="https://www.qiniu.com/" target="_blank" rel="external">https://www.qiniu.com/</a></p>
<p>相关：<br><a href="http://www.jianshu.com/p/6dce6094bf61" target="_blank" rel="external">如何使用七牛云做为图床？</a></p>
<h2 id="腾讯云-万象优图"><a href="#腾讯云-万象优图" class="headerlink" title="腾讯云-万象优图"></a>腾讯云-万象优图</h2><p>地址：<a href="https://cloud.tencent.com/product/ci" target="_blank" rel="external">https://cloud.tencent.com/product/ci</a></p>
<h2 id="阿里云OSS-Android客户端SDK"><a href="#阿里云OSS-Android客户端SDK" class="headerlink" title="阿里云OSS-Android客户端SDK"></a>阿里云OSS-Android客户端SDK</h2><p>地址：<a href="https://help.aliyun.com/document_detail/32172.html" target="_blank" rel="external">https://help.aliyun.com/document_detail/32172.html</a></p>
<p>提供文件（图片、视频等等）上传<br>大文件分块上传<br>删除操作（不推荐在客户端使用）</p>
<h2 id="LeanCloud-1"><a href="#LeanCloud-1" class="headerlink" title="LeanCloud"></a>LeanCloud</h2><p>图片上传( LeanCloud 文件存储实际用的也是七牛的云存储)</p>
<h2 id="TinyPng"><a href="#TinyPng" class="headerlink" title="TinyPng"></a>TinyPng</h2><p>地址：<a href="https://tinypng.com/" target="_blank" rel="external">https://tinypng.com/</a></p>
<p>是一个非常不错的图片压缩工具，在保持alpha通道的情况下对PNG的压缩可以达到1/3之内，而且用肉眼基本上分辨不出压缩的损失。<br>本文直接调用的是 TinyPNG 站点的 API，该站提供的压缩服务还是不错的，图片压缩率高，且压缩前后显示效果差别很小。对于开发者而言，该网站上相关文档也是相当齐全的。</p>
<p>相关：<br><a href="http://app.hustonline.net/article/detail/51" target="_blank" rel="external">TinyPNG—一个压缩PNG的神站</a></p>
<hr>
<h1 id="云通讯验证码（SMS）"><a href="#云通讯验证码（SMS）" class="headerlink" title="云通讯验证码（SMS）"></a>云通讯验证码（SMS）</h1><hr>
<p>用途：短信验证码服务</p>
<h2 id="云片"><a href="#云片" class="headerlink" title="云片"></a>云片</h2><p>地址：<a href="https://www.yunpian.com/" target="_blank" rel="external">https://www.yunpian.com/</a></p>
<h2 id="云通讯"><a href="#云通讯" class="headerlink" title="云通讯"></a>云通讯</h2><p>地址：<a href="https://www.253.com/" target="_blank" rel="external">https://www.253.com/</a><br>解决方案成熟，众多公司使用</p>
<h2 id="Fabric-Digits"><a href="#Fabric-Digits" class="headerlink" title="Fabric Digits"></a>Fabric Digits</h2><p>国外：twitter出品，居然不要钱。</p>
<hr>
<h1 id="移动安全（Safe）"><a href="#移动安全（Safe）" class="headerlink" title="移动安全（Safe）"></a>移动安全（Safe）</h1><hr>
<p>用途：混淆/程序加固/防止被反编译</p>
<h2 id="360加固保"><a href="#360加固保" class="headerlink" title="360加固保"></a>360加固保</h2><p>地址：<a href="http://jiagu.360.cn/" target="_blank" rel="external">http://jiagu.360.cn/</a></p>
<h2 id="阿里云-聚安全"><a href="#阿里云-聚安全" class="headerlink" title="阿里云-聚安全"></a>阿里云-聚安全</h2><p>地址：<a href="https://www.aliyun.com/product/mobsec?utm_content=se_854054" target="_blank" rel="external">https://www.aliyun.com/product/mobsec?utm_content=se_854054</a></p>
<h2 id="腾讯-应用加固"><a href="#腾讯-应用加固" class="headerlink" title="腾讯-应用加固"></a>腾讯-应用加固</h2><p>地址：<a href="http://wiki.open.qq.com/wiki/%E5%BA%94%E7%94%A8%E5%8A%A0%E5%9B%BA" target="_blank" rel="external">http://wiki.open.qq.com/wiki/%E5%BA%94%E7%94%A8%E5%8A%A0%E5%9B%BA</a></p>
<h2 id="腾讯云-乐固"><a href="#腾讯云-乐固" class="headerlink" title="腾讯云-乐固"></a>腾讯云-乐固</h2><p>地址：<a href="https://cloud.tencent.com/product/ms" target="_blank" rel="external">https://cloud.tencent.com/product/ms</a></p>
<h2 id="网易云-易盾"><a href="#网易云-易盾" class="headerlink" title="网易云-易盾"></a>网易云-易盾</h2><p>地址：<a href="http://dun.163.com/" target="_blank" rel="external">http://dun.163.com/</a></p>
<h2 id="梆梆加固"><a href="#梆梆加固" class="headerlink" title="梆梆加固"></a>梆梆加固</h2><p>地址：<a href="https://www.bangcle.com/" target="_blank" rel="external">https://www.bangcle.com/</a></p>
<h2 id="爱加密"><a href="#爱加密" class="headerlink" title="爱加密"></a>爱加密</h2><p>地址：<a href="http://www.ijiami.cn/" target="_blank" rel="external">http://www.ijiami.cn/</a></p>
<h2 id="Dexguard"><a href="#Dexguard" class="headerlink" title="Dexguard"></a>Dexguard</h2><p>国外的</p>
<h1 id="性能监控（Crash）"><a href="#性能监控（Crash）" class="headerlink" title="性能监控（Crash）"></a>性能监控（Crash）</h1><p>用于：Crash监控分析/崩溃统计/异常上报</p>
<h2 id="腾讯Bugly"><a href="#腾讯Bugly" class="headerlink" title="腾讯Bugly"></a>腾讯Bugly</h2><p>地址：<a href="https://bugly.qq.com/" target="_blank" rel="external">https://bugly.qq.com/</a></p>
<p>Android Crash(崩溃)监控<br>腾讯Bugly, 号称全球唯一自带ANR收集，其实原理很简单。</p>
<h2 id="Testin"><a href="#Testin" class="headerlink" title="Testin"></a>Testin</h2><p>地址：<a href="https://www.testin.cn/" target="_blank" rel="external">https://www.testin.cn/</a></p>
<h2 id="听云-Apm"><a href="#听云-Apm" class="headerlink" title="听云-Apm"></a>听云-Apm</h2><p>地址：<a href="http://www.tingyun.com/lp.html" target="_blank" rel="external">http://www.tingyun.com/lp.html</a></p>
<h2 id="Crashlytics"><a href="#Crashlytics" class="headerlink" title="Crashlytics"></a>Crashlytics</h2><p>国外的，已经收归Twitter Fabric开发者工具集，免费好用。</p>
<h2 id="BugHD"><a href="#BugHD" class="headerlink" title="BugHD"></a>BugHD</h2><p>地址：<a href="http://bughd.com/" target="_blank" rel="external">http://bughd.com/</a></p>
<p>实时监控APP的崩溃分析工具</p>
<hr>
<h1 id="数据统计（Statistics）"><a href="#数据统计（Statistics）" class="headerlink" title="数据统计（Statistics）"></a>数据统计（Statistics）</h1><hr>
<p>用途：用户统数据统计分析</p>
<p>有的公司要求收集各个应用市场的用户使用量，是我们写在代码里上传到服务器统计的<br>把软件提交到应用市场是自动统计显示下载量的<br>当然自己也能统计，代码中调用统计的接口，一调那么服务器的计数就加1<br>当然，第一次就调一次，以后就不用调了</p>
<h2 id="腾讯云分析Mta"><a href="#腾讯云分析Mta" class="headerlink" title="腾讯云分析Mta"></a>腾讯云分析Mta</h2><p>地址：<a href="http://mta.qq.com/mta/" target="_blank" rel="external">http://mta.qq.com/mta/</a></p>
<p>腾讯云分析,数据统计上报, 类似友盟统计</p>
<h2 id="友盟统计（umeng）"><a href="#友盟统计（umeng）" class="headerlink" title="友盟统计（umeng）"></a>友盟统计（umeng）</h2><p>地址：<a href="https://www.umeng.com/" target="_blank" rel="external">https://www.umeng.com/</a></p>
<p>•国内专业的移动应用统计分析平台<br>•统计和分析流量来源、内容使用、用户属性和行为数据<br>•Crash log跟踪</p>
<h2 id="Fir-im"><a href="#Fir-im" class="headerlink" title="Fir.im"></a>Fir.im</h2><p>地址：<a href="https://fir.im/" target="_blank" rel="external">https://fir.im/</a></p>
<h2 id="Talking-Data"><a href="#Talking-Data" class="headerlink" title="Talking Data"></a>Talking Data</h2><p>地址：<a href="http://www.talkingdata.com/" target="_blank" rel="external">http://www.talkingdata.com/</a></p>
<h2 id="Flurry"><a href="#Flurry" class="headerlink" title="Flurry"></a>Flurry</h2><p>国外统计分析系统的标杆，免费的</p>
<hr>
<h1 id="数据可视化分析-Analyze"><a href="#数据可视化分析-Analyze" class="headerlink" title="数据可视化分析(Analyze)"></a>数据可视化分析(Analyze)</h1><hr>
<h2 id="Growingio"><a href="#Growingio" class="headerlink" title="Growingio"></a>Growingio</h2><p>地址：<a href="https://www.growingio.com/" target="_blank" rel="external">https://www.growingio.com/</a></p>
<p>国内公司，linkedin数据分析大牛回国创业，据说黑科技，可以直接在app上实时查看各种转化率数据。</p>
<h2 id="Appsee"><a href="#Appsee" class="headerlink" title="Appsee"></a>Appsee</h2><p>国公司，绝对黑科技，PM最爱，转化率什么的再也不怕上不去了，用过后我们团队成员一致好评，在我的微信公众号里有专门文章介绍使用体验。</p>
<p>相关文章：<br><a href="http://www.jianshu.com/p/68b629f3e34c" target="_blank" rel="external">AppSee: 为什么叫它神器？</a></p>
<hr>
<h1 id="云测适配（Test）"><a href="#云测适配（Test）" class="headerlink" title="云测适配（Test）"></a>云测适配（Test）</h1><hr>
<p>用途：云手机</p>
<h2 id="腾讯-优测"><a href="#腾讯-优测" class="headerlink" title="腾讯-优测"></a>腾讯-优测</h2><p>地址：<a href="http://utest.qq.com/" target="_blank" rel="external">http://utest.qq.com/</a></p>
<h2 id="特性-WeTest"><a href="#特性-WeTest" class="headerlink" title="特性-WeTest"></a>特性-WeTest</h2><p>腾讯质量开放平台</p>
<p>地址：<a href="http://wetest.qq.com/product/expert-compatibility-testing?from=content_lab" target="_blank" rel="external">http://wetest.qq.com/product/expert-compatibility-testing?from=content_lab</a></p>
<h2 id="test-in"><a href="#test-in" class="headerlink" title="test in"></a>test in</h2><p>国外的其实百度的也跑，国内的Android设备都卖到国外去了。</p>
<hr>
<h1 id="灰度测试（Gray）"><a href="#灰度测试（Gray）" class="headerlink" title="灰度测试（Gray）"></a>灰度测试（Gray）</h1><hr>
<h2 id="AppAdhoc"><a href="#AppAdhoc" class="headerlink" title="AppAdhoc"></a>AppAdhoc</h2><p>国内：AppAdhoc，移动AB测试国内最专业的一家。</p>
<h2 id="optimizely"><a href="#optimizely" class="headerlink" title="optimizely"></a>optimizely</h2><p>国外：optimizely, 支持Android, iOS, 直接在线改UI做AB测试, 三观都要颠覆了。</p>
<hr>
<h1 id="广告变现（Advert）"><a href="#广告变现（Advert）" class="headerlink" title="广告变现（Advert）"></a>广告变现（Advert）</h1><hr>
<h2 id="万普世纪"><a href="#万普世纪" class="headerlink" title="万普世纪"></a>万普世纪</h2><h2 id="有米广告"><a href="#有米广告" class="headerlink" title="有米广告"></a>有米广告</h2><h2 id="多盟"><a href="#多盟" class="headerlink" title="多盟"></a>多盟</h2><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><h2 id="广点通"><a href="#广点通" class="headerlink" title="广点通"></a>广点通</h2><p>百度 or 广点通，两个效果差不多。</p>
<h2 id="FB"><a href="#FB" class="headerlink" title="FB"></a>FB</h2><h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p>国外：FB or Google，做native广告，效果最佳。</p>
<h2 id="AdMob"><a href="#AdMob" class="headerlink" title="AdMob"></a>AdMob</h2><p>嵌入广告进行盈利<br>谷歌充分考虑到了可以在Android应用程序中嵌入广告来让开发者获得收入，因此早早地就收购了AdMob公司。AdMob创立于2006年，是全球最早致力于在移动设备上提供广告服务的公司之一，如今成为了谷歌的子公司，AdMob的广告更加适合在Android系统以及Google Play上面进行投放。<br>不过对于国内开发者来说，AdMob可能并不是那么的适合。因为AdMob平台上的广告大多都是英文的，中文广告数有限，并且将AdMob账户中的钱提取到银行账户中也比较麻烦，因此这里我们就不准备使用AdMob了，而是将眼光放在一些国内的移动广告平台上面。在国内的这一领域，做得比较好的移动广告平台也不少，如万普、有米、多盟等，其中我个人认为有米平台特别的专业，因此我们就选择它来为酷欧天气提供广告服务吧。</p>
<hr>
<h1 id="社会化评论（Comment）"><a href="#社会化评论（Comment）" class="headerlink" title="社会化评论（Comment）"></a>社会化评论（Comment）</h1><hr>
<h2 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>国外, 基本不用考虑其他家的，虽然确实有竞品。</p>
<h2 id="畅言"><a href="#畅言" class="headerlink" title="畅言"></a>畅言</h2><p>国内，搜狐，基本抄的Disqus, 免费，算是良心产品了。<br><a href="https://changyan.kuaizhan.com/" target="_blank" rel="external">https://changyan.kuaizhan.com/</a></p>
<h2 id="多说"><a href="#多说" class="headerlink" title="多说"></a>多说</h2><p>已关闭</p>
<h2 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h2><hr>
<h1 id="客服（Customer）"><a href="#客服（Customer）" class="headerlink" title="客服（Customer）"></a>客服（Customer）</h1><hr>
<h2 id="微客服"><a href="#微客服" class="headerlink" title="微客服"></a>微客服</h2><p>国内：微客服, 有免费额度，中小应用够用。</p>
<h2 id="helpshift"><a href="#helpshift" class="headerlink" title="helpshift"></a>helpshift</h2><p>国外：helpshift，国外最专业的客服平台。</p>
<hr>
<h1 id="语音识别（Voice）"><a href="#语音识别（Voice）" class="headerlink" title="语音识别（Voice）"></a>语音识别（Voice）</h1><hr>
<h2 id="科大讯飞语音云"><a href="#科大讯飞语音云" class="headerlink" title="科大讯飞语音云"></a>科大讯飞语音云</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_opencloud_logo1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android —— 开源框架：工具库篇</title>
    <link href="https://hengxing0080.github.io/2017/10/02/it/1.Android/OpenProject/"/>
    <id>https://hengxing0080.github.io/2017/10/02/it/1.Android/OpenProject/</id>
    <published>2017-10-02T15:56:13.000Z</published>
    <updated>2017-11-08T13:48:29.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_openutils_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>主要包括那些不错的开发库，包括依赖注入框架、图片缓存、网络请求、数据库 ORM 建模、Android 公共库、Android 高版本向低版本兼容、多媒体相关及其他。</p>
<p>思维导图地址：<a href="http://naotu.baidu.com/file/680bda2c67e4a888b086d49852982a5e?token=37669eaa5e7a778d&amp;qq-pf-to=pcqq.group" target="_blank" rel="external">百度脑图-开源项目工具库篇-鱼骨头图</a><br>PS：这篇是别人总结的，先心领神会看个大概，后期陆陆续续加入自己总结的</p>
<hr>
<h1 id="综合框架"><a href="#综合框架" class="headerlink" title="综合框架"></a>综合框架</h1><hr>
<p>关键词：公共库/大而全的框架/快速开发型框架</p>
<h2 id="Afinal"><a href="#Afinal" class="headerlink" title="Afinal"></a>Afinal</h2><p>项目Github：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="external">https://github.com/yangfuhai/afinal</a></p>
<p>简介：<br>Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用；<br>使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。<br>Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。</p>
<p>目前Afinal主要有四大模块：<br>1.FinalDB模块<br>android中的orm框架，一行代码就可以进行增删改查。支持一对多，多对一等查询。</p>
<p>2.FinalActivity模块<br>android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。</p>
<p>3.FinalHttp模块<br>通过httpclient进行封装http数据请求，支持ajax方式加载。</p>
<p>4.FinalBitmap模块<br>通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，没有使用弱引用（android2.3以后google已经不建议使用弱引用，android2.3后强行回收软引用和弱引用，详情查看android官方文档），更好的管理bitmap内存。FinalBitmap可以自定义下载器，用来扩展其他</p>
<h2 id="XUtils"><a href="#XUtils" class="headerlink" title="XUtils"></a>XUtils</h2><p>项目Github：<a href="https://github.com/wyouflf/xUtils" target="_blank" rel="external">https://github.com/wyouflf/xUtils</a></p>
<p>简介：<br>快速开发型框架<br>众多开源的集合，出现时间大概是2010-2011</p>
<p>特色：<br>(1)xUtils 包含了很多实用的android工具。<br>(2)xUtils 最初源于Afinal框架，进行了大量重构，使得xUtils支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响…<br>(3)xUitls最低兼容android 2.2 (api level 8)</p>
<p>主要有四大模块：<br>(1) 数据库模块：<br>android中的orm框架，一行代码就可以进行增删改查；<br>支持事务，默认关闭；<br>可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；<br>支持绑定外键，保存实体时外键关联实体自动保存或更新；<br> 自动加载外键关联实体，支持延时加载；<br>支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子。    </p>
<p>(2) 注解模块<br>android中的ioc框架，完全注解方式就可以进行UI，资源和事件绑定；<br>新的事件绑定方式，使用混淆工具混淆后仍可正常工作；<br>目前支持常用的20种事件绑定，参见ViewCommonEventListener类和包com.lidroid.xutils.view.annotation.event。</p>
<p>(3) 网络模块：<br>支持同步，异步方式的请求；<br>支持大文件上传，上传大文件不会oom；<br>支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；<br>下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；<br>返回文本内容的请求(默认只启用了GET请求)支持缓存，可设置默认过期时间和针对当前请求的过期时间。            </p>
<p>(4) 图片缓存模块<br>加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象；<br>支持加载网络图片和本地图片；<br>内存管理使用lru算法，更好的管理bitmap内存；<br>可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等…</p>
<p>Xutils是单例吗   不是</p>
<h2 id="UltimateAndroid"><a href="#UltimateAndroid" class="headerlink" title="UltimateAndroid"></a>UltimateAndroid</h2><p>项目github：<a href="https://github.com/cymcsg/UltimateAndroid" target="_blank" rel="external">https://github.com/cymcsg/UltimateAndroid</a><br>相关：<a href="http://blog.csdn.net/marshalchen/article/details/39138365" target="_blank" rel="external">UltimateAndroid快速开发框架简介与教程（也是一套Android快速开发的教程）</a></p>
<h2 id="LoonAndroid"><a href="#LoonAndroid" class="headerlink" title="LoonAndroid"></a>LoonAndroid</h2><p>项目Github：<a href="https://github.com/gdpancheng/LoonAndroid" target="_blank" rel="external">https://github.com/gdpancheng/LoonAndroid</a></p>
<h2 id="ThinkAndroid"><a href="#ThinkAndroid" class="headerlink" title="ThinkAndroid"></a>ThinkAndroid</h2><p>项目Github：<a href="https://github.com/white-cat/ThinkAndroid" target="_blank" rel="external">https://github.com/white-cat/ThinkAndroid</a></p>
<p>ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行 Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块, 具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能， 在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类， 如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具。</p>
<p>目前ThinkAndroid主要有以下模块：</p>
<p>1.MVC模块：实现视图与模型的分离。</p>
<p>2.ioc模块：android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。</p>
<p>3.数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。</p>
<p>4.http模块：通过httpclient进行封装http数据请求，支持异步及同步方式加载。</p>
<p>5.缓存模块：通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置</p>
<p>6.图片缓存模块：imageview加载图片的时候无需考虑图片加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。</p>
<p>7.配置器模块：可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。</p>
<p>8.日志打印模块：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印</p>
<p>9.下载器模块:可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。</p>
<p>10.网络状态检测模块：当网络状态改变时，对其进行检测。</p>
<h2 id="TrineaAndroidCommon"><a href="#TrineaAndroidCommon" class="headerlink" title="TrineaAndroidCommon"></a>TrineaAndroidCommon</h2><p>作者：Trinea<br>来源地址：<a href="http://www.trinea.cn/android/android-common-lib/" target="_blank" rel="external">Android公共库——图片缓存 网络缓存 下拉及底部更多ListView 公共类</a><br>项目Github：<a href="https://github.com/Trinea/android-common" target="_blank" rel="external">AndroidCommon</a></p>
<h2 id="KJFrameForAndroid"><a href="#KJFrameForAndroid" class="headerlink" title="KJFrameForAndroid"></a>KJFrameForAndroid</h2><p>项目Github：<a href="https://github.com/kymjs/KJFrameForAndroid" target="_blank" rel="external">https://github.com/kymjs/KJFrameForAndroid</a><br>相关：<a href="http://blog.csdn.net/zhongjc_bill/article/details/49930269" target="_blank" rel="external">与android不得不说的故事之KJFrameForAndroid</a></p>
<hr>
<h1 id="响应式开发框架"><a href="#响应式开发框架" class="headerlink" title="响应式开发框架"></a>响应式开发框架</h1><hr>
<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p>项目Github：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a></p>
<h2 id="RxBinding"><a href="#RxBinding" class="headerlink" title="RxBinding"></a>RxBinding</h2><p>项目Github：<a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">https://github.com/JakeWharton/RxBinding</a><br>RxBinding出自Square公司的Jake Wharton大神之手，往往是结合RxJava一起使用。</p>
<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p>项目Github：<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">https://github.com/ReactiveX/RxAndroid</a></p>
<h2 id="RxKotlin"><a href="#RxKotlin" class="headerlink" title="RxKotlin"></a>RxKotlin</h2><p>项目Github：<a href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="external">https://github.com/ReactiveX/RxKotlin</a></p>
<hr>
<h1 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h1><hr>
<h2 id="网络请求库-网络通信库"><a href="#网络请求库-网络通信库" class="headerlink" title="网络请求库/网络通信库"></a>网络请求库/网络通信库</h2><h3 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h3><p>项目Github：<a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="external">https://github.com/mcxiaoke/android-volley</a></p>
<p>Google 提供的网络通信库，使得网络请求更简单、更快速</p>
<p>Google I/O 2013上，Volley发布了。<br>Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮。<br>这是Volley名称的由来： a burst or emission of many things or a large amount at once<br>在Google IO的演讲上，其配图是一幅发射火弓箭的图，有点类似流星。见文章最上面头图就是</p>
<p>其实，从头图可以看出来，Volley特别适合数据量不大但是通信频繁的场景。</p>
<p>相关：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1018/1800.html" target="_blank" rel="external">Android 网络通信框架Volley简介(Google IO 2013)</a><br><a href="http://www.kwstu.com/ArticleView/kwstu_20144118313429" target="_blank" rel="external">Android Volley完全解析(一)，初识Volley的基本用法</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/17656437" target="_blank" rel="external">Android Volley完全解析(四)，带你从源码的角度理解Volley</a></p>
<h4 id="关于Volley的缓存"><a href="#关于Volley的缓存" class="headerlink" title="关于Volley的缓存"></a>关于Volley的缓存</h4><p><a href="https://kymjs.com/code/2016/03/08/01/" target="_blank" rel="external">开源实验室——面试后的总结</a></p>
<h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><p>相关Github：<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a></p>
<p>Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。</p>
<p>尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。<br>OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。</p>
<p>OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>
<p>使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>
<p>注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。<br>截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了）</p>
<p>相关：<a href="http://blog.csdn.net/lmj623565791/article/details/47911083" target="_blank" rel="external">Android OkHttp完全解析 是时候来了解OkHttp了</a></p>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p>项目Github：<a href="https://github.com/square/retrofit" target="_blank" rel="external">https://github.com/square/retrofit</a><br>最新版本：Retrofit2.0</p>
<p>简介：<br>Retrofit与okhttp共同出自于Square公司，retrofit就是对okhttp做了一层封装。把网络请求都交给给了Okhttp，我们只需要通过简单的配置就能使用retrofit来进行网络请求了，其主要作者是Android大神JakeWharton。</p>
<p>相关：<br><a href="http://blog.csdn.net/bitian123/article/details/51899716" target="_blank" rel="external">android 介绍Retrofit的简单使用</a></p>
<h3 id="AsyncHttpClient"><a href="#AsyncHttpClient" class="headerlink" title="AsyncHttpClient"></a>AsyncHttpClient</h3><p>项目Github：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">https://github.com/loopj/android-async-http</a></p>
<p>异步的HttpClient，用于纯异步的下载网页</p>
<p>(1) 在匿名回调中处理请求结果<br>(2) 在UI线程外进行http请求<br>(3) 文件断点上传<br>(4) 智能重试<br>(5) 默认gzip压缩<br>(6) 支持解析成Json格式<br>(7) 可将Cookies持久化到SharedPreferences</p>
<h3 id="Mars"><a href="#Mars" class="headerlink" title="Mars"></a>Mars</h3><p>腾讯内部专用<br>微信自用的移动端IM网络层跨平台组件库</p>
<h2 id="网络数据-Gson-解析库"><a href="#网络数据-Gson-解析库" class="headerlink" title="网络数据(Gson)解析库"></a>网络数据(Gson)解析库</h2><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>项目Github：<a href="https://github.com/google/gson" target="_blank" rel="external">https://github.com/google/gson</a></p>
<p>Google提供的用来解析GSON</p>
<p>Gson解决对象和json的转换，方便简单快速</p>
<h3 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h3><p>项目Github：<a href="https://github.com/alibaba/fastjson" target="_blank" rel="external">https://github.com/alibaba/fastjson</a></p>
<p>阿里巴巴FastJson是一个Json处理工具包，包括“序列化”和“反序列化”两部分，它具备如下特征：<br>速度最快，测试表明，fastjson具有极快的性能，超越任其他的Java Json parser。包括自称最快的JackJson；<br>功能强大，完全支持Java Bean、集合、Map、日期、Enum，支持范型，支持自省；无依赖，能够直接运行在Java SE 5.0以上版本；支持Android；开源 (Apache 2.0)</p>
<h3 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h3><p>项目Github：<a href="https://github.com/FasterXML/jackson" target="_blank" rel="external">https://github.com/FasterXML/jackson</a></p>
<p>轻易转换JSON</p>
<p>Jackson可以轻松的将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象。</p>
<p>相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。</p>
<p>在线博文：<a href="http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2011/04/21/2023805.html</a></p>
<h3 id="Moshi"><a href="#Moshi" class="headerlink" title="Moshi"></a>Moshi</h3><p>项目Github：<a href="https://github.com/square/moshi" target="_blank" rel="external">https://github.com/square/moshi</a></p>
<h3 id="LoganSquare"><a href="#LoganSquare" class="headerlink" title="LoganSquare"></a>LoganSquare</h3><p>项目Github：<a href="https://github.com/bluelinelabs/LoganSquare" target="_blank" rel="external">https://github.com/bluelinelabs/LoganSquare</a></p>
<p>相关：<br><a href="http://www.jianshu.com/p/9c3173b2e70b" target="_blank" rel="external">LoganSquare的简单使用——快到爆炸地解析和序列化JSON</a></p>
<h3 id="json-lib"><a href="#json-lib" class="headerlink" title="json-lib"></a>json-lib</h3><p><a href="http://www.cnblogs.com/sunzn/archive/2013/02/12/2910241.html" target="_blank" rel="external">Json 和 Jsonlib 的使用 </a></p>
<hr>
<h1 id="多媒体框架"><a href="#多媒体框架" class="headerlink" title="多媒体框架"></a>多媒体框架</h1><hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="图片加载库"><a href="#图片加载库" class="headerlink" title="图片加载库"></a>图片加载库</h3><p>关键词：异步图片加载/图片缓存</p>
<p>相关：<br><a href="http://www.trinea.cn/android/android-image-cache-compare/" target="_blank" rel="external">Android 三大图片缓存原理、特性对比</a></p>
<h4 id="Fresco"><a href="#Fresco" class="headerlink" title="Fresco"></a>Fresco</h4><p>项目地址：<a href="https://github.com/facebook/fresco" target="_blank" rel="external">https://github.com/facebook/fresco</a></p>
<p>一款强大的图片缓存工具，由 Facebook 开发<br>特点：<br>(1) 两个内存缓存加上磁盘缓存构成了三级缓存<br>(2) 支持流式，可以类似网页上模糊渐进式显示图片<br>(3) 对多帧动画图片支持更好，如 Gif、WebP<br>(4) 更多样的显示，如圆角、进度条、点击重试、自定义对焦点<br>(5) 更多样的加载，如支持 EXIF、全面支持 WebP<br>(6) 支持 Android 2.3+</p>
<h4 id="Picasso"><a href="#Picasso" class="headerlink" title="Picasso"></a>Picasso</h4><p>项目地址：<a href="https://github.com/square/picasso" target="_blank" rel="external">https://github.com/square/picasso</a></p>
<p>square 开源的图片缓存</p>
<p>特点：<br>(1)可以自动检测 adapter 的重用并取消之前的下载<br>(2)图片变换<br>(3)可以加载本地资源<br>(4)可以设置占位资源<br>(5)支持 debug 模式</p>
<h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><p>项目地址：<a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://github.com/bumptech/glide</a></p>
<p>相关：<br><a href="http://blog.csdn.net/fancylovejava/article/details/44747759" target="_blank" rel="external">Google推荐的图片加载库Glide介绍</a></p>
<h4 id="Android-Universal-Imageloader"><a href="#Android-Universal-Imageloader" class="headerlink" title="Android Universal Imageloader"></a>Android Universal Imageloader</h4><p>项目地址：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
<p>简介：<br>android端用于异步加载图片，内存缓存，文件缓存，imageview显示图片时增加淡入淡出动画<br>图片缓存是最大特色，目前使用最广泛的图片缓存，支持主流图片缓存的绝大多数特性。</p>
<p>特殊：<br>•多线程下载图片，图片可以来源于网络，文件系统，项目文件夹assets中以及drawable中等<br>•支持随意的配置ImageLoader，例如线程池，图片下载器，内存缓存策略，硬盘缓存策略，图片显示选项以及其他的一些配置<br>•支持图片的内存缓存，文件系统缓存或者SD卡缓存<br>•支持图片下载过程的监听<br>•根据控件(ImageView)的大小对Bitmap进行裁剪，减少Bitmap占用过多的内存<br>•较好的控制图片的加载过程，例如暂停图片加载，重新开始加载图片，一般使用在ListView,GridView中，滑动过程中暂停加载图片，停止滑动的时候去加载图片<br>•提供在较慢的网络下对图片进行加载</p>
<h4 id="SmartImageView"><a href="#SmartImageView" class="headerlink" title="SmartImageView"></a>SmartImageView</h4><p>项目地址：<a href="https://github.com/JackCho/SmartImageView" target="_blank" rel="external">https://github.com/JackCho/SmartImageView</a></p>
<p>Android中加载网络图片的ImageView，功能强大，代码简单，使用无后顾之忧。</p>
<h3 id="图片处理库"><a href="#图片处理库" class="headerlink" title="图片处理库"></a>图片处理库</h3><h4 id="大图片缩放"><a href="#大图片缩放" class="headerlink" title="大图片缩放"></a>大图片缩放</h4><h5 id="PhotoView"><a href="#PhotoView" class="headerlink" title="PhotoView"></a>PhotoView</h5><p>项目地址：<a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="external">https://github.com/chrisbanes/PhotoView</a></p>
<p>PhotoView 是一款扩展自Android ImageView ，支持通过单点/多点触摸来进行图片缩放的智能控件。</p>
<p>类似微信,微博 图片点击放大浏览功能的库</p>
<p>特性：<br>支持单点/多点触摸，即时缩放图片；<br>支持平滑滚动；<br>在滑动父控件下能够运行良好；（例如：ViewPager）</p>
<p>缺点：<br>不支持网络过来的图片，用下面的PhotoDraweeView来替代</p>
<h6 id="问题集锦"><a href="#问题集锦" class="headerlink" title="问题集锦"></a>问题集锦</h6><p>1.IllegalArgumentException: pointerIndex out of range<br>解决方案：<br><a href="http://www.cnblogs.com/lao-liang/p/4941653.html" target="_blank" rel="external">Android开发的那些坑和小技巧</a></p>
<h5 id="PhotoDraweeView"><a href="#PhotoDraweeView" class="headerlink" title="PhotoDraweeView"></a>PhotoDraweeView</h5><p>项目地址：<a href="https://github.com/ongakuer/PhotoDraweeView" target="_blank" rel="external">https://github.com/ongakuer/PhotoDraweeView</a></p>
<h5 id="SubsamplingScaleImageView"><a href="#SubsamplingScaleImageView" class="headerlink" title="SubsamplingScaleImageView"></a>SubsamplingScaleImageView</h5><p>项目地址：<a href="https://github.com/davemorrissey/subsampling-scale-image-view" target="_blank" rel="external">https://github.com/davemorrissey/subsampling-scale-image-view</a></p>
<p>相关地址：<br><a href="http://blog.csdn.net/zhangphil/article/details/49557549" target="_blank" rel="external">Android加载/处理超大图片神器！</a></p>
<h5 id="TouchImageView"><a href="#TouchImageView" class="headerlink" title="TouchImageView"></a>TouchImageView</h5><p>项目地址：<a href="https://github.com/MikeOrtiz/TouchImageView" target="_blank" rel="external">https://github.com/MikeOrtiz/TouchImageView</a></p>
<p>相关：<br><a href="http://blog.csdn.net/leilifengxingmw/article/details/50813006" target="_blank" rel="external">TouchImageView 实现图片的缩放，双击放大缩小，多点触控的功能</a></p>
<h5 id="ImageViewZoom"><a href="#ImageViewZoom" class="headerlink" title="ImageViewZoom"></a>ImageViewZoom</h5><p>项目地址：<a href="https://github.com/sephiroth74/ImageViewZoom" target="_blank" rel="external">https://github.com/sephiroth74/ImageViewZoom</a></p>
<h5 id="GestureImageview"><a href="#GestureImageview" class="headerlink" title="GestureImageview"></a>GestureImageview</h5><p>项目地址：<a href="https://github.com/jasonpolites/gesture-imageview" target="_blank" rel="external">https://github.com/jasonpolites/gesture-imageview</a></p>
<h4 id="照相选相册裁剪照片"><a href="#照相选相册裁剪照片" class="headerlink" title="照相选相册裁剪照片"></a>照相选相册裁剪照片</h4><h5 id="CanPhotos"><a href="#CanPhotos" class="headerlink" title="CanPhotos"></a>CanPhotos</h5><p>项目地址：<a href="https://github.com/canyinghao/CanPhotos" target="_blank" rel="external">https://github.com/canyinghao/CanPhotos</a></p>
<p>使用fresco选取多张图片并可预览图片</p>
<h5 id="MultiImageSelector"><a href="#MultiImageSelector" class="headerlink" title="MultiImageSelector"></a>MultiImageSelector</h5><p>项目地址：<a href="https://github.com/lovetuzitong/MultiImageSelector.git" target="_blank" rel="external">https://github.com/lovetuzitong/MultiImageSelector.git</a></p>
<p>一个本地图片选择器，支持图片的单选和多选，直接返回所选图片的路径。</p>
<h5 id="Cropper"><a href="#Cropper" class="headerlink" title="Cropper"></a>Cropper</h5><p>项目地址：<a href="https://github.com/edmodo/cropper" target="_blank" rel="external">https://github.com/edmodo/cropper</a></p>
<p>图片局部剪切工具，可触摸控制选择区域或旋转</p>
<h5 id="PhotoCropper"><a href="#PhotoCropper" class="headerlink" title="PhotoCropper"></a>PhotoCropper</h5><p>项目地址：<a href="https://github.com/ryanhoo/PhotoCropper" target="_blank" rel="external">https://github.com/ryanhoo/PhotoCropper</a></p>
<h5 id="Android-crop"><a href="#Android-crop" class="headerlink" title="Android-crop"></a>Android-crop</h5><p>项目地址：<a href="https://github.com/jdamcd/android-crop" target="_blank" rel="external">https://github.com/jdamcd/android-crop</a></p>
<h4 id="高斯模糊-毛玻璃-效果"><a href="#高斯模糊-毛玻璃-效果" class="headerlink" title="高斯模糊(毛玻璃)效果"></a>高斯模糊(毛玻璃)效果</h4><h5 id="Stackblur"><a href="#Stackblur" class="headerlink" title="Stackblur"></a>Stackblur</h5><p>项目地址：<a href="https://github.com/kikoso/android-stackblur" target="_blank" rel="external">https://github.com/kikoso/android-stackblur</a></p>
<p>高斯模糊框架 </p>
<h5 id="ImageBlurring"><a href="#ImageBlurring" class="headerlink" title="ImageBlurring"></a>ImageBlurring</h5><p>项目地址：<a href="https://github.com/qiujuer/ImageBlurring" target="_blank" rel="external">https://github.com/qiujuer/ImageBlurring</a></p>
<h2 id="音视频处理"><a href="#音视频处理" class="headerlink" title="音视频处理"></a>音视频处理</h2><h3 id="Vitamio"><a href="#Vitamio" class="headerlink" title="Vitamio"></a>Vitamio</h3><p>项目地址：<a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="external">https://github.com/yixia/VitamioBundle</a></p>
<p>是一款 Android 与 iOS 平台上的全能多媒体开发框架</p>
<p>特点：<br>(1) 全面支持硬件解码与 GPU 渲染<br>(2) 能够流畅播放 720P 甚至 1080P 高清 MKV，FLV，MP4，MOV，TS，RMVB 等常见格式的视频<br>(3) 在 Android 与 iOS 上跨平台支持 MMS, RTSP, RTMP, HLS(m3u8)等常见的多种视频流媒体协议，包括点播与直播。</p>
<h3 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h3><p>开源的音视频解码库<br>QQ影音，快播，暴风影音用的解码库都是它</p>
<h3 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h3><p>Telecine</p>
<p>Jitsi</p>
<p>Amphitheatre</p>
<p>MediaChooser</p>
<p>OPlayer</p>
<p>BambooPlayer</p>
<p>VideoRecorder</p>
<p>video-crop</p>
<p>AndroidVideoView</p>
<p>LandscapeVideoCamera</p>
<p>VideoEnabledWebView</p>
<p>ZmqVideoChat</p>
<p>Android-ScalableVideoView</p>
<p>AndroidRecording</p>
<p>Fenster</p>
<p>FFmpegMediaPlayer</p>
<p>Audiorecognizer</p>
<hr>
<h1 id="数据库ORM框架"><a href="#数据库ORM框架" class="headerlink" title="数据库ORM框架"></a>数据库ORM框架</h1><hr>
<p>用途：数据库建模/数据库加密</p>
<p>说明：orm 的 db 工具类，简化建表、查询、更新、插入、事务、索引的操作</p>
<h2 id="GreenDao"><a href="#GreenDao" class="headerlink" title="GreenDao"></a>GreenDao</h2><p>Android Sqlite orm 的 db 工具类<br>项目地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a><br>特点：<br>(1) 性能佳<br>(2) 简单易用的 API<br>(3) 内存小好小<br>(4) 库大小小</p>
<h2 id="SQLCipher"><a href="#SQLCipher" class="headerlink" title="SQLCipher"></a>SQLCipher</h2><p>Android本地数据库加密库SQLCipher<br>•基于SQLite扩展的开源数据库，在SQLite的基础之上增加了数据加密功能<br>•SQLCipher对Android SDK中所有与数据库相关的API都制作了一份镜像，使得开发者可以像操作普遍的数据库文件一样来操作SQLCipher</p>
<h2 id="ActiveAndroid"><a href="#ActiveAndroid" class="headerlink" title="ActiveAndroid"></a>ActiveAndroid</h2><p>项目地址：<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid</a></p>
<p>相关：<br><a href="http://blog.csdn.net/u012702547/article/details/51355355" target="_blank" rel="external">玩转Android之数据库框架ActiveAndroid的使用</a></p>
<h2 id="AndroidOrmLite"><a href="#AndroidOrmLite" class="headerlink" title="AndroidOrmLite"></a>AndroidOrmLite</h2><p>项目地址：<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid</a></p>
<p>相关：<br><a href="http://blog.csdn.net/ziqiang1/article/details/52121643" target="_blank" rel="external">android OrmLite 入门</a></p>
<h2 id="Android-lite-orm"><a href="#Android-lite-orm" class="headerlink" title="Android-lite-orm"></a>Android-lite-orm</h2><p>项目地址：<a href="https://github.com/litesuits/android-lite-orm" target="_blank" rel="external">https://github.com/litesuits/android-lite-orm</a></p>
<p>相关：<br><a href="http://blog.csdn.net/u014099894/article/details/51586500" target="_blank" rel="external">Android ORM框架 LiteOrm使用</a></p>
<h2 id="Sugar-ORM"><a href="#Sugar-ORM" class="headerlink" title="Sugar ORM"></a>Sugar ORM</h2><p><a href="http://blog.csdn.net/Norwaya007/article/details/51595908" target="_blank" rel="external">SugarOrm使用</a></p>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><h2 id="DEFlow"><a href="#DEFlow" class="headerlink" title="DEFlow"></a>DEFlow</h2><hr>
<h1 id="快速开发辅助库"><a href="#快速开发辅助库" class="headerlink" title="快速开发辅助库"></a>快速开发辅助库</h1><hr>
<h2 id="IOC-DI框架"><a href="#IOC-DI框架" class="headerlink" title="IOC/DI框架"></a>IOC/DI框架</h2><p>关键词：依赖注入库/DI框架/视图注入库</p>
<p>用途：通过依赖注入减少 View、服务、资源简化初始化，事件绑定等重复繁琐工作</p>
<p>相关文章：<br><a href="http://a.codekk.com/detail/Android/%E6%89%94%E7%89%A9%E7%BA%BF/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="external">公共技术点之依赖注入</a><br><a href="http://www.jianshu.com/p/3968ffabdf9d" target="_blank" rel="external">Android主流IOC框架浅析</a></p>
<h3 id="Android-Annotations"><a href="#Android-Annotations" class="headerlink" title="Android Annotations"></a>Android Annotations</h3><p>地址：<a href="https://github.com/androidannotations/androidannotations/wiki" target="_blank" rel="external">https://github.com/androidannotations/androidannotations/wiki</a></p>
<p>相关：<br><a href="http://blog.csdn.net/zjbpku/article/details/18676149" target="_blank" rel="external">Android开源框架(一)：AndroidAnnotations</a></p>
<h3 id="Butter-Knife"><a href="#Butter-Knife" class="headerlink" title="Butter Knife"></a>Butter Knife</h3><p>地址：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">https://github.com/JakeWharton/butterknife</a></p>
<p>Android视图注入库，它使用注释来处理findViewById，Onclick()等内容<br>View的依赖注入</p>
<p>相关：<br><a href="https://mp.weixin.qq.com/s/HJVsyjnqR9W0urKxkJqv6A" target="_blank" rel="external">一篇文章玩转ButterKnife，让代码更简洁</a></p>
<h3 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h3><p>项目地址：<a href="https://github.com/square/dagger" target="_blank" rel="external">https://github.com/square/dagger</a><br>最新版本：Dagger2</p>
<p>依赖注入，适用于Android和Java</p>
<h3 id="guice"><a href="#guice" class="headerlink" title="guice"></a>guice</h3><p>地址：<a href="https://github.com/google/guice" target="_blank" rel="external">https://github.com/google/guice</a></p>
<h3 id="RoboGuice"><a href="#RoboGuice" class="headerlink" title="RoboGuice"></a>RoboGuice</h3><p>地址：<a href="https://github.com/roboguice/roboguice" target="_blank" rel="external">https://github.com/roboguice/roboguice</a></p>
<h2 id="事件总线框架"><a href="#事件总线框架" class="headerlink" title="事件总线框架"></a>事件总线框架</h2><p>用途：事件管理(订阅者模式)/组件内通讯</p>
<p>基于发布者/订阅者(publisher/subscriber)模式<br>解耦事件发送和接受<br>从而简化应用程序组件(Activities, Fragments 及后台线程)之间的通信</p>
<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>项目地址：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a></p>
<p>greenrobot 的开源项目</p>
<p>组件内通讯</p>
<p>采用EventBus作为事件管理，简直就是爽。简简单单就可以跨线程，跨组件通信，很多以前要很复杂才能实现的功能一下子就可以实现了。</p>
<p>特点：<br>(1) 支持在不同类型的线程中处理订阅，包括发布所在线程，UI 线程、单一后台线程、异步线程<br>(2) 支持事件优先级定义，支持优先级高的订阅者取消事件继续传递，支持粘性事件，是不是跟系统的有序广播、粘性广播很像啊<br>(3) 不是基于 annotations<br>(4) 性能更优<br>(5) 体积小<br>(6) 支持单例创建或创建多个对象<br>(7) 支持根据事件类型订阅</p>
<p>相关：<br><a href="http://blog.csdn.net/stimgo/article/details/52684390" target="_blank" rel="external">EventBus事件总线——优雅地替换Handler</a><br><a href="http://blog.csdn.net/harvic880925/article/details/40660137" target="_blank" rel="external">EventBus使用详解(一)——初步使用EventBus</a><br><a href="http://blog.csdn.net/harvic880925/article/details/40787203" target="_blank" rel="external">EventBus使用详解(二)——EventBus使用进阶</a></p>
<h3 id="otto"><a href="#otto" class="headerlink" title="otto"></a>otto</h3><p>项目地址：<a href="https://github.com/square/otto" target="_blank" rel="external">https://github.com/square/otto</a></p>
<p>Square 的开源项目，基于 Guava 的 Android 优化</p>
<h3 id="AndroidEventBus"><a href="#AndroidEventBus" class="headerlink" title="AndroidEventBus"></a>AndroidEventBus</h3><p>地址：<a href="https://github.com/hehonghui/AndroidEventBus" target="_blank" rel="external">https://github.com/hehonghui/AndroidEventBus</a></p>
<p>书籍：Android源码设计模式解析与实战——12.8 实战 推荐的库</p>
<h2 id="兼容库"><a href="#兼容库" class="headerlink" title="兼容库"></a>兼容库</h2><p>用途：Android 高版本向低版本兼容</p>
<h3 id="Nineoldandroids"><a href="#Nineoldandroids" class="headerlink" title="Nineoldandroids"></a>Nineoldandroids</h3><p>Nineold是比API9早的动画，支持低版本，因为属性动画是3.0才出现的</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>HoloEverywhere</p>
<p>Android-styled-dialogs</p>
<p>Android-switch-backport</p>
<p>MaterialDesignLibrary</p>
<p>Material</p>
<p>Material-dialogs</p>
<h2 id="缓存库"><a href="#缓存库" class="headerlink" title="缓存库"></a>缓存库</h2><p>DiskLurCacje</p>
<p>ASimpleCache</p>
<p>ObjectCache</p>
<p>Android-easy-cache</p>
<p>AndridVideoCache</p>
<p>Base-diskcache</p>
<h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p>Guava</p>
<p>AndroidCommon</p>
<p>LiteCommon</p>
<p>AndResGuard</p>
<h2 id="Android插件化"><a href="#Android插件化" class="headerlink" title="Android插件化"></a>Android插件化</h2><p>DroidPlugin</p>
<p>Dynamic-load-apk</p>
<p>CJFrameForAndroid</p>
<p>Android-Skin-Loader</p>
<p>AndroidDynamicLoader</p>
<p>xCombine</p>
<p>Apf</p>
<p>OpenAtlas</p>
<p>Android-plugin</p>
<hr>
<h1 id="测试库"><a href="#测试库" class="headerlink" title="测试库"></a>测试库</h1><hr>
<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p>Robotium<br>自动化测试框架。<br>想想你要花多久的时间在调试、测试上面，就知道这个自动化测试框架有多重要了。</p>
<p>selendroid</p>
<p>Android-testing</p>
<p>Assertj-android</p>
<p>Android-testing-templates</p>
<p>Appium</p>
<p>Robolectric</p>
<p>UiAutomator</p>
<h2 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h2><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>项目地址：<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">https://github.com/orhanobut/logger</a></p>
<p>一个简单、漂亮、功能强大的Android日志程序。<br>简单、美观而且十分强大的 Android 日志工具</p>
<p>相关：<br><a href="http://www.open-open.com/lib/view/open1427166371418.html" target="_blank" rel="external">一个简单、漂亮、功能强大的Android日志程序：logger</a></p>
<h3 id="DebugLog"><a href="#DebugLog" class="headerlink" title="DebugLog"></a>DebugLog</h3><p>项目地址：<a href="https://github.com/MustafaFerhan/DebugLog" target="_blank" rel="external">https://github.com/MustafaFerhan/DebugLog</a></p>
<p>很简单的一个Lib项目，却能在很大程度上帮助开发者。可以在打印Log的时候自动打印出方法名和行号。<br>可以帮你创建更简单和更容易理解的调试日志，能够友好的显示调试信息所在类和函数。</p>
<h3 id="jlog"><a href="#jlog" class="headerlink" title="jlog"></a>jlog</h3><p>项目地址：<a href="https://github.com/JiongBull/jlog" target="_blank" rel="external">https://github.com/JiongBull/jlog</a></p>
<p>可以灵活配置的日志工具，支持JSON打印，日志保存到指定文件，日志显示调用位置（混淆模式下依然有效）</p>
<h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等;我们也可以控制每一条日志的输出格式;通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
<p>网络有个工具（log4j.jar）建立Java日志信息的，<br>把这工具下载下来，里面有很多对象，可以完成日志信息的建立，它更方便一些，而且存储格式更好看一些.</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>Hugo</p>
<p>Timber</p>
<p>Galgo</p>
<p>Puree-android</p>
<p>LogUtils</p>
<hr>
<h1 id="其他三方库"><a href="#其他三方库" class="headerlink" title="其他三方库"></a>其他三方库</h1><hr>
<h2 id="智能识别"><a href="#智能识别" class="headerlink" title="智能识别"></a>智能识别</h2><p>用途：人脸识别，指纹识别，文字识别，语音识别，图像识别，地理区域识别</p>
<p>OpenCV<br>人脸识别</p>
<p>Android-tesseract-ocr</p>
<p>Card.io SDK for Android</p>
<h2 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h2><p>用户：二维码生成与扫描    </p>
<h3 id="zxing"><a href="#zxing" class="headerlink" title="zxing"></a>zxing</h3><p>项目地址：<a href="https://github.com/zxing/zxing" target="_blank" rel="external">https://github.com/zxing/zxing</a><br>二维码，条形码</p>
<h3 id="ZBar"><a href="#ZBar" class="headerlink" title="ZBar"></a>ZBar</h3><h3 id="QrCodeScan"><a href="#QrCodeScan" class="headerlink" title="QrCodeScan"></a>QrCodeScan</h3><p>项目地址：<a href="https://github.com/SkillCollege/QrCodeScan" target="_blank" rel="external">https://github.com/SkillCollege/QrCodeScan</a><br>ZXing 和 ZBar 结合的二维码扫描项目，提高了扫描效率</p>
<h2 id="消息推送-即时通信"><a href="#消息推送-即时通信" class="headerlink" title="消息推送/即时通信"></a>消息推送/即时通信</h2><p>Conversations</p>
<p>Asmack</p>
<p>Smack</p>
<p>Openfire</p>
<p>Androidpn</p>
<p>Yaxim</p>
<p>Jitsi-android</p>
<p>PushTalk</p>
<p>Android-tcp-long-connection-based-on-Apache-mina</p>
<p>DDPush</p>
<p>TeamTalk</p>
<h2 id="地图定位"><a href="#地图定位" class="headerlink" title="地图定位"></a>地图定位</h2><p>Android-maps-utils</p>
<p>Android-play-location</p>
<p>Smart-location-lib</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="HeiPermission"><a href="#HeiPermission" class="headerlink" title="HeiPermission"></a>HeiPermission</h3><p>用处：<br>一句代码搞定 Android 6.0 权限检测</p>
<p>发现出处：<br><a href="http://p.codekk.com/" target="_blank" rel="external">http://p.codekk.com/</a><br><a href="http://p.codekk.com/detail/Android/forJrking/HeiPermission" target="_blank" rel="external">http://p.codekk.com/detail/Android/forJrking/HeiPermission</a></p>
<p>地址：<br><a href="https://github.com/forJrking/HeiPermission" target="_blank" rel="external">https://github.com/forJrking/HeiPermission</a></p>
<h2 id="反射库"><a href="#反射库" class="headerlink" title="反射库"></a>反射库</h2><p><a href="http://droidyue.com/blog/2017/01/09/joor-examples/" target="_blank" rel="external">一个事半功倍的Java反射库</a></p>
<h2 id="拼音搜索"><a href="#拼音搜索" class="headerlink" title="拼音搜索"></a>拼音搜索</h2><h3 id="PinyinSearch"><a href="#PinyinSearch" class="headerlink" title="PinyinSearch"></a>PinyinSearch</h3><p>项目地址： <a href="https://github.com/handsomezhou/PinyinSearchLibrary" target="_blank" rel="external">https://github.com/handsomezhou/PinyinSearchLibrary</a></p>
<p>一个为 T9 搜索和 Qwerty 搜索,提供数据解析与匹配等方法的拼音搜索 java 库。</p>
<p>APP使用场所示例： 通讯录应用，微信电话本</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_openutils_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android —— 性能优化系列</title>
    <link href="https://hengxing0080.github.io/2017/09/28/it/1.Android/Performance/"/>
    <id>https://hengxing0080.github.io/2017/09/28/it/1.Android/Performance/</id>
    <published>2017-09-28T15:56:13.000Z</published>
    <updated>2017-11-10T11:19:43.378Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_performance_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>(上图临时占位，等后续总结成思维导图待替换…)</p>
<p>优化前言：<br>工作中随着代码体量变得日趋臃肿，视图层级越来越深，工程结构也越来越复杂。<br>相应的，输出的apk包越来越大，界面流畅性大不如前，经常性发生卡顿，甚至不时出现内存溢出崩溃。<br>在这个阶段，Android开发需要掌握以下方面的技术：<br>AndroidStudio的使用(包括调试工具，测试工具，快捷键等)<br>Android资源管理<br>Android视图架构（Activity视图层级、layout inflate）<br>代码优化<br>UI优化<br>内存优化<br>电量优化<br>网络优化<br>数据库优化<br>动画优化<br>NDK JNI开发<br>……</p>
<p>优化的原则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.时间换空间</div><div class="line">    牺牲时间换取空间, 流的读写</div><div class="line">2.空间换时间</div><div class="line">    把文件的路径存放到数据库里面,以后查询效率就高很多</div><div class="line">    Android下的图库应用检索sd卡的图片</div><div class="line">3.空间换空间</div><div class="line">    把内存换成硬盘 或者把硬盘换成内存</div><div class="line">4.时间换时间</div><div class="line">    开启启动速度的优化</div></pre></td></tr></table></figure></p>
<p>性能测试中存在两个概念：<br>(1). 响应时间<br>指从用户操作开始到系统给用户以正确反馈的时间。一般包括逻辑处理时间 + 网络传输时间 + 展现时间。对于非网络类应用不包括网络传输时间。<br>展现时间即网页或 App 界面渲染时间。</p>
<p>响应时间是用户对性能最直接的感受。</p>
<p>(2). TPS(Transaction Per Second)<br>TPS为每秒处理的事务数，是系统吞吐量的指标，在搜索系统中也用QPS(Query Per Second)衡量。TPS一般与响应时间反相关。</p>
<p>通常所说的性能问题就是指响应时间过长、系统吞吐量过低。</p>
<p>对后台开发来说，也常将高并发下内存泄漏归为性能问题。<br>对移动开发来说，性能问题还包括电量、内存使用这两类较特殊情况。</p>
<p>性能调优方式：<br>明白了何为性能问题之后，就能明白性能优化实际就是优化系统的响应时间，提高TPS。优化响应时间，提高TPS。方式不外乎这三大类：<br>(1) 降低执行时间<br>又包括几小类<br>a. 利用多线程并发或分布式提高 TPS<br>b. 缓存(包括对象缓存、IO 缓存、网络缓存等)<br>c. 数据结构和算法优化<br>d. 性能更优的底层接口调用，如 JNI 实现<br>e. 逻辑优化<br>f. 需求优化</p>
<p>(2) 同步改异步，利用多线程提高TPS</p>
<p>充分利用多核Cpu优势，利用线程解决密集型计算、IO、网络等操作。</p>
<p>(3) 提前或延迟操作，错峰提高TPS</p>
<p>对于上面提到的数据库优化、布局优化、代码优化、网络优化等等都可以归纳到上面的几种方式中。</p>
<p>下面开始各个章节的介绍，这是我工作学习中不断自我收集和收集各种技术大牛博客总结的，此文将不断的更新！</p>
<hr>
<h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><hr>
<p>相关文章：<br><a href="http://www.trinea.cn/android/layout-performance/" target="_blank" rel="external">Trinea——性能优化之布局优化</a><br><a href="http://blog.csdn.net/arui319/article/details/8549849" target="_blank" rel="external">[Android] Android开发优化之——对界面UI的优化（1）</a><br><a href="http://blog.csdn.net/arui319/article/details/8554816" target="_blank" rel="external">[Android] Android开发优化之——对界面UI的优化（2）</a><br><a href="http://blog.csdn.net/arui319/article/details/8561757" target="_blank" rel="external">[Android] Android开发优化之——对界面UI的优化（3）</a></p>
<p>UI界面布局也会对应用程序的性能会产生很大的影响，如果布局写得糟糕的话，那么程序加载UI的速度就会非常慢，从而造成不好的用户体验。<br>那么本篇文章就来学习一下，如何通过优化布局来提供应用程序的性能。</p>
<h2 id="复用Android系统资源"><a href="#复用Android系统资源" class="headerlink" title="复用Android系统资源"></a>复用Android系统资源</h2><p>Android系统本身有很多资源在应用中都可以直接使用，具体的，可以进入android-sdk的相应文件夹中去查看。例如：可以进入$android-sdk$\platforms\android-8\data\res，里面的系统资源就一览无余了。<br>开发者需要花一些时间去熟悉这些资源，特别是图片资源和各种Style资源，这样在开发过程中，能够想到有相关资源并且直接拿来使用。</p>
<h3 id="利用系统定义的id"><a href="#利用系统定义的id" class="headerlink" title="利用系统定义的id"></a>利用系统定义的id</h3><p>比如我们有一个定义ListView的xml文件，一般的，我们会写类似下面的代码片段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    android:id=<span class="string">"@+id/mylist"</span></div><div class="line">    android:layout_width=<span class="string">"fill_parent"</span></div><div class="line">    android:layout_height=<span class="string">"fill_parent"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>这里我们定义了一个ListView，定义它的id是”@+id/mylist”。实际上，如果没有特别的需求，就可以利用系统定义的id，类似下面的样子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    android:id=<span class="string">"@android:id/list"</span></div><div class="line">    android:layout_width=<span class="string">"fill_parent"</span></div><div class="line">    android:layout_height=<span class="string">"fill_parent"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>在xml文件中引用系统的id，只需要加上“@android:”前缀即可。如果是在Java代码中使用系统资源，和使用自己的资源基本上是一样的。不同的是，需要使用android.R类来使用系统的资源，而不是使用应用程序指定的R类。这里如果要获取ListView可以使用android.R.id.list来获取。</p>
<h3 id="利用系统的图片资源"><a href="#利用系统的图片资源" class="headerlink" title="利用系统的图片资源"></a>利用系统的图片资源</h3><p> 假设我们在应用程序中定义了一个menu，xml文件如下。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/menu_attachment"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"附件"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@android:drawable/ic_menu_attachment"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中代码片段android:icon=”@android:drawable/ic_menu_attachment”本来是想引用系统中已有的Menu里的“附件”的图标。但是在Build工程以后，发现出现了错误。提示信息如下：<br>error: Error: Resource is not public. (at ‘icon’ with value ‘@android:drawable/ic_menu_attachment’).</p>
<p>从错误的提示信息大概可以看出，由于该资源没有被公开，所以无法在我们的应用中直接引用。既然这样的话，我们就可以在Android SDK中找到相应的图片资源，直接拷贝到我们的工程目录中，然后使用类似android:icon=”@drawable/ic_menu_attachment”的代码片段进行引用。<br>这样做的好处，一个是美工不需要重复的做一份已有的图片了，可以节约不少工时；另一个是能保证我们的应用程序的风格与系统一致。</p>
<p>PS经验分享：<br>Android中没有公开的资源，在xml中直接引用会报错。除了去找到对应资源并拷贝到我们自己的应用目录下使用以外，我们还可以将引用“@android”改成“@<em>android”解决。比如上面引用的附件图标，可以修改成下面的代码。<br>android:icon=”@</em>android:drawable/ic_menu_attachment”<br>修改后，再次Build工程，就不会报错了。</p>
<h3 id="利用系统的字符串资源"><a href="#利用系统的字符串资源" class="headerlink" title="利用系统的字符串资源"></a>利用系统的字符串资源</h3><p>假设我们要实现一个Dialog，Dialog上面有“确定”和“取消”按钮。就可以使用下面的代码直接使用Android系统自带的字符串。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/yes"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.0"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@android:string/yes"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/no"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.0"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@android:string/no"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果使用系统的字符串，默认就已经支持多语言环境了。<br>如上述代码，直接使用了@android:string/yes和@android:string/no，在简体中文环境下会显示“确定”和“取消”，在英文环境下会显示“OK”和“Cancel”。</p>
<h3 id="利用系统的Style"><a href="#利用系统的Style" class="headerlink" title="利用系统的Style"></a>利用系统的Style</h3><p>假设布局文件中有一个TextView，用来显示窗口的标题，使用中等大小字体。可以使用下面的代码片段来定义TextView的Style。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/title"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:textAppearance</span>=<span class="string">"?android:attr/textAppearanceMedium"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>其中android:textAppearance=”?android:attr/textAppearanceMedium”就是使用系统的style。需要注意的是，使用系统的style，需要在想要使用的资源前面加“?android:”作为前缀，而不是“@android:”。</p>
<h3 id="利用系统的颜色定义"><a href="#利用系统的颜色定义" class="headerlink" title="利用系统的颜色定义"></a>利用系统的颜色定义</h3><p>除了上述的各种系统资源以外，还可以使用系统定义好的颜色。<br>在项目中最常用的，就是透明色的使用。代码片段如下。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:background ="@android:color/transparent"</div></pre></td></tr></table></figure></p>
<p>经验分享：<br>Android系统本身有很多资源在应用中都可以直接使用，具体的，可以进入android-sdk的相应文件夹中去查看。例如：可以进入$android-sdk$\platforms\android-8\data\res，里面的系统资源就一览无余了。<br>开发者需要花一些时间去熟悉这些资源，特别是图片资源和各种Style资源，这样在开发过程中，能够想到有相关资源并且直接拿来使用。</p>
<h3 id="尽量为所有分辨率创建资源"><a href="#尽量为所有分辨率创建资源" class="headerlink" title="尽量为所有分辨率创建资源"></a>尽量为所有分辨率创建资源</h3><p>减少不必要的硬件缩放，这会降低UI的绘制速度，可借助Android asset studio</p>
<h2 id="巧用抽象布局标签-include-viewstub-merge"><a href="#巧用抽象布局标签-include-viewstub-merge" class="headerlink" title="巧用抽象布局标签(include, viewstub, merge)"></a>巧用抽象布局标签(include, viewstub, merge)</h2><p>在布局优化中，Androi的官方提到了这三种布局并介绍了这三种布局各有的优势<br>当你在Application中创建复杂的布局时，页面的渲染过程也变得更加缓慢。<br>此时，我们需要利用include标签(布局重用,避免重复渲染)和ViewStub标签(延迟加载)和merge标签(布局合并)来优化我们的页面。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/43376527" target="_blank" rel="external">Android最佳性能实践(四)——布局优化技巧</a></p>
<h2 id="OverDraw（过度绘制）-amp-渲染绘制的性能优化"><a href="#OverDraw（过度绘制）-amp-渲染绘制的性能优化" class="headerlink" title="OverDraw（过度绘制）&amp; 渲染绘制的性能优化"></a>OverDraw（过度绘制）&amp; 渲染绘制的性能优化</h2><p>相关文章：<br>    <a href="http://blog.csdn.net/lmj623565791/article/details/45556391" target="_blank" rel="external">Android UI性能优化实战 识别绘制中的性能问题</a><br>    <a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a><br>    <a href="http://www.jianshu.com/p/9e095bacf44a" target="_blank" rel="external">实战 Android中的UI过度绘制</a></p>
<p>准备知识：<br>    Android渲染机制</p>
<p>处理方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.移除不必要的background</div><div class="line">    1.1.移除Window默认的Background</div><div class="line">    1.2.移除XML布局文件中非必需的Background</div><div class="line"></div><div class="line">2.onDraw多次重复绘制图案</div><div class="line">    1.1.clipRect的妙用</div><div class="line">    1.2.drawRect等等</div></pre></td></tr></table></figure></p>
<h2 id="去除不必要的层级嵌套和View节点"><a href="#去除不必要的层级嵌套和View节点" class="headerlink" title="去除不必要的层级嵌套和View节点"></a>去除不必要的层级嵌套和View节点</h2><p>4.0及以上Android版本可通过设置-&gt;开发者选项-&gt;显示布局边界打开页面布局显示，看看是否有不必要的节点和嵌套。4.0以下版本可通过hierarchy viewer查看。</p>
<p>(1) 首次不需要使用的节点设置为GONE或使用viewstub<br>很多人在工作中将不常用的元素使用INVISIBLE或者GONE进行隐藏，然后当用户需要使用这些元素的时候再把它们置成VISIBLE显示出来。使用这种方式肯定可以实现功能的，但是性能方面就表现得一般了，因为即使是将元素进行隐藏，它们其实还是在布局当中的，每个元素还拥有着自己的宽、高、背景等等属性，解析布局的时候也会将这些隐藏的元素一一解析出来。</p>
<p>那么我们如何才能让这些不常用的元素仅在需要时才去加载呢？Android为此提供了一种非常轻量级的控件，ViewStub。ViewStub虽说也是View的一种，但是它没有大小，没有绘制功能，也不参与布局，资源消耗非常低，将它放置在布局当中基本可以认为是完全不会影响性能的。</p>
<p>(2) 使用RelativeLayout代替LinearLayout<br>大约在Android4.0之前，新建工程的默认main.xml中顶节点是LinearLayout，而在之后已经改为RelativeLayout，因为RelativeLayout性能更优，且可以简单实现LinearLayout嵌套才能实现的布局。<br>使用RelativeLayout减少视图树的层级，防止过度绘制</p>
<p>某网友关键评论如下：<br>通过测试，相同层级的情况下， RelativeLayout 和LinearLayour之间的效率没<br>有太大差异，但是对于同样的一个布局效果，用RelativeLayout产生的View层级嵌套比<br>LinearLayout的层级要少一些，我们知道，层级嵌套越深，资源消耗是越大的，测量和布局<br>所花费的时间是越长的。所以，相对来说RelativeLayout的效率比LinearLayout要高一些。<br>Google更加推荐咱们在写布局时，使用RelativeLayout，当我们在创建一个新工程时，<br>main_activity.xml的最外层布局是RelativeLayout。</p>
<p>复杂布局推荐使用RelativeLayout</p>
<p><a href="http://www.jianshu.com/p/8a7d059da746" target="_blank" rel="external">Android中RelativeLayout和LinearLayout性能分析</a><br><a href="http://blog.csdn.net/wangjia55/article/details/37772763" target="_blank" rel="external">【Android性能优化】尽可能用RelativeLayout来代替多层嵌套的LinearLayout</a><br><a href="https://www.zhihu.com/question/36762882" target="_blank" rel="external">安卓FrameLayout LinearLayout RelativeLayout 效率高低？</a></p>
<h2 id="减少不必要的infalte"><a href="#减少不必要的infalte" class="headerlink" title="减少不必要的infalte"></a>减少不必要的infalte</h2><p>(1) 对于inflate的布局可以直接缓存，用全部变量代替局部变量，避免下次需再次inflate<br>如上面ViewStub示例中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</div><div class="line">  networkErrorView.setVisibility(View.VISIBLE);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</div><div class="line">  networkErrorView.setVisibility(View.VISIBLE);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2) ListView提供了item缓存，adapter getView的标准写法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">  ImageView appIcon;</div><div class="line">  TextView  appName;</div><div class="line">  TextView  appInfo;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">  ViewHolder holder;</div><div class="line">  <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">    convertView = inflater.inflate(R.layout.list_item, <span class="keyword">null</span>);</div><div class="line">    holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">    ……</div><div class="line">    convertView.setTag(holder);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    holder = (ViewHolder)convertView.getTag();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于ListView缓存原理可见Android ListView缓存机制。</p>
<h2 id="View控件优化"><a href="#View控件优化" class="headerlink" title="View控件优化"></a>View控件优化</h2><h3 id="用SurfaceView或TextureView代替普通View"><a href="#用SurfaceView或TextureView代替普通View" class="headerlink" title="用SurfaceView或TextureView代替普通View"></a>用SurfaceView或TextureView代替普通View</h3><p>SurfaceView或TextureView可以通过将绘图操作移动到另一个单独线程上提高性能。<br>普通View的绘制过程都是在主线程(UI线程)中完成，如果某些绘图操作影响性能就不好优化了，这时我们可以考虑使用SurfaceView和TextureView，他们的绘图操作发生在UI线程之外的另一个线程上。<br>因为SurfaceView在常规视图系统之外，所以无法像常规试图一样移动、缩放或旋转一个SurfaceView。<br>TextureView是Android4.0引入的，除了与SurfaceView一样在单独线程绘制外，还可以像常规视图一样被改变。</p>
<h3 id="ViewPager优化"><a href="#ViewPager优化" class="headerlink" title="ViewPager优化"></a>ViewPager优化</h3><h4 id="Activity返回ViewPager-Activity较慢"><a href="#Activity返回ViewPager-Activity较慢" class="headerlink" title="Activity返回ViewPager Activity较慢"></a>Activity返回ViewPager Activity较慢</h4><p>定位：在onStart函数<br>解决：使用延迟策略，具体代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    appUpdateListAdapter.notifyDataSetChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    <span class="comment">// delay send message</span></div><div class="line">    handler.sendMessageDelayed(handler.obtainMessage(MessageConstants.WHAT_NOTIFY_DATA_CHANGED), <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MessageConstants.WHAT_NOTIFY_DATA_CHANGED:</div><div class="line">                <span class="keyword">if</span> (appUpdateListAdapter != <span class="keyword">null</span>) &#123;</div><div class="line">                    appUpdateListAdapter.notifyDataSetChanged();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><p>相关文章：<br><a href="http://www.cnblogs.com/xiongbo/archive/2011/07/14/2106387.html" target="_blank" rel="external">ListView优化三原则</a></p>
<h4 id="复用convertView"><a href="#复用convertView" class="headerlink" title="复用convertView"></a>复用convertView</h4><p>使用ListView的时候，必须让ConvertView得到复用。</p>
<p>在getItemView中，判断convertView是否为空，如果不为空，可复用。</p>
<p>这个最常用的缓存方法如果不小心写错了造成的内存损失也相当巨大，数据量大手机内存小的情况下只需疯狂滑动几下app即可崩溃.</p>
<p>标准模板也留下一个：<br>在继承BaseAdapter时会让我们重写getView(int position, View   convertView, ViewGroup parent)方法，<br>第二个参数convertView就是我们要用到的重用的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;  </div><div class="line">    ViewHolder vHolder = <span class="keyword">null</span>;  </div><div class="line">    <span class="comment">//如果convertView对象为空则创建新对象，不为空则复用  </span></div><div class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;  </div><div class="line">        convertView = inflater.inflate(..., <span class="keyword">null</span>);  </div><div class="line">        <span class="comment">// 创建 ViewHodler 对象  </span></div><div class="line">        vHolder = <span class="keyword">new</span> ViewHolder();  </div><div class="line">        vHolder.img= (ImageView) convertView.findViewById(...);  </div><div class="line">        vHolder.tv= (TextView) convertView.findViewById(...);  </div><div class="line">        <span class="comment">// 将ViewHodler保存到Tag中  </span></div><div class="line">        convertView.setTag(vHolder);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                       <span class="comment">//当convertView不为空时，通过getTag()得到View  </span></div><div class="line">        vHolder = (ViewHolder) convertView.getTag();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 给对象赋值，修改显示的值  </span></div><div class="line">    vHolder.img.setImageBitmap(...);  </div><div class="line">    vHolder.tv.setText(...);  </div><div class="line">    <span class="keyword">return</span> convertView;  </div><div class="line">&#125;  </div><div class="line">       <span class="comment">//将显示的View 包装成类  </span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;  </div><div class="line">    TextView tv;  </div><div class="line">    ImageView img;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里只讲使用方法，具体性能测试文章请见：<br><a href="http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html" target="_blank" rel="external">ListView中getView的原理＋如何在ListView中放置多个item</a><br><a href="http://shinfocom.iteye.com/blog/1231511" target="_blank" rel="external">Android开发之ListView适配器（Adapter）优化</a></p>
<p>注意事项：<br>如果convertView中的view需要添加listerner，代码一定要在if(convertView==null){}之外。</p>
<h4 id="Listview判断不滑动才加载数据"><a href="#Listview判断不滑动才加载数据" class="headerlink" title="Listview判断不滑动才加载数据"></a>Listview判断不滑动才加载数据</h4><p>快速滑动时不显示图片<br>当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来</p>
<p>相关文章：<br><a href="http://blog.csdn.net/yy1300326388/article/details/45153813" target="_blank" rel="external">Listview滑动时不加载数据，停下来时加载数据，让App更优</a></p>
<h4 id="异步加载图片和图片缓存和Lru回收"><a href="#异步加载图片和图片缓存和Lru回收" class="headerlink" title="异步加载图片和图片缓存和Lru回收"></a>异步加载图片和图片缓存和Lru回收</h4><p>item中如果包含有webimage，那么最好异步加载</p>
<p>list中异步加载的图片，当不在可视范围内，按照一定的算法及时回收（如在当前可视范围的上下10条item以外的图片进行回收，或者将图片进行缓存，设置一个大小，按照最近最少使用原则超过部分进行回收）</p>
<h4 id="BaseAdapter避免内存溢出"><a href="#BaseAdapter避免内存溢出" class="headerlink" title="BaseAdapter避免内存溢出"></a>BaseAdapter避免内存溢出</h4><p>如果BaseAdapter的实体类有属性非常消耗内存，可以将保存到文件；为提高性能，可以进行缓存，并限制缓存大小。</p>
<h3 id="GridView优化"><a href="#GridView优化" class="headerlink" title="GridView优化"></a>GridView优化</h3><h4 id="Gridview的滥用"><a href="#Gridview的滥用" class="headerlink" title="Gridview的滥用"></a>Gridview的滥用</h4><p>Gridview和Listview的实现方式一样，GridVIew的view不是及时创建，而全部保存在内存中，比如Gridview有100项，虽然我们只能看10项，但是其实整个100项都是在内存中</p>
<h3 id="Webview优化"><a href="#Webview优化" class="headerlink" title="Webview优化"></a>Webview优化</h3><p>Webview也能泄漏，如webview对象没有销毁，所以要注意了</p>
<h3 id="TextView优化"><a href="#TextView优化" class="headerlink" title="TextView优化"></a>TextView优化</h3><p>TextView的android:ellipsize=”marquee”跑马灯效果极耗性能，具体原因还在深入源码中</p>
<hr>
<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><hr>
<p>时间和空间的处理<br>处理每一个细节<br>使用的任何资源都记得关闭或者异常处理，保证在最恶劣的情况下也能使资源得到释放。</p>
<p>本文会介绍一些常见的避免创建对象的场景和方法，其中有些属于微优化，有的属于编码技巧，当然也有确实能够起到显著效果的方法。</p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/java-android-performance/" target="_blank" rel="external">Trinea——性能优化之Java(Android)代码优化</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/42318689" target="_blank" rel="external">Android最佳性能实践(三)——高性能编码优化</a><br><a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">如何在Android中避免创建不必要的对象</a><br><a href="http://blog.csdn.net/arui319/article/details/8537588" target="_blank" rel="external">[Android] Android开发优化之——从代码角度进行优化</a></p>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>减少变量创建的次数<br>去掉大量的临时变量和部分全局变量<br>不要在循环当中声明临时变量，不要在循环中捕获异常。<br>但当局部变量不需要时，不需明显的设为null，因为一个方法执行完毕时，这些引用会自动被清理。</p>
<p>我们所要遵守的一个基本原则就是尽可能地少创建临时对象，越少的对象意味着越少的GC操作，同时也就意味着越好的程序性能和用户体验。</p>
<p>避免创建对象的场景：<br>1.在没有特殊原因的情况下，尽量使用基本数据类来代替封装数据类型，int比Integer要更加高效，其它数据类型也是一样。<br>2.正如前面所说，基本数据类型要优于对象数据类型，类似地，基本数据类型的数组也要优于对象数据类型的数组。另外，两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的两个数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效得多。</p>
<h2 id="使用单例"><a href="#使用单例" class="headerlink" title="使用单例"></a>使用单例</h2><p>单例是我们常用的设计模式，使用这种模式，我们可以只提供一个对象供全局调用。因此单例是避免创建不必要的对象的一种方式。</p>
<p>单例模式上手容易，但是需要注意很多问题，最重要的就是多线程并发的情况下保证单例的唯一性。当然方式很多，比如饿汉式，懒汉式double-check等。这里介绍一个很极客的书写单例的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceHolder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java中，类的静态初始化会在类被加载时触发，我们利用这个原理，可以实现利用这一特性，结合内部类，可以实现上面的代码，进行懒汉式创建实例。</p>
<p>当然还有其他常见的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object    obj      = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// if already inited, no need to get lock everytime</span></div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单例还有个会造成内存泄漏的问题。<br>别急，详情查看在后面的章节（单例引起的内存泄露）</p>
<h3 id="注意字符串拼接"><a href="#注意字符串拼接" class="headerlink" title="注意字符串拼接"></a>注意字符串拼接</h3><p>字符串这个或许是最不起眼的一项了。这里主要讲的是字符串的拼接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Log.i(LOGTAG, <span class="string">"onCreate bundle="</span> + savedInstanceState);</div></pre></td></tr></table></figure></p>
<p>这应该是我们最常见的打log的方式了，然而字符串的拼接内部实际是生成StringBuilder对象，然后挨个进行append，直至最后调用toString方法的过程。</p>
<p>下面是一段代码循环的代码，这明显是很不好的，因为这其中创建了很多的StringBuilder对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">implicitUseStringBuilder</span><span class="params">(String[] values)</span> </span>&#123;</div><div class="line">  String result = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; values.length; i ++) &#123;</div><div class="line">      result += values[i];</div><div class="line">  &#125;</div><div class="line">  System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>降低字符串拼接的方法有<br>1.使用String.format替换<br>2.如果是循环拼接，建议显式在循环外部创建StringBuilder使用</p>
<p>关于字符串拼接的原理考究，可以参考这篇文章：<a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/" target="_blank" rel="external">Java细节：字符串的拼接</a></p>
<h3 id="StringBuffer或StringBuilder替代String"><a href="#StringBuffer或StringBuilder替代String" class="headerlink" title="StringBuffer或StringBuilder替代String"></a>StringBuffer或StringBuilder替代String</h3><p>字符串拼接用StringBuilder代替String（String对象在进程处理时是新建一个对象），在非并发情况下用StringBuilder代替StringBuffer。</p>
<p>场景：<br>1.如果我们有一个需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。</p>
<p>2.当一个方法的返回值是String的时候，通常可以去判断一下这个String的作用是什么，如果我们明确地知道调用方会将这个返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。</p>
<p>3.设置合理的大小<br>如果你对字符串的长度有大致了解，如100字符左右，可以直接new StringBuilder(128)指定初始大小，减少空间不够时的再次分配。</p>
<p>4.用完记得回收对象<br>StringBuilder.sentLength(0) </p>
<h2 id="对象不用了把对象数据成员设为null或者从集合中移除该对象。"><a href="#对象不用了把对象数据成员设为null或者从集合中移除该对象。" class="headerlink" title="对象不用了把对象数据成员设为null或者从集合中移除该对象。"></a>对象不用了把对象数据成员设为null或者从集合中移除该对象。</h2><p>有一些变量的引用没有被释放，导致资源不能被垃圾回收掉</p>
<p>还有一个特殊场景要注意<br>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">100</span>);     </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;      </div><div class="line">    Object o = <span class="keyword">new</span> Object();      　</div><div class="line">    v.add(o);      　</div><div class="line">    o = <span class="keyword">null</span>;      </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 循环执行完之后，此时，所有的Object对象都没有被释放，因为变量v引用这些对象（还在集合里）。</span></div></pre></td></tr></table></figure></p>
<h2 id="优化for循环-使用增强for循环"><a href="#优化for循环-使用增强for循环" class="headerlink" title="优化for循环(使用增强for循环)"></a>优化for循环(使用增强for循环)</h2><p>增强型for循环（也被称为for-each循环）可以用于去遍历实现Iterable接口的集合以及数组，这是jdk 1.5中新增的一种循环模式。当然除了这种新增的循环模式之外，我们仍然还可以使用原有的普通循环模式，只不过它们之间是有效率区别的，我们来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> mCount;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">Counter[] mArray = ...  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;  </div><div class="line">        sum += mArray[i].mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    Counter[] localArray = mArray;  </div><div class="line">    <span class="keyword">int</span> len = localArray.length;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;  </div><div class="line">        sum += localArray[i].mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (Counter a : mArray) &#123;  </div><div class="line">        sum += a.mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，上述代码当中我们使用了三种不同的循环方式来对mArray中的所有元素进行求和。其中zero()方法是最慢的一种，因为它是把mArray.length写在循环当中的，也就是说每循环一次都需要重新计算一次mArray的长度。而one()方法则相对快得多，因为它使用了一个局部变量len来记录数组的长度，这样就省去了每次循环时字段搜寻的时间。two()方法在没有JIT（Just In Time Compiler）的设备上是运行最快的，而在有JIT的设备上运行效率和one()方法不相上下，唯一需要注意的是这种写法需要JDK 1.5之后才支持。</p>
<p>但是这里要跟大家提一个特殊情况，对于ArrayList这种集合，自己手写的循环要比增强型for循环更快，而其他的集合就没有这种情况。因此，对于我们来说，默认情况下可以都使用增强型for循环，而遍历ArrayList时就还是使用传统的循环方式吧。</p>
<h2 id="巧用静态方法"><a href="#巧用静态方法" class="headerlink" title="巧用静态方法"></a>巧用静态方法</h2><p>如果你并不需要访问一个对象中的某些字段，只是想调用它的某个方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，这会让调用的速度提升15%-20%，同时也不用为了调用这个方法而去专门创建对象了，这样还满足了上面的一条原则。另外这也是一种好的编程习惯，因为我们可以放心地调用静态方法，而不用担心调用这个方法后是否会改变对象的状态（静态方法内无法访问非静态字段）。</p>
<h2 id="对常量使用static-final修饰符"><a href="#对常量使用static-final修饰符" class="headerlink" title="对常量使用static final修饰符"></a>对常量使用static final修饰符</h2><p>final类型存储在常量区中读取效率更高</p>
<p>我们先来看一下在一个类的最顶部定义如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;  </div><div class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>编译器会为上述代码生成一个初始化方法，称为<clinit>方法，该方法会在定义类第一次被使用的时候调用。然后这个方法会将42的值赋值到intVal当中，并从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式来去访问具体的值了。</clinit></p>
<p>但是我们还可以通过final关键字来对上述代码进行优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;  </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>经过这样修改之后，定义类就不再需要一个<clinit>方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal时会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。</clinit></p>
<p>另外需要大家注意的是，这种优化方式只对基本数据类型以及String类型的常量有效，对于其它数据类型的常量是无效的。不过，对于任何常量都是用static final的关键字来进行声明仍然是一种非常好的习惯。</p>
<h2 id="基本数据类型的选型"><a href="#基本数据类型的选型" class="headerlink" title="基本数据类型的选型"></a>基本数据类型的选型</h2><p>64位类型如long double的处理比32位如int慢</p>
<h2 id="多使用系统封装好的API"><a href="#多使用系统封装好的API" class="headerlink" title="多使用系统封装好的API"></a>多使用系统封装好的API</h2><p>Java语言当中其实给我们提供了非常丰富的API接口，我们在编写程序时如果可以使用系统提供的API就应该尽量使用，系统提供的API完成不了我们需要的功能时才应该自己去写，因为使用系统的API在很多时候比我们自己写的代码要快得多，它们的很多功能都是通过底层的汇编模式执行的。</p>
<p>比如说String类当中提供的好多API都是拥有极高的效率的，像indexOf()方法和一些其它相关的API，虽说我们通过自己编写算法也能够完成同样的功能，但是效率方面会和这些方法差的比较远。这里举个例子，如果我们要实现一个数组拷贝的功能，使用循环的方式来对数组中的每一个元素一一进行赋值当然是可行的，但是如果我们直接使用系统中提供的System.arraycopy()方法将会让执行效率快9倍以上。</p>
<h2 id="避免在内部调用Getters-Setters方法"><a href="#避免在内部调用Getters-Setters方法" class="headerlink" title="避免在内部调用Getters/Setters方法"></a>避免在内部调用Getters/Setters方法</h2><p>我们平时写代码时都被告知，一定要使用面向对象的思维去写代码，而面向对象的三大特性我们都知道，封装、多态和继承。其中封装的基本思想就是不要把类内部的字段暴漏给外部，而是提供特定的方法来允许外部操作相应类的内部字段，从而在Java语言当中就出现了Getters/Setters这种封装技巧。</p>
<p>然而在Android上这个技巧就不再是那么的受推崇了，因为字段搜寻要比方法调用效率高得多，我们直接访问某个字段可能要比通过getters方法来去访问这个字段快3到7倍。不过我们肯定不能仅仅因为效率的原因就将封装这个技巧给抛弃了，编写代码还是要按照面向对象思维的，但是我们可以在能优化的地方进行优化，比如说避免在内部调用getters/setters方法。</p>
<p>那什么叫做在内部调用getters/setters方法呢？这里我举一个非常简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one = <span class="number">1</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two = <span class="number">2</span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOne</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> one;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTwo</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> two;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> getOne() + getTwo();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上面是一个Calculate类，这个类的功能非常简单，先将one和two这两个字段进行了封装，然后提供了getOne()方法获取one字段的值，提供了getTwo()方法获取two字段的值，还提供了一个getSum()方法用于获取总和的值。</p>
<p>这里我们注意到，getSum()方法当中的算法就是将one和two的值相加进行返回，但是它获取one和two的值的方式也是通过getters方法进行获取的，其实这是一种完全没有必要的方式，因为getSum()方法本身就是Calculate类内部的方法，它是可以直接访问到Calculate类中的封装字段的，因此这种写法在Android上是不推崇的，我们可以进行如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one = <span class="number">1</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two = <span class="number">2</span>;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> one + two;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改成这种写法之后，我们就避免了在内部调用getters/setters方法，而对于外部而言Calculate类仍然是具有很好的封装性的。</p>
<h2 id="避免进行隐式装箱"><a href="#避免进行隐式装箱" class="headerlink" title="避免进行隐式装箱"></a>避免进行隐式装箱</h2><p>自动装箱是Java 5 引入的一个特性，即自动将原始类型的数据转换成对应的引用类型，比如将int转为Integer等。</p>
<p>这种特性，极大的减少了编码时的琐碎工作，但是稍有不注意就可能创建了不必要的对象了。比如下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;</div><div class="line">   sum+=i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码sum+=i可以看成sum = sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> result = sum.intValue() + i;</div><div class="line">Integer sum = <span class="keyword">new</span> Integer(result);</div></pre></td></tr></table></figure></p>
<p>由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p>
<p>另外，当将原始数据类型的值加入集合中时，也会发生自动装箱，所以这个过程中也是有对象创建的。如有需要避免这种情况，可以选择SparseArray,SparseBooleanArray,SparseLongArray等容器。</p>
<p>关于Java中的自动装箱与拆箱，参考文章：<a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">Java中的自动装箱与拆箱</a></p>
<h2 id="用好LaunchMode"><a href="#用好LaunchMode" class="headerlink" title="用好LaunchMode"></a>用好LaunchMode</h2><p>复用、回收Activity对象</p>
<p>提到LaunchMode必然和Activity有关系。正常情况下我们在manifest中声明Activity，如果不设置LaunchMode就使用默认的standard模式。</p>
<p>一旦设置成standard，每当有一次Intent请求，就会创建一个新的Activity实例。举个例子，如果有10个撰写邮件的Intent，那么就会创建10个ComposeMailActivity的实例来处理这些Intent。结果很明显，这种模式会创建某个Activity的多个实例。</p>
<p>如果对于一个搜索功能的Activity，实际上保持一个Activity示例就可以了，使用standard模式会造成Activity实例的过多创建，因而不好。</p>
<p>确保符合常理的情况下，合理的使用LaunchMode，减少Activity的创建。</p>
<p>推荐用法：<br>主界面设置为singleTask<br>一般界面设置为singleTop<br>临时的activity及时finish</p>
<p>详细了解LaunchMode，阅读文章：<a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">深入讲解Android中Activity launchMode</a></p>
<h2 id="Activity处理onConfigurationChanged"><a href="#Activity处理onConfigurationChanged" class="headerlink" title="Activity处理onConfigurationChanged"></a>Activity处理onConfigurationChanged</h2><p>这又是一个关于Activity对象创建相关的，因为Activity创建的成本相对其他对象要高很多。</p>
<p>默认情况下，当我们进行屏幕旋转时，原Activity会销毁，一个新的Activity被创建，之所以这样做是为了处理布局适应。当然这是系统默认的做法，在我们开发可控的情况下，我们可以避免重新创建Activity。</p>
<p>以屏幕切换为例，在Activity声明时，加上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">".MainActivity"</span></div><div class="line">    android:label=<span class="string">"@string/app_name"</span></div><div class="line">    android:theme=<span class="string">"@style/AppTheme.NoActionBar"</span></div><div class="line">    android:configChanges=<span class="string">"orientation"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>然后重写Activity的onConfigurationChanged方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</div><div class="line">    <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</div><div class="line">        setContentView(R.layout.portrait_layout);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</div><div class="line">        setContentView(R.layout.landscape_layout);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="提前检查，减少不必要的异常"><a href="#提前检查，减少不必要的异常" class="headerlink" title="提前检查，减少不必要的异常"></a>提前检查，减少不必要的异常</h2><p>异常对于程序来说，在平常不过了，然后其实异常的代码很高的，因为它需要收集现场数据stacktrace。但是还是有一些避免异常抛出的措施的，那就是做一些提前检查。</p>
<p>比如，我们想要打印一个文件的每一行字符串，没做检查的代码如下，是存在FileNotFoundException抛出可能的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printFileByLine</span><span class="params">(String filePath)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"textfile.txt"</span>);</div><div class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</div><div class="line">        String strLine;</div><div class="line">        <span class="comment">//Read File Line By Line</span></div><div class="line">        <span class="keyword">while</span> ((strLine = br.readLine()) != <span class="keyword">null</span>)   &#123;</div><div class="line">            <span class="comment">// Print the content on the console</span></div><div class="line">            System.out.println (strLine);</div><div class="line">        &#125;</div><div class="line">        br.close();</div><div class="line">    &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们进行文件是否存在的检查，抛出FileNotFoundException的概率会减少很多，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printFileByLine</span><span class="params">(String filePath)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span> File(filePath).exists()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"textfile.txt"</span>);</div><div class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</div><div class="line">        String strLine;</div><div class="line">        <span class="comment">//Read File Line By Line</span></div><div class="line">        <span class="keyword">while</span> ((strLine = br.readLine()) != <span class="keyword">null</span>)   &#123;</div><div class="line">            <span class="comment">// Print the content on the console</span></div><div class="line">            System.out.println (strLine);</div><div class="line">        &#125;</div><div class="line">        br.close();</div><div class="line">    &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述的检查是一个不错的编码技巧，建议采纳。</p>
<p>还有一点<br>慎用异常，使用异常会导致性能降低</p>
<h2 id="选用对象池"><a href="#选用对象池" class="headerlink" title="选用对象池"></a>选用对象池</h2><p>在Android中有很多池的概念，如线程池，连接池。包括我们很长用的Handler.Message就是使用了池的技术。</p>
<p>比如，我们想要使用Handler发送消息，可以使用Message msg = new Message()，也可以使用Message msg = handler.obtainMessage()。使用池并不会每一次都创建新的对象，而是优先从池中取对象。</p>
<p>使用对象池需要需要注意几点</p>
<p>将对象放回池中，注意初始化对象的数据，防止存在脏数据<br>合理控制池的增长，避免过大，导致很多对象处于闲置状态</p>
<h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p>对于很多耗时逻辑没必要立即执行，这时候我们可以将其延迟执行。</p>
<p>线程延迟执行：<br>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);</p>
<p>消息延迟发送：<br>handler.sendMessageDelayed(handler.obtainMessage(0), 1000);<br>handler.postDelayed<br>handler.postAtTime</p>
<p>视图延迟：<br>View.postDelayed</p>
<p>警告器定时：<br>AlarmManager</p>
<p>不推荐使用：<br>Timer.schedule;</p>
<h2 id="提前操作"><a href="#提前操作" class="headerlink" title="提前操作"></a>提前操作</h2><p>对于第一次调用较耗时操作，可统一放到初始化中，将耗时提前。如得到壁纸wallpaperManager.getDrawable();</p>
<h2 id="简化代码规范"><a href="#简化代码规范" class="headerlink" title="简化代码规范"></a>简化代码规范</h2><p>这是一个不可以忽略的问题。与那些连基本的Android开发编码规范都不遵守的人一起工作是很困难的。</p>
<p>这不是什么困难的事情，要不了几个小时的时间就可以学习基本的Java 和 Android 编码规范。而且这不是一次性买卖，作为一个开发者终生受益。</p>
<p>提示：这里 有一个开始学习标准编码规范的极佳资源。<br><a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md" target="_blank" rel="external">https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md</a><br>其他：<br><a href="http://www.cnblogs.com/xiongbo/archive/2011/08/15/2098130.html" target="_blank" rel="external">Android开发规范</a></p>
<h2 id="重构App"><a href="#重构App" class="headerlink" title="重构App"></a>重构App</h2><p>就是重新架构app</p>
<p>大多数时候我们都笼统的把代码放到Activity和Fragment中（在这个问题上你也可以责怪我），导致它们变成庞大的“上帝对象”，这几乎不可维护和测试。</p>
<p>为app采用一个好的架构是非常重要的，比如MVP, MVVM, Redux等。考虑把app的业务逻辑，视图交互，数据交换分为不同的层，让它们更易管理和测试。</p>
<p>提示：看一看谷歌的 这些 模版可以让你在架构app的时候更容易。<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">https://github.com/googlesamples/android-architecture</a></p>
<hr>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><hr>
<p>相关文章收集：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a></p>
<p>学习之前要知道这2个至关重要的概念，所有的内存优化方式都是避免下面这俩种情况发生.</p>
<h2 id="内存泄露-amp-内存溢出"><a href="#内存泄露-amp-内存溢出" class="headerlink" title="内存泄露&amp;内存溢出"></a>内存泄露&amp;内存溢出</h2><h3 id="内存泄露-a-memory-leak"><a href="#内存泄露-a-memory-leak" class="headerlink" title="内存泄露(a memory leak)"></a>内存泄露(a memory leak)</h3><p>定义：<br>内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕由于错误或漏洞造成的内存占用过多没释放，或占用内存后无法释放</p>
<p>简单理解：<br>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，<br>结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），<br>而系统也不能再次将它分配给需要的程序。</p>
<p>详细的说：<br>就说是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，<br>但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。</p>
<p>形象比喻：<br>操作系统可提供给所有进程的存储空间正在被某个进程榨干”，<br>最终结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。<br>所以“内存泄漏”是从操作系统的角度来看的。<br>这里的存储空间并不是指物理内存，而是指虚拟内存大小，<br>这个虚拟内存大小取决于磁盘交换区设定的大小。<br>由程序申请的一块内存，如果没有任何一个指针指向它，那么这块内存就泄漏了。</p>
<p>Java中有内存泄露吗？为什么？<br>有！<br>所谓内存泄露就是对象再也不用了程序一直运行还一直占用内存空间没有被释放掉，<br>程序还在一直运行，导致浪费内存，最后导致内存溢出，就叫内存泄露！</p>
<p>Android系统中GC什么情况下会出现内存泄露呢？<br>有Java带垃圾回收的机制,为什么还会内存泄露呢?<br>导致内存泄漏主要的原因是，先前申请了内存空间而忘记了释放。<br>如果程序中存在对无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器GC验证这些对象是否不再需要。<br>如果存在对象的引用，这个对象就被定义为”有效的活动”，同时不会被释放。<br>要确定对象所占内存将被回收，我们就要务必确认该对象不再会被使用。<br>安卓的内存泄露不明显：如电池不扛用没电了关机重启下就恢复了，因为内存不足在后台，被系统给回收掉了重启一下<br>也因为安卓应用内存泄露不明显，很多公司不去处理这个问题</p>
<h3 id="内存溢出-OOM-Out-of-Memory"><a href="#内存溢出-OOM-Out-of-Memory" class="headerlink" title="内存溢出(OOM:Out of Memory)"></a>内存溢出(OOM:Out of Memory)</h3><p>形象比喻：<br>一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！</p>
<p>通俗理解：<br>就是内存不够了<br>你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出</p>
<p>详细理解：<br>内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，即使已有的数据超过了其获得到的内存所能存储的范围，所以出现out of memory；<br>比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>比如用一个字节存放1000这个数字也属于内存溢出</p>
<p>通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，此时软件或游戏就运行不了，系统会提示内存溢出，<br>有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件或游戏一段时间。</p>
<p>Android里出现的OOM：<br>OOM异常是Android中经常遇到的一个问题，程序员稍微不注意可能就导致其产生。<br>因为Android的每一个应用都是一个Davlik虚拟机，该虚拟机的默认堆内存只有16M，远远无法跟我们的PC机比较，因此和容易导致OOM异常的产生。<br>最常见的OOM主要是加载图片导致的。因为不良代码是可以通过约束程序员的编码规范来进行预防，或者使用性能分析工具来检查。</p>
<p>Android出现OOM只有2种可能：<br>Bitmap<br>线程</p>
<h2 id="内存泄露：资源对象引用没释放"><a href="#内存泄露：资源对象引用没释放" class="headerlink" title="内存泄露：资源对象引用没释放"></a>内存泄露：资源对象引用没释放</h2><h3 id="Handler内存泄漏"><a href="#Handler内存泄漏" class="headerlink" title="Handler内存泄漏"></a>Handler内存泄漏</h3><p>已单独整合成一篇文章，请跳转查看↓<br><a href="http://localhost:4000/2017/10/09/it/1.Android/Handler/" target="_blank" rel="external">Android —— 异步任务机制 &amp; 消息通知机制</a></p>
<h3 id="Context内存泄漏"><a href="#Context内存泄漏" class="headerlink" title="Context内存泄漏"></a>Context内存泄漏</h3><p>已单独整理成一篇文章，请跳转查看↓<br><a href="http://www.hengxing.me/2017/10/10/it/1.Android/Context/" target="_blank" rel="external">Android —— Context的几种环境和区别</a></p>
<h4 id="Drawable引起的内存泄露"><a href="#Drawable引起的内存泄露" class="headerlink" title="Drawable引起的内存泄露"></a>Drawable引起的内存泄露</h4><p>这是一个很隐晦的OutOfMemoryError的情况。先看一个Android官网提供的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;  </div><div class="line"></div><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);  </div><div class="line">  </div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);  </div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;  </div><div class="line">      sBackground = getDrawable(R.drawable.large_bitmap);  </div><div class="line">    &#125;  </div><div class="line">    label.setBackgroundDrawable(sBackground);  </div><div class="line">  </div><div class="line">    setContentView(label);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码效率很快，但同时又是极其错误的；<br>在第一次屏幕方向切换时它泄露了一开始创建的Activity。当一个Drawable附加到一个 View上时，<br>View会将其作为一个callback设定到Drawable上。上述的代码片段，意味着Drawable拥有一个TextView的引用，<br>而TextView又拥有Activity（Context类型）的引用，换句话说，Drawable拥有了更多的对象引用。即使Activity被 销毁，内存仍然不会被释放。<br>另外，对Context的引用超过它本身的生命周期，也会导致Context泄漏。所以尽量使用Application这种Context类型。<br>这种Context拥有和应用程序一样长的生命周期，并且不依赖Activity的生命周期。如果你打算保存一个长时间的对象，<br>并且其需要一个 Context，记得使用Application对象。你可以通过调用Context.getApplicationContext()或 Activity.getApplication()轻松得到Application对象。 </p>
<p>关于Drawable的其他解决方案：<br>2.3.7及以下版本Drawable的setCallback方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback cb)</span> </span>&#123;</div><div class="line">    mCallback = cb;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好在从4.0.1开始，引入了弱引用处理这个问题，弱引用在GC回收时，不会阻止GC回收其指向的对象，避免了内存泄露问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback cb)</span> </span>&#123;</div><div class="line">    mCallback = <span class="keyword">new</span> WeakReference&lt;Callback&gt;(cb);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="单例引起的内存泄露"><a href="#单例引起的内存泄露" class="headerlink" title="单例引起的内存泄露"></a>单例引起的内存泄露</h4><p>单例是我们比较简单常用的一种设计模式,然而如果单例使用不当也会导致内存泄露。 比如这样一个例子,我们使用饿汉式初始化单例，AppSettings我们需要持有一个Context作为成员变量，如果我们按照下面的实现其实是有问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSettings</span> </span>&#123;    </div><div class="line">    <span class="keyword">private</span> Context mAppContext;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppSettings sInstance = <span class="keyword">new</span> AppSettings();</div><div class="line"></div><div class="line">    <span class="comment">//some other codes</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppSettings <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        mAppContext = context;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sInstance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，当我们进行屏幕旋转，默认情况下，系统会销毁当前Activity，然后当前的Activity被一个单例持有，导致垃圾回收器无法进行回收，进而产生了内存泄露。</p>
<p>解决的方法就是不持有Activity的引用，而是持有Application的Context引用。代码如下修改<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    mAppContext = context.getApplicationContext(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://blog.csdn.net/syc434432458/article/details/51612747" target="_blank" rel="external">单例造成的内存泄漏</a></p>
<h4 id="getSystemService内存泄漏"><a href="#getSystemService内存泄漏" class="headerlink" title="getSystemService内存泄漏"></a>getSystemService内存泄漏</h4><p>相关文章：<br><a href="http://droidyue.com/blog/2016/11/14/be-careful-using-getsystemservice/" target="_blank" rel="external">技术小黑屋——Android内存泄漏：谨慎使用getSystemService</a></p>
<h4 id="线程引起的内存泄漏"><a href="#线程引起的内存泄漏" class="headerlink" title="线程引起的内存泄漏"></a>线程引起的内存泄漏</h4><p>最近遇到一种情况引起了Context泄漏，就是在Activity销毁时，里面有其他线程没有停。<br>详细看下面关于多线程的踪迹</p>
<h3 id="AsyncTask内存泄漏"><a href="#AsyncTask内存泄漏" class="headerlink" title="AsyncTask内存泄漏"></a>AsyncTask内存泄漏</h3><h3 id="Listener内存泄露"><a href="#Listener内存泄露" class="headerlink" title="Listener内存泄露"></a>Listener内存泄露</h3><p>下面各类监听器注册后，没有在对应的位置写取消（反注册）的代码：<br>广播接受者(BroadcastReceiver)<br>观察者(Observer)<br>传感器(Sensor)</p>
<h3 id="Timer内存泄漏"><a href="#Timer内存泄漏" class="headerlink" title="Timer内存泄漏"></a>Timer内存泄漏</h3><p>下面是一个使用Java Timer的例子，功能是在5秒后做一些工作。它们两个类可以被用于调度一些运行于后台的线程。在Android中还有一些类似的处理方法，你可以使用带有postDelayed的Handler或者是Handler 结合调用sendMessageDelayed（）方法，这样handler就会运行在后台正如上面展示的一样。同样，你要清楚这两个API对于Android的生命周期不清楚，很难在Activity、Fragment或者是View中引用它们，因为这样可能会导致内存泄露。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">timer.schedule(<span class="keyword">new</span> TimerTask()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// time ran out.</span></div><div class="line">    timer.cancel(); </div><div class="line">  &#125;</div><div class="line">&#125;, <span class="number">5000</span>);</div></pre></td></tr></table></figure></p>
<h3 id="属性动画导致内存泄露"><a href="#属性动画导致内存泄露" class="headerlink" title="属性动画导致内存泄露"></a>属性动画导致内存泄露</h3><p>例如代码中设置了属性动画（ObjectAnimator），在Activity中启动了动画，但是在销毁的时候，没有调用cancle方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。</p>
<h3 id="NotificationManager内存泄漏"><a href="#NotificationManager内存泄漏" class="headerlink" title="NotificationManager内存泄漏"></a>NotificationManager内存泄漏</h3><p>android 直到4.1.3 之前的版本，通知栏API 都存在内存泄露BUG，反复调用 NotificationManager.notify 方法会造成手机死机重启。<br>绕过此BUG 的方法是每次调用notify 时都必须 new 一个新的RemoteViews。</p>
<h3 id="new-Message内存泄露"><a href="#new-Message内存泄露" class="headerlink" title="new Message内存泄露"></a>new Message内存泄露</h3><p>尽量采用Message.obtain();</p>
<h3 id="关于OnSharedPreferenceChangeListener的设计"><a href="#关于OnSharedPreferenceChangeListener的设计" class="headerlink" title="关于OnSharedPreferenceChangeListener的设计"></a>关于OnSharedPreferenceChangeListener的设计</h3><p>它的设计用弱引用的方式不和Activity纠缠在一起，的确避免了内存泄漏<br>但是还时有些问题需要额外处理下.<br>详情查看文章：<br><a href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/" target="_blank" rel="external">技术小黑屋——Google为何这样设计OnSharedPreferenceChangeListener</a></p>
<h3 id="静态变量（static关键字）引起内存泄露"><a href="#静态变量（static关键字）引起内存泄露" class="headerlink" title="静态变量（static关键字）引起内存泄露"></a>静态变量（static关键字）引起内存泄露</h3><p>小心静态变量引用了activity<br>代码有静态变量引用了activity，随着代码的运行导致内存越来越大导致内存泄漏</p>
<p>要谨慎的对象：<br>Bitmap<br>Animation </p>
<p>原因：<br>因为有静态关键字，字节码被装载进来了，static对应的空间就被申请进来了<br>即使MainActivity被回收掉了，如静态bitmap空间还被占用着</p>
<p>解决方案：<br>就是把静态的引用去掉</p>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Resources mResources; </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>.onCreate(state);</div><div class="line"><span class="keyword">if</span> (mResources == <span class="keyword">null</span>) &#123;</div><div class="line">    mResources = <span class="keyword">this</span>.getResources();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中有一个静态的Resources对象。代码片段mResources = this.getResources()对Resources对象进行了初始化。这时Resources对象拥有了当前Activity对象的引用，Activity又引用了整个页面中所有的对象。<br>如果当前的Activity被重新创建（比如横竖屏切换，默认情况下整个Activity会被重新创建），由于Resources引用了第一次创建的Activity，就会导致第一次创建的Activity不能被垃圾回收器回收，从而导致第一次创建的Activity中的所有对象都不能被回收。这个时候，一部分内存就浪费掉了。</p>
<p>解决方案：<br>使用Application的Context<br>在Android中，Application Context的生命周期和应用的生命周期一样长，而不是取决于某个Activity的生命周期。如果想保持一个长期生命的对象，并且这个对象需要一个Context，就可以使用Application对象。<br>可以通过调用Context.getApplicationContext()方法或者Activity.getApplication()方法来获得Application对象。<br>依然拿上面的代码作为例子。可以将代码修改成下面的样子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Resources mResources; </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>.onCreate(state);</div><div class="line"><span class="keyword">if</span> (mResources == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// mResources = this.getResources();</span></div><div class="line">    mResources = <span class="keyword">this</span>.getApplication().getResources();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里将this.getResources()修改为this.getApplication().getResources()。<br>修改以后，Resources对象拥有的是Application对象的引用。<br>如果Activity被重新创建，第一次创建的Activity就可以被回收了。</p>
<p>经验分享：<br>在实际项目中，我们经常会把一些对象的引用加入到集合中，如果这个集合是静态的话，就需要特别注意了。当不需要某对象时，务必及时把它的引用从集合中清理掉。或者可以为集合提供一种更新策略，及时更新整个集合，这样可以保证集合的大小不超过某值，避免内存空间的浪费。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/wuchuy/article/details/51242738" target="_blank" rel="external">android中不小心使用静态变量会导致内存泄露</a></p>
<h3 id="非static的内部类"><a href="#非static的内部类" class="headerlink" title="非static的内部类"></a>非static的内部类</h3><p>如果你不想控制内部类的生命周期，应该避免在activity中使用非静态的内部类，而应该是静态的内部类</p>
<p>典型案例：<br>Handler</p>
<h3 id="使用WeakReference代替强引用"><a href="#使用WeakReference代替强引用" class="headerlink" title="使用WeakReference代替强引用"></a>使用WeakReference代替强引用</h3><p>弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。</p>
<p>使用SoftReference、WeakReference相对正常的强应用来说更有利于系统垃圾回收</p>
<p>相关文章：<br><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="external">[Android] Android开发优化之——使用软引用和弱引用</a></p>
<h2 id="内存泄露：资源对象没有关闭"><a href="#内存泄露：资源对象没有关闭" class="headerlink" title="内存泄露：资源对象没有关闭"></a>内存泄露：资源对象没有关闭</h2><h3 id="数据库的Cursor-未及时关闭"><a href="#数据库的Cursor-未及时关闭" class="headerlink" title="数据库的Cursor 未及时关闭"></a>数据库的Cursor 未及时关闭</h3><p>操作Sqlite数据库时，Cursor是数据库表中每一行的集合，是Android查询数据后得到的一个管理数据集合的类，Cursor提供了很多方法，可以很方便的读取数据库中的值，<br>可以根据索引，列名等获取数据库中的值，通过游标的方式可以调用moveToNext()移到下一行<br>当我们操作完数据库后，一定要记得调用Cursor对象的close()来关闭游标，释放资源。<br>正常情况下，如果我们没有关闭它，系统会在回收它时进行关闭，但是这样的效率特别低。如果查询得到的数据量较小时还好，如果Cursor的数据量非常大，特别是如果里面有Blob信息时，就可能出现内存问题。<br>所以一定要及时关闭Cursor。<br>这样保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。<br>并且Android明显是倾向于编程者手动的将Cursor close掉</p>
<p>下面给出一个通用的使用Cursor的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Cursor cursor = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    cursor = mContext.getContentResolver().query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</div><div class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</div><div class="line">        cursor.moveToFirst();</div><div class="line">        <span class="comment">// 处理数据</span></div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">    e.printStatckTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>)&#123;</div><div class="line">        cursor.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即对异常进行捕获，并且在finally中将cursor关闭。<br>同样的，在使用文件的时候，也要及时关闭。</p>
<h3 id="网络资源-连接Socket-、IO流资源没有及时关闭（InputStream-OutputStream），File"><a href="#网络资源-连接Socket-、IO流资源没有及时关闭（InputStream-OutputStream），File" class="headerlink" title="网络资源(连接Socket)、IO流资源没有及时关闭（InputStream/OutputStream），File"></a>网络资源(连接Socket)、IO流资源没有及时关闭（InputStream/OutputStream），File</h3><p>这个就不多说了，我们操作完输入输出流都要关闭流 </p>
<h2 id="内存泄漏：资源对象没有回收"><a href="#内存泄漏：资源对象没有回收" class="headerlink" title="内存泄漏：资源对象没有回收"></a>内存泄漏：资源对象没有回收</h2><p>1.Bitmap recycle<br>在不使用Bitmap对象时，需要调用recycle()释放内存，然后将它设置为null。虽然调用recycle()并不能保证立即释放占用的内存，但是可以加速Bitmap的内存的释放。<br>在代码优化的过程中，如果发现某个Activity用到了Bitmap对象，却没有显式的调用recycle()释放内存，则需要分析代码逻辑，增加相关代码，在不再使用Bitmap以后调用recycle()释放内存。</p>
<p>2.TypedArray recycle</p>
<h2 id="释放内存：当界面不可见"><a href="#释放内存：当界面不可见" class="headerlink" title="释放内存：当界面不可见"></a>释放内存：当界面不可见</h2><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h3><p>取消网络连接<br>注销广播接收器</p>
<h3 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a>onTrimMemory</h3><p>在适当的生命周期中创建释放对象<br>onTrimMemory回调：应用响应此回调释放非必须内存，如图片的内存占用</p>
<p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。</p>
<p>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onTrimMemory(level);  </div><div class="line">    <span class="keyword">switch</span> (level) &#123;  </div><div class="line">    <span class="keyword">case</span> TRIM_MEMORY_UI_HIDDEN:  </div><div class="line">        <span class="comment">// 进行资源释放操作  </span></div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>
<h2 id="释放内存：当内存紧张时"><a href="#释放内存：当内存紧张时" class="headerlink" title="释放内存：当内存紧张时"></a>释放内存：当内存紧张时</h2><p>详情查看里面的部分段落<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a></p>
<h2 id="释放内存：知晓内存的开支情况"><a href="#释放内存：知晓内存的开支情况" class="headerlink" title="释放内存：知晓内存的开支情况"></a>释放内存：知晓内存的开支情况</h2><p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：</p>
<p>任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。<br>任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。<br>在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</p>
<h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>重复使用的资源可以考虑使用缓存池技术</p>
<p>Java的对象创建需要分配资源较耗费时间，加上创建的对象越多会造成越频繁的gc影响系统响应。</p>
<p>在内存、文件、数据库、网络的读写速度中，内存都是最优的，且速度数量级差别，所以尽量将需要频繁访问或访问一次消耗较大的数据存储在缓存中。</p>
<p>(1). 单例模式<br>对于创建开销较大的类可使用此方法，保证全局一个实例，在程序运行过程中该类不会因新建额外对象产生开销。</p>
<p>(2). 缓存<br>程序中用到了对象缓存，图片缓存、线程池、View缓存、IO缓存、消网络缓存，DB缓存，消息缓存、通知栏notification缓存)及其他方式减少对象创建。</p>
<p>对象缓存能减少内存的分配，IO缓存减少磁盘的读写次数，网络缓存减少网络传输，DB缓存较少Database的访问次数。</p>
<p>a. 图片缓存：<br><a href="http://www.trinea.cn/android/android-imagecache/" target="_blank" rel="external">ImageCache</a><br><a href="http://www.trinea.cn/android/android-imagesdcardcache/" target="_blank" rel="external">ImageSdCache</a><br><a href="http://www.trinea.cn/android/preloaddatacache/" target="_blank" rel="external">数据预取缓存</a></p>
<p>b. 线程池：使用Java的Executors类，通过newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool提供四种不同类型的线程池</p>
<p>c. View缓存：<br>可见<a href="Android ListView滑动过程中图片显示重复错位闪烁问题解决">ListView缓存机制</a><br>listView的getView缓存<br>通过convertView是否为null减少layout inflate次数，通过静态的ViewHolder减少findViewById的次数，这两个函数尤其是inflate是相当费时间的</p>
<p>d. IO缓存：<br>使用具有缓存策略的输入流<br>BufferedInputStream替代InputStream<br>BufferedReader替代Reader<br>BufferedReader替代BufferedInputStream.<br>对文件、网络IO皆适用。</p>
<p>e. 网络缓存<br><a href="http://www.trinea.cn/android/android-http-cache/" target="_blank" rel="external">Android网络缓存</a></p>
<p>http response，根据http头信息中的Cache-Control域确定缓存过期时间。</p>
<p>f. 消息缓存：<br>1.通过 Handler 的 obtainMessage 来从消息池中回收 Message 对象，减少 Message 对象的创建开销<br>handler.sendMessage(handler.obtainMessage(1));</p>
<p>2.如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</p>
<p>g. 通知栏notification缓存：<br>下载中需要不断改变通知栏进度条状态，如果不断新建Notification会导致通知栏很卡。这里我们可以使用最简单的缓存<br>Map<string, notification=""> notificationMap = new HashMap<string, notification="">();如果notificationMap中不存在，则新建notification并且put into map.</string,></string,></p>
<p>h.Layout缓存<br><a href="http://www.trinea.cn/android/layout-performance/" target="_blank" rel="external">性能优化之布局优化</a></p>
<h2 id="4大组件优化"><a href="#4大组件优化" class="headerlink" title="4大组件优化"></a>4大组件优化</h2><h3 id="Activity优化"><a href="#Activity优化" class="headerlink" title="Activity优化"></a>Activity优化</h3><p>如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可</p>
<h3 id="Service优化"><a href="#Service优化" class="headerlink" title="Service优化"></a>Service优化</h3><h4 id="节制使用Service"><a href="#节制使用Service" class="headerlink" title="节制使用Service"></a>节制使用Service</h4><p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>
<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。关于IntentService更加详细的用法讲解，可以参考《第一行代码——Android》的9.5.2节。</p>
<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载（我个人就会这么做）。</p>
<h4 id="推荐使用IntentService"><a href="#推荐使用IntentService" class="headerlink" title="推荐使用IntentService"></a>推荐使用IntentService</h4><p>简介：<br>一个可以干完活后自己去死且不需要我们去管理子线程的Service。</p>
<p>注意：<br>最后，别忘了配置Service，因为它继承于Service，所以，它还是一个Service，一定要配置，否则是不起作用的，开始我就是忘了，结果半天没反应。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=".IntentServiceDemo"&gt;</div><div class="line">      &lt;intent-filter &gt;</div><div class="line">          &lt;action android:name="com.test.intentservice"/&gt;</div><div class="line">      &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure></p>
<p>参考文章：<br><a href="http://www.tuicool.com/articles/zeMFFvB" target="_blank" rel="external">Android中IntentService详解</a><br><a href="https://www.2cto.com/kf/201409/331983.html" target="_blank" rel="external">Android面试，IntentService的原理及使用</a><br><a href="https://zhidao.baidu.com/question/617440918557008172.html" target="_blank" rel="external">Service和IntentService中显示Toast的区别</a></p>
<p>参考书籍：<br>《第一行代码——Android》的9.5.2节。</p>
<h3 id="BroadcastReceiver优化"><a href="#BroadcastReceiver优化" class="headerlink" title="BroadcastReceiver优化"></a>BroadcastReceiver优化</h3><h4 id="广播接受者的内存泄漏"><a href="#广播接受者的内存泄漏" class="headerlink" title="广播接受者的内存泄漏"></a>广播接受者的内存泄漏</h4><p>广播接收者（BroadcastReceiver）经常在应用中用到，可以在多线程任务完成后发送广播通知UI更新，也可以接收系统广播实现一些功能 </p>
<p>泄漏关键就是调用registerReceiver()后未调用unregisterReceiver(). </p>
<p>流程如下：<br>可以通过代码的方式注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntentFilter postFilter = <span class="keyword">new</span> IntentFilter(); </div><div class="line">postFilter.addAction(getPackageName() + <span class="string">".background.job"</span>); </div><div class="line"><span class="keyword">this</span>.registerReceiver(receiver, postFilter);</div></pre></td></tr></table></figure></p>
<p>当我们Activity中使用了registerReceiver()方法注册了BroadcastReceiver，<br>一定要在Activity的生命周期内调用unregisterReceiver()方法取消注册<br>也就是说registerReceiver()和unregisterReceiver()方法一定要成对出现，通常我们可以重写Activity的onDestory()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">this</span>.unregisterReceiver(receiver);  </div><div class="line">      <span class="keyword">super</span>.onDestroy();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="LocalBroadcastManager"><a href="#LocalBroadcastManager" class="headerlink" title="LocalBroadcastManager"></a>LocalBroadcastManager</h2><p>LocalBroadcastManager代替BroadcastReceiver，效率和安全性都更高</p>
<h3 id="ContentProvider优化"><a href="#ContentProvider优化" class="headerlink" title="ContentProvider优化"></a>ContentProvider优化</h3><h2 id="异步任务优化"><a href="#异步任务优化" class="headerlink" title="异步任务优化"></a>异步任务优化</h2><p>异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态<br><a href="http://blog.csdn.net/sfshine/article/details/8144387" target="_blank" rel="external">判断一个Activity在当前激活状态</a></p>
<h2 id="Bitmap图片优化"><a href="#Bitmap图片优化" class="headerlink" title="Bitmap图片优化"></a>Bitmap图片优化</h2><p>因内容庞大，已单独总结分割成一篇文章，请查看以下链接↓<br><a href="http://www.hengxing.me/2017/09/09/it/1.Android/Bitmap/" target="_blank" rel="external">Android —— Bitmap图片的总结</a></p>
<h2 id="集合容器优化-amp-数据结构和算法优化"><a href="#集合容器优化-amp-数据结构和算法优化" class="headerlink" title="集合容器优化 &amp; 数据结构和算法优化"></a>集合容器优化 &amp; 数据结构和算法优化</h2><h3 id="HashMap代替arrayList"><a href="#HashMap代替arrayList" class="headerlink" title="HashMap代替arrayList"></a>HashMap代替arrayList</h3><p>使用hashMap代替arrayList，时间复杂度降低一个数量级</p>
<h3 id="新型集合替代Hash系列集合"><a href="#新型集合替代Hash系列集合" class="headerlink" title="新型集合替代Hash系列集合"></a>新型集合替代Hash系列集合</h3><p>关于Sparse系列和ArrayMap清查看以下文章：<br><a href="http://www.hengxing.me/2017/09/07/it/1.Java/CollectionsFramework/" target="_blank" rel="external">集合框架和其他容器类的总结</a></p>
<h3 id="谨慎选用容器和集合容器扩容优化"><a href="#谨慎选用容器和集合容器扩容优化" class="headerlink" title="谨慎选用容器和集合容器扩容优化"></a>谨慎选用容器和集合容器扩容优化</h3><p>Java和Android提供了很多编辑的容器集合来组织对象。比如ArrayList,ContentValues,HashMap等。</p>
<p>然而，这样容器虽然使用起来方便，但也存在一些问题，就是他们会自动扩容，这其中不是创建新的对象，而是创建一个更大的容器对象。这就意味这将占用更大的内存空间。</p>
<p>以HashMap为例，当我们put key和value时，会检测是否需要扩容，如需要则双倍扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> putValueForNullKey(value);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//some code here</span></div><div class="line"></div><div class="line">    <span class="comment">// No entry for (non-null) key is present; create one</span></div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (size++ &gt; threshold) &#123;</div><div class="line">        tab = doubleCapacity();</div><div class="line">        index = hash &amp; (tab.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    addNewEntry(key, value, hash, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于扩容的问题，通常有如下几种方法<br>1.预估一个较大的容量值，避免多次扩容<br>2.寻找替代的数据结构，确保做到时间和空间的平衡</p>
<p>优化的小细节：<br>使用集合对象，如果事先知道其大小，则可以在构造方法中设置初始大小。</p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2017/03/05/java-performance-tuning-collection-size-growth/" target="_blank" rel="external">Java性能调优之容器扩容问题</a></p>
<h3 id="集合的循环遍历方式性能分析"><a href="#集合的循环遍历方式性能分析" class="headerlink" title="集合的循环遍历方式性能分析"></a>集合的循环遍历方式性能分析</h3><p>List<br>(1) 无论ArrayList还是LinkedList，遍历建议使用foreach，尤其是数据量较大时LinkedList避免使用get遍历。<br>(2) List使用首选ArrayList。对于个别插入删除非常多的可以使用LinkedList。<br>(3) 可能在遍历List循环内部需要使用到下标，这时综合考虑下是使用foreach和自增count还是get方式。<br>(4) 用临时遍历变量size取代list.size()性能更优<br><a href="http://www.trinea.cn/android/arraylist-linkedlist-loop-performance/" target="_blank" rel="external">ArrayList和LinkedList的几种循环遍历方式及性能对比分析</a></p>
<p>Map<br>(1) HashMap的循环，如果既需要key也需要value，直接用<br>Map<string, string=""> map = new HashMap<string, string="">();<br>for (Entry<string, string=""> entry : map.entrySet()) {<br>    entry.getKey();<br>    entry.getValue();<br>}<br>即可，foreach简洁易懂。<br>(2) 如果只是遍历key而无需value的话，可以直接用<br>Map<string, string=""> map = new HashMap<string, string="">();<br>for (String key : map.keySet()) {<br>    // key process<br>}<br><a href="http://www.trinea.cn/android/hashmap-loop-performance/" target="_blank" rel="external">HashMap循环遍历方式及其性能对比</a></string,></string,></string,></string,></string,></p>
<h3 id="集合容器对象没有清理造成的内存泄露"><a href="#集合容器对象没有清理造成的内存泄露" class="headerlink" title="集合容器对象没有清理造成的内存泄露"></a>集合容器对象没有清理造成的内存泄露</h3><p>记得不用了就赋予null</p>
<h3 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h3><p>常见的数据结构选择如：<br>ArrayList和LinkedList的选择：<br>ArrayList根据index取值更快，LinkedList更占内存、随机插入删除更快速、扩容效率更高。一般推荐ArrayList。</p>
<p>ArrayList、HashMap、LinkedHashMap、HashSet的选择：<br>hash系列数据结构查询速度更优，ArrayList存储有序元素，HashMap为键值对数据结构，LinkedHashMap可以记住加入次序的hashMap，HashSet不允许重复元素。</p>
<p>HashMap、WeakHashMap选择：<br>WeakHashMap中元素可在适当时候被系统垃圾回收器自动回收，所以适合在内存紧张型中使用。</p>
<p>Collections.synchronizedMap和ConcurrentHashMap的选择：<br>ConcurrentHashMap为细分锁，锁粒度更小，并发性能更优。<br>Collections.synchronizedMap为对象锁，自己添加函数进行锁控制更方便。</p>
<p>Android也提供了一些性能更优的数据类型：<br>SparseArray、SparseBooleanArray、SparseIntArray、Pair。</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>尽量不用O(n*n)时间复杂度以上的算法，必要时候可用空间换时间。<br>查询考虑hash和二分，尽量不用递归。</p>
<h2 id="多线程优化和多进程优化"><a href="#多线程优化和多进程优化" class="headerlink" title="多线程优化和多进程优化"></a>多线程优化和多进程优化</h2><p>已单独整合成一篇文章，请点击以下文章阅读：↓<br><a href="http://www.hengxing.me/2017/10/09/it/1.Android/Process/" target="_blank" rel="external">Android —— 进程和线程</a></p>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="谨慎使用抽象编程"><a href="#谨慎使用抽象编程" class="headerlink" title="谨慎使用抽象编程"></a>谨慎使用抽象编程</h3><p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>
<h3 id="不建议使用枚举用注解"><a href="#不建议使用枚举用注解" class="headerlink" title="不建议使用枚举用注解"></a>不建议使用枚举用注解</h3><p>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。<br>如括Enum，EnumSet，EnumMap等。<br>枚举也是单例，所以也可能会带来内存泄露</p>
<p>一、枚举常量的优势<br>1）枚举常量会更简单<br>2）枚举常量会更安全<br>3）枚举可以有内置方法和自己的方法<br>4）可以用EnumSet代替位标志<br>二、使用枚举带来的问题<br>1）枚举会增加dex文件大小<br>2）枚举会增加dex文件方法数量<br>3）枚举会增加内存的使用<br>4）枚举会增加字符串常量<br>5）枚举会增加函数调用时间</p>
<p>相关文章：<a href="http://blog.csdn.net/warden032/article/details/52452035" target="_blank" rel="external">android开发之避免使用枚举</a></p>
<p>使用注解替代枚举</p>
<p>枚举是我们经常使用的一种用作值限定的手段，使用枚举比单纯的常量约定要靠谱。然后枚举的实质还是创建对象。好在Android提供了相关的注解，使得值限定在编译时进行，进而减少了运行时的压力。相关的注解为IntDef和StringDef。</p>
<p>如下以IntDef为例，介绍如何使用</p>
<p>在一个文件中如下声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConstants</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_OPEN = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_CLOSE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_BROKEN = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="meta">@IntDef</span>(&#123;STATE_OPEN, STATE_CLOSE, STATE_BROKEN&#125;)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span>  DoorState &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后设置书写这样的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDoorState</span><span class="params">(@AppConstants.DoorState <span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">    <span class="comment">//some code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用方法时只能使用STATE_OPEN，STATE_CLOSE和STATE_BROKEN。使用其他值会导致编译提醒和警告。</p>
<p>想要深入了解注解，可以阅读：<a href="http://droidyue.com/blog/2016/04/24/look-into-java-annotation/" target="_blank" rel="external">详解Java中的注解</a></p>
<h3 id="尽量避免使用依赖注入框架"><a href="#尽量避免使用依赖注入框架" class="headerlink" title="尽量避免使用依赖注入框架"></a>尽量避免使用依赖注入框架</h3><p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidWay</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;   </div><div class="line">    TextView name;   </div><div class="line">    ImageView thumbnail;   </div><div class="line">    LocationManager loc;   </div><div class="line">    Drawable icon;   </div><div class="line">    String myName;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">        name      = (TextView) findViewById(R.id.name);   </div><div class="line">        thumbnail = (ImageView) findViewById(R.id.thumbnail);   </div><div class="line">        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE);   </div><div class="line">        icon      = getResources().getDrawable(R.drawable.icon);   </div><div class="line">        myName    = getString(R.string.app_name);   </div><div class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简化成这样的一种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ContentView</span>(R.layout.main)  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoboWay</span> <span class="keyword">extends</span> <span class="title">RoboActivity</span> </span>&#123;   </div><div class="line">    <span class="meta">@InjectView</span>(R.id.name)             TextView name;   </div><div class="line">    <span class="meta">@InjectView</span>(R.id.thumbnail)        ImageView thumbnail;   </div><div class="line">    <span class="meta">@InjectResource</span>(R.drawable.icon)   Drawable icon;   </div><div class="line">    <span class="meta">@InjectResource</span>(R.string.app_name) String myName;   </div><div class="line">    <span class="meta">@Inject</span>                            LocationManager loc;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </div><div class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>
<h3 id="判断app是否已安装的状态的优化"><a href="#判断app是否已安装的状态的优化" class="headerlink" title="判断app是否已安装的状态的优化"></a>判断app是否已安装的状态的优化</h3><p>修改设置app是否已安装的状态，具体代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;PackageInfo&gt; installedPackageList = getPackageManager().getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);</div><div class="line">List&lt;App&gt; installedAppList = function(installedAppList)</div><div class="line"><span class="keyword">for</span> (App app : appList) &#123;</div><div class="line">	<span class="keyword">for</span> (App installedApp : installedAppList) &#123;</div><div class="line"> </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (App app : appList) &#123;</div><div class="line">	Pair&lt;Integer, String&gt; versionInfo = INSTALLED_APP_MAP.get(app.getPackageName());</div><div class="line">	<span class="keyword">if</span> (versionInfo != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从每次获取List<packageinfo> installedAppList = getPackageManager().getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);修改为只在有应用安装或卸载广播时获取应用列表，并且用hashMap代替installedAppList减少查询时间。<br>将平均执行时间从201ms降低到1ms。</packageinfo></p>
<hr>
<h1 id="工具优化"><a href="#工具优化" class="headerlink" title="工具优化"></a>工具优化</h1><hr>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238633" target="_blank" rel="external">Android最佳性能实践(二)——分析内存的使用情况</a></p>
<h2 id="性能优化分析工具"><a href="#性能优化分析工具" class="headerlink" title="性能优化分析工具"></a>性能优化分析工具</h2><p>用途：性能分析优化监视/查看UI/调试Bug/检测内存泄露工具 </p>
<h3 id="简单有用的发现性能问题的方法"><a href="#简单有用的发现性能问题的方法" class="headerlink" title="简单有用的发现性能问题的方法"></a>简单有用的发现性能问题的方法</h3><p><a href="http://droidyue.com/blog/2017/03/13/a-small-trick-to-detect-time-consuming-task/" target="_blank" rel="external">Android中一个简单有用的发现性能问题的方法</a></p>
<h3 id="手机-设置-开发者选项"><a href="#手机-设置-开发者选项" class="headerlink" title="手机/设置/开发者选项"></a>手机/设置/开发者选项</h3><p>1.查看UI过度绘制<br>手机 / 设置 / 开发者选项 / 显示布局边界（Show GPU Overdraw）<br><a href="http://jingyan.baidu.com/article/1e5468f97c4772484961b72a.html" target="_blank" rel="external">手机怎么设置调试GPU过度绘制</a></p>
<h3 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h3><p>减少不必要的层次：巧用Hierarchy Viewer<br>hierarchy viewer可以方便的查看Activity的布局，各个View的属性、measure、layout、draw的时间，如果耗时较多会用红色标记，否则显示绿色。<br>hierarchy viewer.bat位于<sdk>/tools/目录下</sdk></p>
<h3 id="ViewServer"><a href="#ViewServer" class="headerlink" title="ViewServer"></a>ViewServer</h3><p>下载地址：<br><a href="https://github.com/romainguy/ViewServer" target="_blank" rel="external">https://github.com/romainguy/ViewServer</a></p>
<p>相关文章：<br><a href="http://blog.csdn.net/wanglu198506/article/details/43106133" target="_blank" rel="external">使用ViewServer让Android真机可用HierarchyView视图检测工具</a></p>
<p>参考书籍：<br>Android群英传-10.1.5</p>
<h3 id="无线uiviewer"><a href="#无线uiviewer" class="headerlink" title="无线uiviewer"></a>无线uiviewer</h3><p>安卓UI集成调试必备利器！<br>在android手机端实现Hierarchyviewer里的uiautomatorviewer功能，查看UI布局、控件位置不再需要通过数据线连接到电脑查看，在手机上随时随地可以查看任意界面！<br>有了此工具，安卓测试人员可以底气十足的告诉开发人员，开发出来的界面控件位置、大小哪些是错的，哪些是对的！<br>有了此工具，安卓开发人员可以信心百倍的告诉测试人员，我开发出来的界面与UI标注图是一模一样的！不信你用“无线uiviewer”量一量！</p>
<p>PS：手机需要root</p>
<p>下载地址：<br><a href="http://download.csdn.net/download/duantihi/9448886" target="_blank" rel="external">http://download.csdn.net/download/duantihi/9448886</a></p>
<h3 id="开发助手"><a href="#开发助手" class="headerlink" title="开发助手"></a>开发助手</h3><p><a href="http://www.trinea.cn/android/android-develop-and-debug-tools/" target="_blank" rel="external">Android应用开发调试利器——开发助手，数十倍效率提升</a></p>
<h3 id="ddms-bat"><a href="#ddms-bat" class="headerlink" title="ddms.bat"></a>ddms.bat</h3><p>DDMS 全称是Dalvik Debug Monitor Service，是 Android 开发环境中的Dalvik虚拟机调试监控服务。<br>adt插件的功能, 提供一个调试的视图</p>
<p>具体功能：<br>设备列表,进程列表<br>文件管理<br>模拟器控制 打入电话 发入短信 定位信息<br>查看模拟器资源信息</p>
<h4 id="dump-View-Hierarchy-for-UI-automator"><a href="#dump-View-Hierarchy-for-UI-automator" class="headerlink" title="dump View Hierarchy for UI automator"></a>dump View Hierarchy for UI automator</h4><p><a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/38498337" target="_blank" rel="external">android 开发UI好工具—–dump View Hierarchy for UI automator</a></p>
<h3 id="Monkey-amp-MonkeyRunner"><a href="#Monkey-amp-MonkeyRunner" class="headerlink" title="Monkey &amp; MonkeyRunner"></a>Monkey &amp; MonkeyRunner</h3><p><a href="http://blog.csdn.net/mad1989/article/details/38087737" target="_blank" rel="external">Monkey和MonkeyRunner</a></p>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>Java程序性能分析工具</p>
<h3 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h3><p>程序性能分析器<br>Android自带的TraceView堪比java的性能调优工具visualvm线程视图，可以方便的查看线程的执行情况，某个方法执行时间、调用次数、在总体中的占比等，从而定位性能点。</p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/android-traceview/" target="_blank" rel="external">Android性能调优工具TraceView介绍</a></p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>Eclipse下的Memory Analyzer Tool（MAT）内存泄漏分析工具 </p>
<h3 id="Monitor-Memory"><a href="#Monitor-Memory" class="headerlink" title="Monitor Memory"></a>Monitor Memory</h3><p>AndroidStudio自带的内存检测工具，可以用于查找内存溢出<br>Android Memory Monitor内置于Android Studio中，用于展示应用内存的使用和释放情况。<br>当你的App占用的内存持续增加，而且你同时出发GC，也没有进行释放，那么你的App很有可能发生了内存泄漏问题。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/u012760183/article/details/52068490" target="_blank" rel="external">Android Studio +MAT 分析内存泄漏实战</a><br><a href="http://www.jianshu.com/p/216b03c22bb8" target="_blank" rel="external">使用新版Android Studio检测内存泄露和性能</a></p>
<h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h3><p>内存泄露目前在项目中一般用LeakCanary（square出品）基本就能搞定，配置起来也相当简单</p>
<p><a href="http://droidyue.com/blog/2016/03/28/android-leakcanary/" target="_blank" rel="external">Android内存泄漏检测利器：LeakCanary</a></p>
<h3 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h3><p>Android性能调优利器StrictMode<br><a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/" target="_blank" rel="external">分析Android app的内存使用</a></p>
<h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><p>函数流程调试工具</p>
<h3 id="Method-Trace"><a href="#Method-Trace" class="headerlink" title="Method Trace"></a>Method Trace</h3><p>函数流程调试工具</p>
<h3 id="draw9patch-bat"><a href="#draw9patch-bat" class="headerlink" title="draw9patch.bat"></a>draw9patch.bat</h3><p>做点九图的工具</p>
<h3 id="emulator-exe"><a href="#emulator-exe" class="headerlink" title="emulator.exe"></a>emulator.exe</h3><p>模拟器</p>
<h3 id="mksdcard-exe"><a href="#mksdcard-exe" class="headerlink" title="mksdcard.exe"></a>mksdcard.exe</h3><p>创建sd卡的工具</p>
<h2 id="代码分析扫描工具"><a href="#代码分析扫描工具" class="headerlink" title="代码分析扫描工具"></a>代码分析扫描工具</h2><p>用途：静态代码扫描/程序分析/代码提示/代码检查</p>
<h3 id="Android-Lint工具"><a href="#Android-Lint工具" class="headerlink" title="Android Lint工具"></a>Android Lint工具</h3><p>先说下layoutopt<br>layoutopt是一个可以提供layout及其层级优化提示的命令行，在sdk16以后已经被lint取代，在Windows-&gt;Show View-&gt;Other-&gt;Android-&gt;Lint Warnings查看lint优化提示，lint具体介绍可见Improving Your Code with lint。</p>
<p>Android lint是在ADT 16提供的新工具，它是一个代码扫描工具，能够帮助我们识别代码结构存在的问题</p>
<p>lint检查：通过Android Studio中的 Analyze-&gt;Inspect Code 对工程代码做静态扫描；找出潜在的问题代码并修改，去掉无用的图片</p>
<p>相关文章：<br><a href="http://blog.csdn.net/xyz_lmn/article/details/14222939" target="_blank" rel="external">Android代码优化——使用Android lint工具</a><br><a href="http://www.bubuko.com/infodetail-1055648.html" target="_blank" rel="external">Android Studio使用Lint进行代码检查</a></p>
<p>相关书籍：<br>Android群英传-10.3 Lint工具</p>
<h3 id="Tools-Attributes"><a href="#Tools-Attributes" class="headerlink" title="Tools Attributes"></a>Tools Attributes</h3><p>官方文档：<br><a href="http://tools.android.com/tech-docs/tools-attributes" target="_blank" rel="external">http://tools.android.com/tech-docs/tools-attributes</a></p>
<p>相关文章：<br><a href="http://www.bubuko.com/infodetail-916616.html" target="_blank" rel="external">android中xml tools属性详解（转）</a><br><a href="http://blog.csdn.net/u011277123/article/details/52814521" target="_blank" rel="external">Android Tools Attributes，让布局设计所见即所得</a></p>
<p>看似Android开发人员只有一种方法来检查成品布局——在设备上运行它。但是，你还可以使用内置于开发框架的Tools Attributes，在我们的例子中所使用的框架是Android Studio。</p>
<p>开发人员在设计Android Layout布局时，总会伴随着一些乱七八槽的困扰。比如，为了更加逼真的真实数据预览效果，我们在开发时会将TextView的text属性写上一些假数据，而当运行到模拟器或真机上时这些假数据就成了造成体验上甚至测试BUG的脏数据，又需要一一清除。再比如，我们想在XML的预览界面上就看到ListView的Item内容，而不是只有通过编译运行时才能查看。等等，诸如这些存在于开发Layout内容阶段的困扰，都可以通过Tools Attributes得以解决，不妨了解一下。</p>
<p>Tools Attributes可以使用额外的命名空间来帮助管理Android Studio，这样开发框架就不会传输运行时版本的属性到最终构建。</p>
<h3 id="Support-Annotations"><a href="#Support-Annotations" class="headerlink" title="Support Annotations"></a>Support Annotations</h3><p>官方文档<br><a href="http://tools.android.com/tech-docs/support-annotations" target="_blank" rel="external">http://tools.android.com/tech-docs/support-annotations</a></p>
<p>学习文章<br><a href="http://www.cnblogs.com/punkisnotdead/p/4705258.html" target="_blank" rel="external">Android 注解的一些应用以及原理</a><br><a href="http://www.codeceo.com/article/android-support-annotations-2.html" target="_blank" rel="external">Android Support Annotations 使用详解</a><br><a href="http://www.mincoder.com/article/6375.shtml" target="_blank" rel="external">使用Android Support Annotations优化你的代码</a></p>
<p>如果你还没有听说过Android Support Annotations 函数库，你将错过一个整洁的新软件包，它有助于你捕获程序中的bugs。该函数库包含了许多的Java注解，用于帮助Android Studio检测代码中可能存在的错误，并报告给开发者。注解类型有很多种</p>
<h3 id="Error-prone"><a href="#Error-prone" class="headerlink" title="Error-prone"></a>Error-prone</h3><p><a href="http://droidyue.com/blog/2017/04/09/error-prone-tool-for-java-and-android/" target="_blank" rel="external">Error-prone,Google出品的Java和Android Bug分析利器</a></p>
<h3 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h3><p>代码检查工具能帮我们检查一些隐藏的bug，代码检查工具中sonar是比较好的一个</p>
<p><a href="http://blog.csdn.net/rain_butterfly/article/details/42170601" target="_blank" rel="external">Android 代码检查工具SonarQube</a></p>
<h3 id="DroidJitChecker"><a href="#DroidJitChecker" class="headerlink" title="DroidJitChecker"></a>DroidJitChecker</h3><p>JIT：JIT全称Just-in-time compilation。意思为实时编译，是JVM中一种优化技术，对频繁调用并且符合条件的方法进行优化将字节码翻译成机器代码，提升执行效率。</p>
<p><a href="http://droidyue.com/blog/2016/04/10/jit-friendly-checker-for-android/" target="_blank" rel="external">一个Android代码JIT友好度检测工具</a></p>
<h3 id="UCDetector"><a href="#UCDetector" class="headerlink" title="UCDetector"></a>UCDetector</h3><p>UCDetector是 eclipse 工具 可以审查出程序中  未被使用的、 冗余的、 变量不规范 的代码 </p>
<p><a href="http://blog.csdn.net/aaawqqq/article/details/46684441" target="_blank" rel="external">android优化 清除无效代码 UCDetector</a></p>
<h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><p>静态分析工具承诺无需开发人员费劲就能找出代码中已有的缺陷。当然，如果有多年的编写经验，就会知道这些承诺并不是一定能兑现。</p>
<h2 id="高效工具-自动化及格式化"><a href="#高效工具-自动化及格式化" class="headerlink" title="高效工具(自动化及格式化)"></a>高效工具(自动化及格式化)</h2><p>相关文章<br><a href="https://github.com/jiang111/awesome-androidstudio-plugins" target="_blank" rel="external">收集Android studio 常用的插件</a><br><a href="https://www.2cto.com/kf/201504/389231.html" target="_blank" rel="external">打造你的开发神器——介绍Android Studio上的几个插件</a></p>
<h3 id="layoutformatter"><a href="#layoutformatter" class="headerlink" title="layoutformatter"></a>layoutformatter</h3><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0424/4176.html" target="_blank" rel="external">XML 布局文件代码的优雅性</a><br><a href="https://github.com/drakeet/LayoutFormatter" target="_blank" rel="external">https://github.com/drakeet/LayoutFormatter</a></p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>根据Gson库使用的要求,将JSONObject格式的String 解析成实体<br>写在前头:本插件只适用 android studio和 Intellij IDEA 工具,eclipse 的少年无视我吧!!!<br>这是一个根据JSONObject格式的字符串,自动生成实体类参数.<br><a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="external">https://github.com/zzz40500/GsonFormat</a></p>
<h3 id="android-layout-id-converter"><a href="#android-layout-id-converter" class="headerlink" title="android layout id converter"></a>android layout id converter</h3><p>Android Studio的一个插件<br>简而言之，可以一秒定义控件并且找到<br>相关文章:<br><a href="http://blog.csdn.net/poison_h/article/details/46722649" target="_blank" rel="external">Android Studio插件之Android Layout ID Converter教程</a></p>
<h3 id="AndroidCodeGenerator"><a href="#AndroidCodeGenerator" class="headerlink" title="AndroidCodeGenerator"></a>AndroidCodeGenerator</h3><p>Android studio 插件<br>可以自动生成findViewById方法和ViewHolder</p>
<p>下载地址：<br><a href="https://github.com/fuxiuyuan/AndroidCodeGenerator" target="_blank" rel="external">https://github.com/fuxiuyuan/AndroidCodeGenerator</a></p>
<h3 id="Android-Toolbox-Plugin"><a href="#Android-Toolbox-Plugin" class="headerlink" title="Android Toolbox Plugin"></a>Android Toolbox Plugin</h3><p>生成viewholder</p>
<h3 id="Android-Studio-Prettify"><a href="#Android-Studio-Prettify" class="headerlink" title="Android Studio Prettify"></a>Android Studio Prettify</h3><p>Studio1.5以上的版本鼠标放在<a href="http://R.layout.xxx右键－Generator可以看到View" target="_blank" rel="external">http://R.layout.xxx右键－Generator可以看到View</a> Variables和View Fields，可以帮你初始化资源文件中有id的view，可以再也不用findViewById了（没有的话请安装JetBrains Plugin Repository :: Android Studio Prettify，2.0以上默认没有<br><a href="http://plugins.jetbrains.com/plugin/7405?pr=androidstudio" target="_blank" rel="external">http://plugins.jetbrains.com/plugin/7405?pr=androidstudio</a></p>
<h3 id="Android-Parcelable-code-generator"><a href="#Android-Parcelable-code-generator" class="headerlink" title="Android Parcelable code generator"></a>Android Parcelable code generator</h3><p>生成实现了Parcelable接口的代码的插件.<br><a href="https://www.2cto.com/kf/201603/493780.html" target="_blank" rel="external">Android Studio添加Parcelable序列化小工具（快速提高开发效率）</a></p>
<h3 id="SelectorChapek-for-Android"><a href="#SelectorChapek-for-Android" class="headerlink" title="SelectorChapek for Android"></a>SelectorChapek for Android</h3><p>这是用于生成Selector的插件</p>
<h3 id="Sexy-Editor"><a href="#Sexy-Editor" class="headerlink" title="Sexy Editor"></a>Sexy Editor</h3><p>设置AS背景插件<br><a href="http://www.jianshu.com/p/6a176c87ef29" target="_blank" rel="external">让你的Android Studio性感起来–Sexy Editor</a></p>
<h3 id="Strings-xml-tools"><a href="#Strings-xml-tools" class="headerlink" title="Strings-xml-tools"></a>Strings-xml-tools</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="jimu-Mirror"><a href="#jimu-Mirror" class="headerlink" title="jimu Mirror"></a>jimu Mirror</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="Android-Holo-Colors-Generator"><a href="#Android-Holo-Colors-Generator" class="headerlink" title="Android Holo Colors Generator"></a>Android Holo Colors Generator</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h3><h3 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a>Android Drawable Importer</h3><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="Genymotion-虚拟机"><a href="#Genymotion-虚拟机" class="headerlink" title="Genymotion 虚拟机"></a>Genymotion 虚拟机</h3><p>刚开始做开发的时候，每次使用官方的虚拟机，都想吐槽一下，但是发现了Genymotion 之后，这一切都变化了，它的速度几乎可以和真机媲美了，当然如果有真机，当然还是推荐使用真机测试。</p>
<h3 id="ES-Explorer"><a href="#ES-Explorer" class="headerlink" title="ES Explorer"></a>ES Explorer</h3><p>ES Explorer 是一款文件管理器，但实际它又不仅仅是一款文件管理器，在获得Root 之后，它的功能更强大了，它可以浏览受限制的文件目录；而且提供了一系列小工具，比如下载器；还有集成了众多云储存服务。</p>
<h3 id="WiFi-ADB"><a href="#WiFi-ADB" class="headerlink" title="WiFi ADB"></a>WiFi ADB</h3><p>WiFi ADB 是一个通过无线网络来使电脑和手机连接，当我们做测试的时候，只需在手机上打开，只需在命令行输入 adb connect xxx.xxx.xxx.xxx:5555，电脑可以连接手机，就可以通过无线网络来调试开发的应用。</p>
<hr>
<h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><hr>
<p>大部分的电都消耗在了网络连接、GPS、传感器上了。<br>简单的说也就是主要在以下情况下耗电比较多：<br>1、大数据量的传输。<br>2、不停的在网络间切换。<br>3、解析大量的文本数据。</p>
<p>相关文章：<br><a href="http://kb.cnblogs.com/page/77741/" target="_blank" rel="external">有效控制Android应用程序的耗电量</a></p>
<h2 id="检查电量"><a href="#检查电量" class="headerlink" title="检查电量"></a>检查电量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">在运行你的程序前先检查电量，电量太低，那么就提示用户充电之类的，使用方法：</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123; </div><div class="line">     <span class="comment">// Register for sticky broadcast and send default     </span></div><div class="line">     registerReceiver(mReceiver, mFilter);    </div><div class="line">     mHandler.sendEmptyMessageDelayed(MSG_BATT, <span class="number">1000</span>);    </div><div class="line"> &#125;   </div><div class="line"> IntentFilter mFilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);    </div><div class="line"> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;   </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">         <span class="comment">// Found sticky broadcast, so trigger update     </span></div><div class="line">         unregisterReceiver(mReceiver);    </div><div class="line">         mHandler.removeMessages(MSG_BATT);    </div><div class="line">         mHandler.obtainMessage(MSG_BATT, intent).sendToTarget();    </div><div class="line">     &#125;   </div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<h2 id="定时启动服务"><a href="#定时启动服务" class="headerlink" title="定时启动服务"></a>定时启动服务</h2><p>很多人开发的程序后台都会一个service不停的去服务器上更新数据，在不更新数据的时候就让它sleep，这种方式是非常耗电的，通常情况下，我们可以使用AlarmManager来定时启动服务。如下所示，第30分钟执行一次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AlarmManager am = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);    </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(context, MyService.class);    </div><div class="line">PendingIntent pendingIntent = PendingIntent.getService(context, <span class="number">0</span>, intent, <span class="number">0</span>);    </div><div class="line"><span class="keyword">long</span> interval = DateUtils.MINUTE_IN_MILLIS * <span class="number">30</span>;    </div><div class="line"><span class="keyword">long</span> firstWake = System.currentTimeMillis() + interval;    </div><div class="line">am.setRepeating(AlarmManager.RTC,firstWake, interval, pendingIntent);</div></pre></td></tr></table></figure></p>
<h2 id="检查网络连接"><a href="#检查网络连接" class="headerlink" title="检查网络连接"></a>检查网络连接</h2><p>在需要网络连接的程序中，首先检查网络连接是否正常，如果没有网络连接，那么就不需要执行相应的程序。<br>检查网络连接的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ConnectivityManager mConnectivity;    </div><div class="line">TelephonyManager mTelephony;    </div><div class="line"></div><div class="line"><span class="comment">// 检查网络连接，如果无网络可用，就不需要进行连网操作等    </span></div><div class="line">NetworkInfo info = mConnectivity.getActiveNetworkInfo();    </div><div class="line"><span class="keyword">if</span> (info == <span class="keyword">null</span> ||   </div><div class="line">        !mConnectivity.getBackgroundDataSetting()) &#123;   </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </div><div class="line">&#125;   </div><div class="line"><span class="comment">// 判断网络连接类型，只有在3G或wifi里进行一些数据更新。    </span></div><div class="line"><span class="keyword">int</span> netType = info.getType();    </div><div class="line"><span class="keyword">int</span> netSubtype = info.getSubtype();    </div><div class="line"><span class="keyword">if</span> (netType == ConnectivityManager.TYPE_WIFI) &#123;   </div><div class="line">    <span class="keyword">return</span> info.isConnected();    </div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (netType == ConnectivityManager.TYPE_MOBILE    </div><div class="line">        &amp;&amp; netSubtype == TelephonyManager.NETWORK_TYPE_UMTS    </div><div class="line">        &amp;&amp; !mTelephony.isNetworkRoaming()) &#123;   </div><div class="line">    <span class="keyword">return</span> info.isConnected();    </div><div class="line">&#125; <span class="keyword">else</span> &#123;   </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用高效的数据格式和解析方法"><a href="#使用高效的数据格式和解析方法" class="headerlink" title="使用高效的数据格式和解析方法"></a>使用高效的数据格式和解析方法</h2><p>目前主流的数据格式，使用树形解析（如DOM）和流的方式解析（SAX）</p>
<p>使用流的方式解析效率要高一些，因为DOM解析是在对整个文档读取完后，再根据节点层次等再组织起来。而流的方式是边读取数据边解析，数据读取完后，解析也就完毕了。</p>
<p>在数据格式方面，JSON和Protobuf效率明显比XML好很多，XML和JSON大家都很熟悉，Protobuf是Google提出的，一种语言无关、平台无关、扩展性好的用于通信协议、数据存储的结构化数据串行化方法。有兴趣的可以到官方去看看更多的信息。</p>
<p>所以可以得出结论就是尽量使用SAX等边读取边解析的方式来解析数据<br>针对移动设备，最好能使用JSON之类的轻量级数据格式为佳。</p>
<h2 id="GZIP压缩"><a href="#GZIP压缩" class="headerlink" title="GZIP压缩"></a>GZIP压缩</h2><p>http使用GZIP压缩方式下载数据，能减少网络流量<br>目前大部门网站都支持GZIP压缩，所以在进行大数据量下载时，尽量使用GZIP方式下载。</p>
<p>使用方法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.zip.GZIPInputStream;    </div><div class="line">HttpGet request = <span class="keyword">new</span> HttpGet(<span class="string">"http://example.com/gzipcontent"</span>);  </div><div class="line">HttpResponse resp = <span class="keyword">new</span> DefaultHttpClient().execute(request);   </div><div class="line">HttpEntity entity = response.getEntity();  </div><div class="line">InputStream compressed = entity.getContent();  </div><div class="line">InputStream rawData = <span class="keyword">new</span> GZIPInputStream(compressed);</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>获取用户的地理位置信息时，在需要获取数据的时候打开GPS，之后及时关闭掉<br>对定位要求不是太高的话尽量不要使用GPS定位，可能使用wifi和移动网络cell定位即可。<br>GPS定位消耗的电量远远高于移动网络定位。</p>
<p>获取屏幕尺寸等信息可以使用缓存技术，不需要进行多次请求。</p>
<p>尽量不要使用浮点运算。</p>
<hr>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><hr>
<p>一个网络请求可以简单分为连接服务器 -&gt; 获取数据两个部分。<br>其中连接服务器前还包括 DNS 解析的过程；获取数据后可能会对数据进行缓存。</p>
<p>以下是网络优化中一些客户端和服务器端需要尽量遵守的准则：<br>a. 图片必须缓存，最好根据机型做图片做图片适配<br>b. 所有http请求必须添加httptimeout<br>c. 开启gzip压缩<br>d. api接口数据以json格式返回，而不是xml或html<br>e. 根据http头信息中的Cache-Control及expires域确定是否缓存请求结果。<br>f. 确定网络请求的connection是否keep-alive<br>g. 减少网络请求次数，服务器端适当做请求合并。<br>h. 减少重定向次数<br>i. api接口服务器端响应时间不超过100ms<br>google正在做将移动端网页速度降至1秒的项目，关注中<a href="https://developers.google.com/speed/docs/insights/mobile" target="_blank" rel="external">https://developers.google.com/speed/docs/insights/mobile</a></p>
<h2 id="连接服务器优化策略"><a href="#连接服务器优化策略" class="headerlink" title="连接服务器优化策略"></a>连接服务器优化策略</h2><p>1.不用域名，用 IP 直连<br>省去 DNS 解析过程，DNS 全名 Domain Name System，解析意指根据域名得到其对应的 IP 地址。 如 <a href="http://www.codekk.com" target="_blank" rel="external">http://www.codekk.com</a> 的域名解析结果就是 104.236.147.76。</p>
<p>首次域名解析一般需要几百毫秒，可通过直接向 IP 而非域名请求，节省掉这部分时间，同时可以预防域名劫持等带来的风险。</p>
<p>当然为了安全和扩展考虑，这个 IP 可能是一个动态更新的 IP 列表，并在 IP 不可用情况下通过域名访问。</p>
<p>2.服务器合理部署<br>服务器多运营商多地部署，一般至少含三大运营商、南中北三地部署。</p>
<p>配合上面说到的动态 IP 列表，支持优先级，每次根据地域、网络类型等选择最优的服务器 IP 进行连接。</p>
<p>对于服务器端还可以调优服务器的 TCP 拥塞窗口大小、重传超时时间(RTO)、最大传输单元(MTU)等。</p>
<h2 id="获取数据优化策略"><a href="#获取数据优化策略" class="headerlink" title="获取数据优化策略"></a>获取数据优化策略</h2><h3 id="连接复用"><a href="#连接复用" class="headerlink" title="连接复用"></a>连接复用</h3><p>节省连接建立时间，如开启 keep-alive。</p>
<p>Http 1.1 默认启动了 keep-alive。对于 Android 来说默认情况下 HttpURLConnection 和 HttpClient 都开启了 keep-alive。只是 2.2 之前 HttpURLConnection 存在影响连接池的 Bug，具体可见：Android HttpURLConnection 及 HttpClient 选择</p>
<h3 id="网络请求增加超时时间"><a href="#网络请求增加超时时间" class="headerlink" title="网络请求增加超时时间"></a>网络请求增加超时时间</h3><p>对于http请求设置连接超时时间和响应超时时间</p>
<h3 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h3><p>即将多个请求合并为一个进行请求，比较常见的就是网页中的 CSS Image Sprites。 如果某个页面内请求过多，也可以考虑做一定的请求合并。</p>
<h3 id="减小请求数据大小"><a href="#减小请求数据大小" class="headerlink" title="减小请求数据大小"></a>减小请求数据大小</h3><p>(1) 对于 POST 请求，Body 可以做 Gzip 压缩，如日志。</p>
<p>(2) 对请求头进行压缩<br>这个 Http 1.1 不支持，SPDY 及 Http 2.0 支持。 Http 1.1 可以通过服务端对前一个请求的请求头进行缓存，后面相同请求头用 md5 之类的 id 来表示即可。</p>
<h3 id="CDN-缓存静态资源"><a href="#CDN-缓存静态资源" class="headerlink" title="CDN 缓存静态资源"></a>CDN 缓存静态资源</h3><p>缓存常见的图片、JS、CSS 等静态资源。</p>
<h3 id="减小返回数据大小"><a href="#减小返回数据大小" class="headerlink" title="减小返回数据大小"></a>减小返回数据大小</h3><p>(1) 压缩<br>一般 API 数据使用 Gzip 压缩和ZIP压缩</p>
<p>相关文章：<br><a href="http://www.cnblogs.com/whoislcj/p/5473806.html" target="_blank" rel="external">Android总结之Gzip/Zip压缩</a></p>
<p>关于压缩算法的术语：</p>
<ul>
<li>压缩比<br>就是通过编码器压缩后的图象数字大小和原图象数字大小的压缩比。这句话表述刚好相反！<br>正确的表述是： 压缩比= （原图象数字大小）/（压缩后的图象数字大小）</li>
</ul>
<p>(2) 精简数据格式<br>传数据用json格式代替XML，解析方便而且省流量<br>WebP 代替其他图片格式</p>
<p>(3) 对于不同的设备不同网络返回不同的内容 如不同分辨率图片大小。</p>
<p>(4) 增量更新<br>需要数据更新时，可考虑增量更新。如常见的服务端进行 bsdiff，客户端进行 bspatch。</p>
<p>(5) 大文件下载<br>支持断点续传，并缓存 Http Resonse 的 ETag 标识，下次请求时带上，从而确定是否数据改变过，未改变则直接返回 304。</p>
<h2 id="网络数据缓存"><a href="#网络数据缓存" class="headerlink" title="网络数据缓存"></a>网络数据缓存</h2><p>http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读。</p>
<h2 id="其他优化手段"><a href="#其他优化手段" class="headerlink" title="其他优化手段"></a>其他优化手段</h2><h3 id="网络获取到展现速度较慢的优化"><a href="#网络获取到展现速度较慢的优化" class="headerlink" title="网络获取到展现速度较慢的优化"></a>网络获取到展现速度较慢的优化</h3><p>定位：在HttpURLConnection.getInputStream()之后的处理<br>解决：使用BufferedReader替代BufferedInputStream获取时间从100ms降低到3ms，具体代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HttpURLConnection con = (HttpURLConnection)url.openConnection();</div><div class="line">InputStream input = con.getInputStream();</div><div class="line"><span class="keyword">while</span> (input.read(buffer, <span class="number">0</span>, <span class="number">1024</span>) != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpURLConnection con = (HttpURLConnection)url.openConnection();</div><div class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</div><div class="line">String s;</div><div class="line"><span class="keyword">while</span> ((s = input.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="预加载和懒加载"><a href="#预加载和懒加载" class="headerlink" title="预加载和懒加载"></a>预加载和懒加载</h3><p>预加载包括预连接、预取数据。<br>懒加载体现于ViewPager默认加载3页，如果为了节省流量，就修改常量值就变成了只加载1页</p>
<h3 id="分优先级、延迟部分请求"><a href="#分优先级、延迟部分请求" class="headerlink" title="分优先级、延迟部分请求"></a>分优先级、延迟部分请求</h3><p>将不重要的请求延迟，这样既可以削峰减少并发、又可以和后面类似的请求做合并。</p>
<h3 id="多连接"><a href="#多连接" class="headerlink" title="多连接"></a>多连接</h3><p>对于较大文件，如大图片、文件下载可考虑多连接。 需要控制请求的最大并发量，毕竟移动端网络受限。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>优化需要通过数据对比才能看出效果，所以监控系统必不可少，通过前后端的数据监控确定调优效果。</p>
<hr>
<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><hr>
<p>主要包括索引和事务及针对Sqlite的优化。</p>
<p>进去Activity如果有频繁的查询数据库的操作，就在onCreate方法里打开数据库，onDestroy里关闭数据库就可，这样就不用每次点击条目打开一次数据库，避免频繁的打开和关闭</p>
<p>具体可见<a href="http://www.trinea.cn/android/database-performance/" target="_blank" rel="external">Trinea——性能优化之数据库优化</a></p>
<hr>
<h1 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h1><hr>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>硬件加速(Hardware Acceleration)<br>有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，<br>在API16之后确实有很多方法不支持硬件加速，<br>通常我们关闭硬件加速都是在清单文件中通过，<br>其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。</p>
<p>相关文章：<br><a href="http://www.cnblogs.com/frydsh/archive/2012/10/23/2733581.html" target="_blank" rel="external">Android的硬件加速</a> </p>
<hr>
<h1 id="JNI优化"><a href="#JNI优化" class="headerlink" title="JNI优化"></a>JNI优化</h1><hr>
<p>Android应用程序大都通过Java开发，需要Dalvik的JIT编译器将Java字节码转换成本地代码运行，而本地代码可以直接由设备管理器直接执行，节省了中间步骤，所以执行速度更快。不过需要注意从Java空间切换到本地空间需要开销，同时JIT编译器也能生成优化的本地代码，所以糟糕的本地代码不一定性能更优。</p>
<p>这个优化点会在后面待补充。</p>
<hr>
<h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1><hr>
<h2 id="各种细节缩减包大小"><a href="#各种细节缩减包大小" class="headerlink" title="各种细节缩减包大小"></a>各种细节缩减包大小</h2><p>图片尽量分拆成多个可重用的图片</p>
<p>服务端可以实现的，就不要放在客户端</p>
<p>引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大</p>
<h2 id="ProGuard优化"><a href="#ProGuard优化" class="headerlink" title="ProGuard优化"></a>ProGuard优化</h2><h3 id="使用ProGuard简化代码"><a href="#使用ProGuard简化代码" class="headerlink" title="使用ProGuard简化代码"></a>使用ProGuard简化代码</h3><p>ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。ProGuard会对我们的代码进行检索，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。</p>
<h2 id="Dex优化"><a href="#Dex优化" class="headerlink" title="Dex优化"></a>Dex优化</h2><p>dex是Android平台上(Dalvik虚拟机)的可执行文件, 相当于Windows平台中的exe文件, 每个Apk安装包中都有dex文件, 里面包含了该app的所有源码, 通过反编译工具可以获取到相应的java源码。</p>
<p>所以dex是一个很重要的东西，当然也可以优化。</p>
<p>查看相关文章：<br><a href="http://www.trinea.cn/android/facebook%E5%BC%80%E6%BA%90%E7%9A%84android%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7redex-%E5%87%8F%E5%B0%8F%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F-%E5%90%8C%E6%97%B6%E6%8F%90%E9%AB%98%E8%BF%90/" target="_blank" rel="external">Facebook App 优化工具 ReDex 优化的 6 点及未优化的一大方面</a><br><!-- 为什么需要学习dex文件格式? 最主要的一个原因: 由于通过反编译dex文件可以直接看到java源码, 越来越多的app(包括恶意病毒app)都使用了加固技术以防止app被轻易反编译, 当需要对一个加固的恶意病毒app进行分析或对一个app进行破解时, 就需要了解dex文件格式, 将加固的dex文件还原后(脱壳)再进行反编译获取java源码, 所以要做Android安全方面的深入, dex文件格式是基础中的基础。 --></p>
<hr>
<h1 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h1><hr>
<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><p>这个不同于算法，主要是理清程序逻辑，减少不必要的操作。</p>
<h2 id="需求优化"><a href="#需求优化" class="headerlink" title="需求优化"></a>需求优化</h2><p>这个就不说了，对于sb的需求可能带来的性能问题，只能说做为一个合格的程序员不能只是执行者，要学会说NO。不过不能拿这种借口敷衍产品经理哦。</p>
<hr>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><hr>
<p>书籍：<br>Andorid开发艺术探索——第15章Android性能优化<br>Android群英传——第10章Android性能优化</p>
<p>文章：<br><a href="http://www.trinea.cn/android/performance/" target="_blank" rel="external">Trinea——性能优化系列总篇</a><br><a href="http://www.trinea.cn/android/android-performance-demo/" target="_blank" rel="external">Trinea——性能优化实例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_performance_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>高效学习工作管理的实用法则</title>
    <link href="https://hengxing0080.github.io/2017/09/27/manager/1.Rule/"/>
    <id>https://hengxing0080.github.io/2017/09/27/manager/1.Rule/</id>
    <published>2017-09-27T08:51:55.000Z</published>
    <updated>2017-11-02T15:41:29.011Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_manager_rule1.jpg" alt="UML图"><br><a id="more"></a></p>
<p>工作期间收集的各种情景的实用方案，它们能让你更有章法的思考和工作和管理，更快的提升自己！</p>
<p>因精华太多篇幅太长，每个概念仅领进门，如对某个关键词感兴趣请自行搜索详细资料！</p>
<hr>
<h1 id="高效学习"><a href="#高效学习" class="headerlink" title="高效学习"></a>高效学习</h1><hr>
<h2 id="一万小时定律"><a href="#一万小时定律" class="headerlink" title="一万小时定律"></a>一万小时定律</h2><p><img src="/images/it_manager_rule21.jpg" alt="UML图"><br>中文名 一万小时定律<br>提出者 马尔科姆·格拉德威尔<br>提出时间 2009年01月19日<br>应用学科 所有学科<br>适用领域范围 所有领域<br>适用领域范围 对于量的积累</p>
<p>作家格拉德威尔在《异类》一书中指出：“<br>人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。<br>1万小时的锤炼是任何人从平凡变成超凡的必要条件.<br>要成为某个领域的专家，需要10000小时，<br>按比例计算就是：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。这就是一万小时定律。</p>
<p>相关文章：<br><a href="https://book.douban.com/review/5705791/" target="_blank" rel="external">无他，唯手熟尔！</a><br><a href="http://www.51pptmoban.com/zhuti/3493.html" target="_blank" rel="external">一万小时黄金定律（天才定律）ppt模板</a></p>
<h2 id="西蒙学习法"><a href="#西蒙学习法" class="headerlink" title="西蒙学习法"></a>西蒙学习法</h2><p>中文名 西蒙学习法<br>外文名 Simon learning method<br>创始者 西蒙教授<br>原理 持续连续的长时间学习</p>
<p>介绍：<br>“西蒙学习法”是指诺贝尔经济学奖获得者西蒙教授提出的一个理论：“对于一个有一定基础的人来说，只要真正肯下功夫，在6个月内就可以掌握任何一门学问。”<br>西蒙教授立论所依据的实验心理的研究成果表明：一个人1分钟到1分半钟可以记忆一个信息，心理学把这样一个信息称为“块”，估记每一门学问所包含的信息量大约是5万块，如果1分钟能记忆1“块”，那么5万块大约需要1000个小时，以每星期学习40小时计算，要掌握一门学问大约需要用6个月。<br>为了感谢西蒙的这个研究成果，教育心理学界称这种学习法为西蒙学习法。</p>
<p>为了形象地说明，把西蒙学习法比做一把锥子。正如居里夫人所说，“知识的专一性像锥尖，精力的集中好比是锥子的作用力，时间的连续性好比是不停顿地使锥子往前钻进。” 西蒙学习法所支配的学习活动，呈现出一种尖锐猛烈、持续不断的态势。<br>这种“锥形学习法”的高效原理在于，连续的长时间学习本身包涵对之前学习内容的应用，这样就省去了大量的复习时间。如果用烧水来做比喻，“锥形学习法”是连续的加热，所以热量散失的少；普通的间断学习是烧一会儿就停止加热，一段时间以后再继续加热，这样许多热量就白白散失了。两相比较，自然是持续“加热”效果显著了。<br>原理：烧一壶开水，如果断断续续地烧，1万个小时也烧不开，如果连续烧，1个小时就够用了。</p>
<h2 id="社会化学习"><a href="#社会化学习" class="headerlink" title="社会化学习"></a>社会化学习</h2><p><img src="/images/it_manager_rule22.jpg" alt="UML图"><br>个人理解：<br>就是经过10多年的填鸭式教育走出校门时在社会上无时不在无处不在的一种学习方式。<br>学习并不痛苦，学习是一种习惯一种不断晋升自我知识和技能的过程，学习是一种习惯性的心态和思维方式，正确理解后这样就能在社会打拼的种种过程都成转化为学习，所以，把社会当成一所庞大的永不毕业的大学来体验人生吧！ 人生的过程就是不断学习！</p>
<p>理论收集：<br>总结起来，社会化学习的路径其实很简单，就三条：<br>1) 学习在窗外<br>这里的“窗”是指传统教育体制。到真实社会和生活环境中去学习，而不仅仅局限在传统僵化的学校教育体制之内。<br>2) 他人即老师<br>和“他人”一起学习，向“他人”进行学习。这里的“他人”不是传统意义上的“学校老师”，而是在同学、父母、社区、社会之间创建各种各样的学习关系。<br>3) 世界是教材<br>过去，教材就是学习者的整个世界；未来，整个世界都可以是学习者的教材。</p>
<p>社会化学习往往发生于传统的教室、教学内容和教学方式之外。社会化学习的目的并不仅仅是让学习者记住某些知识点或者某个技术，而是将学习置身于真实的社会生活之中，帮助他们体验和发展“生而为人”最重要的品质和能力：创造能力、独立思考能力、沟通能力、好奇心、合作能力、勇气、公民素养，等等。</p>
<p>相关文章：<a href="http://www.sohu.com/a/133648011_100928" target="_blank" rel="external">顾远：什么是“社会化学习” ？</a></p>
<h2 id="康奈尔笔记系统-5R笔记法"><a href="#康奈尔笔记系统-5R笔记法" class="headerlink" title="康奈尔笔记系统/5R笔记法"></a>康奈尔笔记系统/5R笔记法</h2><p>康奈尔笔记系统是沃尔特·鲍克等人发明的，旨在为帮助学生有效地做笔记。康奈尔笔记系统把一页纸分成了三部分：左边四分之一左右（线索栏）和下方五分之一左右的空间（总结）和右上最大的空间（草稿）。</p>
<p>中文名 康奈尔笔记系统<br>发明者 沃尔特·鲍克</p>
<p>系统介绍：<br>康奈尔笔记系统把一页纸分成了三部分：<br>右上最大的空间是我们平时做笔记的地方，你按照平时的习惯记录<br>就行了。<br>左边那竖着的一条空间叫做“线索栏”，是用来归纳右边的内容的，写一些提纲挈领的东西，这个工作不要在做笔记的时候做，而是在上完课之后马上回顾，然后把要点都写到左边，这样一方面马上复习了内容，另一方面理清了头绪。<br>下面那横着的一栏是用来做总结的，就是用一两句话总结你这页记录的内容，这个工作可以延后一点儿做，起到促进你思考消化的作用，另外也是笔记内容的极度浓缩和升华。<br><img src="/images/it_manager_rule2.jpg" alt="UML图"></p>
<h2 id="学习高原现象"><a href="#学习高原现象" class="headerlink" title="学习高原现象"></a>学习高原现象</h2><p><img src="/images/it_manager_rule3.png" alt="UML图"></p>
<p>就是进阶某一学习阶段的瓶颈<br>克服“高原现象”<br>爱学习的人都会有这样的经历：学习持续了一段时间之后，往往会有一个瓶颈期，长时间似乎都没有什么进步，于是内心非常着急。<br>这种情况，实际上是由人的学习规律决定的一种“高原现象”。据研究，学习者在刚开始进步快，随后有一个明显的或长或短的进步停顿期，后期进步慢，中间的停顿期叫高原期（如上图所示）。</p>
<p>高原期，实质是一个消化期。由于前期的学习积累了太多的知识点，这些知识点在大脑中乱作一团，还没有形成一个知识体系。这时需要一定的时间来消化它，让它融会贯通，经常思考总结可以快速帮你跨过高原期。<br>处于高原期时，还可以换一个相关的方向来学习。例如，编程语言学不下去了，可以学习一下设计模式，设计模式也学不下去了，再换成数据库。通过学习这些相关的知识，不但补齐了知识体系中的短板，而且各个知识点之间可以互相启发，帮助你实现顿悟，跨过高原期。</p>
<h2 id="过度学习效应"><a href="#过度学习效应" class="headerlink" title="过度学习效应"></a>过度学习效应</h2><p>中文名 过度学习效应<br>外文名 Over learning effect<br>提出者 H·艾宾浩斯<br>提出时间 1950<br>应用学科 全部学科都适用<br>适用领域范围 学习领域</p>
<p>过度学习效应指的是人们对所学习、记忆的内容达到了初步掌握的程序后，如果再用原来所花时间的一半去巩固强化，使学习程度达到150%，将会使记忆得到强化。<br>艾宾浩斯所说的“过度学习”,不是毫无限度的“超度学习”。一般认为在一定范围内，过度学习是必须的，超过了一定限度，就是很不经济的，因为过度学习需要更多的时间和精力。一般说来，学习程度以150%为佳，其效应也最大。超过150%,会因学习疲劳而发生“报酬递减”现象,学习的效果就会逐渐下降，出现注意分散、厌倦、疲劳等消极效应。</p>
<h2 id="心流状态-心流理论"><a href="#心流状态-心流理论" class="headerlink" title="心流状态/心流理论"></a>心流状态/心流理论</h2><p><img src="/images/it_manager_rule23.jpg" alt="UML图"><br><img src="/images/it_manager_rule24.jpg" alt="UML图"><br>心流（英语：Mental flow）在心理学中是一种某者在专注进行某行为时所表现的心理状态。<br>如艺术家在创作时所表现的心理状态。某者在此状态时，通常不愿被打扰，即抗拒中断。<br>定义是一种将个人精神力完全投注在某种活动上的感觉；心流产生时同时会有高度的兴奋及充实感。齐克森米哈里认为，使心流发生的活动有多样性。</p>
<p>相关文章：<br><a href="https://baike.baidu.com/tashuo/browse/content?id=7e0fcb27ad2ceff4478d8ded&amp;fr=qingtian&amp;lemmaId=9824097" target="_blank" rel="external">为什么我一玩游戏，就忘记了时间？| “忘我”也可以令你获得幸福</a></p>
<h2 id="泉涌状态-涌流理论"><a href="#泉涌状态-涌流理论" class="headerlink" title="泉涌状态/涌流理论"></a>泉涌状态/涌流理论</h2><p>忘我的状态，专注，高效<br>工作、学习都需要激发这种状态<br>比如在音乐的世界中，不知不觉把事情做完</p>
<p>PS：暂未把泉涌状态和上面的心流状态弄明白有何区别，也可能是一个意思.</p>
<h2 id="期望定律"><a href="#期望定律" class="headerlink" title="期望定律"></a>期望定律</h2><p>提出者 心理学家罗森塔尔<br>提出时间 1966年<br>适用领域范围 管理</p>
<p>期望定律告诉我们，当我们怀着对某件事情非常强烈期望的时候，我们所期望的事物就会出现。 如果一个人有自信心，对自己怀着期望，他就会朝着自己期望的方向发展。</p>
<h2 id="用进废退"><a href="#用进废退" class="headerlink" title="用进废退"></a>用进废退</h2><p>中文名 用进废退<br>外文名 use and disuse theory<br>提出者 法国生物学家拉马克<br>理论应用 越是懒惰不动脑 难以正常运转<br>观点辨析 达尔文对他的观点进行了驳斥<br>例    证 长颈鹿<br>其他信息 达尔文认为物种的进化是渐进的</p>
<h2 id="归零心态、空杯心态"><a href="#归零心态、空杯心态" class="headerlink" title="归零心态、空杯心态"></a>归零心态、空杯心态</h2><p>象征意义：做事前提是先要有好心态<br>释义：一种挑战自我的永不满足</p>
<p>空杯心态属于心理学概念，象征意义是做事的前提是先要有好心态。如果想学到更多学问，先要把自己想象成“一个空着的杯子”，而不是骄傲自满。</p>
<hr>
<h1 id="高效工作"><a href="#高效工作" class="headerlink" title="高效工作"></a>高效工作</h1><hr>
<h2 id="GTD"><a href="#GTD" class="headerlink" title="GTD"></a>GTD</h2><p><img src="/images/it_manager_rule19.jpg" alt="UML图"></p>
<p>中文名 竭尽所能<br>外文名 Getting Things Done<br>别称 GTD<br>表达式 收集、整理、组织、回顾、执行<br>提出者 David Allen(戴维·艾伦)<br>提出时间 2002年12月31日<br>推荐GTD应用 TickTick、any.do、wunderlist等<br>理论属性 行动管理法</p>
<p>GTD就是Getting Things Done的缩写，翻译过来就是“把事情做完”，GTD的核心理念概括就是必须记录下来要做的事，然后整理安排并使自己一一去执行。<br>GTD的五个核心原则是：收集、整理、组织、回顾、执行。<br>GTD的核心理念在于清空大脑，然后一步步按照设定的路线去努力执行。</p>
<h2 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h2><p><img src="/images/it_manager_rule20.jpg" alt="UML图"></p>
<p>中文名 番茄工作法<br>外文名 The pomodoro technique<br>创始人 弗朗西斯科·西里洛<br>时间 1992年<br>类型 时间管理方法<br>作用 提高效率</p>
<p>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。<br>使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。<br>番茄工作法极大地提高了工作的效率，还会有意想不到的成就感。</p>
<p>选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。<br>合理设置自己一个天的番茄时间段，尽量将重要的工作放在头脑高效的时段，比如上午8:30~11:00，下午15:00到17:00等。</p>
<h2 id="6点优先工作制"><a href="#6点优先工作制" class="headerlink" title="6点优先工作制"></a>6点优先工作制</h2><p><img src="/images/it_manager_rule25.jpg" alt="UML图"><br><img src="/images/it_manager_rule26.jpg" alt="UML图"><br>该方法是效率大师艾维利向美国一家钢铁公司提供咨询时提出的，它使这家公司用了5年的时间，从濒临破产一跃成为当时全美最大的私营钢铁企业，艾维利因此获得了2.5万美元咨询费，故管理界将该方法喻为“价值2.5万美元的时间管理方法”。<br>这一方法要求把每天所要做的事情按重要性排序，分别从“1”到“6”标出6件最重要的事情。每天一开始，先全力以赴做好标号为“1”的事情，直到它被完成或被完全准备好，然后再全力以赴地做标号为“2”的事，依此类推……<br>艾维利认为，一般情况下，如果一个人每都能全力以赴地完6件最重要的事情，那么他一定是一位高效率人士</p>
<h2 id="办公室美学"><a href="#办公室美学" class="headerlink" title="办公室美学"></a>办公室美学</h2><p><img src="/images/it_manager_rule27.jpg" alt="UML图"><br>秩序是一种美。均匀、对称、平衡和整齐的事物能给人一种美感。简洁就是速度，条理就是效率。简洁和条理也是一种美，是一种办公室的美学、工作的美学。<br>第一我们应当养成如下良好习惯：<br>★物以类聚，东西用毕物归原处；<br>★不乱放东西；<br>★把整理好的东西编上号，贴上标签，做好登记；<br>★好记性不如烂笔头，要勤于记录；<br>★处理文件的3个环节：第一，迅速回复。<br>第二，迅速归档，以免文件弄乱或弄丢。<br>第三，及时销毁。没用的文件要及时处理掉，以免继续浪费空间和时间。</p>
<h2 id="全脑模型"><a href="#全脑模型" class="headerlink" title="全脑模型"></a>全脑模型</h2><p><img src="/images/it_manager_rule4.png" alt="UML图"><br><img src="/images/it_manager_rule5.png" alt="UML图"></p>
<p>中文名 全脑模型<br>方式： 逻辑型、组织型、交流型、空想型<br>起源： 1970年</p>
<p>全脑模型（Whole Brain Model）是由20世纪70年代，担任GE管理发展中心主任的奈德·赫曼（Ned Herrmann）博士，对自己集音乐家、艺术家、科学家的兴趣感到好奇。因而投入大脑思维偏好的研究，在1976年经由德州大学以脑电仪证明HBDI理论的成立。是一种被用来分析个人和组织的思维方式的方法。</p>
<p>全脑模型的四种方式为：<br>1、逻辑型。分析的，数学的，技术的和解决问题的。<br>2、组织型。控制的，保守的，计划的，组织的和实际上管理的。<br>3、交流型。人际间，情绪的，音乐的，精神上的，和“谈话”模式。<br>4、空想型。 虚构的，综合的，艺术的和概念上模式。</p>
<p>注：男（左脑）   女（右脑）</p>
<hr>
<h1 id="高效记忆"><a href="#高效记忆" class="headerlink" title="高效记忆"></a>高效记忆</h1><hr>
<h2 id="艾宾浩斯记忆法"><a href="#艾宾浩斯记忆法" class="headerlink" title="艾宾浩斯记忆法"></a>艾宾浩斯记忆法</h2><p>中文名 艾宾浩斯记忆法<br>外文名 Hermann Ebbinghaus<br>创始人 艾宾浩斯<br>时间 1885年</p>
<p>信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。遵循艾宾浩斯遗忘曲线所揭示的记忆规律，对所学知识及时进行复习，这种记忆方法即为艾宾浩斯记忆法。 对所学知识和记忆效果及时进行复习和自测是艾宾浩斯记忆法的主要方式。<br>艾宾浩斯记忆法也是遗忘曲线；一个小时后就会遗忘；在一个小时内回想就可以记住那个东西；最好一天之后在回想；三天之后再回想就可以了。<br><img src="/images/it_manager_rule6.png" alt="UML图"><br><img src="/images/it_manager_rule9.jpg" alt="UML图"></p>
<h2 id="思维导图法"><a href="#思维导图法" class="headerlink" title="思维导图法"></a>思维导图法</h2><p>概    念 有效的思维模式<br>应    用 应用于记忆、学习、思考<br>作    用 利于人脑的扩散思维的展开<br>创    始 东尼·巴赞</p>
<p>思维导图是有效的思维模式，应用于记忆、学习、思考等的思维“地图”，利于人脑的扩散思维的展开。思维导图已经在全球范围得到广泛应用 ，包括大量的500强企业。思维导图的创始人是东尼·巴赞。中国应用思维导图大约有20多年时间。</p>
<p><img src="/images/it_manager_rule7.jpg" alt="UML图"></p>
<h2 id="超右脑"><a href="#超右脑" class="headerlink" title="超右脑"></a>超右脑</h2><p>相关文章：<a href="https://zhidao.baidu.com/daily/view?id=12395" target="_blank" rel="external">右脑记忆能力真的是左脑的100万倍？</a></p>
<h2 id="图像记忆法"><a href="#图像记忆法" class="headerlink" title="图像记忆法"></a>图像记忆法</h2><p><img src="/images/it_manager_rule8.jpg" alt="UML图"></p>
<hr>
<h1 id="休息管理"><a href="#休息管理" class="headerlink" title="休息管理"></a>休息管理</h1><hr>
<h2 id="莫法特休息法"><a href="#莫法特休息法" class="headerlink" title="莫法特休息法"></a>莫法特休息法</h2><p>连续分段时间管理法<br>《圣经•新约》的翻译者詹姆斯•莫法特的书房里有3张桌子：第一张摆着他正在翻译的《圣经•新约》译稿；第二张摆的是他的一篇论文的原稿；第三张摆的是他正在写的一篇侦探小说。<br>莫法特的休息方法就是从一张书桌搬到另一张书桌，继续工作。<br>“间作套种”是农业上常用的一种科学种田的方法。人们在实践中发现，连续几季都种相同的作物，土壤的肥力就会下降很多，因为同一种作物吸收的是同一类养分，长此以往，地力就会枯竭。人的脑力和体力也是这样，<br>如果长时间持续同一项工作内容，就会产生疲劳，使活动能力下降。如果这时改变工作内容，就会产生新的优势兴奋灶，而原来的兴奋灶则得到抑制，这样人的脑力和体力就可以得到有交的调剂和放松。</p>
<p>个人简评：现有工作和学习模式就是这样，腻了就来回切换地点工作学习，写字楼，图书馆，星巴克，便利店，只要环境安静干净，有公共座椅和Wifi就可以无缝切换，个人推荐这种！</p>
<h2 id="达芬奇睡眠法"><a href="#达芬奇睡眠法" class="headerlink" title="达芬奇睡眠法"></a>达芬奇睡眠法</h2><p>中文名 达芬奇睡眠法<br>外文名 Da Vinci sleep<br>别称 多阶段睡眠<br>提出者 达·芬奇<br>应用学科 睡眠<br>适用领域范围 特殊人群</p>
<p>一句话理解：减少睡眠时间的方式</p>
<p>达芬奇睡眠法是一种将人类习惯的单次睡眠过程分散成多个睡眠周期进行，以达成减少睡眠时间的睡眠方式，又称多阶段睡眠（Polyphasic sleep）、Uberman睡眠或多相睡眠。<br>传说达芬奇在500多年前创造了一个奇怪的睡眠作息时间表――“达芬奇睡眠法”，规定每4小时就要小睡15分钟。<br>这样一来，每天只需要睡一个半小时就够了.</p>
<p>个人简评：这种极端方式，只适应少数人，感兴趣可以自我实验1天试试，切勿深入着迷，反正我个人是受不了4小时一睡（关键是睡不着，时间都浪费在酝酿睡意上了）.</p>
<h2 id="维克斯健脑操"><a href="#维克斯健脑操" class="headerlink" title="维克斯健脑操"></a>维克斯健脑操</h2><p>英国爱丁堡大学脑医学博士维克斯先生经多年研究发明的一套“健脑操”，健脑操包括人的记忆思维能力和练习大脑的创造力两个部分。</p>
<p>详情看链接：<br><a href="https://www.douban.com/note/627418932/" target="_blank" rel="external">豆瓣-维克斯健脑操</a></p>
<hr>
<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><hr>
<h2 id="四像限原则"><a href="#四像限原则" class="headerlink" title="四像限原则"></a>四像限原则</h2><p>一种时间精力分配方法</p>
<p>究竟什么占据了人们的时间？这是一个经常令人困惑的问题。<br>著名管理学家科维提出了一个时间管理的理论，把工作按照重要和紧急两个不同的程度进行了划分，基本上可以分为四个“象限”：<br>　既紧急又重要<br>　重要但不紧急<br>　紧急但不重要<br>　既不紧急也不重要<br>这就是关于时间管理的“四象限法则”。<br><img src="/images/it_manager_rule10.jpg" alt="UML图"></p>
<h2 id="二八原则"><a href="#二八原则" class="headerlink" title="二八原则"></a>二八原则</h2><p>又名80/20定律、帕累托法则（定律）也叫巴莱特定律、最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。<br>是意大利经济学家巴莱多发明的。他认为，在任何一组东西中，最重要的只占其中一小部分，约20%。其余80%的尽管是多数，却是次要的，因此又称二八法则。<br>避免将时间花在琐碎的多数问题上，应该集中精力解决 20% 的少数问题，因为你只需花 20% 的时间，即可取得 80% 的成效。 </p>
<p>不可忽略的二八法则<br>犹太人认为，存在一条78∶22宇宙法则，世界上许多事物，都是按78∶22这样的比率存在的。比如空气中，氮气占78%，氧气及其他气体占22%。人体中的水分占78%，其他为22%等等。上升到理论高度，就是我们常说的“二八法则”（也叫“二八定律”）。</p>
<p>日常工作生活中，二八法则无处不在。占人口20%的人，拥有世界上80%的财富；商家发现，自己80%的收入，来自20%的消费者；而我们的工作中，用20%的时间完成80%的任务。</p>
<p>•通常一个企业80%的利润来自它20%的项目<br>•成功的关键是要确定带来80%利润的20%的顾客在哪里并且留住他们<br>•要事第一，重要产品第一，关键人物第一，核心环节第一<br>•找出工作最关键的部分，尽可能把精力放在上面</p>
<p>其核心内容是生活中80%的结果几乎源于20%的活动。比如，总是那些20%的客户给你带来了80%的业绩，可能创造了80%的利润；世界上创造了80%的财富是被20%的人掌握着，世界上80%的人只分享了 20%的财富。因此，要把注意力放在20%的关键事情上。<br>根据这一原则，我们应当对要做的事情分轻重缓急，进行如下的排序：<br>     A．重要且紧急（比如救火、抢险等）——必须立刻做。<br>     B．重要但不紧急（比如学习、做计划、与人谈心、体检等）——只要没有前一类事的压力，应该当成紧急的事去做，而不是拖延。<br>     C．紧急但不重要（比如有人因为打麻将“三缺一”而紧急约你、有人突然打电话请吃饭等）——只有在优先考虑了重要的事情后，再来考虑这类事。人们常犯的毛病是把“紧急”当成优先原则，而不是把“重要”当成优先原则。其实，许多看似很紧急的事，拖一拖，甚至不办，也无关大局。<br>     D．既不紧急也不重要（比如娱乐、消遣等事情）——有闲工夫再说。</p>
<hr>
<h1 id="行动管理"><a href="#行动管理" class="headerlink" title="行动管理"></a>行动管理</h1><hr>
<h2 id="90-10原则"><a href="#90-10原则" class="headerlink" title="90/10原则"></a>90/10原则</h2><p><a href="http://www.jianshu.com/p/04c7d48b6433" target="_blank" rel="external">90/10原则如何影响着你的生活？</a></p>
<hr>
<h1 id="企业管理"><a href="#企业管理" class="headerlink" title="企业管理"></a>企业管理</h1><hr>
<h2 id="马斯洛需求层次理论"><a href="#马斯洛需求层次理论" class="headerlink" title="马斯洛需求层次理论"></a>马斯洛需求层次理论</h2><p>中文名 马斯洛需求层次理论<br>外文名Maslow’s hierarchy of needs<br>别    称 需求层次理论<br>提出人亚伯拉罕·马斯洛<br>时    间 1943年<br>相关论文 《人类激励理论》<br>理论方向 激励，薪酬博弈，管理学 应用领域 人力资源，心理学，教育<br>理论流派 人本主义</p>
<p>马斯洛需求层次理论是人本主义科学的理论之一，由美国心理学家亚伯拉罕·马斯洛在1943年在《人类激励理论》论文中所提出。书中将人类需求像阶梯一样从低到高按层次分为五种，分别是：生理需求、安全需求、社交需求、尊重需求和自我实现需求。</p>
<p><img src="/images/it_manager_rule12.png" alt="UML图"></p>
<h2 id="麦肯锡7S模型"><a href="#麦肯锡7S模型" class="headerlink" title="麦肯锡7S模型"></a>麦肯锡7S模型</h2><p>中文名 麦肯锡解决问题7步法<br>外文名 Mckinsey 7S Model<br>简称 7s模型<br>隶属 麦肯锡顾问公司</p>
<p>麦肯锡7S模型(Mckinsey 7S Model)，简称7s模型，是麦肯锡顾问公司研究中心设计的企业组织七要素，指出了企业在发展过程中必须全面地考虑各方面的情况，包括结构（structure）、制度（system）、风格（style）、员工（staff）、技能（skill）、战略（strategy）、共同的价值观（shared values）。<br><img src="/images/it_manager_rule42.png" alt="UML图"></p>
<h2 id="波特五力模型"><a href="#波特五力模型" class="headerlink" title="波特五力模型"></a>波特五力模型</h2><p>波特五力模型是迈克尔·波特（Michael Porter）于20世纪80年代初提出。它认为行业中存在着决定竞争规模和程度的五种力量，这五种力量综合起来影响着产业的吸引力以及现有企业的竞争战略决策。五种力量分别为同行业内现有竞争者的竞争能力、潜在竞争者进入的能力、替代品的替代能力、供应商的讨价还价能力、购买者的讨价还价能力。</p>
<p>中文名 波特五力模型<br>外文名 Michael Porter five forces model<br>提出者 迈克尔·波特(Michael Porter)<br>应    用 企业战略规划</p>
<p><img src="/images/it_manager_rule51.png" alt="UML图"></p>
<h2 id="领导力五力模型"><a href="#领导力五力模型" class="headerlink" title="领导力五力模型"></a>领导力五力模型</h2><p>中文名 领导力五力模型<br>应用学科 企业经营管理<br>内    容 感召、前瞻、影响、决断和控制力</p>
<p>领导力概念与领导过程、领导行为、领导能力、领导知识和领导情境等密切相关，它们共同构成了领导力概念链，并诠释了领导力诸要素的关系：处于核心层（第一圈层）的是领导过程；第二圈层的领导行为、领导能力和领导知识都是领导过程的直接或间接产物；第三圈层的领导情境是指确保领导过程正常运行的环境因素的总和，是领导行为、领导能力和领导知识等要素形成和发展的重要基础。</p>
<p>领导力五力模型<br><img src="/images/it_manager_rule49.png" alt="UML图"><br><img src="/images/it_manager_rule50.png" alt="UML图"></p>
<h2 id="5C理论"><a href="#5C理论" class="headerlink" title="5C理论"></a>5C理论</h2><p>中文名 5C理论<br>评价 总经理能力体系评价<br>类型 一种最新理论模型<br>含义 change 变革 cadreman骨干等</p>
<p>5C是指：change 变革 cadreman骨干 customer客户 check考核 culture文化。<br>以这五个方面的领导管理能力为主要标志，对企业领导（总经理）的测量、评价体系。<br><img src="/images/it_manager_rule41.png" alt="UML图"></p>
<h2 id="领导权变理论"><a href="#领导权变理论" class="headerlink" title="领导权变理论"></a>领导权变理论</h2><p>“权变”一词有“随具体情境而变”或“依具体情况而定的意思”。<br>领导权变理论主要研究与领导行为有关的情境因素对领导效力的潜在影响。该理论认为，在不同的情境中，不同的领导行为有不同的效果，所以又被称为领导情境理论。<br>中文名 领导权变理论<br>发源于 西方组织管理学<br>性    质 管理理论<br>内    容 领导行为有关<br>又    称 领导情境理论<br>发源地 西方</p>
<h2 id="STAR法则"><a href="#STAR法则" class="headerlink" title="STAR法则"></a>STAR法则</h2><p>STAR法则是情境(situation)、任务(task)、行动(action)、结果(result)四项的缩写。STAR法则是一种常常被面试官使用的工具，用来收集面试者与工作相关的具体信息和能力。S<br>TAR法则比起传统的面试手法来说，可以更精确地预测面试者未来的工作表现。<br>中文名 STAR法则<br>定    义 一种讲述自己故事的方式<br>优    点 更精确地预测面试者未来工作表现<br>STAR 四个单词的缩写</p>
<p>STAR法则,即为Situation Task Action Result的缩写，具体含义是:<br>S(Situation): 事情是在什么情况下发。如：项目属于什么类型，参与人都有哪些，项目周期多长……<br>T(Task): 你是如何明确你的任务的，如：团队的分工，你的职责是什么？<br>A(Action): 针对这样的情况分析，你采用了什么行动方式。如：具体的实施过程，你都做了哪些具体的工作？<br>R(Result): 结果怎样，在这样的情况下你学习到了什么，如：就是最后的成果总结你从中的成长和收获。<br>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>
<p>相关文章：<br><a href="http://www.jianshu.com/p/d833c4cd4f46" target="_blank" rel="external">STAR法则，被这个理由拒绝这么多次，必须搞明白！</a><br><a href="http://blog.csdn.net/zhengjialux/article/details/61680787" target="_blank" rel="external">STAR法则</a><br><a href="http://www.xuexila.com/success/story/509956.html" target="_blank" rel="external">star法编写成就故事_有哪些小故事例文</a></p>
<p><img src="/images/it_manager_rule40.jpg" alt="UML图"></p>
<h2 id="SMART原则"><a href="#SMART原则" class="headerlink" title="SMART原则"></a>SMART原则</h2><p>绩效管理的一种方式<br>原则即目标管理，目标管理是使经理的工作变被动为主动的一个很好的手段，实施目标管理不但是有利于员工更加明确高效地工作，更是为未来的绩效考核制定了目标和考核标准，使考核更加科学化、规范化，更能保证考核的公开、公平与公正，没有目标是无法考核员工的。</p>
<p>•具体的（Specific）<br>•可以衡量的（Measurable）<br>•可以达到的（Attainable）<br>•相关性的(Relevant) 比如一个前台，你让她学点英语以便接电话的时候用得上，这时候提升英语水平和前台接电话的服务质量有关联<br>•具有明确的截止期限（Time-bound）</p>
<p><img src="/images/it_manager_rule39.jpg" alt="UML图"></p>
<p>相关文章：<a href="http://jixiaoguanli.baike.com/article-703023.html" target="_blank" rel="external">什么是SMART原则？</a></p>
<h2 id="PDCA循环"><a href="#PDCA循环" class="headerlink" title="PDCA循环"></a>PDCA循环</h2><p>著名的PDCA循环（Plan Do Check Action），也称戴明环。PDCA是为了提高质量的管理思想，是一套科学程序，注重管理活动的全部过程。</p>
<p>“P”是PLAN：制定目标和计划。《礼记·中庸》提到：“凡事预则立，不预则废。”，说明了目标和计划的重要性。很多时候，我们都是走一步算一步，缺少目标的定制和计划，认为这个很虚，没有必要，也就缺少对目标的实施，到底完成了多少，实现了多少，还是那些未能实现，是什么原因导致的，都无从知晓。</p>
<p>“D”是DO：开始行动，实施计划很多人制定了计划，可以说，计划是相当完美，可因见异思迁，三分钟热度，一时的激情过后就没了动力了。有位记者采访通用公司前总裁杰克·韦尔奇时，记者问：“请问韦尔奇先生，你们为什么能成功？”，韦尔奇先生回答说：“你们知道了，我们做到了”。很多时候我们都没有勇敢的迈出第一步，总是想着这，顾虑那，慢慢就放弃了。</p>
<p>“C”是CHECK，对行动的结果进行检验，行动了，做了，要有个结果，对其结果是否满意，思考下次方案是否可以改进等。</p>
<p>“A”是ACTION：纠正错误，调整方向。其实也就是总结、完善的意思善于总结，我们伟大的毛主席就非常提倡这点，他把他的成功归咎于善于总结经验，集中群众智慧，可见总结这个环节不容忽视。工作中，小到日报，周报，大到月总结，季总结等。有总结我们才能更进一步把工作做得更好。</p>
<p><img src="/images/it_manager_rule32.png" alt="UML图"></p>
<h2 id="1-1-lt-2效应"><a href="#1-1-lt-2效应" class="headerlink" title="1+1&lt;2效应"></a>1+1&lt;2效应</h2><p>指的是团队合作效应<br><a href="https://zhidao.baidu.com/question/553547684.html" target="_blank" rel="external">“1+1&lt;2”效应 阅读答案</a></p>
<h2 id="能力素质模型"><a href="#能力素质模型" class="headerlink" title="能力素质模型"></a>能力素质模型</h2><p>中文名 能力素质模型<br>外文名 Competence Model<br>开发方法 关键事件访谈法<br>应用 人才甄选、绩效管理、继任计划等</p>
<p>能力素质模型通常包括三类能力：通用能力、可转移的能力、独特的能力。这些行为和技能必须是可衡量、可观察、可指导的，并对员工的个人绩效以及企业的成功产生关键影响。</p>
<p><img src="/images/it_manager_rule43.png" alt="UML图"></p>
<h2 id="岗位胜任力素质模型"><a href="#岗位胜任力素质模型" class="headerlink" title="岗位胜任力素质模型"></a>岗位胜任力素质模型</h2><p>中文名 胜任素质模型<br>外文名 Competency Model<br>别称 素质模型<br>用途 员工产生工作绩效的各种特征集合 </p>
<p>胜任素质模型就是个体为完成某项工作、达成某一绩效目标所应具备的系列不同素质要素的组合，分为内在动机、知识技能、自我形象与社会角色特征等几个方面。这些行为和技能必须是可衡量、可观察、可指导的，并对员工的个人绩效以及企业的成功产生关键影响。</p>
<p><img src="/images/it_manager_rule44.png" alt="UML图"></p>
<h2 id="冰山模型"><a href="#冰山模型" class="headerlink" title="冰山模型"></a>冰山模型</h2><p>冰山模型是美国著名心理学家麦克利兰于1973年提出了一个著名的模型，所谓“冰山模型”，就是将人员个体素质的不同表现表式划分为表面的“冰山以上部分”和深藏的“冰山以下部分”。</p>
<p>中文名 冰山模型<br>提出者 麦克利兰（美）<br>用    处 心理治疗<br>归    类 社会科学/心理学</p>
<p><img src="/images/it_manager_rule45.png" alt="UML图"></p>
<h2 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h2><p>洋葱模型是在冰山模型基础上演变而来的。美国学者理查德·博亚特兹对麦克利兰的素质理论进行了深入和广泛的研究，提出了“素质洋葱模型”，展示了素质构成的核心要素，并说明了各构成要素可被观察和衡量的特点。洋葱模型，是把胜任素质由内到外概括为层层包裹的结构，最核心的是动机，然后向外依次展开为个性、自我形象与价值观、社会角色、态度、知识、技能。越向外层，越易于培养和评价；越向内层，越难以评价和习得。</p>
<p>中文名 洋葱模型<br>外文名 Onion model<br>提出者 美国学者R.博亚特兹<br>核心要素 素质构成<br>应    用人员选拔，人员测评</p>
<p><img src="/images/it_manager_rule46.png" alt="UML图"></p>
<h2 id="高绩效素质模型"><a href="#高绩效素质模型" class="headerlink" title="高绩效素质模型"></a>高绩效素质模型</h2><p>高绩效素质模型是对一个企业当中高绩效模型的描述，分成动脑，动心，动手，动嘴四个模块，简称BHM体系。通过这种无缝联接，可以系统的或者单独模块的就企业员工素质进行业绩导向的提升，是企业业绩提升的有利工具。</p>
<p><img src="/images/it_manager_rule47.png" alt="UML图"></p>
<h2 id="GROW模型"><a href="#GROW模型" class="headerlink" title="GROW模型"></a>GROW模型</h2><p>GROW的意思是成长，帮助员工成长。<br>G（Goal setting）：代表确认员工业绩目标；<br>R（Reality Check）：是现状，要搞清楚目前的现状、客观事实是什么；寻找动因；<br>O（Options）：代表寻找解决方案；<br>W（Way Forward）：What? When? Who? Will? What should be done? When by whom and does the will exist to do it?代表制定行动计划和评审时间。</p>
<p>Grow模型可以在生活很多不同的地方运用，它的主旨意为理清现状，减少某些事情的干扰，使执行人从内心找到对应的办法。<br>GROW其目标，是使得员工认识也认同现目标的自己有什么能做的，或者怎么做。<br><img src="/images/it_manager_rule52.png" alt="UML图"></p>
<h2 id="坏苹果法则"><a href="#坏苹果法则" class="headerlink" title="坏苹果法则"></a>坏苹果法则</h2><p>中文名 坏苹果法则<br>外文名 Bad apple law<br>法    则 态度决定团队<br>内    容 坏苹果留在好苹果里，结果全变烂</p>
<p>一句话理解：人的态度将影响到团队</p>
<p><img src="/images/it_manager_rule37.jpg" alt="UML图"></p>
<h2 id="蘑菇定律"><a href="#蘑菇定律" class="headerlink" title="蘑菇定律"></a>蘑菇定律</h2><p>中文名 蘑菇定律<br>别    称 蘑菇管理<br>提出者 电脑程序员<br>提出时间 20世纪70年代<br>适用领域范围 心理学</p>
<p>战胜苦难突出重围</p>
<p>蘑菇定律是指初入世者常常会被置于阴暗的角落，不受重视或打杂跑腿，就象蘑菇培育一样还要被浇上大粪，接受各种无端的批评、指责、代人受过，得不到必要的指导和提携，处于自生自灭过程中。蘑菇生长必须经历这样一个过程，人的成长也肯定会经历这样一个过程。这就是蘑菇定律，或叫萌发定律。</p>
<p>“蘑菇管理”指的是组织或个人对待新进者的一种管理心态。因为初学者常常被置于阴暗的角落，不受重视的部门，只是做一些打杂跑腿的工作，有时还会被浇上一头大粪，受到无端的批评、指责、代人受过，组织或个人任其自生自灭，初学者得不到必要的指导和提携，这种情况与蘑菇的生长情景极为相似 。一般在管理机构比较正式的大企业和公司里，这种情况比较多  。相信很多人都有过这样一段“蘑菇”的经历，这不一定是什么坏事，尤其是当一切刚刚开始的时候，当几天“蘑菇”，能够消除我们很多不切实际的幻想，让我们更加接近现实，看问题也更加实际.</p>
<p><img src="/images/it_manager_rule36.jpg" alt="UML图"></p>
<h2 id="异性效应"><a href="#异性效应" class="headerlink" title="异性效应"></a>异性效应</h2><p>中文名 异性效应<br>意义 自愿为了事业进步、丰富生活<br>范围 三情（友情、爱情、亲情）<br>本质 心理现象</p>
<p>一句话理解：男女搭配干活不累</p>
<p>在个体间关系中，异性接触会产生一种特殊的相互吸引力和激发力，并能从中体验到难以言传的感情追求，对动物的活动和学习通常起积极的影响，这种现象称为异性效应，也叫“磁铁效应”，即“同性相斥，异性相吸”，俗话说：“男女搭配，干活不累”正是如此。</p>
<p><img src="/images/it_manager_rule35.jpg" alt="UML图"></p>
<h2 id="懒蚂蚁效应"><a href="#懒蚂蚁效应" class="headerlink" title="懒蚂蚁效应"></a>懒蚂蚁效应</h2><p>中文名 懒蚂蚁效应<br>外文名 Lazy ant effect<br>适用领域 企业管理 市场研究<br>特征 能够为集体寻找一些重要线索</p>
<p>懒蚂蚁效应是日本北海道大学进化生物研究小组对三个分别由30只蚂蚁组成的黑蚁群的活动观察。结果发现。大部分蚂蚁都很勤快地寻找、搬运食物、少数蚂蚁却整日无所事事、东张西望，人们把这少数蚂蚁叫做“懒蚂蚁”。 有趣的是，当生物学家在这些“懒蚂蚁”身上做上标记，并且断绝蚁群的食物来源时，那些平时工作很勤快的蚂蚁表现得一筹莫展，而“懒蚂蚁”们则“挺身而出”，带领众蚂蚁向它们早已侦察到的新的食物源转移。原来“懒蚂蚁”们把大部分时间都花在了“侦察”和“研究”上了。它们能观察到组织的薄弱之处，同时保持对新的食物的探索状态，从而保证群体不断得到新的食物来源。在蚁群和企业中，“懒蚂蚁”很重要，此现象被称为“懒蚂蚁效应”。</p>
<p><img src="/images/it_manager_rule34.jpg" alt="UML图"></p>
<h2 id="顾客细分"><a href="#顾客细分" class="headerlink" title="顾客细分"></a>顾客细分</h2><p>中文名 顾客细分<br>提    出美国学者温德尔·史密斯<br>提出时间 20世纪50年代中期<br>理论依据 顾客特征与顾客反映</p>
<p>顾客（客户）细分是20世纪50年代中期由美国学者温德尔·史密斯提出的一种将顾客分类的方法，其理论依据主要有两点：顾客特征与顾客反映。</p>
<p><img src="/images/it_manager_rule48.png" alt="UML图"></p>
<h2 id="营销漏斗模型"><a href="#营销漏斗模型" class="headerlink" title="营销漏斗模型"></a>营销漏斗模型</h2><p>中文名 营销漏斗模型<br>全    称搜索营销效果转化漏斗<br>作    用 反映客户数量及流失<br>关键要素 营销的环节，相邻环节的转化率</p>
<p>全称为”搜索营销效果转化漏斗”，漏斗的五层对应了企业搜索营销的各个环节，反映了从展现、点击、访问、咨询，直到生成订单过程中的客户数量及流失。从最大的展现量到最小的订单量，这个一层层缩小的过程表示不断有客户因为各种原因离开，对企业失去兴趣或放弃购买。</p>
<p><img src="/images/it_manager_rule53.jpg" alt="UML图"></p>
<h2 id="产品定位五步法"><a href="#产品定位五步法" class="headerlink" title="产品定位五步法"></a>产品定位五步法</h2><p>产品定位是指确定公司或产品在顾客或消费者心目中的形象和地位．这个形象和地位应该是与众不同的。但是，对于如何定位，部分人士认为，定位是给产品定位。营销研究与竞争实践表明，仅有产品定位已经不够了，必须从产品定位扩展至营销定位。<br>相关文章：<a href="http://wiki.mbalib.com/wiki/%E4%BA%A7%E5%93%81%E5%AE%9A%E4%BD%8D%E4%BA%94%E6%AD%A5%E6%B3%95" target="_blank" rel="external">产品定位五步法</a></p>
<p><img src="/images/it_manager_rule54.jpg" alt="UML图"></p>
<hr>
<h1 id="创业管理"><a href="#创业管理" class="headerlink" title="创业管理"></a>创业管理</h1><hr>
<h2 id="29岁现象"><a href="#29岁现象" class="headerlink" title="29岁现象"></a>29岁现象</h2><p>年龄将届30岁，却发现尚未成家立业，相较于周围的成功者，很多年轻人心态失衡、焦虑，一改过去勤恳、踏实的本色，变得情绪波动大，对亲友不耐烦；工作浮躁，急功近利；看书学习注意力不集中，对外界事物兴趣忽高忽低……这就是29岁现象。它更多的是受“三十而立”的传统观念影响，其实大可不必。</p>
<h2 id="35岁现象-35岁危机"><a href="#35岁现象-35岁危机" class="headerlink" title="35岁现象/35岁危机"></a>35岁现象/35岁危机</h2><p>“35岁现象”是指很多企业也将进人的门槛限定在35岁，35岁俨然成为职场“生死线”。</p>
<p><a href="https://mp.weixin.qq.com/s/0HxW2IX4dC48d1pYr1Ik3g" target="_blank" rel="external">职场35岁现象，HR不会告诉你的真相</a><br><a href="https://mp.weixin.qq.com/s/MgiC4V1OeLAXEFTEISqm0Q" target="_blank" rel="external">职场“35岁危机”：这是我看过的最棒建议|职场</a></p>
<h2 id="44岁现象"><a href="#44岁现象" class="headerlink" title="44岁现象"></a>44岁现象</h2><p>44岁现象，是指男人步入中年后出现的一系列心理危机现象。由于生理上的变化，使44岁中年男人在心理、思维和工作等方面都会发生显著变化。大多数44岁男人都会有精神上的孤独和压抑。</p>
<h2 id="20-40-60法则"><a href="#20-40-60法则" class="headerlink" title="20-40-60法则"></a>20-40-60法则</h2><p>没有人像你一样关注你<br><a href="http://news.xinhuanet.com/mrdx/2015-08/14/c_134516112.htm" target="_blank" rel="external">http://news.xinhuanet.com/mrdx/2015-08/14/c_134516112.htm</a></p>
<h2 id="ABZ规划"><a href="#ABZ规划" class="headerlink" title="ABZ规划"></a>ABZ规划</h2><p>有一种计划叫ABZ理论，据说实践过后都成了有钱银！</p>
<p>linkedln和paypal的联合创始人Reid Hoffman有一个非常著名的ABZ理论，他认为，你在任何时刻，都要有三个计划，abz计划。</p>
<p>A主业（当前的工作）<br>B副业（预留的职业，当A计划无法执行时，可以顺利的切换B计划）<br>Z（B到A这个过程需要的投资，或者是最稳妥的退路。）</p>
<p>简单理解<br>a是你目前能够长期从事下去的工作，值得你持续投入，并可以获得安全感，并且这份工作，你个人还很满意。<br>b是除去a计划外，你给自己的一些培训机会，或者兴趣爱好，你只坚持a，可能未来某天会被其他人或者机器替代，b，是除了a之外的，你愿意长期投入精力的一项属于自己的“小事业”，未来某天，机会合适，你也完全可以把b变为a。<br>z，是你的安全牌，假设有一天你的ab计划全部落空失败，你的z计划，可以保证你在未来某一段时间内，可以继续保持现有的生活品质。我的理解就是一定金额的储蓄存款。</p>
<p>尤其是马云的英语，成就了今天的马云，哦不，是绝对帮助了今天的马云，这个观点特别赞同，如果你特别能喝酒，这也可能会成为未来的一项优势，技多不压身嘛！</p>
<h2 id="收入四象限"><a href="#收入四象限" class="headerlink" title="收入四象限"></a>收入四象限</h2><p><img src="/images/it_manager_rule11.png" alt="UML图"><br>相关文章：<a href="http://www.finnciti.cc/2659.html" target="_blank" rel="external">四个收入象限让你决定人生该往哪个方向走</a></p>
<h2 id="养猪理论"><a href="#养猪理论" class="headerlink" title="养猪理论"></a>养猪理论</h2><p>领域 创业管理<br>提出者 单祥双</p>
<p>在创业管理中有一个“养猪理论”，是说猪越肥代表价格越高，劝人在职场上把自己也要当猪来养，不断学习，增加自己的附加值，以此才能在职场上为自己卖到好价钱。</p>
<hr>
<h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><hr>
<h2 id="WBS工作分解结构"><a href="#WBS工作分解结构" class="headerlink" title="WBS工作分解结构"></a>WBS工作分解结构</h2><p><img src="/images/it_manager_rule56.jpg" alt="UML图"><br>中文名工作分解结构<br>外文名 WBS<br>全称 Work Breakdown Structure<br>属性项目管理<br>构成 三个关键元素</p>
<p>创建WBS是把项目 交付成果和项目工作分解成较小的，更易于管理的组成部分的过程。</p>
<hr>
<h1 id="营销管理"><a href="#营销管理" class="headerlink" title="营销管理"></a>营销管理</h1><hr>
<h2 id="4P理论"><a href="#4P理论" class="headerlink" title="4P理论"></a>4P理论</h2><p>类    别 一种营销理论<br>提出人杰瑞·麦卡锡教授</p>
<p>4p理论是一种营销理论即；Product、Price、Place、Promotion。取其开头字母，意思为产品，价格，渠道，宣传。<br>杰瑞·麦卡锡（Jerry McCarthy）教授在其《营销学》（Marketing，第一版，出版于1960年左右）最早提出了这个理论。</p>
<h2 id="空雨伞"><a href="#空雨伞" class="headerlink" title="空雨伞"></a>空雨伞</h2><p><a href="https://www.digitaling.com/articles/22929.html" target="_blank" rel="external">一把「空雨伞」秘密武器，让你的文字更精彩！</a><br><a href="https://www.digitaling.com/articles/22929.html" target="_blank" rel="external">揭秘百万销冠工作笔记—空雨伞黄金三分法，三分钟学会受用一生 
</a></p>
<h2 id="FAB法则-和-FABE销售法"><a href="#FAB法则-和-FABE销售法" class="headerlink" title="FAB法则 和 FABE销售法"></a>FAB法则 和 FABE销售法</h2><p>中文名 FABE销售法<br>F代表 特征(Features)<br>A代表 优点(Advantages)<br>B代表 利益(Benefits)<br>E代表 证据(Evidence)</p>
<p>FABE模式是由美国奥克拉荷大学企业管理博士、台湾中兴大学商学院院长郭昆漠总结出来的。FABE推销法是非常典型的利益推销法，而且是非常具体、具有高度、可操作性很强的利益推销法。它通过四个关键环节，极为巧妙地处理好了顾客关心的问题，从而顺利地实现产品的销售。</p>
<p>FABE模式起源于FAB法则<br>即属性，作用，益处的法则，FAB对应的是三个英文单词：Feature、Advantage和Benefit，按照这样的顺序来介绍，就是说服性演讲的结构，它达到的效果就是让客户相信你的是最好的。</p>
<p>FAB法则也体现写简历上<br>首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。<br>Feature：是什么<br>Advantage：比别人好在哪些地方<br>Benefit：如果雇佣你，招聘方会得到什么好处</p>
<h2 id="AIDMA"><a href="#AIDMA" class="headerlink" title="AIDMA"></a>AIDMA</h2><p>中文名 AIDMA<br>分类 广告 </p>
<p>定义 心理学 消费者行为学<br>AIDMA是消费者行为学领域很成熟的理论模型之一，由美国广告学家E.S.刘易斯在1898年提出。该理论认为，消费者从接触到信息到最后达成购买，会经历这5个阶段：</p>
<p>A：Attention（引起注意）——花哨的名片、提包上绣着广告词等被经常采用的引起注意的方法</p>
<p>I:Interest （引起兴趣）——一般使用的方法是精制的彩色目录、有关商品的新闻简报加以剪贴。</p>
<p>D:Desire（唤起欲望）——推销茶叶的要随时准备茶具，给顾客沏上一杯香气扑鼻的浓茶，顾客一品茶香体会茶的美味，就会产生购买欲。推销房子的，要带顾客参观房子。餐馆的入口处要陈列色香味具全的精制样品，让顾客倍感商品的魅力，就能唤起他的购买欲。</p>
<p>M:Memory（留下记忆）—— 一位成功的推销员说：“每次我在宣传自己公司的产品时，总是拿着别公司的产品目录，一一加以详细说明比较。因为如果总是说自己的产品有多好多好，顾客对你不相信。反而想多了解一下其他公司的产品，而如果你先提出其他公司的产品，顾客反而会认定你自己的产品。”</p>
<p>A:Action（购买行动）——从引起注意到付诸购买的整个销售过程，推销员必须始终信心十足。过分自信也会引起顾客的反感，以为你在说大话、吹牛皮。从而不信任你的话。</p>
<hr>
<h1 id="思考策略"><a href="#思考策略" class="headerlink" title="思考策略"></a>思考策略</h1><hr>
<h2 id="MECE分析法"><a href="#MECE分析法" class="headerlink" title="MECE分析法"></a>MECE分析法</h2><p><img src="/images/it_manager_rule28.jpg" alt="UML图"><br><img src="/images/it_manager_rule29.jpg" alt="UML图"><br>MECE 原则：取自“Mutually Exclusive Collectively Exhaustive”，意为“相互独立，完全穷尽”。<br>类似剥洋葱，从一个最高层的问题开始，逐层向下进行分解，形成系统化的思维模式。（把复杂问题，拆分成小的容易解决的子问题） </p>
<h2 id="六顶思考帽"><a href="#六顶思考帽" class="headerlink" title="六顶思考帽"></a>六顶思考帽</h2><p><img src="/images/it_manager_rule55.jpg" alt="UML图"><br>中文名 六顶思考帽<br>国    家英国<br>开    发 爱德华·德·博诺<br>性    质 思维训练模式</p>
<p>六顶思考帽是英国学者爱德华·德·博诺（Edward de Bono）博士开发的一种思维训练模式，或者说是一个全面思考问题的模型。它提供了“平行思维”的工具，避免将时间浪费在互相争执上。强调的是“能够成为什么”，而非 “本身是什么”，是寻求一条向前发展的路，而不是争论谁对谁错。运用德博诺的六顶思考帽，将会使混乱的思考变得更清晰，使团体中无意义的争论变成集思广益的创造，使每个人变得富有创造性。</p>
<p>所谓六顶思考帽，是指使用六种不同颜色的帽子代表六种不同的思维模式。任何人都有能力使用以下六种基本思维模式：</p>
<p>白色思考帽<br>白色是中立而客观的。戴上白色思考帽，人们思考的是关注客观的事实和数据。</p>
<p>绿色思考帽<br>绿色代表茵茵芳草，象征勃勃生机。绿色思考帽寓意创造力和想象力。它具有创造性思考、头脑风暴、求异思维等功能。</p>
<p>黄色思考帽<br>黄色代表价值与肯定。戴上黄色思考帽，人们从正面考虑问题，表达乐观的、满怀希望的、建设性的观点。</p>
<p>黑色思考帽<br>戴上黑色思考帽，人们可以运用否定、怀疑、质疑的看法，合乎逻辑的进行批判，尽情发表负面的意见，找出逻辑上的错误。</p>
<p>红色思考帽<br>红色是情感的色彩。戴上红色思考帽，人们可以表现自己的情绪，人们还可以表达直觉、感受、预感等方面的看法。</p>
<p>蓝色思考帽<br>蓝色思考帽负责控制和调节思维过程。它负责控制各种思考帽的使用顺序，它规划和管理整个思考过程，并负责做出结论。</p>
<p>作用:<br>六顶思考帽是平行思维工具，是创新思维工具，也是人际沟通的操作框架，更是提高团队智商的有效方法 。<br>六顶思考帽是一个操作简单、经过反复验证的思维工具，它给人以热情，勇气和创造力，让每一次会议，每一次讨论，每一份报告，每一个决策都充满新意和生命力。这个工具能够帮助人们：<br>●提出建设性的观点；<br>●聆听别人的观点；<br>●从不同角度思考同一个问题，从而创造高效能的解决方案。<br>●用“平行思维“取代批判式思维和垂直思维。<br>●提高团队成员的集思广益能力，为统合综效提供操作工具。</p>
<p>应用步骤:<br>用“六顶思考帽”来考虑我们工作中存在的问题，也会起到意外的效果。<br>运用“白色思考帽”来思考、搜集各环节的信息，收取各个部门存在的问题，找到基础数据。<br>戴上“绿色思考帽”，用创新的思维来考虑这些问题，不是一个人思考，而是各层次管理人员都用创新的思维去思考，大家提出各自解决问题的办法、好的建议、好的措施。也许这些方法不对、甚至无法实施。但是，运用创新的思考方式就是要跳出一般的思考模式。<br>接着，分别戴上“黄色思考帽”和“黑色思考帽”，对所有的想法从“光明面”和“良性面”进行逐个分析，对每一种想法的危险性和隐患进行分析，找出最佳切合点。“黄色思考帽”和“黑色思考帽”这两种思考方法，就好像是孟子的性善论和性恶论，都能进行否决或都进行肯定。<br>到了这个时候，再戴上“红色思考帽”，从经验、直觉上，对已经过滤的问题进行分析、筛选，做出决定。<br>在思考的过程中，还应随时运用“蓝色思考帽”，对思考的顺序进行调整和控制，甚至有时还要刹车。因为，观点可能是正确的，也可能会进入死胡同。所以，在整个思考过程中，应随时调换思考帽，进行不同角度的分析和讨论。</p>
<h2 id="头脑风暴法-智力激励法-BS法"><a href="#头脑风暴法-智力激励法-BS法" class="headerlink" title="头脑风暴法/智力激励法/BS法"></a>头脑风暴法/智力激励法/BS法</h2><p>中文名 头脑风暴法<br>外文名 Brainstorming<br>属    性 一种集体研讨行为<br>最    早精神病理学上的用语</p>
<p>（Brain Storming——BS）：一种通过集思广益、发挥团体智慧，从各种不同角度找出问题所有原因或构成要素的会议方法。BS有四大原则：严禁批评、自由奔放、多多益善、搭便车。</p>
<p>头脑风暴法出自”头脑风暴”一词。所谓头脑风暴是最早是精神病理学上的用语，指精神病患者的精神错乱状态而言的，如今转而为无限制的自由联想和讨论，其目的在于产生新观念或激发创新设想。<br>在群体决策中，由于群体成员心理相互作用影响，易屈于权威或大多数人意见，形成所谓的“群体思维”。群体思维削弱了群体的批判精神和创造力，损害了决策的质量。为了保证群体决策的创造性，提高决策质量，管理上发展了一系列改善群体决策的方法，头脑风暴法是较为典型的一个。</p>
<p><img src="/images/it_manager_rule38.jpg" alt="UML图"></p>
<h2 id="鱼骨分析法"><a href="#鱼骨分析法" class="headerlink" title="鱼骨分析法"></a>鱼骨分析法</h2><p>中文名 鱼骨分析法<br>外文名 Fishbone analysis method<br>别    名因果分析法<br>含    义 发现问题“根本原因”的分析方法<br>应    用 现代工商管理教育</p>
<p>鱼骨分析法，又名因果分析法，是一种发现问题“根本原因”的分析方法，现代工商管理教育如MBA、EMBA等将其划分为问题型、原因型及对策型鱼骨分析等几类先进技术分析。</p>
<p>问题的特性总是受到一些因素的影响，通过头脑风暴找出这些因素，并将它们与特性值一起，按相互关联性整理而成的层次分明、条理清楚，因其形状如鱼骨，所以叫鱼骨图。<br>鱼骨图(Fishbone analysis method)是由日本管理大师石川馨先生所发展出来的，故又名石川图。鱼骨图是一种发现问题“根本原因”的方法，它也可以称之为“因果图”。鱼骨图主要用于工商管理中建立分析模型。<br><img src="/images/it_manager_rule13.png" alt="UML图"></p>
<h2 id="SWOT分析模型"><a href="#SWOT分析模型" class="headerlink" title="SWOT分析模型"></a>SWOT分析模型</h2><p>中文名 SWOT分析模型<br>外文名 SWOT<br>内容 优势、劣势、机会、威胁<br>应用领域 企业战略规划</p>
<p>SWOT分析模型，又称为态势分析法，EMBA及MBA等主流商管教育均将SWOT分析法作为一种常用的战略规划工具包含在内。</p>
<h2 id="5why分析法"><a href="#5why分析法" class="headerlink" title="5why分析法"></a>5why分析法</h2><p>中文名 5why分析法<br>别称 5问法<br>提出者 丰田佐吉</p>
<p>所谓5why分析法，又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。虽为5个为什么，但使用时不限定只做“5次为什么的探讨”，主要是必须找到根本原因为止，有时可能只要3次，有时也许要10次，如古话所言：打破砂锅问到底。5why法的关键所在：鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。<br><img src="/images/it_manager_rule14.png" alt="UML图"></p>
<h2 id="5W1H分析法"><a href="#5W1H分析法" class="headerlink" title="5W1H分析法"></a>5W1H分析法</h2><p>5W1H（WWWWWH）分析法也叫六何分析法，是一种思考方法，也可以说是一种创造技法。在企业管理、日常工作生活和学习中得到广泛的应用。</p>
<p>5W+1H：是对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等六个方面提出问题进行思考。<br>1、对象 （What）——什么事情<br>公司生产什么产品？车间生产什么零配件？为什么要生产这<br>5W1H分析法思路<br>5W1H分析法思路<br>个产品？能不能生产别的？我到底应该生产什么？例如:如果这个产品不挣钱，换个利润高点的好不好？<br>2、场所 （Where）——什么地点<br>生产是在哪里干的？为什么偏偏要在这个地方干？换个地方行不行？到底应该在什么地方干？这是选择工作场所应该考虑的。<br>3、时间和程序 （When）——什么时候<br>例如这个工序或者零部件是在什么时候干的？为什么要在这个时候干？能不能在其他时候干？把后工序提到前面行不行？到底应该在什么时间干？<br>4、人员 （Who）——责任人<br>这个事情是谁在干？为什么要让他干？如果他既不负责任，脾气又很大，是不是可以换个人？有时候换一个人，整个生产就有起色了。<br>5、为什么（Why）——原因<br>为什么采用这个技术参数？为什么不能有变动？为什么不能使用？为什么变成红色？为什么要做成这个形状？为什么采用机器代替人力？为什么非做不可？<br>6、方式 （How）——如何<br>手段也就是工艺方法，例如，我们是怎样干的？为什么用这种方法来干？有没有别的方法可以干？到底应该怎么干？有时候方法一改，全局就会改变。<br><img src="/images/it_manager_rule15.png" alt="UML图"></p>
<h2 id="5W2H分析法"><a href="#5W2H分析法" class="headerlink" title="5W2H分析法"></a>5W2H分析法</h2><p>中文名 5W2H分析法<br>别    称 七何分析法<br>表达式 WHAT+WHY+WHEN+WHERE+WHO+HOW+HOW MUCH<br>提出者 美国陆军兵器修理部</p>
<p>5W2H分析法又叫七何分析法，是二战中美国陆军兵器修理部首创。简单、方便，易于理解、使用，富有启发意义，广泛用于企业管理和技术活动，对于决策和执行性的活动措施也非常有帮助，也有助于弥补考虑问题的疏漏。</p>
<p>发明者用五个以W开头的英语单词和两个以H开头的英语单词进行设问，发现解决问题的线索，寻找发明<br>5W2H分析法<br>思路，进行设计构思，从而搞出新的发明项目，这就叫做5W2H法。<br>（1） WHAT——是什么？目的是什么？做什么工作？<br>（2）WHY——为什么要做？可不可以不做？有没有替代方案？<br>（3）WHO——谁？由谁来做？<br>（4）WHEN——何时？什么时间做？什么时机最适宜？<br>（5） WHERE——何处？在哪里做？<br>（6）HOW ——怎么做？如何提高效率？如何实施？方法是什么？<br>（7） HOW MUCH——多少？做到什么程度？数量如何？质量水平如何？费用产出如何？<br><img src="/images/it_manager_rule16.png" alt="UML图"></p>
<h2 id="九宫图分析法"><a href="#九宫图分析法" class="headerlink" title="九宫图分析法"></a>九宫图分析法</h2><p>中文名 九宫图分析法<br>利用 九宫格图<br>作用 扩散性思维<br>类型 思考策略<br>曼陀罗法 将主题写在中央<br>莲花法 曼陀罗法的基本单位</p>
<p>九宫图法 是一种有助扩散性思维的思考策略，利用一幅像九宫格图，将主题写在中央，然后把由主题所引发的各种想法或联想写在其余优点乃由事物之核心出发，向八个方向去思考，发挥八种不同的创见。依循此思维方式加以发挥并扩散其思考范围。<br><img src="/images/it_manager_rule17.png" alt="UML图"></p>
<h2 id="PEST分析法"><a href="#PEST分析法" class="headerlink" title="PEST分析法"></a>PEST分析法</h2><p>中文名 PEST分析法<br>外文名 PEST<br>内    容 政治、经济、社会、技术<br>应    用 战略分析</p>
<p>PEST分析是指宏观环境的分析，P是政治(politics)，E是经济(economy)，S是社会(society)，T是技术(technology)。<br>在分析一个企业集团所处的背景的时候，通常是通过这四个因素来进行分析企业集团所面临的状况。<br><img src="/images/it_manager_rule18.png" alt="UML图"></p>
<h2 id="杜邦分析法"><a href="#杜邦分析法" class="headerlink" title="杜邦分析法"></a>杜邦分析法</h2><p>中文名 杜邦分析法<br>外文名 DuPont Analysis<br>相关公司 美国杜邦公司<br>作    用 综合地分析企业的财务状况</p>
<p>杜邦分析法（DuPont Analysis）是利用几种主要的财务比率之间的关系来综合地分析企业的财务状况。具体来说，它是一种用来评价公司赢利能力和股东权益回报水平，从财务角度评价企业绩效的一种经典方法。其基本思想是将企业净资产收益率逐级分解为多项财务比率乘积，这样有助于深入分析比较企业经营业绩。由于这种分析方法最早由美国杜邦公司使用，故名杜邦分析法。</p>
<hr>
<h1 id="决策管理"><a href="#决策管理" class="headerlink" title="决策管理"></a>决策管理</h1><hr>
<h2 id="决策瘫痪"><a href="#决策瘫痪" class="headerlink" title="决策瘫痪"></a>决策瘫痪</h2><p>微博之类的“碎片化信息”正在彻底改变我们的生活。但是，意想不到的结果是，在必须做出决定时，我们超载的大脑在“信息洪流”的冲击下已经变得麻木， 面临大脑决策的瘫痪。</p>
<p>减少信息<br>那么，你怎样不受过多信息的影响，而做出自己的决定呢？专家建议，不要总是去处理大量的电邮和文本，这样就会打开你无意识的决策系统。为了避免思维陷阱，你最好系统地评估大量复杂信息后再做决策；如果你从信息洪流中抽出身来，让自己的无意识取而代之，你就会做得更好。<br>生活中不难发现，那些被称为“知足者”的人在换频道时，发现一个可以接受的节目就会停下来；而那些“贪多者”则从来都会不停地搜索换台，所以要他们做出一个决定会相当艰难。如果你认为自己是个“贪多者”，那么，最好的办法可能就是——关掉你智能手机上过多的功能。</p>
<h2 id="正反面决策法"><a href="#正反面决策法" class="headerlink" title="正反面决策法"></a>正反面决策法</h2><p>富兰克林发明了正反面决策法，他指出，在面对多种选择时，只要列出每种选择方案的正面影响（Pros）和负面影响（Cons），最佳答案自然会浮出水面。</p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>所谓决策树，其实是一种通过图像方式来呈现各种解决方案的方法。通过决策树，你可以看到各种解决方案将会带来什么最终结果。</p>
<p>打个比方，想象你是一家公司的总经理，你想要聘请一位很给力的销售主管，但又担心此人可能是个骗子。你就可能绘制出下面的决策树<br><img src="/images/it_manager_rule56.jpg" alt="UML图"></p>
<h2 id="可能指数和渴望指数"><a href="#可能指数和渴望指数" class="headerlink" title="可能指数和渴望指数"></a>可能指数和渴望指数</h2><p>除了正反面决策外，你还可以用可能指数（Likelihood，表示该结果出现的可能性有多大）和渴望指数（Desirability，表示你对该结果有多么渴望）。</p>
<p>打个比方，你想确定一场慈善晚宴的主题演讲人，此时你只能邀请三个候选对象中的一位。你要邀请哪位呢？</p>
<p>下面的表格列出了三位候选人的吸引力指数（可能指数与渴望指数的乘积）：<br><img src="/images/it_manager_rule57.jpg" alt="UML图"></p>
<h2 id="卡佛矩阵"><a href="#卡佛矩阵" class="headerlink" title="卡佛矩阵"></a>卡佛矩阵</h2><p>卡佛矩阵源自美国军方，现在也可以用来解决日常工作和生活问题，帮助你从几个可能的选择中确认最佳答案。具体来讲，在面临多种选择时，你可以问自己以下几个问题：</p>
<p>关键度：这个目标究竟有多重要？</p>
<p>实现度：实现这个目标究竟有多容易？</p>
<p>确认度：实现该目标所需要的信息是否容易获取？是否容易判断自己是否实现了该目标？</p>
<p>脆弱度：该目标是否过于简单？你为实现该目标所投入的精力越少，它通常就越脆弱。</p>
<p>影响：实现该目标会在多大程度上影响你的生活？</p>
<p>可恢复性：如果没有实现该目标，你为此所白白失去的时间和精力有多少？</p>
<p>举个例子，理查德目标正面临事业上的十字路口，他有三个选择：提前退休、还家公司或者接替上司的职位。他画出的卡佛矩阵如下：<br><img src="/images/it_manager_rule59.jpg" alt="UML图"><br>根据该矩阵，“接替上司”应该是他目前最理想的选择。</p>
<hr>
<h1 id="生活管理"><a href="#生活管理" class="headerlink" title="生活管理"></a>生活管理</h1><hr>
<h2 id="断舍离"><a href="#断舍离" class="headerlink" title="断舍离"></a>断舍离</h2><p>断舍离”是由日本杂物管理咨询师山下英子提出的人生整理观念。<br>也是现在非常流行的现代家居整理方法。</p>
<p>断=对于那些自己不需要的东西不买、不收； 　　<br>舍=处理掉堆放在家里没用的东西； 　　<br>离=远离物质的诱惑，放弃对物品的执著，让自己处于宽敞舒适，自由自在的空间。</p>
<h2 id="奥卡姆剃刀原理"><a href="#奥卡姆剃刀原理" class="headerlink" title="奥卡姆剃刀原理"></a>奥卡姆剃刀原理</h2><p>企业管理<br>奥卡姆剃刀不断在哲学、科学等领域得到应用，使它进一步发扬光大，并广为世人所知的，则是在近代的企业管理学中。好的理论应当是简单、清晰、重点突出，企业管理理论亦不例外。在管理企业制定决策时，应该尽量把复杂的事情简单化，剔除干扰，抓住主要矛盾，解决最根本的问题，才能让企业保持正确的方向。对于现代企业而言，信息爆炸式的增长，使得主导企业发展的因素盘根错节，做到化复杂为简单就更加不易。企业管理是系统工程，包括基础管理、组织管理、营销管理、技术管理、生产管理、企业战略，奥卡姆剃刀所倡导的简单化管理，并不是把众多相关因素粗暴地剔除，而是要穿过复杂，才能走向简单。通过奥卡姆剃刀将企业最关键的脉络明晰化、简单化，加强核心竞争力。</p>
<p>策略投资<br>投资需要策略，在投资市场，太保守不行，太冒险也不行。投资市场是复杂的，不少投资者整天在忙忙碌碌地分析、研究和频繁操作，投入了大量精力，却依然难以应付市场中庞杂的信息。 面对复杂当投资市场，应拿起奥卡姆剃刀，把复杂事情简单化，简化自己的投资策略，对那些消耗了大量金钱、时间、精力的事情加以区分，然后釆取步骤去摆脱它们。</p>
<p>生活理念<br>作为一种思维理念，当然并不仅仅局限于某一些领域，事实上，奥卡姆剃刀在社会各方面已得到越来越多的应用。 奥卡姆剃刀同时也是一种生活理念。这个原理要求我们在处理事情时，要把握事情的本质，解决最根本的问题。尤其要顺应自然，不要把事情人为地复杂化，这样才 能把事情处理好。 爱因斯坦说：“如果你不能改变旧有的思维方式，你也就不能改变自己当前的生活状况。”当你用奥卡姆剃刀改变你的思维时，你的生活将会发生改变。 在运用奥卡姆剃刀时应牢记爱因斯坦的一句著名的格言：万事万物应该都应尽可能简洁，不能过于简单。如果将这一理念与中国儒家的《中庸》思想结合起来，那么会使我们的行为更趋于完美。</p>
<hr>
<h1 id="人际关系管理"><a href="#人际关系管理" class="headerlink" title="人际关系管理"></a>人际关系管理</h1><hr>
<h2 id="1-25裂变定律"><a href="#1-25裂变定律" class="headerlink" title="1:25裂变定律"></a>1:25裂变定律</h2><p>1比25裂变定律，即你如果认识一个人，那么通过他，你就有可能再认识25个人。这套著名的理论由美国社会学家博恩·思希提出，曾被西方商业界广泛采用。<br>一个资源的无限裂变<br>适用于人际交往</p>
<p>西方商业界：<br>1比25裂变定律 曾被西方商业界广泛采用。他们在营销过程中，推行微笑服务，让服务人员不要得罪任何一名顾客，因为在一位顾客的背后，潜藏着25个客户。<br>成功学领域：<br>1比25裂变定律理论又被引入到成功学领域。更有人推波助澜，打出这样的公式：成功=20%的知识+80%的人脉。把人脉当成了事业成功的黄金定律。<br>拓展黄金人脉：<br>十年前，这一理论传入中国。有一阵子，甚至出现这样一种现象：一些私营企业的老总为了拓展黄金人脉，花高价或通过巨额赞助的方式，把子女送到北大和清华，让他们插班学习，自己也通过某种方式，到中央党校进修。他们学习也能学到一点东西，但更重要的，是认识了很多人，很多重量级的人。扩大社交圈，拓展黄金人脉，成为他们的潜在目的。</p>
<p>评价：<br>无论你的产业有多大，人脉有多广，你一生所面对的，说到底就是身边的那几个人。<br>相互琢磨和提防的，也就是你身边的那几个人。而真正给你爱和你真正能爱的，也就是那几个人。<br>——这也许是博恩·思希想说而没有说的。<br>你周围的亲人，从小认识的那几个朋友，以及身处的小环境，也许就是你最具有价值的人脉。</p>
<p><img src="/images/it_manager_rule33.jpg" alt="UML图"></p>
<h2 id="互惠关系定律"><a href="#互惠关系定律" class="headerlink" title="互惠关系定律"></a>互惠关系定律</h2><p>给予就会被给予，剥夺就会被剥夺。<br>信任就会被信任，怀疑就会被怀疑。<br>爱就会被爱，恨就会被恨。<br>这就是心理学上的互惠关系定律。<br>人是三分理智、七分感情的动物。<br>士为知己者死，从业者可以为认可自己存在价值的上司鞠躬尽瘁。<br>当你真诚地帮助员工的时候，员工才能真正地帮助你！</p>
<h2 id="南风法则"><a href="#南风法则" class="headerlink" title="南风法则"></a>南风法则</h2><p>南风法则（South Wind Law）也叫做“温暖”法则，它来源于法国作家拉·封丹写的这则寓言。它告诉我们：温暖胜于严寒。运用到管理实践中，南风法则要求管理者要尊重和关心下属，时刻以下属为本，多点“人情味”，多注意解决下属日常生活中的实际困难，使下属真正感受到管理者给予的温暖。这样，下属出于感激就会更加努力积极地为企业工作，维护企业利益。</p>
<h2 id="第十名效应"><a href="#第十名效应" class="headerlink" title="第十名效应"></a>第十名效应</h2><p>中游最有出息定律</p>
<h2 id="出丑效应"><a href="#出丑效应" class="headerlink" title="出丑效应"></a>出丑效应</h2><p>外文名 The pratfall effect<br>别名 仰巴脚效应<br>提出者 艾略特·阿伦森<br>含义精明的人无意中犯点小错误</p>
<p>出丑效应又叫仰巴脚效应，犯错误效应(PRATFALLEFFECT)：是指才能平庸者固然不会受人倾慕，而全然无缺点的人，也未必讨人喜欢。最讨人喜欢的人物是精明而带有小缺点的人，此种现象亦称为仰巴脚效应。</p>
<hr>
<h1 id="沟通谈判管理"><a href="#沟通谈判管理" class="headerlink" title="沟通谈判管理"></a>沟通谈判管理</h1><hr>
<h2 id="乔哈里视窗"><a href="#乔哈里视窗" class="headerlink" title="乔哈里视窗"></a>乔哈里视窗</h2><p>所谓的乔哈里视窗（Johari Window）是一种关于沟通的技巧和理论，也被称为“自我意识的发现——反馈模型”，中国管理学实务中通常称之为沟通视窗。这个理论最初是由乔瑟夫（Joseph）和哈里（Harry）在20世纪50年代提出的。视窗理论将人际沟通的信息比作一个窗子，它被分为4个区域：开放区、隐秘区、盲目区、未知区，人的有效沟通就是这四个区域的有机融合。</p>
<p>中文名 乔哈里视窗<br>外文名 Johari window<br>别名 沟通视窗<br>范畴 心理学，管理学<br>组成 开放区，隐秘区，盲目区，未知区<br>创建时间 20世纪50年代</p>
<h2 id="麦肯锡30秒电梯理论"><a href="#麦肯锡30秒电梯理论" class="headerlink" title="麦肯锡30秒电梯理论"></a>麦肯锡30秒电梯理论</h2><p><img src="/images/it_manager_rule30.jpg" alt="UML图"><br><img src="/images/it_manager_rule31.jpg" alt="UML图"><br>这是一种电梯法则.<br>不要妄想所有人都有时间和耐心，在 30 秒内清晰而准确地解释清楚你的解决方案，是加分项。要诀：一要出语惊人，二要短小精悍，三要提炼要点。 </p>
<p>麦肯锡公司曾经得到过一次沉痛的教训：该公司曾经为一家重要的客户做咨询。咨询结束的时候，麦肯锡的项目负责人在电梯间里遇见了对方的董事长，该董事长问麦肯锡的项目负责人：“你能不能说一下现在的结果呢？”由于该项目负责人没有准备，而且即使有准备也无法在电梯从30层1层运行的30秒钟内把结果说清楚。最终，麦肯锡失去了这一重要的客户。从此，麦肯锡要求公司员工凡事要在最短的时间内把结果表达清楚，凡事要直奔主题、直奔结果。麦肯锡认为，一般情况下人们最多记得住一二三，记不住四五六，所以凡事要归纳在3条以内`。这就是如今在商界流传甚广的“30秒电梯理论”或称“电梯演讲”。</p>
<h2 id="沉锚效应"><a href="#沉锚效应" class="headerlink" title="沉锚效应"></a>沉锚效应</h2><p>又名 锚定效应<br>外文名 Anchoring effect<br>定    位 心理学名词<br>类    型 心理现象</p>
<p>沉锚效应，心理学名词，指的是人们在对某人某事做出判断时，易受第一印象或第一信息支配，就像沉入海底的锚一样把人们的思想固定在某处。作为一种心理现象，沉锚效应普遍存在于生活的方方面面。第一印象和先入为主是其在社会生活中的表现形式。<br>通常来讲，人们在作决策时，思维往往会被得到的第一信息所左右，就像沉入海底的锚一样，把你的思维固定在某处。而用一个限定性的词语或规定作行为导向，达成行为效果的心理效应，被称为“沉锚效应”。</p>
<p>有人为此举的例证是：两家卖粥的小店，每天顾客的数量和粥店的服务质量都差不多，但结算的时候，总是一家粥店的销售额高于另一家。探其究竟，原来效益好的那家粥店的服务员为客人盛好粥后，总问： “加一个鸡蛋还是两个？”而另一家粥店的服务员总问：“加不加鸡蛋？”接收到第一个问题的客人考虑的是加几个鸡蛋的问题，而接收到第二个问题的客人考虑的是加不加鸡蛋的问题。考虑的问题不同，答案自然也不同。通过不同的提问方式，第一家粥店不知不觉地多卖了鸡蛋，增加了销售。<br>相关文章：<br><a href="https://baike.baidu.com/item/%E6%B2%89%E9%94%9A%E6%95%88%E5%BA%94/11010988?fr=aladdin" target="_blank" rel="external">沉锚效应</a></p>
<h2 id="超限效应"><a href="#超限效应" class="headerlink" title="超限效应"></a>超限效应</h2><p>美国著名幽默作家马克?吐温有一次在教堂听牧师演讲。最初，他觉得牧师讲得很好，使人感动，准备捐款。过了10分钟，牧师还没有讲完，他有些不耐烦了，决定只捐一些零钱。又过了10分钟，牧师还没有讲完，于是他决定，1分钱也不捐。到牧师终于结束了冗长的演讲，开始募捐时，马克?吐温由于气愤，不仅未捐钱，还从盘子里偷了2元钱。这种刺激过多、过强和作用时间过久而引起心理极不耐烦或反抗的心理现象，称之为“超限效应”。超限效应在家庭教育中时常发生。如：当孩子不用心而没考好时，父母会一次、两次、三次，甚至四次、五次重复对一件事作同样的批评，使孩子从内疚不安到不耐烦最后反感讨厌。被“逼急”了，就会出现“我偏要这样”的反抗心理和行为。因为孩子一旦受到批评，总需要一段时间才能恢复心理平衡，受到重复批评时，他心里会嘀咕：“怎么老这样对我？”孩子挨批评的心情就无法复归平静，反抗心理就高亢起来。可见，家长对孩子的批评不能超过限度，应对孩子“犯一次错，只批评一次”。如果非要再次批评，那也不应简单地重复，要换个角度，换种说法。这样，孩子才不会觉得同样的错误被“揪住不放”，厌烦心理、逆反心理也会随之减低。</p>
<p>点评：过犹不及的心理学解释：同时也告诉我们，讲课的时候千万不要拖堂……这很容易过学生的底线哦。</p>
<h2 id="登门坎效应-得寸进尺效应"><a href="#登门坎效应-得寸进尺效应" class="headerlink" title="登门坎效应/得寸进尺效应"></a>登门坎效应/得寸进尺效应</h2><p>中文名 登门槛效应<br>外文名 Foot In The Door Effect<br>应用领域 管理应用<br>释义 步步为营，奠定成功之路</p>
<p>登门槛效应（Foot In The Door Effect）又称得寸进尺效应，是指一个人一旦接受了他人的一个微不足道的要求，为了避免认知上的不协调，或想给他人以前后一致的印象，就有可能接受更大的要求。这种现象，犹如登门坎时要一级台阶一级台阶地登，这样能更容易更顺利地登上高处。</p>
<h2 id="留面子效应"><a href="#留面子效应" class="headerlink" title="留面子效应"></a>留面子效应</h2><p>相反 登门槛效应<br>领域 心理学</p>
<p>与登门槛效应相反，留面子效应是指人们拒绝了一个较大的要求后，对较小要求接受的可能性增加的现象。<br>为了更好地使人接受要求，提高人的接受可能性的最好办法，就是先提出一个较大的要求，这种方法被称为“留面子技术”。</p>
<h2 id="拆屋效应"><a href="#拆屋效应" class="headerlink" title="拆屋效应"></a>拆屋效应</h2><p>提出者鲁迅<br>来源 《无声的中国》<br>时间 1927年</p>
<p>鲁迅先生曾于1927 年发表了一篇名为《无声的中国》的演讲中写道：“中国人的性情总是喜欢调和、折中的，譬如你说，这屋子太暗，说在这里开一个天窗，大家一定是不允许的。但如果你主张拆掉屋顶，他们就会来调和，愿意开天窗了。”这种先提出很大的要求来，接着提出较小、较少的要求，在心理学上被称为“ 拆屋效应”。</p>
<p>谈判中常用有效技巧<br>拆屋效应也是在谈判中常用的和有效的技巧，有时候我们需要在谈判一开始就抛出一个看似无理而令对方难以接受的条件，但这却并不意味着我们不想继续谈判下去，而只代表着一种谈判的策略罢了。这是个非常有效的策略，它能让你在谈判一开始就占据着比较主动的地位，但记住这只是“拆屋”，如果想让谈判真正有所进展，不要忘记“开天窗”。所以，如果你的一个要求别人很难接受时，在此前你不妨试试提出个他更不可能接受的要求，或许你会有意外的收获。</p>
<h2 id="裙长理论"><a href="#裙长理论" class="headerlink" title="裙长理论"></a>裙长理论</h2><p>裙子愈短经济愈好</p>
<p>“裙长理论”(Hemline theory)，1920年由美国经济学者乔治泰勒(George Taylor)提出，主要内容是：女人的裙长可以反映经济兴衰荣枯，裙子愈短，经济愈好，裙子愈长，经济愈是艰险。2012年夏的英国街头，女士多长裙飘飘，有评论说根据“裙长指数”，英国经济或已触底。</p>
<p>裙长反映经济的理论，起源于1920年代宾州大学华顿商学院经济学家乔治泰勒的观点：“经济增长时，女人会穿短裙，因为她们要炫耀里面的长丝袜；当经济不景气时，女人买不起丝袜，只好把裙边放长，来掩饰没有穿长丝袜的窘迫。”</p>
<p>纽约大都会博物馆服装馆馆长哈罗德柯达(Harold Koda)认为：“伟大的设计师会掌握社会脉搏，了解普通百姓最关心的问题，当他感觉人们心理遇到困境、悲观情绪滋长，所设计的衣服就会朝着保守低调的方向发展，如长袖、高领、长裙。”</p>
<p>设计师对于人们情绪的观察，直接、快速地反应在服装上，如当前经济大好的莫斯科，当地女性裙装以短、薄为主，而且奢华繁复；而持续受到次级房贷影响的美国，女性穿着似乎有呈现保守的趋势，甚至是习惯浮华耀眼衣着的好莱坞明星，受到2007年好莱坞编剧大罢工对美国娱乐产业的打击，也开始一阵长裙风。</p>
<h2 id="口红效应"><a href="#口红效应" class="headerlink" title="口红效应"></a>口红效应</h2><p>外文名 The lipstick effect<br>属性 经济现象<br>别称 低价产品偏爱趋势<br>来源 海外对某些消费现象的描述</p>
<p>“口红效应”是指因经济萧条而导致口红热卖的一种有趣的经济现象，也叫“低价产品偏爱趋势”。<br>在美国，每当在经济不景气时，口红的销量反而会直线上升。这是因为，在美国，人们认为口红是一种比较廉价的奢侈品，在经济不景气的情况下，人们仍然会有强烈的消费欲望，所以会转而购买比较廉价的奢侈品。<br>口红作为一种“廉价的非必要之物”，可以对消费者起到一种“安慰”的作用，尤其是当柔软润泽的口红接触嘴唇的那一刻。<br>再有，经济的衰退会让一些人的消费降低，这样手中反而会出现一些“小闲钱”，正好去买一些“廉价的非必要之物”。</p>
<hr>
<h1 id="习惯管理"><a href="#习惯管理" class="headerlink" title="习惯管理"></a>习惯管理</h1><hr>
<h2 id="重要事情优先"><a href="#重要事情优先" class="headerlink" title="重要事情优先"></a>重要事情优先</h2><p>列出3到4件重要的事情，先完成</p>
<h2 id="随时记录"><a href="#随时记录" class="headerlink" title="随时记录"></a>随时记录</h2><p>捕捉头脑中闪过的想法，记在手机笔记便签或者笔记本上，经常拿出来看看，逐一归类到待办事项.</p>
<h2 id="回顾总结"><a href="#回顾总结" class="headerlink" title="回顾总结"></a>回顾总结</h2><p>日总结、周总结、月总结、季总结、年总结</p>
<h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>感兴趣自行搜索</p>
<h2 id="角色平衡"><a href="#角色平衡" class="headerlink" title="角色平衡"></a>角色平衡</h2><p>父亲、伴侣、儿子、职员、同学朋友平衡好自己的角色</p>
<h2 id="个人使命宣言"><a href="#个人使命宣言" class="headerlink" title="个人使命宣言"></a>个人使命宣言</h2><p>经常反省自己是否离这个大目标更近，周期性的回顾和修正使命宣言<br>•使命: 帮助更多的人获得积极快乐的人生!<br>•生活: 永远保持积极乐观的生活态度!<br>•信念: 坚持不懈，直到成功，为中华崛起而奋斗!<br>•儿子：让父母幸福，健康，长寿。<br>•父亲：让儿女幸福，健康，富裕。<br>•丈夫: 让妻子幸福，健康，积极，乐观。<br>•学习：每个月看一本书。<br>•工作: 和战友们一起共同奋斗。<br>•爱好：永远热爱事业,永远热爱生活。</p>
<h2 id="戴上耳机"><a href="#戴上耳机" class="headerlink" title="戴上耳机"></a>戴上耳机</h2><p>偶尔也要给自己私人空间</p>
<h2 id="单个任务"><a href="#单个任务" class="headerlink" title="单个任务"></a>单个任务</h2><p>•一次只做一件事情<br>•事情一件一件做</p>
<h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>•培养良好的生活和工作习惯<br>•习惯养成了，好习惯养成了，目标就不远了</p>
<h2 id="保持整洁有序"><a href="#保持整洁有序" class="headerlink" title="保持整洁有序"></a>保持整洁有序</h2><p>•心情就会舒畅，心情好，大脑兴奋，没有疲劳感，自然工作效率高。<br>•东西摆放整齐，丢东西或者出差错的几率就小，自然工作效率高。<br>•环境好，空气好，细菌少，生病少，身体倍棒，自然工作效率高。</p>
<h2 id="懂得拒绝"><a href="#懂得拒绝" class="headerlink" title="懂得拒绝"></a>懂得拒绝</h2><p>学会拒绝</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_manager_rule1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="管理学与心理学" scheme="https://hengxing0080.github.io/categories/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    
      <category term="管理学与心理学" scheme="https://hengxing0080.github.io/tags/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>技术类书籍总结</title>
    <link href="https://hengxing0080.github.io/2017/09/25/it/4.Statistics/Book/"/>
    <id>https://hengxing0080.github.io/2017/09/25/it/4.Statistics/Book/</id>
    <published>2017-09-25T11:06:13.000Z</published>
    <updated>2017-11-10T04:56:35.634Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_book_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>只收集基本信息和书名，具体书籍详细信息请自行用豆瓣读书查询：<br><a href="https://book.douban.com/" target="_blank" rel="external">https://book.douban.com/</a></p>
<hr>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><hr>
<h2 id="谷歌官方文档"><a href="#谷歌官方文档" class="headerlink" title="谷歌官方文档"></a>谷歌官方文档</h2><p>Android Training<br>Android API Guides                        </p>
<h2 id="第一行代码（Android）"><a href="#第一行代码（Android）" class="headerlink" title="第一行代码（Android）"></a>第一行代码（Android）</h2><p>版本：<br>第一行代码第1版<br>第一行代码第2版        </p>
<p>作者：郭霖                            </p>
<h2 id="Android疯狂讲义"><a href="#Android疯狂讲义" class="headerlink" title="Android疯狂讲义"></a>Android疯狂讲义</h2><p>版本：<br>Android疯狂讲义第1版<br>Android疯狂讲义第2版<br>Android疯狂讲义第3版        </p>
<p>作者：李刚</p>
<h2 id="Android群英传"><a href="#Android群英传" class="headerlink" title="Android群英传"></a>Android群英传</h2><p>版本：<br>Android群英传<br>Android群英传:神兵利器</p>
<p>作者：徐宜生</p>
<h2 id="Android开发艺术探索"><a href="#Android开发艺术探索" class="headerlink" title="Android开发艺术探索"></a>Android开发艺术探索</h2><p>作者：任玉刚<br>难度：Android进阶类书籍</p>
<h2 id="Android-4高级编程"><a href="#Android-4高级编程" class="headerlink" title="Android 4高级编程"></a>Android 4高级编程</h2><p>版本：<br>android 4高级编程 第1版<br>android 4高级编程 第2版<br>android 4高级编程 第3版</p>
<p>作者：(英)迈耶(Meier, R.) 著</p>
<h2 id="Android编程权威指南"><a href="#Android编程权威指南" class="headerlink" title="Android编程权威指南"></a>Android编程权威指南</h2><p>版本：<br>Android编程权威指南 第1版<br>Android编程权威指南 第2版<br>Android编程权威指南 第3版</p>
<p>作者： [美] Bill Phillips / [美] Brian Hardy</p>
<h2 id="深入理解Android"><a href="#深入理解Android" class="headerlink" title="深入理解Android"></a>深入理解Android</h2><p>版本：<br>深入理解android 卷1<br>深入理解android 卷2<br>深入理解android 卷3<br>深入理解android wifi nfc和gps<br>深入理解android 系统<br>深入理解android 内核设计思想</p>
<p>作者：邓凡平</p>
<h2 id="App研发录"><a href="#App研发录" class="headerlink" title="App研发录"></a>App研发录</h2><p>作者：包建强</p>
<h2 id="打造高质量android应用-50个Android开发技巧"><a href="#打造高质量android应用-50个Android开发技巧" class="headerlink" title="打造高质量android应用-50个Android开发技巧"></a>打造高质量android应用-50个Android开发技巧</h2><p>作者：[美] Carlos Sessa </p>
<h2 id="Android开发进阶：从小工到专家"><a href="#Android开发进阶：从小工到专家" class="headerlink" title="Android开发进阶：从小工到专家"></a>Android开发进阶：从小工到专家</h2><p>作者：何红辉<br>出版时间：2016-02-01</p>
<h2 id="Android从入门到精通"><a href="#Android从入门到精通" class="headerlink" title="Android从入门到精通"></a>Android从入门到精通</h2><p>作者：孙更新<br>出版时间：2011</p>
<h2 id="Android开发精要"><a href="#Android开发精要" class="headerlink" title="Android开发精要"></a>Android开发精要</h2><p>作者：范怀宇<br>出版时间：2012-8</p>
<h2 id="Android框架揭秘"><a href="#Android框架揭秘" class="headerlink" title="Android框架揭秘"></a>Android框架揭秘</h2><p>作者：(韩)金泰延等<br>译者：武传海<br>出版时间：2012 年4月</p>
<h2 id="Android系统源代码情景分析"><a href="#Android系统源代码情景分析" class="headerlink" title="Android系统源代码情景分析"></a>Android系统源代码情景分析</h2><p>作者：罗升阳著<br>出版时间：2012年10月<br>页数：840页 </p>
<h2 id="Android内核剖析"><a href="#Android内核剖析" class="headerlink" title="Android内核剖析"></a>Android内核剖析</h2><p>作者：柯元旦<br>页数：616页<br>出版社：电子工业出版社<br>出版时间：2011年9月1日 </p>
<hr>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><hr>
<h2 id="Java核心技术"><a href="#Java核心技术" class="headerlink" title="Java核心技术"></a>Java核心技术</h2><p>作者：昊斯特曼 (Horstmann Cay S.) , Gary Cornell<br>译者：叶乃文, 邝劲筠, 杜永萍<br>出版社：电子工业出版社<br>出版时间：2011年7月1日<br>最新版本：第9版</p>
<h2 id="Effective-Java"><a href="#Effective-Java" class="headerlink" title="Effective Java"></a>Effective Java</h2><p>作者: [美] Joshua Bloch<br>出版社: 机械工业出版社<br>译者: 潘爱民<br>出版年: 2003-1<br>页数: 225</p>
<h2 id="疯狂Java讲义"><a href="#疯狂Java讲义" class="headerlink" title="疯狂Java讲义"></a>疯狂Java讲义</h2><p>作者：李刚<br>页数：887<br>出版社：电子工业出版社<br>出版时间：2008-09<br>最新版本：第5版</p>
<h2 id="Thinking-in-java"><a href="#Thinking-in-java" class="headerlink" title="Thinking in java"></a>Thinking in java</h2><p>作者:  [美] Bruce Eckel<br>出版社: Prentice Hall<br>出版年: 2006-2-20<br>页数: 1150</p>
<hr>
<h1 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h1><hr>
<h2 id="疯狂HTML-5-CSS-3-JavaScript讲义"><a href="#疯狂HTML-5-CSS-3-JavaScript讲义" class="headerlink" title="疯狂HTML 5/CSS 3/JavaScript讲义"></a>疯狂HTML 5/CSS 3/JavaScript讲义</h2><p>作者: 李刚<br>出版社: 电子工业出版社<br>出版年: 2012-5-1<br>页数: 500<br>最新版本：第2版</p>
<h2 id="使用HTML、CSS和JavaScript开发Android程序"><a href="#使用HTML、CSS和JavaScript开发Android程序" class="headerlink" title="使用HTML、CSS和JavaScript开发Android程序"></a>使用HTML、CSS和JavaScript开发Android程序</h2><p>作者: [美]Jonathan Stark<br>出版社: 电子工业出版社<br>原作名: Building Android Apps with HTML, CSS, and JavaScript<br>译者: 申林 / 邹宇<br>出版年: 2011-6<br>页数: 165</p>
<hr>
<h1 id="设计模式-编程思想"><a href="#设计模式-编程思想" class="headerlink" title="设计模式/编程思想"></a>设计模式/编程思想</h1><hr>
<h2 id="Android-源码设计模式解析与实战"><a href="#Android-源码设计模式解析与实战" class="headerlink" title="Android 源码设计模式解析与实战"></a>Android 源码设计模式解析与实战</h2><p>作者: 何红辉 / 关爱民<br>出版社: 人民邮电出版社<br>出版年: 2015-11<br>页数: 366</p>
<h2 id="大话设计模式（程杰）"><a href="#大话设计模式（程杰）" class="headerlink" title="大话设计模式（程杰）"></a>大话设计模式（程杰）</h2><p>作者:  程杰<br>出版社: 清华大学出版社<br>出版年: 2007-12-1<br>页数: 368</p>
<h2 id="大话设计模式（吴强）"><a href="#大话设计模式（吴强）" class="headerlink" title="大话设计模式（吴强）"></a>大话设计模式（吴强）</h2><p>作者:  吴强<br>出版社: 企业管理出版社<br>出版年: 2010-7-1<br>页数: 393</p>
<p>不推荐，山寨的，里面排版都有问题.很多代码是重复的，书很差.</p>
<h2 id="Head-First-设计模式（中文版）"><a href="#Head-First-设计模式（中文版）" class="headerlink" title="Head First 设计模式（中文版）"></a>Head First 设计模式（中文版）</h2><p>作者:  [美] 弗里曼<br>出版社: 中国电力出版社<br>译者: O’Reilly Taiwan公司<br>出版年: 2007-9<br>页数: 637</p>
<h2 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h2><p>作者: 秦小波<br>出版社: 机械工业出版社<br>出版年: 2010年3月<br>页数: 545<br>最新版本：第2版</p>
<h2 id="软件秘笈：设计模式那点事"><a href="#软件秘笈：设计模式那点事" class="headerlink" title="软件秘笈：设计模式那点事"></a>软件秘笈：设计模式那点事</h2><p>作者 郑阿奇<br>页数 628页<br>出版社 电子工业出版社<br>出版时间 2011年11月1日</p>
<h2 id="设计模式：可复用面向对象软件的基础"><a href="#设计模式：可复用面向对象软件的基础" class="headerlink" title="设计模式：可复用面向对象软件的基础"></a>设计模式：可复用面向对象软件的基础</h2><p>作者: [美] Erich Gamma / Richard Helm / Ralph Johnson / John Vlissides<br>出版社: 机械工业出版社<br>副标题: 可复用面向对象软件的基础<br>原作名: Design Patterns: Elements of Reusable Object-Oriented Software<br>译者: 李英军 / 马晓星 / 蔡敏 / 刘建中 等<br>出版年: 2000-9<br>页数: 254</p>
<hr>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><hr>
<h2 id="大话数据结构"><a href="#大话数据结构" class="headerlink" title="大话数据结构"></a>大话数据结构</h2><p>作者:  程杰<br>出版社: 清华大学出版社<br>出版年: 2011-6<br>页数: 440</p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><hr>
<h2 id="大话数据库"><a href="#大话数据库" class="headerlink" title="大话数据库"></a>大话数据库</h2><p>作者: 邹茂扬 田洪川<br>出版社: 清华大学出版社<br>出版年: 2013-3<br>页数: 464</p>
<hr>
<h1 id="代码规范-开发方式-程序员修养"><a href="#代码规范-开发方式-程序员修养" class="headerlink" title="代码规范/开发方式/程序员修养"></a>代码规范/开发方式/程序员修养</h1><hr>
<h2 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h2><p>作者:  [美] Robert C·Martin<br>出版社: 人民邮电出版社<br>原作名: Clean Code: A Handbook of Agile Software Craftsmanship<br>译者: 韩磊<br>出版年: 2010-1-1<br>页数: 388</p>
<h2 id="高效程序员的45个习惯"><a href="#高效程序员的45个习惯" class="headerlink" title="高效程序员的45个习惯"></a>高效程序员的45个习惯</h2><p>作者:  [美] Venkat Subramaniam / [美] Andy Hunt<br>出版社: 人民邮电出版社<br>副标题: 敏捷开发修炼之道<br>译者: 钱安川 / 郑柯<br>出版年: 2010-01<br>页数: 204</p>
<h2 id="程序员修炼之道-从小工到专家"><a href="#程序员修炼之道-从小工到专家" class="headerlink" title="程序员修炼之道-从小工到专家"></a>程序员修炼之道-从小工到专家</h2><p>作者: Andrew Hunt / David Thomas<br>出版社: 电子工业出版社<br>副标题: 从小工到专家<br>原作名: The Pragmatic Programmer: From Journeyman to Master<br>译者: 马维达<br>出版年: 2011-1<br>页数: 272</p>
<h2 id="疯狂Java程序员的基本修养"><a href="#疯狂Java程序员的基本修养" class="headerlink" title="疯狂Java程序员的基本修养"></a>疯狂Java程序员的基本修养</h2><p>作者: 李刚<br>出版社: 电子工业出版社<br>出版年: 2013-1<br>页数: 484</p>
<hr>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><hr>
<h2 id="谁是谷歌想要的人才"><a href="#谁是谷歌想要的人才" class="headerlink" title="谁是谷歌想要的人才"></a>谁是谷歌想要的人才</h2><p>作者:  [美] 威廉·庞德斯通<br>出版社: 浙江人民出版社<br>副标题: 破解世界最顶尖公司的面试密码<br>原作名: Are You Smart Enough to Work at Google?<br>译者: 闾佳<br>出版年: 2013-2-23<br>页数: 256</p>
<h2 id="如何移动富士山"><a href="#如何移动富士山" class="headerlink" title="如何移动富士山"></a>如何移动富士山</h2><p>作者:  [美] 威廉·庞德斯通<br>出版社: 中信出版社<br>译者: 刘俊朝<br>出版年: 2006-1<br>页数: 214</p>
<h2 id="编程之美——微软技术面试心得"><a href="#编程之美——微软技术面试心得" class="headerlink" title="编程之美——微软技术面试心得"></a>编程之美——微软技术面试心得</h2><p>作者: 《编程之美》小组 编<br>出版社: 电子工业出版社<br>副标题: 微软技术面试心得<br>出版年: 2008-3<br>页数: 327</p>
<h2 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h2><p>作者: 何海涛<br>出版社: 电子工业出版社<br>副标题: 名企面试官精讲典型编程题<br>出版年: 2012-1<br>页数: 260</p>
<hr>
<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><hr>
<h2 id="重构：改善既有代码的设计"><a href="#重构：改善既有代码的设计" class="headerlink" title="重构：改善既有代码的设计"></a>重构：改善既有代码的设计</h2><h2 id="代码大全"><a href="#代码大全" class="headerlink" title="代码大全"></a>代码大全</h2><h2 id="人月神话"><a href="#人月神话" class="headerlink" title="人月神话"></a>人月神话</h2><h2 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h2><h2 id="编程珠玑"><a href="#编程珠玑" class="headerlink" title="编程珠玑"></a>编程珠玑</h2><h2 id="架构之美"><a href="#架构之美" class="headerlink" title="架构之美"></a>架构之美</h2><hr>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><hr>
<h2 id="程序员的数学"><a href="#程序员的数学" class="headerlink" title="程序员的数学"></a>程序员的数学</h2><p>版本：<br>程序员的数学1<br>程序员的数学2<br>程序员的数学3</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_book_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 统计分析" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    
    
      <category term="统计分析" scheme="https://hengxing0080.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>IT类学习网站总结</title>
    <link href="https://hengxing0080.github.io/2017/09/24/it/4.Statistics/Webpage/"/>
    <id>https://hengxing0080.github.io/2017/09/24/it/4.Statistics/Webpage/</id>
    <published>2017-09-24T11:06:13.000Z</published>
    <updated>2017-11-10T10:00:48.494Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_webpage_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><hr>
<h2 id="Baidu"><a href="#Baidu" class="headerlink" title="Baidu"></a>Baidu</h2><p><a href="https://www.baidu.com/" target="_blank" rel="external">https://www.baidu.com/</a><br>每天都用，不解释了</p>
<h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p><a href="http://www.google.cn/" target="_blank" rel="external">http://www.google.cn/</a><br>尝试一下用Google English版本，使用英文关键词，可能会比中文找到更好的解决方案</p>
<p>做开发前完全是小白，真心不知道有Google这东西，只晓得百度，遇到问题直接百度，不是黑百度，百度在娱乐八卦方面确实靠谱，但是技术方面查出来的东西基本千篇一律，有些答案甚至还会起到误导作用，直到有一天我的老大告诉我用Google，我才知道这个世界上原来还有另外一个搜索引擎，那个时候Google还没有被墙，从此算是迈过了一道坎。。。。</p>
<h2 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h2><p><a href="http://stackoverflow.com/" target="_blank" rel="external">http://stackoverflow.com/</a></p>
<p>善用Google和StackOverFlow，比百度和CSDN靠谱多了，比如想查下如何从代码中设置TextView的drawLeft属性，google搜索“android textview drawableLeft programmatically”即可，这是搜索到的第一条里面的内容：</p>
<p>用Google之后搜索出来的东西还是习惯性的点击中文结果，直到有一天我发现基本每次搜索排名第一的都是这个网站，于是尝试着点进去用我蹩脚的英语阅读，之后真是相见恨晚的感觉啊，上面几乎能搜到你遇到的绝大部分问题，某种程度上来说推荐用Google搜索的原因之一是因为排名靠前的答案基本都在StackOverflow上。</p>
<h2 id="Segmentfault"><a href="#Segmentfault" class="headerlink" title="Segmentfault"></a>Segmentfault</h2><p><a href="http://segmentfault.com/" target="_blank" rel="external">http://segmentfault.com/</a></p>
<h2 id="Quora"><a href="#Quora" class="headerlink" title="Quora"></a>Quora</h2><p><a href="https://www.quora.com/" target="_blank" rel="external">https://www.quora.com/</a></p>
<h2 id="LinkedIn"><a href="#LinkedIn" class="headerlink" title="LinkedIn"></a>LinkedIn</h2><p><a href="https://www.linkedin.com/" target="_blank" rel="external">https://www.linkedin.com/</a></p>
<h2 id="Wikipedia"><a href="#Wikipedia" class="headerlink" title="Wikipedia"></a>Wikipedia</h2><p><a href="https://www.wikipedia.org/" target="_blank" rel="external">https://www.wikipedia.org/</a></p>
<h2 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h2><p><a href="https://www.facebook.com/" target="_blank" rel="external">https://www.facebook.com/</a></p>
<h2 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h2><p><a href="https://twitter.com/" target="_blank" rel="external">https://twitter.com/</a></p>
<h2 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h2><p>主页<br><a href="http://www.csdn.net/" target="_blank" rel="external">http://www.csdn.net/</a></p>
<p>博客专栏<br><a href="http://blog.csdn.net/column.html" target="_blank" rel="external">http://blog.csdn.net/column.html</a></p>
<p>知识库<br><a href="http://lib.csdn.net/home" target="_blank" rel="external">http://lib.csdn.net/home</a></p>
<h2 id="51CTO"><a href="#51CTO" class="headerlink" title="51CTO"></a>51CTO</h2><p><a href="http://www.51cto.com/" target="_blank" rel="external">http://www.51cto.com/</a></p>
<h2 id="我要自学网"><a href="#我要自学网" class="headerlink" title="我要自学网"></a>我要自学网</h2><p><a href="http://www.51zxw.net/" target="_blank" rel="external">http://www.51zxw.net/</a></p>
<h2 id="博客园"><a href="#博客园" class="headerlink" title="博客园"></a>博客园</h2><p><a href="http://www.cnblogs.com/" target="_blank" rel="external">http://www.cnblogs.com/</a></p>
<h2 id="开源中国社区"><a href="#开源中国社区" class="headerlink" title="开源中国社区"></a>开源中国社区</h2><p><a href="https://www.oschina.net/" target="_blank" rel="external">https://www.oschina.net/</a></p>
<h2 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h2><p><a href="https://gold.xitu.io/" target="_blank" rel="external">https://gold.xitu.io/</a></p>
<h2 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h2><p><a href="https://www.zhihu.com/" target="_blank" rel="external">https://www.zhihu.com/</a></p>
<h2 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h2><p><a href="http://www.jianshu.com/" target="_blank" rel="external">http://www.jianshu.com/</a></p>
<h2 id="推酷"><a href="#推酷" class="headerlink" title="推酷"></a>推酷</h2><p><a href="http://www.tuicool.com/" target="_blank" rel="external">http://www.tuicool.com/</a></p>
<h2 id="安卓巴士"><a href="#安卓巴士" class="headerlink" title="安卓巴士"></a>安卓巴士</h2><p><a href="http://www.apkbus.com/" target="_blank" rel="external">http://www.apkbus.com/</a></p>
<h2 id="eoeAndroid"><a href="#eoeAndroid" class="headerlink" title="eoeAndroid"></a>eoeAndroid</h2><p><a href="http://www.eoeandroid.com/" target="_blank" rel="external">http://www.eoeandroid.com/</a>    </p>
<h2 id="我的异常网"><a href="#我的异常网" class="headerlink" title="我的异常网"></a>我的异常网</h2><p>主页<br><a href="http://www.myexception.cn/" target="_blank" rel="external">http://www.myexception.cn/</a></p>
<p>Android<br><a href="http://www.myexception.cn/android/" target="_blank" rel="external">http://www.myexception.cn/android/</a></p>
<h2 id="深度开源OPEN经验"><a href="#深度开源OPEN经验" class="headerlink" title="深度开源OPEN经验"></a>深度开源OPEN经验</h2><p><a href="http://www.open-open.com/lib/list/41" target="_blank" rel="external">http://www.open-open.com/lib/list/41</a></p>
<h2 id="ITeye"><a href="#ITeye" class="headerlink" title="ITeye"></a>ITeye</h2><p><a href="http://www.iteye.com/" target="_blank" rel="external">http://www.iteye.com/</a></p>
<h2 id="ITPUB"><a href="#ITPUB" class="headerlink" title="ITPUB"></a>ITPUB</h2><p><a href="http://www.itpub.net/" target="_blank" rel="external">http://www.itpub.net/</a></p>
<h2 id="InfoQ"><a href="#InfoQ" class="headerlink" title="InfoQ"></a>InfoQ</h2><p><a href="http://www.infoq.com/cn" target="_blank" rel="external">http://www.infoq.com/cn</a></p>
<h2 id="伯乐在线"><a href="#伯乐在线" class="headerlink" title="伯乐在线"></a>伯乐在线</h2><p><a href="http://www.jobbole.com/" target="_blank" rel="external">http://www.jobbole.com/</a></p>
<h2 id="iPc-me-与你分享互联网的精彩"><a href="#iPc-me-与你分享互联网的精彩" class="headerlink" title="iPc.me - 与你分享互联网的精彩!"></a>iPc.me - 与你分享互联网的精彩!</h2><p><a href="http://www.ipc.me/" target="_blank" rel="external">http://www.ipc.me/</a></p>
<hr>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><hr>
<h2 id="Android中文API"><a href="#Android中文API" class="headerlink" title="Android中文API"></a>Android中文API</h2><p><a href="http://www.android-doc.com/" target="_blank" rel="external">http://www.android-doc.com/</a><br><a href="http://www.android-doc.com/reference/packages.html" target="_blank" rel="external">http://www.android-doc.com/reference/packages.html</a></p>
<h2 id="谷歌开发者-google-developers-中文网站"><a href="#谷歌开发者-google-developers-中文网站" class="headerlink" title="谷歌开发者(google developers)中文网站"></a>谷歌开发者(google developers)中文网站</h2><p>主页：<br><a href="https://developers.google.cn/" target="_blank" rel="external">https://developers.google.cn/</a><br>Android：<br><a href="https://developer.android.google.cn/index.html" target="_blank" rel="external">https://developer.android.google.cn/index.html</a></p>
<h2 id="谷歌开发者代码实验室-Google-Developers-Codelabs"><a href="#谷歌开发者代码实验室-Google-Developers-Codelabs" class="headerlink" title="谷歌开发者代码实验室(Google Developers Codelabs)"></a>谷歌开发者代码实验室(Google Developers Codelabs)</h2><p><a href="https://codelabs.developers.google.com/" target="_blank" rel="external">https://codelabs.developers.google.com/</a><br><a href="http://clmirror.storage.googleapis.com/index.html" target="_blank" rel="external">http://clmirror.storage.googleapis.com/index.html</a><br><a href="https://codelabs.cn/" target="_blank" rel="external">https://codelabs.cn/</a></p>
<h2 id="极客导航"><a href="#极客导航" class="headerlink" title="极客导航"></a>极客导航</h2><p><a href="http://www.jikedaohang.com/" target="_blank" rel="external">http://www.jikedaohang.com/</a></p>
<h2 id="AndroidAssetStudio"><a href="#AndroidAssetStudio" class="headerlink" title="AndroidAssetStudio"></a>AndroidAssetStudio</h2><p>Android Asset Studio 是一个在线制作工具，它可以制作Iocn，ActionBar，点9 图等等，简单的操作，大大提高了我们开发的效率。<br><a href="http://romannurik.github.io/AndroidAssetStudio/" target="_blank" rel="external">http://romannurik.github.io/AndroidAssetStudio/</a></p>
<h2 id="Android官方培训课程中文版"><a href="#Android官方培训课程中文版" class="headerlink" title="Android官方培训课程中文版"></a>Android官方培训课程中文版</h2><p><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">http://hukai.me/android-training-course-in-chinese/index.html</a></p>
<hr>
<h1 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h1><hr>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<p>源代码托管，不用多说，下面网站大多以它为数据源。</p>
<p>Google+stackoverflow基本上能解决开发中遇到的大部分“奇葩”问题了，但是开发到一定程度你需要进一步提升自己的技能，这个时候GitHub简直就是快速提升必备，在上面可以找到很多第三方组件，不用重复发明轮子，也可以直接阅读牛人们的代码，吸取他们的精华，代码读的多了不知不觉有一种质的飞越，直到最后你会开源自己的项目，大力拥抱开源社区，这是接触了另一个世界。</p>
<h2 id="码云"><a href="#码云" class="headerlink" title="码云"></a>码云</h2><p><a href="http://git.oschina.net/" target="_blank" rel="external">http://git.oschina.net/</a></p>
<h2 id="DevStore-移动互联网企业运营解决方案整合平台"><a href="#DevStore-移动互联网企业运营解决方案整合平台" class="headerlink" title="DevStore_移动互联网企业运营解决方案整合平台"></a>DevStore_移动互联网企业运营解决方案整合平台</h2><p><a href="http://www.devstore.cn/" target="_blank" rel="external">http://www.devstore.cn/</a><br>传说中的Android军火库，很多东西都是在这里面找的</p>
<h2 id="android-arsenal"><a href="#android-arsenal" class="headerlink" title="android-arsenal"></a>android-arsenal</h2><p>android-arsenal.com<br>国外的Android军火库<br>Android Arsenal 主要是推荐Github 上一些流行的Android 开源项目，基本上最近热门的Android 开源项目都会出现在这里，它还对不同类库进行了分类。<br>从 2014 年开始做，囊括库最多的网站了，支持英文搜索、分类选择、显示最新开源项目。</p>
<h2 id="codeKK"><a href="#codeKK" class="headerlink" title="codeKK"></a>codeKK</h2><p><a href="http://p.codekk.com/" target="_blank" rel="external">http://p.codekk.com/</a><br>这是一个开源项目自动搜集、方便快速浏览和中英文搜索的网站，目前已经收集了 1000+ Android 开源项目。</p>
<h2 id="泡在网上的日子——代码"><a href="#泡在网上的日子——代码" class="headerlink" title="泡在网上的日子——代码"></a>泡在网上的日子——代码</h2><p><a href="http://www.jcodecraeer.com/plus/list.php?tid=31" target="_blank" rel="external">http://www.jcodecraeer.com/plus/list.php?tid=31</a></p>
<h2 id="Android中文API——APP源码"><a href="#Android中文API——APP源码" class="headerlink" title="Android中文API——APP源码"></a>Android中文API——APP源码</h2><p><a href="http://www.android-doc.com/apps/" target="_blank" rel="external">http://www.android-doc.com/apps/</a></p>
<h2 id="安卓巴士——全部代码"><a href="#安卓巴士——全部代码" class="headerlink" title="安卓巴士——全部代码"></a>安卓巴士——全部代码</h2><p><a href="http://www.apkbus.com/code.php" target="_blank" rel="external">http://www.apkbus.com/code.php</a></p>
<h2 id="GrepCode"><a href="#GrepCode" class="headerlink" title="GrepCode"></a>GrepCode</h2><p><a href="http://www.grepcode.com/" target="_blank" rel="external">http://www.grepcode.com/</a><br>可快速搜索 Android、Java 任何版本及部分开源项目源码，看各版本系统代码排查问题相当方便。<br>除了 GrepCode 还有 codota.com，不过体验比较差，没有 GrepCode 方便。</p>
<h2 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h2><p>地址：<a href="https://www.codota.com/" target="_blank" rel="external">https://www.codota.com/</a><br>Codota 是一款Android 代码搜索工具，Codota 目前已经收录超过七百万精品代码实例<br>具体的详细介绍请看文章:<br><a href="http://www.jianshu.com/p/59b89c26f9e0" target="_blank" rel="external">《Android 开发工具之Codota——搜索最好的Android 代码 - 简书》</a></p>
<h2 id="Android-开源项目分类汇总"><a href="#Android-开源项目分类汇总" class="headerlink" title="Android 开源项目分类汇总"></a>Android 开源项目分类汇总</h2><p><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="external">https://github.com/Trinea/android-open-project</a></p>
<h2 id="GitHub上最火的Android开源项目持续更新中…"><a href="#GitHub上最火的Android开源项目持续更新中…" class="headerlink" title="GitHub上最火的Android开源项目持续更新中….."></a>GitHub上最火的Android开源项目持续更新中…..</h2><p><a href="https://github.com/open-android/Android" target="_blank" rel="external">https://github.com/open-android/Android</a></p>
<h2 id="Android-Libraries-and-Resources"><a href="#Android-Libraries-and-Resources" class="headerlink" title="Android Libraries and Resources"></a>Android Libraries and Resources</h2><p><a href="http://alamkanak.github.io/android-libraries-and-resources/" target="_blank" rel="external">http://alamkanak.github.io/android-libraries-and-resources/</a><br>界面简洁明了，最大的特点是按照“标签”区分，支持英文搜索，不过只搜集了 200+ 项目。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://bbs.itheima.com/thread-281406-1-1.html" target="_blank" rel="external">http://bbs.itheima.com/thread-281406-1-1.html</a><br><a href="http://bbs.itheima.com/thread-300073-1-1.html" target="_blank" rel="external">http://bbs.itheima.com/thread-300073-1-1.html</a><br><a href="http://www.open-open.com/lib/view/open1488768419258.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1488768419258.html</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/40212367" target="_blank" rel="external">Android 打造任意层级树形控件 考验你的数据结构和设计</a><br><a href="http://www.jianshu.com/p/b672afa32318" target="_blank" rel="external">低仿知乎ViewPager三层嵌套页面布局</a><br><a href="http://www.jianshu.com/p/b672afa32318" target="_blank" rel="external">ViewPager三层嵌套之逼死程序员不带偿命的奇葩设计</a><br><a href="http://blog.csdn.net/u014540814/article/details/52833034" target="_blank" rel="external">京东QQ都没有的牛轰特效、两个ListView联动效果，不用stickyheaderlistview</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9526203" target="_blank" rel="external">Android照片墙应用实现，再多的图片也不怕崩溃</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/10470797" target="_blank" rel="external">Android瀑布流照片墙实现，体验不规则排列的美感</a></p>
<hr>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><hr>
<h2 id="jQuery插件库"><a href="#jQuery插件库" class="headerlink" title="jQuery插件库"></a>jQuery插件库</h2><p><a href="http://www.jq22.com/" target="_blank" rel="external">http://www.jq22.com/</a></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><a href="http://www.zaole.net/demo/" target="_blank" rel="external">http://www.zaole.net/demo/</a></p>
<h2 id="前端导航"><a href="#前端导航" class="headerlink" title="前端导航"></a>前端导航</h2><p><a href="http://www.alloyteam.com/nav/" target="_blank" rel="external">http://www.alloyteam.com/nav/</a></p>
<hr>
<h1 id="学院"><a href="#学院" class="headerlink" title="学院"></a>学院</h1><hr>
<h2 id="网易公开课"><a href="#网易公开课" class="headerlink" title="网易公开课"></a>网易公开课</h2><p><a href="https://open.163.com" target="_blank" rel="external">https://open.163.com</a><br>用户可以在线免费观看来自于哈佛大学等世界级名校的公开课课程，可汗学院，TED等教育性组织的精彩视频，内容涵盖人文、社会、艺术、科学、金融等领域。</p>
<h2 id="学堂在线"><a href="#学堂在线" class="headerlink" title="学堂在线"></a>学堂在线</h2><p><a href="http://www.xuetangx.com" target="_blank" rel="external">http://www.xuetangx.com</a><br>目前，学堂在线运行了包括包括清华大学、北京大学、复旦大学、斯坦福大学、麻省理工学院、加州大学伯克利分校等国内外几十所顶尖高校的优质课程。<br>在2016年发布的“全球慕课排行”中，学堂在线被评为“拥有最多精品好课”的三甲平台之一。</p>
<h2 id="慕课网"><a href="#慕课网" class="headerlink" title="慕课网"></a>慕课网</h2><p><a href="http://www.imooc.com/" target="_blank" rel="external">http://www.imooc.com/</a><br>慕课网(IMOOC)是国内最大的IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课。</p>
<h2 id="极客学院"><a href="#极客学院" class="headerlink" title="极客学院"></a>极客学院</h2><p><a href="http://www.jikexueyuan.com" target="_blank" rel="external">http://www.jikexueyuan.com</a><br>极客学院是中国android开发在线学习平台，汇集了几十名国内顶尖的有多年项目和实战经验的Android开发授课大师，精心制作了上千个高质量视频教程，涵盖了Android开发学习的基础入门、中级进阶，高级提升、项目实战开发等专业的android开发课程。</p>
<h2 id="黑马程序员"><a href="#黑马程序员" class="headerlink" title="黑马程序员"></a>黑马程序员</h2><p><a href="http://www.itheima.com/" target="_blank" rel="external">http://www.itheima.com/</a></p>
<h2 id="传智播客"><a href="#传智播客" class="headerlink" title="传智播客"></a>传智播客</h2><p><a href="http://www.itcast.cn/" target="_blank" rel="external">http://www.itcast.cn/</a></p>
<h2 id="腾讯大学"><a href="#腾讯大学" class="headerlink" title="腾讯大学"></a>腾讯大学</h2><p><a href="http://daxue.qq.com/" target="_blank" rel="external">http://daxue.qq.com/</a></p>
<h2 id="腾讯课堂"><a href="#腾讯课堂" class="headerlink" title="腾讯课堂"></a>腾讯课堂</h2><p><a href="https://ke.qq.com" target="_blank" rel="external">https://ke.qq.com</a><br>腾讯课堂凭借QQ客户端的优势，实现在线即时互动教学；并利用QQ积累多年的音视频能力，提供流畅、高音质的课程直播效果；</p>
<h2 id="百度传课"><a href="#百度传课" class="headerlink" title="百度传课"></a>百度传课</h2><p><a href="https://chuanke.baidu.com" target="_blank" rel="external">https://chuanke.baidu.com</a><br>百度传课引入全国知名重点学校的一线教学名师，采取网络互动直播和点播的授课模式，突破地域和时间的限制，为广大的学生群体提供高效便捷的网络学习渠道，推出高质量的线上精品课程。</p>
<h2 id="龙果学院"><a href="#龙果学院" class="headerlink" title="龙果学院"></a>龙果学院</h2><p><a href="http://www.roncoo.com/index.html" target="_blank" rel="external">http://www.roncoo.com/index.html</a></p>
<h2 id="起点学院-https-www-qidianla-com"><a href="#起点学院-https-www-qidianla-com" class="headerlink" title="起点学院 https://www.qidianla.com"></a>起点学院 <a href="https://www.qidianla.com" target="_blank" rel="external">https://www.qidianla.com</a></h2><p>起点学院-产品经理黄埔军校,是人人都是产品经理社区旗下的产品经理培训平台。让更多的产品爱好者实现产品梦,这个网站主要关注移动互联网产品相关知识，如果你喜欢产品，上这个网站就对啦。</p>
<h2 id="插座学院"><a href="#插座学院" class="headerlink" title="插座学院"></a>插座学院</h2><p><a href="http://www.chazuomba.com" target="_blank" rel="external">http://www.chazuomba.com</a><br>插坐学院从泛互联网学习社区,转变为聚焦新媒体的垂直学习社区,而目前,新媒体运营恰巧是一种全新行业技能,也是一种新岗位。上面很多知识，是新媒体运营相关知识。</p>
<h2 id="开课吧"><a href="#开课吧" class="headerlink" title="开课吧"></a>开课吧</h2><p><a href="http://www.kaikeba.com" target="_blank" rel="external">http://www.kaikeba.com</a><br>开课吧-互联网从业者在线学习社区,旨在为你提供一个具有创业、互联网技术、互联网营销,产品UI设计、商务技能(word、excel、PPT…)等视频在线课程培训。</p>
<h2 id="优米网"><a href="#优米网" class="headerlink" title="优米网"></a>优米网</h2><p><a href="http://www.youmi.cn" target="_blank" rel="external">http://www.youmi.cn</a><br>现有的500多位知名企业家讲师，1000多个在线课程旨在服务创业者，为他们提供独家商业智慧视频服务。讲师团队包括史玉柱、马云、王石等商界大佬及各行业专家,内容覆盖营销、创业商机、领导力等等。</p>
<h2 id="软酷网"><a href="#软酷网" class="headerlink" title="软酷网"></a>软酷网</h2><p><a href="http://www.ruanko.com" target="_blank" rel="external">http://www.ruanko.com</a><br>软酷网是中国第一家个性化泛IT学习方案服务商,为用户提供android、java、C语言、软件测试、数据库等视频。</p>
<h2 id="多贝网"><a href="#多贝网" class="headerlink" title="多贝网"></a>多贝网</h2><p><a href="http://www.duobei.com" target="_blank" rel="external">http://www.duobei.com</a><br>多贝是中国新开的视频公开课网站，有最新的网络公开课课程，是具备在线教学功能的网络教室。你可以找到好的老师和课程，也可以发布自己的公开课。基本专注互联网领域，课程很干货，有收费的课程，免费的也不错哦。</p>
<h2 id="麦子学院"><a href="#麦子学院" class="headerlink" title="麦子学院"></a>麦子学院</h2><p><a href="http://www.maiziedu.com" target="_blank" rel="external">http://www.maiziedu.com</a><br>国内第一家在美国建立商务中心的IT在线教育机构，目前已与美国知名教育公司取得合作，未来将源源不断向国内输出大量高质量教育资源。</p>
<h2 id="可汗学院"><a href="#可汗学院" class="headerlink" title="可汗学院"></a>可汗学院</h2><p><a href="https://www.khanacademy.org" target="_blank" rel="external">https://www.khanacademy.org</a><br>可汗学院(Khan Academy)，是由孟加拉裔美国人萨尔曼·可汗创立的一家教育性非营利组织，主旨在于利用网络影片进行免费授课，现有关于数学、历史、金融、物理、化学、生物、天文学等科目的内容，里面的老师算全世界最牛的老师了吧。</p>
<h2 id="TED"><a href="#TED" class="headerlink" title="TED"></a>TED</h2><p><a href="https://www.ted.com" target="_blank" rel="external">https://www.ted.com</a><br>TED它是美国的一家私有非盈利机构，该机构以它组织的TED大会著称。TED演讲的主旨是：Ideas worth spreading.【T】Technology 技术【E】Entertainment 娱乐【D】Design 设计。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_webpage_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 统计分析" scheme="https://hengxing0080.github.io/categories/IT-%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    
    
      <category term="统计分析" scheme="https://hengxing0080.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android —— Context的几种环境和区别</title>
    <link href="https://hengxing0080.github.io/2017/09/20/it/1.Android/Context/"/>
    <id>https://hengxing0080.github.io/2017/09/20/it/1.Android/Context/</id>
    <published>2017-09-20T15:57:13.000Z</published>
    <updated>2017-11-10T11:22:22.578Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_context_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<h1 id="上下文理解"><a href="#上下文理解" class="headerlink" title="上下文理解"></a>上下文理解</h1><p>Context上下文<br>应用程序运行的一个依赖的全局环境.<br>必须有这个环境,才可以方便的执行代码.<br>如得到应用程序的包名,目录,等等系统的服务都在这个环境里<br>它是应用程序运行的全局的环境，一个舞台，一个帮助类.<br>一个全局的环境对象,提供了很多方便的操作<br>帮助我们快速的获取数据,进行一些常规的操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.getFilesDir(),<span class="string">"info.txt"</span>); </div><div class="line"><span class="comment">// this:上下文,可省略不写</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.getApplicationContext()  </div><div class="line"><span class="comment">// 等于this, 都是同一含义,写哪个都可以</span></div><div class="line"><span class="comment">// 外部类写this方便</span></div><div class="line"><span class="comment">// 内部类写this.getApplicationContext() 会方便一些</span></div><div class="line"></div><div class="line">Toast.makeText(<span class="keyword">this</span>, <span class="string">"登陆成功"</span>, <span class="number">0</span>).show();</div><div class="line">Toast.makeText(<span class="keyword">this</span>.getApplicationContext(), <span class="string">"登陆失败"</span>, <span class="number">0</span>).show();</div><div class="line"><span class="comment">// 这2段代码是一个意思</span></div></pre></td></tr></table></figure>
<h1 id="Context内存泄漏"><a href="#Context内存泄漏" class="headerlink" title="Context内存泄漏"></a>Context内存泄漏</h1><p>不要保留对context—-activity长时间的引用，对activity的引用，一定要确保拥有和activity一样的生命周期</p>
<p>总结一下避免Context泄漏应该注意的问题：<br>1.使用Application这种Context类型。<br>2.注意对Context的引用不要超过它本身的生命周期。<br>3.慎重的使用“static”关键字。<br>4.Context里如果有线程，一定要在onDestroy()里及时停掉。<br>长期持有(Activity)Context导致的泄漏</p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2015/04/12/avoid-memory-leaks-on-context-in-android/" target="_blank" rel="external">避免Android中Context引起的内存泄露</a></p>
<h1 id="4种获取上下文的方式"><a href="#4种获取上下文的方式" class="headerlink" title="4种获取上下文的方式"></a>4种获取上下文的方式</h1><p>通常我们想要获取Context对象，主要有以下四种方法：</p>
<ul>
<li><p>1.XXXActivity.this<br>Activity.this 返回当前的Activity实例<br>如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。<br>当前Activity对象，Context的子类对象，<br>子类比父类功能强大，独立显示界面，<br>AlertDialog是界面的一部分，依附在Activity之上，所以Alertdialog应该传递是 XXXActivity.this 这个上下文</p>
</li>
<li><p>2.Activity.getApplicationContext()<br>获取当前Activity所在的(应用)进程的Context对象<br>应用程序的上下文，保存环境<br>存活周期整个应用程序，只要进程不被销毁<br>通常我们使用Context对象时，要优先考虑这个全局的进程Context。</p>
</li>
<li><p>3.View.getContext()<br>返回当前View对象的Context对象，通常是当前正在展示的Activity对象。<br>虚拟的上下文<br>功能是上下文中最弱的<br>内容提供者模拟的假的上下文 (这种方式只能在内容提供者的onCreate方法里用)<br>通过这个上下文用的唯一的一件事就是得到数据库的路径<br>用于: 内容提供者, 单元测试</p>
</li>
<li><p>4.ContextWrapper.getBaseContext():<br>用来获取一个ContextWrapper进行装饰之前的Context<br>这个方法在实际开发中使用并不多，也不建议使用。</p>
</li>
</ul>
<h1 id="this-和-getApplicationContext-的区别"><a href="#this-和-getApplicationContext-的区别" class="headerlink" title="this 和 getApplicationContext 的区别"></a>this 和 getApplicationContext 的区别</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AlertDialog.Builder builder = <span class="keyword">new</span> Builder(<span class="keyword">this</span>); </div><div class="line"><span class="comment">// AlertDialog.Builder builder = new Builder(getApplicationContext());  // 点击后错误</span></div></pre></td></tr></table></figure>
<p>对话框是Activity的一部分.对话框的显示是依赖于Activity显示的</p>
<p>this代表MainActivity<br>getApplicationContext : 代表整个应用程序的上下文</p>
<p>为了避免出错,最简单的做法 :所有的上下文都写this , 它表示子类, 因为父类中的东西子类都有</p>
<p>getApplicationContext 的生命非常长, 只要应用程序在, 如果进程没了它才会被回收<br>而this只activity界面在, 它就一直在</p>
<h1 id="Toast的上下文"><a href="#Toast的上下文" class="headerlink" title="Toast的上下文"></a>Toast的上下文</h1><p>比较特殊, 直接显示在手机屏幕上, 不认任何的Activity当爹, 在任何界面都能显示出来<br>只需要父类的上下文（Context）<br>土司直接Windows窗体上，跟Activity没有关系</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_context_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android —— 进程和线程</title>
    <link href="https://hengxing0080.github.io/2017/09/19/it/1.Android/Process/"/>
    <id>https://hengxing0080.github.io/2017/09/19/it/1.Android/Process/</id>
    <published>2017-09-19T15:12:13.000Z</published>
    <updated>2017-11-10T11:22:32.825Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_process_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>操作系统分配内存空间的单位<br>进程与进程之间内存空间彼此独立<br>线程是程序运行的最小的内存单元<br>一个进程可以包含多个线程<br>android下的四大组件都是运行在主线程里面的</p>
<p>一般来讲一个应用程序就会对应一个进程<br>二般情况下一个应用程序可以有多个进程</p>
<hr>
<h1 id="进程-多进程"><a href="#进程-多进程" class="headerlink" title="进程/多进程"></a>进程/多进程</h1><hr>
<p>注意：<br>谨慎使用Android的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题：<br>（1）不能实现完全退出所有Activity的功能（如果有同行在应用内采用多进程成功实现过完全退出程序欢迎沟通交流）；<br>（2）首次进入新启动进程的页面时会有延时的现象（有可能黑屏、白屏几秒，是白屏还是黑屏和新Activity的主题有关）；<br>（3）应用内多进程时，新启动一个进程都会重新跑一次Application的onCreate方法，不上重新创建一个Application，但会重新跑Application的onCreate，这样就不能在Application中缓存数据作为内存共享的途径了；<br>（4）多进程间通过SharedPreferences共享数据时不稳定，具体可以查阅《Android开发艺术探索》。</p>
<h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2><p>杀死别人：ActivityManager / killBackgroudProcess();</p>
<p>自杀：android.os.Process.kill(pid);</p>
<h2 id="关于几种退出整个应用程序的区别"><a href="#关于几种退出整个应用程序的区别" class="headerlink" title="关于几种退出整个应用程序的区别"></a>关于几种退出整个应用程序的区别</h2><p>Android手机的用户，根据习惯不同，可能会有两种方式退出整个应用程序：<br>1：按Home键直接退到桌面<br>2：从应用程序的退出按钮或者按Back键退出程序。</p>
<p>那么从系统的角度来说，这两种方式有什么区别呢？<br>按Home键，应用程序并没有被关闭，而是成为了后台应用程序。<br>按Back键，一般来说，应用程序关闭了，但是进程并没有被杀死，而是成为了空进程（程序本身对退出做了特殊处理的不考虑在内）。</p>
<p>Android系统已经做了大量进程管理的工作，这些已经可以满足用户的需求。<br>个人建议，应用程序在退出应用的时候不需要手动杀死自己所在的进程。<br>对于应用程序本身的进程管理，交给Android系统来处理就可以了。<br>应用程序需要做的，是尽量做好程序本身的内存管理工作。</p>
<p>代码实现按Home键时隐藏程序的效果:<br>1:Android 2.0之前需要监听按键事件,进行判断是不是按下了back键<br>2:Android 2.0之后系统提供了一个onBackPressed()方法,这个方法就是专门用来监听back键事件的,所以只需重写onBackPressed()方法即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="comment">//实现Home键效果 </span></div><div class="line">    <span class="comment">//super.onBackPressed();这句话一定要注掉,不然又去调用默认的back处理方式了 </span></div><div class="line">    Intent i= <span class="keyword">new</span> Intent(Intent.ACTION_MAIN); </div><div class="line">    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); </div><div class="line">    i.addCategory(Intent.CATEGORY_HOME); </div><div class="line">    startActivity(i);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码实现退出应用程序的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitProgrames</span><span class="params">()</span></span>&#123; </div><div class="line">    Intent startMain = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN); </div><div class="line">    startMain.addCategory(Intent.CATEGORY_HOME); </div><div class="line">    startMain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); </div><div class="line">    startActivity(startMain); </div><div class="line">    android.os.Process.killProcess(android.os.Process.myPid()); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://www.cnblogs.com/linjiqin/archive/2011/12/14/2287968.html" target="_blank" rel="external">Android home键和back键区别</a></p>
<h2 id="多进程优化"><a href="#多进程优化" class="headerlink" title="多进程优化"></a>多进程优化</h2><p>这个技巧其实并不是非常建议使用，但它确实是一种可以帮助我们节省和管理内存的高级技巧。如果你要使用它的话一定要谨慎使用，因为绝大多数的应用程序都不应该在多个进程当中运行的，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于那些需要在后台去完成一项独立的任务，和前台的功能是可以完全区分开的场景。</p>
<h3 id="多进程分担APP任务"><a href="#多进程分担APP任务" class="headerlink" title="多进程分担APP任务"></a>多进程分担APP任务</h3><p>这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。</p>
<p>想要实现多进程的功能也非常简单，只需要在AndroidManifest文件的应用程序组件中声明一个android:process属性就可以了，比如说我们希望播放音乐的Service可以运行在一个单独的进程当中，就可以这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=<span class="string">".PlaybackService"</span>  </div><div class="line">         android:process=<span class="string">":background"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>这里指定的进程名是background，你也可以将它改成任意你喜欢的名字。需要注意的是，进程名的前面都应该加上一个冒号，表示该进程是一个当前应用程序的私有进程。</p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2017/01/15/android-multiple-processes-summary/" target="_blank" rel="external">技术小黑屋——关于 Android 应用多进程的整理</a></p>
<h3 id="多进程下谨慎初始化Application"><a href="#多进程下谨慎初始化Application" class="headerlink" title="多进程下谨慎初始化Application"></a>多进程下谨慎初始化Application</h3><p>Android应用可以支持开启多个进程。 通常的做法是这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=<span class="string">".NetworkService"</span></div><div class="line">    android:process=<span class="string">":network"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>通常我们在Application的onCreate方法中会做很多初始化操作,但是每个进程启动都需要执行到这个onCreate方法,为了避免不必要的初始化,建议按照进程(通过判断当前进程名)对应初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGTAG = <span class="string">"MyApplication"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        String currentProcessName = getCurrentProcessName();</div><div class="line">        Log.i(LOGTAG, <span class="string">"onCreate currentProcessName="</span> + currentProcessName);</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        <span class="keyword">if</span> (getPackageName().equals(currentProcessName)) &#123;</div><div class="line">            <span class="comment">//init for default process</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentProcessName.endsWith(<span class="string">":network"</span>)) &#123;</div><div class="line">            <span class="comment">//init for netowrk process</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCurrentProcessName</span><span class="params">()</span> </span>&#123;</div><div class="line">        String currentProcessName = <span class="string">""</span>;</div><div class="line">        <span class="keyword">int</span> pid = android.os.Process.myPid();</div><div class="line">        ActivityManager manager = (ActivityManager) <span class="keyword">this</span>.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) &#123;</div><div class="line">            <span class="keyword">if</span> (processInfo.pid == pid) &#123;</div><div class="line">                currentProcessName = processInfo.processName;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> currentProcessName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h2><p>Zygote是一个Dalvik虚拟机进程，同时也是一个Dalvik虚拟机实例的孵化器，每当系统要求执行一个Android应用程序时，Zygote就会FORK出一个子进程来执行该应用程序。这样做的好处显而易见，Zygote进程是在系统启动时产生的，它会完成虚拟机的初始化，库的加载，预置类库的加载等操作，而在系统需要一个新的虚拟机实例时，Zygote通过复制自身，以最快的速度提供一个虚拟机实例。另外，对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域，大大节省了内存开销。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/luoshengyang/article/details/6768304" target="_blank" rel="external">Android系统进程Zygote启动过程的源代码分析</a><br><a href="https://www.zhihu.com/question/50828920/answer/123029345" target="_blank" rel="external">Android 应用的真正入口是哪里？</a></p>
<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>文章：<br><a href="http://droidyue.com/blog/2017/01/15/android-multiple-processes-summary/" target="_blank" rel="external">关于 Android 应用多进程的整理</a></p>
<p>书籍：<br>Android开发艺术探索——第2章 IPC机制</p>
<hr>
<h1 id="线程-多线程"><a href="#线程-多线程" class="headerlink" title="线程/多线程"></a>线程/多线程</h1><hr>
<h2 id="线程用法技巧"><a href="#线程用法技巧" class="headerlink" title="线程用法技巧"></a>线程用法技巧</h2><h3 id="判断是否为是否为主线程"><a href="#判断是否为是否为主线程" class="headerlink" title="判断是否为是否为主线程"></a>判断是否为是否为主线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInMainThread</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> Looper.myLooper() == Looper.getMainLooper();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关文章：<br><a href="http://droidyue.com/blog/2014/07/12/check-main-thread-in-android-chinese-edition/" target="_blank" rel="external">Android中检测当前是否为主线程</a></p>
<h3 id="获取线程名字"><a href="#获取线程名字" class="headerlink" title="获取线程名字"></a>获取线程名字</h3><p>Thread.currentThread();</p>
<h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>android.os.Process.myPid());    </p>
<h3 id="获取线程ID"><a href="#获取线程ID" class="headerlink" title="获取线程ID"></a>获取线程ID</h3><p>android.os.Process.myTid()); // 方式1<br>mMainThread.getId(); // 方式2</p>
<h3 id="获取线程ID-1"><a href="#获取线程ID-1" class="headerlink" title="获取线程ID"></a>获取线程ID</h3><p>Thread.currentThread().getId());</p>
<h3 id="获取用户ID"><a href="#获取用户ID" class="headerlink" title="获取用户ID"></a>获取用户ID</h3><p>android.os.Process.myUid()); </p>
<h2 id="开启子线程的2种方式"><a href="#开启子线程的2种方式" class="headerlink" title="开启子线程的2种方式"></a>开启子线程的2种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.</div><div class="line"><span class="keyword">new</span> Thread()&#123;  <span class="comment">// 开启普通的线程</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">&#125;.start();</div><div class="line"></div><div class="line"><span class="number">2</span>.</div><div class="line">ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="number">1</span>)<span class="comment">// 这种方式是开启线程池，参数给1就是开一个线程</span></div><div class="line">newFixedThreadPool.execute(<span class="keyword">new</span> TaskRunnable);</div></pre></td></tr></table></figure>
<h2 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h2><h3 id="避免ANR异常"><a href="#避免ANR异常" class="headerlink" title="避免ANR异常"></a>避免ANR异常</h3><p>英文全称：Application Not Responding<br>释义：应用程序无响应</p>
<p>解释：<br>在Android系统中, 应用程序一段时间响应不够灵敏, 系统就认为这个应用无响应, 产生ANR的异常，<br>然后系统会向用户弹出一个对话框,这个对话框叫应用程序无响应对话框.<br>用户可以选择让程序继续运行, 也可以强制终止.<br>但是一般用户在使用我们程序时, 并不希望每次都要处理这个对话框.<br>因此, 在编写程序时对响应性能的设计很重要,<br>处理好ANR, 也是提升产品体验的一个重要因素.</p>
<p>注意ANR发生的原则：<br>四大组件都运行在主线程<br>Activity   超过5秒<br>Broadcast和Service     超过10秒</p>
<p>如何避免:<br>基本的思路就是将IO操作在工作线程来处理，减少其他耗时操作和错误操作<br>不要把耗时的操作放在主线程里面执行</p>
<p>耗时的操作都应该子线程里面<br>如：<br>网络请求<br>拷贝数据库<br>大文件的读取<br>各种耗时的计算</p>
<p>其他的一些细节解决方法：<br>1.使用AsyncTask处理耗时IO操作</p>
<p>2.使用Thread或者HandlerThread时，<br>调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</p>
<p>3.使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</p>
<p>4.Activity的onCreate和onResume回调中尽量避免耗时的代码</p>
<p>5.BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。</p>
<p>6.同步改异步：耗时操作放在线程中执行防止占用主线程，一定程度上解决anr。（但需要注意线程和service结合（防止activity被回收后线程也被回收）以及线程的数量）</p>
<p>相关文章：<br><a href="http://jingyan.baidu.com/article/546ae1850504a31148f28c78.html" target="_blank" rel="external">Android开发中的ANR问题如何避免？</a><br><a href="http://droidyue.com/blog/2015/07/18/anr-in-android/" target="_blank" rel="external">说说Android中的ANR</a></p>
<h3 id="能创建基类解决问题就不用具体子类"><a href="#能创建基类解决问题就不用具体子类" class="headerlink" title="能创建基类解决问题就不用具体子类"></a>能创建基类解决问题就不用具体子类</h3><p>除需要设置优先级的线程使用new Thread创建外，其余线程创建使用new Runnable。因为子类会有自己的属性创建需要更多开销。</p>
<h3 id="Thread内存泄露"><a href="#Thread内存泄露" class="headerlink" title="Thread内存泄露"></a>Thread内存泄露</h3><p>线程也是造成内存泄露的一个重要的源头。<br>线程产生内存泄露的主要原因在于线程生命周期的不可控。</p>
<p>看一下下面是否存在问题,是否您以前也是这样用的呢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="keyword">new</span> MyThread().start();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.run();</div><div class="line">            dosomthing();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dosomthing</span><span class="params">()</span></span>&#123;</div><div class="line">                                                                    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://localhost:4000/2017/09/28/it/1.Android/Performance/" target="_blank" rel="external">在Activity中使用Thread导致的内存泄漏</a></p>
<h3 id="Threadlocal内存泄漏"><a href="#Threadlocal内存泄漏" class="headerlink" title="Threadlocal内存泄漏"></a>Threadlocal内存泄漏</h3><p>threadlocal使用不当<br>如果我们粗暴的把ThreadLocal设置null，而不调用renmove方法或者set（null）。<br>那么就可能造成Threadlocal绑定的对象长期也不能够回收，因而产生泄露</p>
<h3 id="ThreadPool替代Thread"><a href="#ThreadPool替代Thread" class="headerlink" title="ThreadPool替代Thread"></a>ThreadPool替代Thread</h3><p>在android中，我们应该尽量避免在主线程中执行耗时的操作，因而需要使用其他线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.run();</div><div class="line">            <span class="comment">//do some io work</span></div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然这些能工作，但是创建线程的代价远比普通对象要高的多，建议使用HandlerThread或者ThreadPool做替换。</p>
<p>如控制最大并发数量：<br>使用Java的Executors类，通过Executors.newFixedThreadPool(nThreads)控制线程池最大线程并发</p>
<p>详情查看自我统计的文章的线程池章节：<br><a href="http://www.hengxing.me/2017/09/06/it/1.Java/Multithreading/" target="_blank" rel="external">Java多线程并发异步的总结</a><br>或者其他牛人文章：<br><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/index.html" target="_blank" rel="external">详解 Android 中的 HandlerThread</a><br><a href="http://droidyue.com/blog/2015/12/20/worker-thread-in-android/" target="_blank" rel="external">关于Android中工作者线程的思考</a></p>
<h3 id="HandlerThread替代Thread"><a href="#HandlerThread替代Thread" class="headerlink" title="HandlerThread替代Thread"></a>HandlerThread替代Thread</h3><p>消息处理器线程类</p>
<p>单一线程 + 任务队列 处理轻量的异步任务 </p>
<p>Android提供了一个封装好的带有looper的线程类，即为HandlerThread</p>
<p>代替不停new Thread开子线程的重复体力写法</p>
<p>从Android中Thread描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread，这个类对Java的Thread做了很多便利Android系统的封装。</p>
<p>确实比较适合单线程+异步队列的场景，比如应用刚进入时的数据初始化操作，如果开启多个线程同时执行，有可能争夺UI线程的CPU执行时间，造成卡顿，这个使用使用单线程+一异步队列模型，设置优先级之后，就可以将同步工作顺序执行，而又不影响UI的初始化</p>
<p>Handler会关联一个单独的线程和消息队列。Handler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。如果要在其他线程执行，可以使用HandlerThread。<br>HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。</p>
<h4 id="HandlerThread和Thread的区别"><a href="#HandlerThread和Thread的区别" class="headerlink" title="HandlerThread和Thread的区别"></a>HandlerThread和Thread的区别</h4><p>HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。</p>
<h4 id="HandlerThread的优化点"><a href="#HandlerThread的优化点" class="headerlink" title="HandlerThread的优化点"></a>HandlerThread的优化点</h4><p>注意HandlerThread没有quit</p>
<h4 id="HandlerThread相关文章"><a href="#HandlerThread相关文章" class="headerlink" title="HandlerThread相关文章"></a>HandlerThread相关文章</h4><p><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/" target="_blank" rel="external">详解 Android 中的 HandlerThread</a><br><a href="http://droidyue.com/blog/2015/12/20/worker-thread-in-android/" target="_blank" rel="external">关于Android中工作者线程的思考</a><br><a href="http://www.3lian.com/edu/2012/11-19/44762.html" target="_blank" rel="external">Android的Handler几种常见的传值方式</a><br><a href="http://blog.sina.com.cn/s/blog_5da93c8f0101kio1.html" target="_blank" rel="external">HandlerThread，Handler，Thread使用方法 </a></p>
<h4 id="建议使用方式"><a href="#建议使用方式" class="headerlink" title="建议使用方式"></a>建议使用方式</h4><p>在 Activity 中尽可能少的创建 Handler 对象，创建一个主线程 Handler，一个后台 HandlerThread 就可以了。</p>
<h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>如果对于线程安全没有要求，尽量使用线程不安全的集合对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_process_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android —— Bitmap图片的总结</title>
    <link href="https://hengxing0080.github.io/2017/09/09/it/1.Android/Bitmap/"/>
    <id>https://hengxing0080.github.io/2017/09/09/it/1.Android/Bitmap/</id>
    <published>2017-09-09T10:12:33.000Z</published>
    <updated>2017-11-10T11:18:03.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_android_bitmap_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>Bitmap是安卓里最胖最能吃内存的对象<br>Android发生OOM百分之99都是Bitmap影响的<br>所以要避免在Bitmap这个大胖子上浪费内存</p>
<h1 id="Android手机加载大图片的原理"><a href="#Android手机加载大图片的原理" class="headerlink" title="Android手机加载大图片的原理"></a>Android手机加载大图片的原理</h1><p>当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。<br>在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。<br>需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，<br>可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的(按ARGB保存图片的每个像素)，</p>
<p>Android系统以ARGB表示每个像素：<br>如ARGB_8888：A占8位，R占8位，G占8位，B占8位；<br>一个像素就占了：8+8+8+8=32位=4个字节<br>所以每个像素占用4个字节，很容易内存溢出<br>如：480<em>800=384000<br>总共占多少位：384000</em>32=12288000bit<br>总共占多少字节：12288000bit/8=153600Byte<br>总共占多少KB：153600Byte/1024=1500KB<br>所以这样这张图片在内存中占用的大小是1500KB</p>
<p>PS:通过分辨率的像素数量也能得出是多少万像素的设备如：3264*2448=7990272（得出是800万像素的相机拍的）</p>
<p>举例1：<br>比如有张图片是1500<em>1000像素，使用的ARGB_8888颜色类型，<br>那么每个像素点就会占用4个字节，总内存就是1500</em>1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。</p>
<p>举例2：<br>手机有某一点击事件点击后加载SD卡的某张(大小为1.73M,图片分辨率为2400<em>3200，格式ARGB_8888)图片,<br>但是为了加载这张图片，虚拟机申请了30720012个字节(29M)，为什么呢？<br>分辨率像素数：2400</em>3200=7680000，<br>按照把图片的每一个像素保存在内存中，每个像素占用4个字节，那么就是：<br>7680000*4=30720000（29M数据就对上了），所以要注意！</p>
<p>android系统每个进程有最大vm限制<br>android模拟器写多少都行，不过大多数真实设备的vm最大的内存申请极限为16M -32M（不然会崩掉）<br>如果图形资源太大(分辨率太多),必须对图形资源进行处理,处理完毕后才能加载到内存.<br>如果一个手机内存是16M，加载一个大图片就要29M，所以崩了！</p>
<p>详细说下为什么BitMap占内存？<br>BitMap就是二维数组，底层存的是short类型的数组<br>数组有个特点：需要有连续的内存空间<br>比如你的应用还有空闲的16M的内存空间<br>但是这16M内存空间被各种应用各种占领不大大小的空间（16M空间被各种应用瓜分了）<br>每个空白区域找不到连续4M的内存空间<br>那么就装不下去，这个bitMap就内存溢出了<br>必须得连续，不连续就显示不出来，这是它的特点</p>
<p>如有的应用虽然占了10几M，但是也没内存溢出，<br>就是因为这个不需要连续的内存空间，只需要零散的空间，有空间就能钻进去</p>
<p>存储图片为什么为出现OOM异常？<br>由于图片在内存中是以shot数组的形式存储，并且需要连续的内存空间，<br>当内存中没有连续的内存大小，即使内存充足也会出现OOM异常.<br>Android最消耗内存的就是连续占用空间的，耗内存大户就是bitmap.<br>数组也是，但是没见过见过数组长度为100一点事都没有，<br>得1000到10000才能有连续空间的感觉，也没有人就故意去建这么长的数据</p>
<p>所以加载大图片，为了节省内存，对它进行缩放（缩小），缩放到适合这个屏幕刚刚好能显示的范围就可！</p>
<p>相关文章：<br><a href="http://dev.qq.com/topic/591d61f56793d26660901b4e" target="_blank" rel="external">安卓开踩过的坑：你的 Bitmap 究竟占多大内存？</a></p>
<hr>
<h1 id="大图片加载的OOM异常和优化解决方案"><a href="#大图片加载的OOM异常和优化解决方案" class="headerlink" title="大图片加载的OOM异常和优化解决方案"></a>大图片加载的OOM异常和优化解决方案</h1><hr>
<p>java.lang.OutOfMemoryError：内存溢出、内存泄露。<br>堆内存空间主要是给类实例、数组分配空间。<br>当图片占用的空间大于堆内存空间时就会抛出内存溢出的异常。</p>
<p>解决方案：<br>1.图片缩放<br>分析照片的尺寸，看下屏幕的尺寸，根据照片和屏幕的尺寸计算出缩放的比例，然后把图片加载到内存里<br>ListView中展示的图片缩略图，这种情况的特点是数量大，但是单个图片内存小，只有几kb，</p>
<p>2.图片压缩<br>我们主要是首先通过BitmapFactory.Options参数获取图片的宽和高，然后再根据我们ImageView的宽高对图片进行一个最大比例压缩。</p>
<p>3.图片缓存策略<br>加载大图片或数量过多的图片，因为图片是超级耗内存的，所以要记住对图片对象进行及时的回收。</p>
<p>4.图片传递<br>大图片的传递用引用的方式去减少对内存的占用：<br>如A界面把大图片传递给B界面让它处理，估计很费内存空间<br>intent.setData(Uri)<br>Uri.fromFile(); </p>
<p>5.其他细节</p>
<p>5.1.Bitmap的recycle和isRecycled方法的灵活使用<br>BItmap对象，使用完成后没有调用recycle（）方法，告诉GC优先回收<br>图片处理不好是造成内存溢出的又一个头号原因，（在我们的产品中也有体现)，<br>当我们处理完图片之后可以通过调用recycle()方法来回收图片对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!bitmap.isRecycled())  &#123;  </div><div class="line">    bitmap.recycle()  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：<br>在Activity的onDestroy时将bitmap回收<br>如果在被UI组件使用后马上进行回收会抛RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap</p>
<p>recycle方法的意义：<br>Bitmap类有一个方法recycle()，从方法名可以看出意思是回收。<br>这里就有疑问了，Android系统有自己的垃圾回收机制，可以不定期的回收掉不使用的内存空间，当然也包括Bitmap的空间。那为什么还需要这个方法呢？<br>Bitmap类的构造方法都是私有的，所以开发者不能直接new出一个Bitmap对象，只能通过BitmapFactory类的各种静态方法来实例化一个Bitmap。仔细查看BitmapFactory的源代码可以看到，生成Bitmap对象最终都是通过JNI调用方式实现的。所以，加载Bitmap到内存里以后，是包含两部分内存区域的。简单的说，一部分是Java部分的，一部分是C部分的。这个Bitmap对象是由Java部分分配的，不用的时候系统就会自动回收了，但是那个对应的C可用的内存区域，虚拟机是不能直接回收的，这个只能调用底层的功能释放。所以需要调用recycle()方法来释放C部分的内存。从Bitmap类的源代码也可以看到，recycle()方法里也的确是调用了JNI方法了的。<br>那如果不调用recycle()，是否就一定存在内存泄露呢？也不是的。Android的每个应用都运行在独立的进程里，有着独立的内存，如果整个进程被应用本身或者系统杀死了，内存也就都被释放掉了，当然也包括C部分的内存。</p>
<p>Bitmap最新情况：<br>听说自Android3.0之后，由于Bitmap被放置到了堆中，其内存由GC管理，就不需要进行释放了</p>
<p>5.2.Bitmap不要定义成静态成员变量<br>例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Bitmap bitmap = BitmapFactory.decodeFile(“/sdcard/a.jpg”);</div><div class="line"><span class="comment">//把图片转成Bitmap，如果做成static，这个位图的引用就一直在了，直到进程结束，位图才被回收掉</span></div><div class="line"><span class="comment">//如果图片非常多，一上来就报OOM异常</span></div></pre></td></tr></table></figure></p>
<p>5.3.Bitmap在WeakRefrence(弱引用)的使用<br>WeakRefrence是一个类，在ArrayList中我们把这个类作为对象传递进去，把我们的图片放在WeakRefrence里面，这样当davlik虚拟机内存不够用的时候，就会把WeakRefrence对象回收掉，这样我们在WeakRefrence里面保存的数据也被回收了。<br>例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Bitmap bitmap = <span class="keyword">new</span> Bitmap();</div><div class="line">SoftReference&lt;Bitmap&gt; sBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</div><div class="line">Bitmap bitmap2 = sBitmap.get();</div></pre></td></tr></table></figure></p>
<p>如果内存不足的时候虚拟机会把r的内存空间给释放掉<br>软引用：类似如果空间够，随便用，如果不够，就把软引用空间释放掉</p>
<p>注意：<br>这些避免内存溢出的引用方式在Android 2.3+的版本上已经不再起太大作用,<br>因为垃圾回收器会频繁回收非强引用的对象,<br>Android官方建议使用LRUCache. </p>
<p>5.4.Bitmap在onTrimMemory释放资源</p>
<p>相关参考文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="external">Android高效加载大图、多图解决方案，有效避免程序OOM</a></p>
<h1 id="图片缩放"><a href="#图片缩放" class="headerlink" title="图片缩放"></a>图片缩放</h1><p>设置一定的采样率(有开发者提供的图片无需进行采样，对于有用户上传或第三方的大小不可控图片，可进行采样减少图片所占的内存)，从服务端返回图片，建议同时反馈图片的size</p>
<p>关键字：分辨率</p>
<p>对图片进行缩小，然后再加载<br>就是要计算缩放比例</p>
<p>如：<br>计算宽需要缩放多少比例：2400/320=7<br>计算高需要缩放的比例：3200/480=6</p>
<p>如果用6缩放，那么宽缩放出来的结果是2400/6=400（但是我们的屏幕宽度是320，所以超出了）<br>所以使用7缩放，那么高说放出来的结果3200/7=457 （我们的屏幕高度是480）</p>
<p>缩放比例的几种方式：<br>1.BitmapFactory<br>用createBitmap来改变分辨率</p>
<p>2.DisplayMetrics </p>
<p>3.ImageLoader</p>
<p>4.Volley</p>
<p>5.XUtils/BitmapUtils</p>
<p>示例代码：<br>直接使用ImageView显示bitmap会占用较多资源，特别是图片较大的时候，可能导致崩溃。<br>使用BitmapFactory.Options设置inSampleSize, 这样做可以减少对系统资源的要求。<br>属性值inSampleSize表示缩略图大小为原始图片大小的几分之一，即如果这个值为2，则取出的缩略图的宽和高都是原始图片的1/2，图片大小就为原始大小的1/4。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options bitmapFactoryOptions = <span class="keyword">new</span> BitmapFactory.Options();  </div><div class="line">bitmapFactoryOptions.inJustDecodeBounds = <span class="keyword">true</span>;  </div><div class="line">bitmapFactoryOptions.inSampleSize = <span class="number">2</span>;  </div><div class="line"><span class="comment">// 这里一定要将其设置回false，因为之前我们将其设置成了true  </span></div><div class="line"><span class="comment">// 设置inJustDecodeBounds为true后，decodeFile并不分配空间，即，BitmapFactory解码出来的Bitmap为Null,但可计算出原始图片的长度和宽度  </span></div><div class="line">options.inJustDecodeBounds = <span class="keyword">false</span>; </div><div class="line">Bitmap bmp = BitmapFactory.decodeFile(sourceBitmap, options);</div></pre></td></tr></table></figure></p>
<h1 id="图片缓存策略"><a href="#图片缓存策略" class="headerlink" title="图片缓存策略"></a>图片缓存策略</h1><p>加载大图片或数量过多的图片，因为图片是超级耗内存的，所以要记住对图片对象进行及时的回收。</p>
<p>相关文章：<br><a href="http://blog.163.com/zhou_411424/blog/static/1973621562012430101610765/" target="_blank" rel="external">Android 之图片本地缓存解决方案</a></p>
<h2 id="图片的三级缓存"><a href="#图片的三级缓存" class="headerlink" title="图片的三级缓存"></a>图片的三级缓存</h2><p>图片的三级缓存流程图：<br><img src="/images/it_android_bitmap1.png" alt="UML图"></p>
<p>图片的三级缓存概念：<br>当界面请求显示图片时，会去内存中拿数据显示；<br>如果内存中没有，就从本地拿，<br>如果本地有图片就保存到内存，<br>如果本地没有图片，就去网络中获取保存在本地，再保存到内存中。</p>
<p>到内存中获取图片，是界面最快显示图片的最好的方法。</p>
<p>XUtils和Volley等等工具都是这种三级缓存思想</p>
<h2 id="强引用，软引用，弱引用，虚引用"><a href="#强引用，软引用，弱引用，虚引用" class="headerlink" title="强引用，软引用，弱引用，虚引用"></a>强引用，软引用，弱引用，虚引用</h2><p>1.强引用 : 成员变量</p>
<p>StrongReference 是 Java 的默认引用实现,<br>虚拟机不会回收：应用程序或JVM崩溃时都不会回收<br>就是我们平时使用的集合, ArrayList,hashMap, HashSet<br>引用会一直存在，即使应用资源挂了，即使内存不足抛出OOM异常也不会回收对象释放资源</p>
<p>例：<br><img src="/images/it_android_bitmap2.png" alt="UML图"><br>没初始化就会报空指针<br>但是变量不会被系统回收，应用程序崩溃都不会回收</p>
<p>在开发时绝大部分是在用强引用</p>
<p>2.软引用：SoftReference 类 ( java.lang.ref )</p>
<p>SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存</p>
<p>在API9 ( 3.0 之前) : bitmap缓存时，用软引用<br>3.0之后就不起作用了，因为3.0之前用的是davik虚拟机或者ART虚拟机（4.4后又的Androidruntime）<br>3.0之后改机制了，就不再遵循JVM的规范了，只要内存不足，不管是软引用还是弱引用，一律回收</p>
<p>例：<br><img src="/images/it_android_bitmap3.png" alt="UML图"><br>mIB一个get方法就能把imageButton给拿到了，因为是软引用，有可能是空（被系统回收了）<br>就多了一个get步骤就获得这个实例，只需用的时候判断是否为空就行了<br>和硬引用比就是多套了一层</p>
<p>建议：<br>要避免用软引用去处理缓存</p>
<p>在实践中，软引用在缓存的处理上是没有效率的。运行时没有足够的信息用于判断哪些引用要清理回收，还有哪些要保存。</p>
<p>最致命的，当同时面对清晰软引用和增加堆内存两种选择时它不知道做什么。</p>
<p>对于应用的每一个引用都缺乏有价值的信息，这一点限制了软引用让它的可用性十分有限。<br>过早清理回收的引用导致了无必要的工作，而那么过晚清理掉的引用又浪费了内存。</p>
<p>大多数应用程序应用使用一个LruCache代替软引用.<br>LruCache有一个有效的回收机制，让用户能够调整有什么内存分配.</p>
<p>简而言之，直接使用软引用缓存的话效果不咋滴，推荐使用LruCache</p>
<p>Level12以后开始引入的，为了兼容更早版本,android-support-v4包内添加了一个Lraucache类<br>所以在12版本以上用的话发现有两个包内都有这个类，其实都是一样的.</p>
<p>3.弱引用：WeakReference 类 ( java.lang.ref )</p>
<p>当jvm的回收机制运行时，就回收<br>JVM: 内存回收机制，gc运行过程中,直接回收WeakReference</p>
<p>弱引用和软引用的区别？<br>虚拟机在跑的时候内存是够了就不会回收软引用<br>但是还是这个情况，虚拟机在跑的时候注定要干掉全部的弱引用</p>
<p>在Android中引用四大组件和Fragment这些重量级对象的时候要用WeakReference，常用的场景是static Handler持有Activity。</p>
<p>4.虚引用：PhantomReference 类 ( java.lang.ref )<br>一旦使用，就回收了<br>应用场景很少, 几乎没有，级别最低<br>就是起个标记的作用（打个标记，就没了）</p>
<p>引用级别总结：<br>强引用 默认引用, 即使内存溢出,也不会回收<br>软引用 SoftReference, 内存不够时, 会考虑回收（注意3.0前后的区别）<br>弱引用 WeakReference 内存不够时, 更会考虑回收<br>虚引用 PhantomReference 内存不够时, 最优先考虑回收!</p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/" target="_blank" rel="external">译文：理解Java中的弱引用</a></p>
<h2 id="LruCache和DiskLruCache"><a href="#LruCache和DiskLruCache" class="headerlink" title="LruCache和DiskLruCache"></a>LruCache和DiskLruCache</h2><p>LruCache和DiskLruCache是采用了LRU(Least Recently Used)近期最少使用算法的两种缓存。<br>LruCache内存缓存，DiskLruCache存储设备缓存</p>
<p>内容已移至以下文章：<br><a href="http://www.hengxing.me/2017/09/07/it/1.Java/CollectionsFramework/" target="_blank" rel="external">集合框架和其他容器类的总结</a></p>
<h1 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h1><p><a href="http://blog.csdn.net/ls703/article/details/40617465" target="_blank" rel="external">Android应用开发之图片（Bitmap）压缩（三）———采样率压缩</a><br><a href="http://www.cnblogs.com/yrhua/p/3499910.html" target="_blank" rel="external">Bitmap 实现对图片压缩的2种方法小结</a></p>
<h1 id="图片转换"><a href="#图片转换" class="headerlink" title="图片转换"></a>图片转换</h1><h2 id="将view转换成bitmap"><a href="#将view转换成bitmap" class="headerlink" title="将view转换成bitmap"></a>将view转换成bitmap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureView</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> height = getStatusHeight(mContext);</div><div class="line">    Bitmap bmp1 = Bitmap.createBitmap(tempView.getWidth(), tempView.getHeight(),Bitmap.Config.ARGB_8888);</div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(bmp1);</div><div class="line">    tempView.draw(canvas);</div><div class="line">    <span class="keyword">int</span> currentapiVersion = android.os.Build.VERSION.SDK_INT;</div><div class="line">    Bitmap bmp2 = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果版本是5.0以上,要去掉状态栏</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (currentapiVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</div><div class="line">        bmp2 = Bitmap.createBitmap(bmp1, <span class="number">0</span>, height, bmp1.getWidth(), bmp1.getHeight() - height);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bmp2 = Bitmap.createBitmap(bmp1);</div><div class="line">    &#125;</div><div class="line">    bmp1.recycle();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getStatusHeight</span><span class="params">(Context ct)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> resourceId = ct.getResources().getIdentifier(<span class="string">"status_bar_height"</span>, <span class="string">"dimen"</span>, <span class="string">"android"</span>);</div><div class="line">    <span class="keyword">if</span> (resourceId &gt; <span class="number">0</span>) &#123;</div><div class="line">        result = ct.getResources().getDimensionPixelSize(resourceId);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他转换"><a href="#其他转换" class="headerlink" title="其他转换"></a>其他转换</h2><p>相关文章：<br><a href="http://www.cnblogs.com/yrhua/p/3946196.html" target="_blank" rel="external">android那些事之Bitmap、InputStream、Drawable、byte[]、Base64之间的转换关系</a></p>
<hr>
<h1 id="图片加水印"><a href="#图片加水印" class="headerlink" title="图片加水印"></a>图片加水印</h1><hr>
<p><a href="http://blog.csdn.net/dawanganban/article/details/51148070" target="_blank" rel="external">Android给图片加文字和图片水印</a></p>
<hr>
<h1 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h1><hr>
<p><a href="http://blog.csdn.net/wangsf1112/article/details/73188977" target="_blank" rel="external">android获取视频、图片时添加防盗链</a></p>
<hr>
<h1 id="加载图片的时候出现错位、重复、闪烁的解决方案"><a href="#加载图片的时候出现错位、重复、闪烁的解决方案" class="headerlink" title="加载图片的时候出现错位、重复、闪烁的解决方案"></a>加载图片的时候出现错位、重复、闪烁的解决方案</h1><hr>
<p>我们在使用ListView异步加载图片的时候，在快速滑动或者网络不好的情况下，会出现图片错位、重复、闪烁等问题，其实这些问题总结起来就是一个问题，我们需要对这些问题进行ListView的优化。</p>
<p>1.Item图片显示重复</p>
<p>这个显示重复是指当前行Item显示了之前某行Item的图片。</p>
<p>比如ListView滑动到第2行会异步加载某个图片，但是加载很慢，加载过程中ListView已经滑动到了第14行，且滑动过程中该图片加载结束。第2行已不在屏幕内，根据上面介绍的缓存原理，第2行的View对象可能被第14行复用，这样我们看到的就是第14行显示了本该属于第2行的图片，造成显示重复。</p>
<p>2.Item图片显示错乱<br>这个显示错乱是指某行Item显示了不属于该行Item的图片。<br>跟上面的原因一样。</p>
<p>3.Item图片显示闪烁<br>上面介绍的另外一种情况，如果第14行图片又很快加载结束，所以我们看到第14行先显示了复用的第2行的图片，立马又显示了自己的图片进行覆盖造成闪烁错乱。</p>
<h2 id="解决方案1：打标记"><a href="#解决方案1：打标记" class="headerlink" title="解决方案1：打标记"></a>解决方案1：打标记</h2><p>通过上面的分析我们知道了出现错乱的原因是异步加载及对象被复用造成的，如果每次getView能给对象一个标识，在异步加载完成时比较标识与当前行Item的标识是否一致，一致则显示，否则不做处理即可。<br>原理：首先给ImageView设置一个Tag，这个Tag中设置的是图片的url，然后在加载的时候取得这个url和要加载那position中的url对比，如果不相同就加载，相同就是复用以前的就不加载了。</p>
<h2 id="解决方案2：通过线程管理"><a href="#解决方案2：通过线程管理" class="headerlink" title="解决方案2：通过线程管理"></a>解决方案2：通过线程管理</h2><p>可以把线程中断，又能节省线程，节省资源，又能避免这种情况<br>Future能让线程池什么时候跑，什么时候关，就能对线程有可控性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义成员变量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExcutorService  mPool;</div><div class="line"><span class="keyword">private</span> statia Map&lt;ImageView,Future&lt;?&gt;&gt;  mFutures;</div><div class="line"></div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="keyword">if</span>(mPool == <span class="keyword">null</span>)&#123;</div><div class="line">    mPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(mFutures == <span class="keyword">null</span>)&#123;</div><div class="line">    mFutures = <span class="keyword">new</span> LinkedHashMap&lt;ImageView,Future&lt;?&gt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getBitmapFromNet</span><span class="params">(ImageView,String url)</span></span>&#123;</div><div class="line">    <span class="comment">//判断是否有线程在为imageView加载数据而执行的</span></div><div class="line">    Future&lt;?&gt; future = mFutures.get(view);</div><div class="line"></div><div class="line">    <span class="comment">//判断是否有而且没干完而且没取消</span></div><div class="line">    <span class="keyword">if</span>(future != <span class="keyword">null</span> &amp;&amp; !future.isDone() &amp;&amp; !future.isCancelled())&#123;</div><div class="line">        <span class="comment">//正在执行的被强制取消掉</span></div><div class="line">        future.cancenl(<span class="keyword">true</span>);</div><div class="line">        future = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    future = mPool.submit(<span class="keyword">new</span> ImageRequestTask(view,url));  </div><div class="line">    <span class="comment">//ImageRequest：task的运行状态对象</span></div><div class="line">    <span class="comment">//将future存起来</span></div><div class="line">    <span class="comment">//key-value key：ImageView，value：future</span></div><div class="line">    <span class="comment">//Future和callback/Runnable</span></div><div class="line">    <span class="comment">//返回值，持有正在执行的线程</span></div><div class="line">    <span class="comment">//保存</span></div><div class="line">    mFureus.put(view,future);  </div><div class="line">    <span class="comment">//这样就是把某个图对应的状态给存起来</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解决方式3：BitmapUtils"><a href="#解决方式3：BitmapUtils" class="headerlink" title="解决方式3：BitmapUtils"></a>解决方式3：BitmapUtils</h2><p>BitmapUtils模块特点：<br>加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象.</p>
<h1 id="Bitmap创建图片副本"><a href="#Bitmap创建图片副本" class="headerlink" title="Bitmap创建图片副本"></a>Bitmap创建图片副本</h1><p>在内存中创建原图的副本</p>
<ol>
<li><p>纸张完全一致<br> 前提是知道原来图形的宽高和纸张材料<br> bitmap.getWidth() 宽度<br> bitmap.getHeight() 高度<br> bitmap.getConfig() 纸张的材料<br> Bitmap.createBitmap(宽度, 高度,纸张材料);</p>
</li>
<li><p>画板和画笔<br> Canvas canvas = new Canvas(newBitmap你创建的纸张);<br> Paint paint = new Paint();<br> paint.setColor(Color.RED);</p>
</li>
<li><p>作画<br> canvas.drawBitmap(临摹的原图,matrix变化的矩阵,画笔);</p>
</li>
</ol>
<p>相关文章：<br><a href="http://blog.csdn.net/dpf1103977916/article/details/51174079" target="_blank" rel="external">Bitmap创建图片副本</a></p>
<hr>
<h1 id="Bitmap图形的变化处理"><a href="#Bitmap图形的变化处理" class="headerlink" title="Bitmap图形的变化处理"></a>Bitmap图形的变化处理</h1><hr>
<p>镜面<br>倒影<br>缩放<br>旋转<br>平移<br>透明度</p>
<h2 id="图形缩放"><a href="#图形缩放" class="headerlink" title="图形缩放"></a>图形缩放</h2><p>就是放大缩小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnBig</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line"></div><div class="line">    matrix.setScale(<span class="number">2</span>, <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth()*<span class="number">2</span>, bitmap.getHeight()*<span class="number">2</span>, bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnSmall</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResourceetResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line"></div><div class="line">    matrix.setScale(<span class="number">0.5f</span>, <span class="number">0.5f</span>);  <span class="comment">//宽一半，高一半 （+f是float类型，如果是1就表示不变）</span></div><div class="line"></div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth()/<span class="number">2</span>, bitmap.getHeight()/<span class="number">2</span>,bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="图形平移"><a href="#图形平移" class="headerlink" title="图形平移"></a>图形平移</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//左移</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnleft</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line"></div><div class="line">    dx --;</div><div class="line">    matrix.setTranslate(dx, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//右移</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line"></div><div class="line">    dx ++;</div><div class="line">    matrix.setTranslate(dx, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="图形旋转"><a href="#图形旋转" class="headerlink" title="图形旋转"></a>图形旋转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//逆时针 倒转</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnleft</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">    degrees--;</div><div class="line">    </div><div class="line">    matrix.setRotate(degrees, bitmap.getWidth(), bitmap.getHeight());</div><div class="line">    matrix.postTranslate(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth()*<span class="number">2</span>, bitmap.getHeight()*<span class="number">2</span>, bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    paint.setColor(Color.WHITE);</div><div class="line">    paint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//锯齿消除</span></div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//顺时针 正转</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnRight</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">                Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">                degrees++;</div><div class="line">                matrix.setRotate(degrees, bitmap.getWidth(), bitmap.getHeight());</div><div class="line">                matrix.postTranslate(<span class="number">30</span>, <span class="number">30</span>);</div><div class="line">                <span class="comment">//1.买一张纸</span></div><div class="line">                <span class="keyword">final</span> Bitmap newBitmap = Bitmap.</div><div class="line">createBitmap((<span class="keyword">int</span>)(bitmap.getWidth()*<span class="number">1.5</span>), (<span class="keyword">int</span>)(bitmap.getHeight()*<span class="number">1.5</span>), bitmap.getConfig());</div><div class="line">                <span class="comment">//2.买个画板</span></div><div class="line">                Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">                <span class="comment">//3.临摹作画</span></div><div class="line">                Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">                canvas.drawColor(Color.WHITE);</div><div class="line">                paint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//锯齿消除</span></div><div class="line">                paint.setColor(Color.WHITE);</div><div class="line">                canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">                runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        iv.setImageBitmap(newBitmap);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">20</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="图像透明度"><a href="#图像透明度" class="headerlink" title="图像透明度"></a>图像透明度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 显示原图</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> ImageView iv_src;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 显示副本</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> ImageView iv_copyed;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        iv_src = (ImageView) findViewById(R.id.iv_src);</div><div class="line">        iv_copyed = (ImageView) findViewById(R.id.iv_copyed);</div><div class="line">        <span class="comment">//设置原图</span></div><div class="line">        Bitmap bitmapSrc = BitmapFactory.decodeResource(getResources(), R.drawable.head);</div><div class="line">        iv_src.setImageBitmap(bitmapSrc);</div><div class="line">        <span class="comment">//不能直接对原图进行变化。--前提创建出来一个原图的拷贝（副本）</span></div><div class="line">        <span class="comment">//获取原图的纸张类型</span></div><div class="line">        Config config = bitmapSrc.getConfig();</div><div class="line">        <span class="comment">//创建的副本，里面的内容是空白的。</span></div><div class="line">        Bitmap alertBitmap = Bitmap.createBitmap(bitmapSrc.getWidth(), bitmapSrc.getHeight(), config);</div><div class="line">        <span class="comment">//以alertbitmap为模板创建一个画板。</span></div><div class="line">        Canvas canvas = <span class="keyword">new</span> Canvas(alertBitmap);</div><div class="line">        <span class="comment">//创建画笔</span></div><div class="line">        Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">        paint.setAlpha(<span class="number">20</span>);</div><div class="line">        <span class="comment">//第一个参数是临摹的图片</span></div><div class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">        canvas.drawBitmap(bitmapSrc,matrix , paint);</div><div class="line">        iv_copyed.setImageBitmap(alertBitmap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="图形的倒影效果-和-镜面效果"><a href="#图形的倒影效果-和-镜面效果" class="headerlink" title="图形的倒影效果 和 镜面效果"></a>图形的倒影效果 和 镜面效果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//倒影</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click01</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line"></div><div class="line">    matrix.setScale(<span class="number">1</span>, -<span class="number">1</span>);</div><div class="line">    matrix.postTranslate(<span class="number">0</span>, bitmap.getHeight());</div><div class="line"></div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//镜面</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click02</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.meinv);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">    matrix.setScale(-<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">    matrix.postTranslate(bitmap.getWidth(),<span class="number">0</span>);</div><div class="line">    <span class="comment">//1.买一张纸</span></div><div class="line">    Bitmap newBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());</div><div class="line">    <span class="comment">//2.买个画板</span></div><div class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(newBitmap);</div><div class="line">    <span class="comment">//3.临摹作画</span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();</div><div class="line">    canvas.drawColor(Color.WHITE);</div><div class="line">    paint.setColor(Color.BLACK);</div><div class="line">    canvas.drawBitmap(bitmap, matrix, paint);</div><div class="line">    iv.setImageBitmap(newBitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="图形的翻转效果"><a href="#图形的翻转效果" class="headerlink" title="图形的翻转效果"></a>图形的翻转效果</h2><p>待添加</p>
<h1 id="Bitmap相关面试题"><a href="#Bitmap相关面试题" class="headerlink" title="Bitmap相关面试题"></a>Bitmap相关面试题</h1><p><a href="http://blog.csdn.net/u010002184/article/details/50890767" target="_blank" rel="external">响应鼠标点击的代码实现了在单独线程中下载图片并在ImageView显示</a></p>
<h1 id="其他图片优化"><a href="#其他图片优化" class="headerlink" title="其他图片优化"></a>其他图片优化</h1><p>异步加载：<br>如果ImageView的图片是来自网络，进行异步加载</p>
<p>设置默认图片：<br>任何类型的图片，如果获取不到（例如文件不存在，或者读取文件时跑OutOfMemory异常），应该有对应的默认图片（默认图片放在在apk中，通过resid获取）；</p>
<p>Drawable：<br>ui组件需要用到的图片是apk包自带的，那么一律用setImageResource或者setBackgroundResource，而不要根据resourceid</p>
<p>注意：get(getResources(), R.drawable.btn_achievement_normal)该方法通过resid转换为drawable，需要考虑回收的问题，如果drawable是对象私有对象，在对象销毁前是肯定不会释放内存的。</p>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="http://blog.csdn.net/arui319/article/details/7953690" target="_blank" rel="external">[Android] Android开发优化之——对Bitmap的内存优化</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_android_bitmap_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Android" scheme="https://hengxing0080.github.io/categories/IT-Android/"/>
    
    
      <category term="Android" scheme="https://hengxing0080.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>集合框架和其他容器类的总结</title>
    <link href="https://hengxing0080.github.io/2017/09/07/it/1.Java/CollectionsFramework/"/>
    <id>https://hengxing0080.github.io/2017/09/07/it/1.Java/CollectionsFramework/</id>
    <published>2017-09-07T10:33:02.000Z</published>
    <updated>2017-11-08T13:54:25.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_java_collection_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="集合——简介"><a href="#集合——简介" class="headerlink" title="集合——简介"></a>集合——简介</h1><hr>
<p>集合类（集合框架,Collctions Framework, JavaSE(JDK2)特性））    </p>
<p>为什么出现集合类？<br>面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，就对对象进行存储，<br>集合就是存储对象最常用的一种方式。<br>数据多了用对象存<br>对象多了用集合存（2种方式，另一种是数组）</p>
<p>集合类的特点?<br>集合只用于存储对象，而且可以是不同类型的对象<br>集合长度是可变的<br>集合应用更广泛，没有局限性</p>
<p>数组和集合类同是容器，有何不同?<br>数组虽然也可以存储对象，但数组长度是固定的；集合长度是可变的。<br>数组中可以存储基本数据类型，集合只能存储对象。</p>
<p>集合的长度方法是：size<br>数组的长度方法是：length</p>
<p>集合存的不是对象实体，和数组一样，存储的都是对象的引用（内存地址值）</p>
<p>在安卓里常用的容器要么是list ,要么是map</p>
<p>相关文章：<br><a href="http://blog.csdn.net/suifeng3051/article/details/39005231" target="_blank" rel="external">几幅图让你认识Java集合</a><br><a href="http://blog.csdn.net/suifeng3051/article/details/49250819" target="_blank" rel="external">Java 集合概览</a></p>
<hr>
<h1 id="集合——Collection接口"><a href="#集合——Collection接口" class="headerlink" title="集合——Collection接口"></a>集合——Collection接口</h1><hr>
<p>Collection的子接口：<br>List和Set<br>这2个接口开发最为常见，其他的几乎用不着</p>
<p>Collection接口的由来：<br>集合框架是搜集共性不断向上抽取出来的体系，顶层集合是Collection，是收集集合的意思</p>
<p>集合类是工具包的成员：java.util → Collection<br>在不断抽取的过程中已经成为接口，里面全是抽象的方法<br>它有很多子类（实现类就是子类），如ArrayList<br>它有很多子接口，这里重点讲List和Set</p>
<p>为什么会出现这么多的容器呢？<br>因为每一个容器对数据的存储方式都是不同的<br>这个存储方式称之为：数据结构</p>
<p>为什么继承体系出来以后先看顶层？<br>因为顶层当中定义的都是这些体系中最共性最基础的行为，顶层看明白了，这个体系的基本功能就了解了<br>为什么看顶层，使用底层？<br>1.因为不断向上抽取出来的对象很有可能不让创建对象，因为抽象<br>2.创建子类对象方法会更多一些<br>所以看顶层，参阅底层</p>
<h2 id="Collection总结"><a href="#Collection总结" class="headerlink" title="Collection总结"></a>Collection总结</h2><p>1.List<br>元素是有序的，元素可以重复。因为该集合体系有索引。  它有3个子类对象 </p>
<p>1.1.ArrayList : 数组列表<br>底层的数据结构使用的是数组结构<br>查询速度很快，但是增删稍慢，元素越多速度越慢，元素少无所谓<br>线程不同步</p>
<p>1.2.LinkedList : 链表（链接列表）<br>底层使用的链表数据结构<br>增删速度很快<br>查询很慢（例如：1问2，2问3，3继续问它下一个诸多此类）<br>线程不同步</p>
<p>1.3.Vector：向量<br>底层是数组数据结构。<br>和ArrayList几乎一样，被ArrayList替代了。因为效率低，增删改查都是超慢<br>线程同步<br>JDK出现版本：Vector版本：1.0 ，ArrayList版本：1.2<br>Vector是元老级集合，1.0和1.1是它的时代，那时候容器就是它，它出现时还没有集合框架，集合出现版本（1.2）<br>Vector（线程同步）和ArrayList（线程不同步），前者增删查询都超慢，还是用后者效率高<br>多线程也不用Vector（因为只有它线程同步），因为可以自己加锁     </p>
<p>2.Set<br>元素是无序，元素不可以重复。该集合没有索引<br>Set集合的功能（方法）和Collection是一致的。<br>Set没有角标和特有方法</p>
<p>ArrayList和Set依赖区别：<br>ArrayList：判断元素是否存在以及删除是依赖equals的方法<br>Set：判断元素是否存在以及删除是先依赖元素的hashCode，然后equals方法</p>
<p>2.1.HashSet：哈希集合<br>底层数据结构是哈希表<br>线程不安全的（线程不同步）</p>
<p>HashSet保证元素唯一性的依据原理：<br>是通过元素的两个方法，hashCode和equals来完成。<br>如果元素的HashCode值相同，才会判断equals是否为true。<br>如果元素的hashCode值不同，不会调用equals。</p>
<p>2.2.TreeSet：树集合<br>底层数据结构是二叉树（和哈希值没关系）<br>可以对Set集合中的元素进行排序， 比如按ABCD字母顺序排名</p>
<p>TreeSet排序的第一种方式：Comparable<br>让元素自身具备比较性。<br>元素需要实现Comparable接口，覆盖compareTo方法。<br>这种方式也成为元素的自然顺序，或者叫做默认顺序。</p>
<p>TreeSet排序的第二种方式：Comparator<br>当元素自身不具备比较性时，或者具备的比较性不是所需要的。<br>这时就需要让集合（容器）自身具备比较性。<br>在集合初始化时，就有了比较方式。<br>定义了比较器Comparator，将比较器对象作为参数传递给TreeSet集合的构造函数。</p>
<p>TreeSet的二种方式的区别：<br>Comparable和Comparator的原理都是二叉树<br>Comparable和Comparator的保证元素唯一性的依据都是compareTo方法return 0（返回0就表示都是相同的，否则都是不相同）<br>Comparable是让元素自身具备比较性<br>Comparator是让容器自身具备比较性<br>如果当两种排序都存在时，以比较器为主。</p>
<h2 id="Collection方法"><a href="#Collection方法" class="headerlink" title="Collection方法"></a>Collection方法</h2><p>Collection定义了集合框架的共性功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.添加</div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span></div><div class="line">添加元素，add方法的参数类型（E）可以理解成Object，以便于接收任意类型对象。是1.5新特性的泛型</div><div class="line">类似StringBuffer的append方法，方法名不一样，功能是一样的</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </div><div class="line">一次添加一组（一堆）元素</div><div class="line"></div><div class="line">2.删除</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </div><div class="line">移除一个元素</div><div class="line">remove的底层原理调用了equals</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </div><div class="line">一次性删除一堆元素，不是全部</div><div class="line"> </div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </div><div class="line">清空容器（容器中所有元素都删掉）</div><div class="line"></div><div class="line">3.判断</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </div><div class="line">包含某个元素</div><div class="line">调用contains，实际上contains是在调用equals，这它的底层原理</div><div class="line">        </div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </div><div class="line">包含某一堆元素</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </div><div class="line">判断集合中是否有元素，长度为0了就是为空了，比如clear方法</div><div class="line"></div><div class="line">4.获取</div><div class="line">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </div><div class="line">迭代取出</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </div><div class="line">返回此 collection 中的元素数。 </div><div class="line">size为0就为空</div><div class="line"></div><div class="line">5.获取交集</div><div class="line"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </div><div class="line">取交集</div><div class="line"></div><div class="line">6.集合变数组</div><div class="line">Object[] <span class="title">toArray</span><span class="params">()</span> </div><div class="line">集合中所有元素变成数组</div><div class="line"></div><div class="line">&lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span> </div><div class="line">toArray的重载形式，T可以理解成Object，是1.5新特性的泛型</div></pre></td></tr></table></figure></p>
<h2 id="Collection子接口"><a href="#Collection子接口" class="headerlink" title="Collection子接口"></a>Collection子接口</h2><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>List集合判断元素是否相同，依据是元素的equals方法。（要记住）<br>contains，remove底层用的全都是equals方法<br>数据结构不同，依赖的方法是不一样的<br>ArrayList，LinkedList依据的都是equals方法，无论是包含还是删除</p>
<p>List增加了一些特有方法（凡是可以操作角标的方法都是该体系特有的方法）<br>但凡操作角标的都是数组原理。<br>有一个特殊的取值方式：遍历，只要有角标就能做到这点</p>
<h4 id="List的排序方式"><a href="#List的排序方式" class="headerlink" title="List的排序方式"></a>List的排序方式</h4><p>因为TreeSet是Set集合的，List没有直接排序的方式，所以集合框架提供的工具Collections来完成排序<br>List想要排序都要进行比较<br>想让对象比较，就必须要用Comparable和Comparator这2个接口<br>对象比大小，不是compareTo，就是compare</p>
<h4 id="List适用场景"><a href="#List适用场景" class="headerlink" title="List适用场景"></a>List适用场景</h4><p>元素不需要保证唯一用List</p>
<h4 id="List方法"><a href="#List方法" class="headerlink" title="List方法"></a>List方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">除拥有上述Collection共性方法，还增加了以下方法</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></div><div class="line">在指定位置插入元素</div><div class="line"> </div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </div><div class="line">在指定位置插入一堆元素</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </div><div class="line">通过索引获取 / 通过某个位置获得元素</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </div><div class="line"> 改变指定位置的元素（只有List集合具备修改功能） </div><div class="line"></div><div class="line"><span class="keyword">abstract</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </div><div class="line">返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。 </div><div class="line">包含头，不包含尾</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </div><div class="line">判断元素的位置</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object object)</span></div><div class="line"></div><div class="line"><span class="keyword">abstract</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </div><div class="line">按照角标移除（凡是带角标的，都是特有方法）</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> location)</span></div><div class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></div></pre></td></tr></table></figure>
<h4 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h4><p>1.写出3种遍历一个list的方法（使用for循环）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String s : list)&#123;</div><div class="line">    System.out.print(s+<span class="string">"/t"</span>);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</div><div class="line">   	System.out.print(list.get(i)+<span class="string">"/t"</span>);</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">for</span>(Iterator item = list.iterator();item.hasNext();)&#123;</div><div class="line">   	System.out.print(item.next()+<span class="string">"/t"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.List的5种遍历方式<br><a href="http://www.trinea.cn/android/arraylist-linkedlist-loop-performance/" target="_blank" rel="external">ArrayList和LinkedList的几种循环遍历方式及性能对比分析</a></p>
<p>3.在Java中怎么修改ArrayList()中元素的值？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>)set(索引位置,元素类型对象)</div><div class="line">(<span class="number">2</span>)get(position).现有元素值 = 最新元素值;</div></pre></td></tr></table></figure></p>
<h4 id="List子类"><a href="#List子类" class="headerlink" title="List子类"></a>List子类</h4><p>List接口下有3个实现类曾经或现在很常用：<br>ArrayList，LinkedList，Vector</p>
<h5 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h5><p>ArrayList的底层实现是Object类型的数组<br>ArrayList默认构造的数组大小是10个, 如果不够存数据能动态加数据,在加就变成15个 (按照原来一半的速度增长)</p>
<p>ArrayList几个用法的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * ArrayList练习1：android中遍历arrayList的四种方法</div><div class="line"> * 听说在android中，最好采用方法3和方法4,迭代器可能会出现内存溢出的问题（待核查）。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        list.add(<span class="string">"王五"</span>);</div><div class="line">        list.add(<span class="string">"李四"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//方法1</span></div><div class="line">        Iterator it1 = list.iterator();</div><div class="line">        <span class="keyword">while</span>(it1.hasNext())&#123;</div><div class="line">            System.out.println(it1.next());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//方法2</span></div><div class="line">        <span class="keyword">for</span>(Iterator it2 = list.iterator();it2.hasNext();)&#123;</div><div class="line">             System.out.println(it2.next());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//方法3</span></div><div class="line">        <span class="keyword">for</span>(String tmp:list)&#123;</div><div class="line">            System.out.println(tmp);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//方法4</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size(); i ++)&#123;</div><div class="line">            System.out.println(list.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * ArrayList练习2：去除ArrayList集合中的重复元素</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 定义旧的ArrayList集合</span></div><div class="line">        ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line">        al.add(<span class="string">"01"</span>);</div><div class="line">        al.add(<span class="string">"02"</span>);</div><div class="line">        al.add(<span class="string">"01"</span>);</div><div class="line">        al.add(<span class="string">"01"</span>);</div><div class="line">        al.add(<span class="string">"03"</span>);</div><div class="line">        al.add(<span class="string">"02"</span>);</div><div class="line"></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">            <span class="comment">// 在迭代时循环中next调用一次，就要hasNext判断一次。</span></div><div class="line">            sop(it.next());</div><div class="line">            <span class="comment">//	sop(it.next()+"...." + it.next());</span></div><div class="line">            <span class="comment">/*  如果写2个next方法一判断，比如上面6个注释1个剩5个就出现没有这个元素异常，偶数没问题，奇数肯定有问题，所以在这个循环中next方法就写一次  */</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sop(al);    <span class="comment">// 去掉重复前输出：[01, 02, 01, 01, 03, 02]</span></div><div class="line">        al = singleElement(al);   <span class="comment">// al传给singleElement，返回一个新集合al</span></div><div class="line">        sop(al);   <span class="comment">// 去掉重复后输出：[01, 02, 03]		</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">singleElement</span><span class="params">(ArrayList al)</span> </span>&#123;  <span class="comment">// 返回List更合适，接口，因为是父类型</span></div><div class="line">        <span class="comment">// 定义个临时容器（新的ArrayList）</span></div><div class="line">        ArrayList newAl = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">        <span class="comment">// 遍历之前的旧的ArrayList集合</span></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">            Object obj = it.next();    <span class="comment">// Object记录下一个元素</span></div><div class="line">            <span class="keyword">if</span> (!newAl.contains(obj))&#123; <span class="comment">// 如果不包含才往里存</span></div><div class="line">                newAl.add(obj);        <span class="comment">// 往新集合里存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newAl;                  <span class="comment">// 返回新集合</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">ArrayList练习3：</div><div class="line"></div><div class="line">将自定义对象作为元素存到ArrayList集合中，并去除重复元素。</div><div class="line"></div><div class="line">比如：存人对象。同姓名同年龄，视为同一个人。为重复元素，就不要存了</div><div class="line"></div><div class="line">思路：</div><div class="line">1.对人描述，将数据封装进人对象。</div><div class="line">2.定义容器，将人存入。</div><div class="line">3.取出。</div><div class="line">*/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;     </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;         </div><div class="line">    </div><div class="line">    Person(String name,<span class="keyword">int</span> age)&#123; </div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="comment">// 如果不是Person</span></div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 要更严谨的话就直接抛异常</span></div><div class="line"></div><div class="line">        <span class="comment">// 如果是Person，那么</span></div><div class="line">        Person p = (Person)obj;</div><div class="line">        <span class="comment">//	System.out.println(this.name + "..." + p.name);  // 打印equals比较过程</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">        <span class="comment">// 存入（存的不是对象，是引用地址）</span></div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">30</span>));  <span class="comment">// 因为Person类一上来就构造函数初始化2个参数（姓名和年龄），所以这里传2个参数）</span></div><div class="line">        <span class="comment">// al.add(Object obj);   // 只有Object才能接受任意对象  // Object obj = new Person("lisi01",30);</span></div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">32</span>));</div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">33</span>));</div><div class="line">        al.add(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">35</span>));</div><div class="line"></div><div class="line">        al = singleElement(al);</div><div class="line"></div><div class="line">        <span class="comment">// 取出姓名和年龄都打印出来</span></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">            Person p = (Person)it.next();</div><div class="line">            sop(p.getName() + <span class="string">"::"</span> + p.getAge());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sop(<span class="string">"remove 03 : "</span> + al.remove(<span class="keyword">new</span> Person(<span class="string">"lisi"</span>,<span class="number">33</span>)));  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">singleElement</span><span class="params">(ArrayList al)</span>  <span class="comment">// 返回List更合适，因为是父类型</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 定义个临时容器</span></div><div class="line">        ArrayList newAl = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">        <span class="comment">// 遍历老集合</span></div><div class="line">        Iterator it = al.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext())</div><div class="line">        &#123;</div><div class="line">            Object obj = it.next();   <span class="comment">// Object记录下一个元素</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span>(!newAl.contains(obj)) <span class="comment">// 如果不包含才往里存</span></div><div class="line">                newAl.add(obj);      <span class="comment">// 往新集合里存</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> newAl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h5><p>LinkedList是List接口的链接列表（链表）实现类</p>
<p>增删操作频繁，用LinkedList</p>
<p>增删操作不频繁，用ArrayList（因为大批量的增删不常见，基本都是查询，所以它作为最常用的容器存在）</p>
<p>当你不知道用什么好，建议用ArrayList，只要元素不是特多，ArrayList增删也可以允许，虽然有点慢</p>
<h6 id="LinkedList特有方法"><a href="#LinkedList特有方法" class="headerlink" title="LinkedList特有方法"></a>LinkedList特有方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>	<span class="title">addLast</span><span class="params">(E e)</span></span></div><div class="line">将指定元素添加到此列表的结尾。（添加尾）</div><div class="line"></div><div class="line"><span class="keyword">void</span>	<span class="title">addFirst</span><span class="params">(E e)</span></div><div class="line">将指定元素插入此列表的开头。  （添加头）</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">offer</span><span class="params">(E o)</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">offerFirst</span><span class="params">(E e)</span>  （1.6版本）</div><div class="line">在此列表的开头插入指定的元素。</div><div class="line">替代addLast</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">offerLast</span><span class="params">(E e)</span>   （1.6版本）</div><div class="line">在此列表末尾插入指定的元素。</div><div class="line">替代addFirst</div><div class="line"></div><div class="line">E	<span class="title">getFirst</span><span class="params">()</span></div><div class="line">返回此列表的第一个元素。</div><div class="line"></div><div class="line">E	<span class="title">getLast</span><span class="params">()</span></div><div class="line">返回此列表的最后一个元素。</div><div class="line"></div><div class="line">E	<span class="title">peek</span><span class="params">()</span></div><div class="line"></div><div class="line">E	<span class="title">peekFirst</span><span class="params">()</span>        （1.6版本）</div><div class="line">获取但不移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代getFirst</div><div class="line"></div><div class="line">E	<span class="title">peekLast</span><span class="params">()</span>         （1.6版本）</div><div class="line">获取但不移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代getLast</div><div class="line"></div><div class="line">E	<span class="title">removeFirst</span><span class="params">()</span></div><div class="line">移除并返回此列表的第一个元素。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></div><div class="line"></div><div class="line">E	<span class="title">removeLast</span><span class="params">()</span></div><div class="line">移除并返回此列表的最后一个元素。</div><div class="line"></div><div class="line"><span class="keyword">boolean</span>	<span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></div><div class="line"></div><div class="line">E	<span class="title">poll</span><span class="params">()</span></div><div class="line"></div><div class="line">E	<span class="title">pollFirst</span><span class="params">()</span>          （1.6版本）</div><div class="line">获取并移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代removeFirst</div><div class="line"></div><div class="line">E	<span class="title">pollLast</span><span class="params">()</span>           （1.6版本）</div><div class="line">获取并移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。</div><div class="line">替代removeLast</div></pre></td></tr></table></figure>
<h6 id="LinkedList示例代码"><a href="#LinkedList示例代码" class="headerlink" title="LinkedList示例代码"></a>LinkedList示例代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用LinkedList模拟一个堆栈或者队列数据结构</div><div class="line"> * 建一个基于链表的容器演示先进先出和先进后出</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuiLie</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> LinkedList link; </div><div class="line">    DuiLie()&#123;			   </div><div class="line">        link = <span class="keyword">new</span> LinkedList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAdd</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        link.addLast(obj); </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">myGet</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//	return link.removeFirst();  // 先进先出</span></div><div class="line">        <span class="keyword">return</span> link.removeLast();  <span class="comment">// 先进后出</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> link.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DuiLie dl = <span class="keyword">new</span> DuiLie();</div><div class="line">        dl.myAdd(<span class="string">"java01"</span>);   <span class="comment">// 自己的容器（基于链表的容器）</span></div><div class="line">        dl.myAdd(<span class="string">"java02"</span>);</div><div class="line">        dl.myAdd(<span class="string">"java03"</span>);</div><div class="line">        dl.myAdd(<span class="string">"java04"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!dl.isNull())&#123; <span class="comment">// 循环取出全部数据（只要不为空的情况下）</span></div><div class="line">            System.out.println(dl.myGet());</div><div class="line">            <span class="comment">// 打印先进先出</span></div><div class="line">            <span class="comment">/*	输出：java01</span></div><div class="line">                      java02</div><div class="line">                      java03</div><div class="line">                      java04	*/</div><div class="line"></div><div class="line">            <span class="comment">// 打印先进后出</span></div><div class="line">            <span class="comment">/*	输出：java04</span></div><div class="line">                      java03</div><div class="line">                      java02</div><div class="line">                      java01	*/</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h5><p>Vector现已被被ArrayList所替代</p>
<p>Vector和ArrayList的区别：<br>ArrayList和Vector都是数组结构的<br>数组结构特点：固定长度<br>集合结构特点：可变长度<br>ArrayList默认长度为10，<br>如果在添加它就会new一个新数组，长度50%延长（15），<br>然后把原来数组中的元素拷贝到新数组中，<br>再把新元素添加到后面去，<br>用它比较好，既能延长又节省空间<br>Vector长度为10，超过这数就会100%延长（20），有点浪费空间，<br>所以Vector现在已经不用了，现在一般都用ArrayList和ListedList</p>
<h6 id="Vector特有方法"><a href="#Vector特有方法" class="headerlink" title="Vector特有方法"></a>Vector特有方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span></div><div class="line">将指定的组件添加到此向量的末尾，将其大小增加 1。</div><div class="line">特有方法 （带element的全是特有方法）</div><div class="line"></div><div class="line">E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span></div><div class="line">返回指定索引处的组件 / 相当于get</div><div class="line"></div><div class="line">E <span class="title">firstElement</span><span class="params">()</span></div><div class="line">返回此向量的第一个组件（位于索引 0) 处的项）/ 获取第一个</div><div class="line"></div><div class="line">Enumeration&lt;E&gt; <span class="title">elements</span><span class="params">()</span> </div><div class="line">返回此向量的组件的枚举。</div></pre></td></tr></table></figure>
<h6 id="Vector相关接口"><a href="#Vector相关接口" class="headerlink" title="Vector相关接口"></a>Vector相关接口</h6><p>Enumeration接口（枚举）</p>
<p>枚举就是Vector特有的取出方式。<br>早期1.0版本就是这种方式，那时没有迭代，只有枚举<br>发现枚举和迭代器很像。其实枚举和迭代是一样的。<br>ArrayList没有枚举，因为除了Vector剩下的都统一用迭代器了<br>因为枚举的名称以及方法的名称都过长。<br>所以被迭代器取代了。枚举郁郁而终了。</p>
<p>此接口的功能与 Iterator 接口的功能是重复的。<br>此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。<br>新的实现应该优先考虑使用 Iterator 接口而不是 Enumeration 接口。 </p>
<p>Vector有几种取值（取出元素）方式？<br>遍历（for循环（get方法））/ 就是按角标索引)<br>迭代器<br>枚举</p>
<p>Enumeration接口方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span>：测试此枚举是否包含更多的元素。 </span></div><div class="line"></div><div class="line">E <span class="title">nextElement</span><span class="params">()</span>：如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</div></pre></td></tr></table></figure></p>
<h5 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h5><p>所属包:java.util<br>API:<a href="http://www.android-doc.com/reference/java/util/Stack.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/Stack.html</a></p>
<p>它是Vector的子类</p>
<p>Stack 类表示后进先出（LIFO）的对象堆栈。<br>它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。<br>它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。</p>
<p>相关文章：<br><a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="external">Stack的三种含义</a><br><a href="http://blog.csdn.net/android_jiangjun/article/details/39183891" target="_blank" rel="external">恶补java(十一)——-Stack类的使用</a></p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set一个不包含重复元素的collection<br>它的方法和Collection是一样的，全是共性方法，没有特有方法，直接拿来用就行了</p>
<p>常用子类有HashSet和TreeSet </p>
<h4 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h4><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/HashSet.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/HashSet.html</a></p>
<p>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示 HashSet </div><div class="line"> *</div><div class="line"> * 往HashSet集合中存入自定义对象</div><div class="line"> * 姓名和年龄相同为同一个人（重复元素）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">        System.out.println(obj);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</div><div class="line"></div><div class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"a1"</span>,<span class="number">11</span>));</div><div class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"a2"</span>,<span class="number">12</span>));</div><div class="line">        hs.add(<span class="keyword">new</span> Person(<span class="string">"a3"</span>,<span class="number">13</span>));</div><div class="line">        <span class="comment">//	hs.add(new Person("a2",12));  // 输出是无序的，而且保证唯一性</span></div><div class="line">        <span class="comment">// 每个元素都有自己不同的哈希值，在哈希表里有4个位置的存储，都存进去了就不读取equals了</span></div><div class="line">        Iterator it = hs.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">            Person p = (Person)it.next();  <span class="comment">// 强转子类（向下转型）</span></div><div class="line">            sop(p.getName() + <span class="string">"::"</span> +p.getAge());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        sop(<span class="string">"a1:"</span> + hs.contains(<span class="keyword">new</span> Person(<span class="string">"a2"</span>,<span class="number">12</span>)));</div><div class="line">        <span class="comment">// 先判断哈希值，如有有这值，所以去比较equals，最后为真，所以它认为这个值在表里是存在的</span></div><div class="line"></div><div class="line">        hs.remove(<span class="keyword">new</span> Person(<span class="string">"a3"</span>,<span class="number">13</span>));</div><div class="line">        <span class="comment">// 先算哈希值（里面没有，所以就删除了，所以就不读equals了）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    Person(String name,<span class="keyword">int</span> age) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重写hashCode方法（建立Person对象自己的哈希值方法）</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name.hashCode()+age*<span class="number">37</span>;</div><div class="line">		<span class="comment">/* 37：张三20岁，字符串哈希值40，共60</span></div><div class="line">		      李四40岁，字符串哈希值20，共60</div><div class="line">		      所以*39才能导致哈希值的不一样，让不然还得判断equals（很低效的），这样才能保证哈希值的唯一性</div><div class="line">		      当然，不能*1，别的乘什么都行，</div><div class="line">              如果乘age（hashCode()*age），因为返回值是int，有可能超出int范围，所以还是乘37比较靠谱 		  */</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重写equals</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Person p = (Person)obj;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</div><div class="line">        <span class="comment">// 判断是否为1个对象：姓名和年龄是否都相同是视为同一个对象（名字用equals方法比较，年龄用等于号比较）</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h4><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/TreeSet.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/TreeSet.html</a></p>
<h5 id="TreeSet相关接口"><a href="#TreeSet相关接口" class="headerlink" title="TreeSet相关接口"></a>TreeSet相关接口</h5><h6 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h6><p>中文名：比较接口<br>所属包：java.lang<br>在线API：<a href="http://www.android-doc.com/reference/java/lang/Comparable.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/lang/Comparable.html</a></p>
<p>此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然（默认）排序，类的 compareTo 方法被称为它的自然比较方法。</p>
<p>Java中很多东西具备比较性就是这东西，比如String和Integer都实现了Comparable接口（在描述的时候就已经具备了可比性）</p>
<p>方法摘要：此接口只有一个方法<br>int compareTo(T o) ：比较此对象与指定对象的顺序。    </p>
<h6 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h6><p>中文名：比较器接口<br>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/Comparator.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/Comparator.html</a></p>
<p>方法摘要：此接口也只有一个方法<br>int compare(T o1, T o2) ：比较用来排序的两个参数。 </p>
<h5 id="TreeSet示例代码"><a href="#TreeSet示例代码" class="headerlink" title="TreeSet示例代码"></a>TreeSet示例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示TreeSet1：TreeSet输出的结果按字典顺序排序</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    TreeSet ts = <span class="keyword">new</span> TreeSet();</div><div class="line">    ts.add(<span class="string">"abc"</span>);</div><div class="line">    ts.add(<span class="string">"cba"</span>);</div><div class="line">    ts.add(<span class="string">"bva"</span>);</div><div class="line">    ts.add(<span class="string">"zva"</span>);</div><div class="line">    ts.add(<span class="string">"DDA"</span>);</div><div class="line">    Iterator it = ts.iterator();</div><div class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">      System.out.println(it.next());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// TreeSet输出的结果按字典顺序（字母的自然顺序，ASCII表）给排序了，怎么挪结果都一样</span></div><div class="line">    <span class="comment">/* 输出：</span></div><div class="line">        DDA</div><div class="line">        abc</div><div class="line">        bva</div><div class="line">        cba</div><div class="line">        zva   */</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示 TreeSet2 —— Comparable接口</div><div class="line"> * </div><div class="line"> * 需求：</div><div class="line"> * 往TreeSet集合中存储自定义对象学生。</div><div class="line"> * 想按照学生的年龄进行排序</div><div class="line"> *</div><div class="line"> * 思路：</div><div class="line"> * 重点在于实现Comparable接口，复写ComparTo方法（在里面判断主要条件（年龄）和次要条件（姓名））</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo2</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet();</div><div class="line"></div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list02"</span>,<span class="number">22</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list07"</span>,<span class="number">20</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list09"</span>,<span class="number">19</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list08"</span>,<span class="number">19</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Studen(<span class="string">"list01"</span>,<span class="number">40</span>));</div><div class="line"></div><div class="line">        Iterator it = ts.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">            Studen str = (Studen)it.next();</div><div class="line">            System.out.println(str.getName() + <span class="string">"..."</span> + str.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123; <span class="comment">// 实现Comparable接口，该接口强制让学生具备比较性</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    Student(String name,<span class="keyword">int</span> age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123; </div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))&#123; </div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不是学生对象"</span>);</div><div class="line">        &#125;</div><div class="line">        Student s = (Student)obj;   </div><div class="line"></div><div class="line">        <span class="comment">// 判断主要条件排序（先判断年龄）</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; s.age) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 正整数 返回 大于 指定对象</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 判断次要条件排序（当年龄相同的情况下在判断姓名）</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age == s.age) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);   </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 负整数 返回 小于 指定对象</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示 TreeSet3 —— Comparator接口</div><div class="line"> *</div><div class="line"> * 需求：</div><div class="line"> * 接上一示例代码，在不允许改代码的前提下按姓名排序（把名字相同和年龄不相同的对象存进去）</div><div class="line"> * </div><div class="line"> * 分析：</div><div class="line"> * 当元素自身不具备比较性，或者具备的比较性不是所需要的。</div><div class="line"> * 这时需要让容器自身具备比较性。</div><div class="line"> * 定义了比较器Comparator，复写Compare方法，主要判断名字，次要判断年龄</div><div class="line"> * 将比较器对象作为参数传递给TreeSet集合的构造函数。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo3</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyCompare());    <span class="comment">// 比较器对象 传给这个构造函数</span></div><div class="line">        <span class="comment">//	TreeSet ts = new TreeSet();  // 如果不传比较器对象，那么打印结果是按年龄排序</span></div><div class="line">        <span class="comment">// 当两种排序都存在时，以比较器为主</span></div><div class="line"></div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi02"</span>,<span class="number">22</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi02"</span>,<span class="number">21</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi007"</span>,<span class="number">20</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi09"</span>,<span class="number">19</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi06"</span>,<span class="number">18</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi06"</span>,<span class="number">18</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi007"</span>,<span class="number">29</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi007"</span>,<span class="number">20</span>));</div><div class="line">        ts.add(<span class="keyword">new</span> Student(<span class="string">"lisi01"</span>,<span class="number">40</span>));</div><div class="line"></div><div class="line">        Iterator it = ts.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">            Student stu = (Student)it.next();</div><div class="line">            System.out.println(stu.getName() + <span class="string">"..."</span> + stu.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123; <span class="comment">// 自定义比较器类 实现 比较器接口</span></div><div class="line">    </div><div class="line">    <span class="comment">// 覆盖compare方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1,Object o2)</span></span>&#123; <span class="comment">// 因为比较器是给集合比较，可得出必须是2个参数以上互相比较才成立</span></div><div class="line">        </div><div class="line">        <span class="comment">// MyCompare继承了Object，里面已有equals，所以不用覆盖，直接用就行</span></div><div class="line">        <span class="comment">// 我们这里用return 0判断</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!(o1 <span class="keyword">instanceof</span> Person)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!(o2 <span class="keyword">instanceof</span> Person)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">        &#125;</div><div class="line">        Student s1 = (Student)o1;</div><div class="line">        Student s2 = (Student)o2;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = s1.getName().compareTo(s2.getName()); </div><div class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(s1.getAge()).compareTo(<span class="keyword">new</span> Integer(s2.getAge()));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    Student(String name,<span class="keyword">int</span> age) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不是学生对象"</span>);</div><div class="line">        Student s = (Student)obj;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; s.age)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.age == s.age) </div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 演示 TreeSet 4</div><div class="line"> *</div><div class="line"> * 练习：练习字符串长度排序（从短到长）</div><div class="line"> * </div><div class="line"> * 分析：字符串本身具备比较性，但是它的比较方法不是所需要的</div><div class="line"> * 		这时就只能使用比较器（比较器更为方便更为常见一些）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo4</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> StrLenComparator());  </div><div class="line"></div><div class="line">        ts.add(<span class="string">"abcs"</span>);</div><div class="line">        ts.add(<span class="string">"cc"</span>);</div><div class="line">        ts.add(<span class="string">"cba"</span>);</div><div class="line">        ts.add(<span class="string">"aaa"</span>);</div><div class="line">        ts.add(<span class="string">"z"</span>);</div><div class="line">        ts.add(<span class="string">"hahahas"</span>);</div><div class="line"></div><div class="line">        Iterator it =ts.iterator();</div><div class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">            System.out.println(it.next());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrLenComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">        String s1 = (String)o1;   </div><div class="line">        String s2 = (String)o2;</div><div class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Integer(s1.length()).compareTo(<span class="keyword">new</span> Integer(s2.length()));  <span class="comment">// 判断主要条件（长度）</span></div><div class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)  <span class="comment">// 判断次要条件（之前测试可以看出长度一样，内容不一样的字符串没有存进去，所以还要继续判断次要）</span></div><div class="line">            <span class="keyword">return</span> s1.compareTo(s2); <span class="comment">// 返回 比较字符串的自然顺序</span></div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><h4 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h4><p>相关文章：<br><a href="http://jackyrong.iteye.com/blog/1995300" target="_blank" rel="external">EnumSet</a></p>
<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><h4 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a>NavigableSet</h4><hr>
<h1 id="集合——Map接口"><a href="#集合——Map接口" class="headerlink" title="集合——Map接口"></a>集合——Map接口</h1><hr>
<p>定义：<br>Map是将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。<br>简单来说就是该集合存储键值对。一对一对往里存。而且要保证键的唯一性。</p>
<p>简介：<br>Map和Collection一样，都属于集合框架的顶层接口，两者没有外观的必然联系，不过内部是有联系的<br>Map和Set很像，其实Set底层就是使用了Map集合。</p>
<p>Map：双列集合，里面存的都是地址（引用），左边键，右边值）<br>Set：单列集合，存的还是引用，集合中键都存里了(所在的Collection都是单列集合)<br>K：Key（键）<br>V：Value（值）<br>它们之间是映射关系<br>这种键值对存储的方式是最多最常见最频繁的，而且是成对出现<br>ArrayList是给元素给索引的<br>Map可以直接给元素起名字都行</p>
<h2 id="Map总结"><a href="#Map总结" class="headerlink" title="Map总结"></a>Map总结</h2><p>Map集合有3个小弟</p>
<p>1.Hashtable<br>哈希表<br>底层是哈希表数据结构<br>不可以存入null键null值（空键空值）<br>该集合是线程同步的<br>jdk1.0 （元老级特点：同步）<br>效率低<br>HashMap中有contains（）方法<br>数组初始化大小和扩容方式：HashTable中hash数组默认大小是11，增加的方式是 old*2+1<br>继承的类不一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></div></pre></td></tr></table></figure></p>
<p>2.HashMap<br>底层是哈希表数据结构<br>允许使用 null 值和 null 键（和Hashtable的最大区别）<br>该集合是线程不同步的<br>将hashtable替代<br>jdk1.2<br>效率高<br>无序<br>数组初始化大小和扩容方式：HashMap中hash数组的默认大小是16，而且一定是2的指数<br>HashMap中没有contains（）方法<br>继承的类不一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></div></pre></td></tr></table></figure></p>
<p>3.TreeMap<br>底层是二叉树数据结构<br>线程不同步<br>可以用于给map集合中的键进行排序</p>
<h2 id="Map方法"><a href="#Map方法" class="headerlink" title="Map方法"></a>Map方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. 添加元素</div><div class="line">put(K key, V value) 添加单个，相当于add方法. 特殊的地方：如果存进去有相同的值，新值替换老值</div><div class="line">putAll(Map&lt;? extends K,? extends V&gt; m)  添加多个</div><div class="line"></div><div class="line"><span class="number">2</span>. 删除元素</div><div class="line">clear() </div><div class="line">remove(Object key)          根据键来删除元素，因为键唯一</div><div class="line"></div><div class="line"><span class="number">3</span>. 判断元素</div><div class="line">containsKey(Object key)     是否包含某个键</div><div class="line">containsValue(Object value) 是否包含某个值</div><div class="line">isEmpty() </div><div class="line"></div><div class="line"><span class="number">4</span>. 获取元素</div><div class="line">get(Object key)   给我一个键，我告你对应的值</div><div class="line">size() </div><div class="line">values()    获取值</div><div class="line">keySet()    返回此映射中包含的键的 Set 视图。 </div><div class="line">entrySet()  返回此映射中包含的映射关系的 Set 视图。</div></pre></td></tr></table></figure>
<h2 id="Map集合的所有元素的两种取出方式"><a href="#Map集合的所有元素的两种取出方式" class="headerlink" title="Map集合的所有元素的两种取出方式"></a>Map集合的所有元素的两种取出方式</h2><p>Map集合的取出原理：<br>将Map集合转成Set集合,在通过迭代器取出。</p>
<p>Map集合的两种取出方式：<br>keySet<br>entrySet</p>
<h3 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h3><p>将map中所有的键存入到Set集合。<br>因为Set具备迭代器,<br>用迭代方式取出所有的键，在根据get方法.获取每一个键对应的值。</p>
<h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h3><p>将Map集合中映射关系取出，存入到Set集合中<br>通过迭代返回来的对象里面既有键又有值，所以封装了方法（getKey和getValue）就能取到键和值.</p>
<p>Map.Entry:<br>将Map集合中的映射关系存入到了Set集合中，<br>而这个关系的数据类型就是：Map.Entry<br>Entry其实就是Map中的一个static内部接口。<br>接口中可以定义内部接口<br>为什么把Entry定义成Map的子接口呢？为什么不定义在外面？<br>Entry代表映射关系，先有Map集合才有映射关系，这个关系是Map集合内部的事务，<br>只有有了Map集合才能有关系，那么这个关系就是Map集合内部的事务，<br>而且Entry这个关系直接访问Map集合中的元素，所以把Entry定义内部规则</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo1</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</div><div class="line"></div><div class="line">      map.put(<span class="number">01</span>, <span class="string">"zhangsan1"</span>);</div><div class="line">      map.put(<span class="number">02</span>, <span class="string">"zhangsan2"</span>);</div><div class="line">      map.put(<span class="number">03</span>, <span class="string">"zhangsan3"</span>);</div><div class="line">      map.put(<span class="number">04</span>, <span class="string">"zhangsan4"</span>);</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line">       * 1.KeySet方法</div><div class="line">       */</div><div class="line">      <span class="comment">// 1.1.普通方式</span></div><div class="line">      Iterator&lt;Integer&gt; it = map.keySet().iterator();</div><div class="line">      <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">        Integer key = it.next();  <span class="comment">// 有了键就能通过map集合的get方法获取其对应的值</span></div><div class="line">        String value = map.get(key);</div><div class="line">        System.out.println(<span class="string">"key+"</span>+key+<span class="string">",value"</span>+value);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 1.2.高级for循环方式</span></div><div class="line">      <span class="keyword">for</span>(Integer in : map.keySet()) &#123;</div><div class="line">          System.out.println(in+<span class="string">":"</span>+map.get(in));</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/*</span></div><div class="line">       * 2.EntrySet方法</div><div class="line">       */</div><div class="line">      <span class="comment">// 2.1.普通方式</span></div><div class="line">      Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; itr = map.entrySet().iterator(); </div><div class="line">      <span class="keyword">while</span>(itr.hasNext()) &#123;</div><div class="line">        Map.Entry&lt;Integer, String&gt; me = itr.next();  <span class="comment">// 返回值是Map.Entry对象（而且还带着泛型）</span></div><div class="line">        Integer key = me.getKey();</div><div class="line">        String value = me.getValue();</div><div class="line">        System.out.println(key + <span class="string">":"</span> + value);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 2.2.高级for循环方式</span></div><div class="line">      <span class="keyword">for</span>(Map.Entry&lt;Integer,String&gt; me : map.entrySet())&#123;</div><div class="line">          System.out.println(me.getKey()+<span class="string">":"</span>+me.getValue());</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="HashMap的四种循环遍历方式"><a href="#HashMap的四种循环遍历方式" class="headerlink" title="HashMap的四种循环遍历方式"></a>HashMap的四种循环遍历方式</h3><p><a href="http://www.trinea.cn/android/hashmap-loop-performance/" target="_blank" rel="external">HashMap循环遍历方式及其性能对比</a></p>
<h2 id="Map子类"><a href="#Map子类" class="headerlink" title="Map子类"></a>Map子类</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/HashMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/HashMap.html</a><br>现状：在Android中被SparseArray和ArrayMap替代</p>
<p>简介：<br>HashMap为键值对数据结构<br>hash系列数据结构查询速度更优</p>
<h4 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h4><p>HashMap内部是通过数组实现的，而数组的每一位都是Entry的对象，这个Entry实际上是一个链表的节点。<br>数据结构有讲过<br>根据hash算法，求出当前key应该存放在数组的那个index处，如果有值了，则存在index所在Entry所在链表相邻的下一个位置。<br><img src="/images/it_java_collection1.png" alt="UML图"></p>
<p><a href="http://blog.csdn.net/ustcbob/article/details/23709589" target="_blank" rel="external">HashMap的底层实现</a></p>
<h4 id="自己实现HashMap如何防止value覆盖-如何哈希冲突怎么办"><a href="#自己实现HashMap如何防止value覆盖-如何哈希冲突怎么办" class="headerlink" title="自己实现HashMap如何防止value覆盖/如何哈希冲突怎么办"></a>自己实现HashMap如何防止value覆盖/如何哈希冲突怎么办</h4><p>Volley缓存文件名的计算原理：<br>把一个key分成两部分，分别求hashCode，最后又做拼接。<br>为什么会要把一个key分成两部分。现在可以肯定的答出，目的是为了尽可能避免hashcode重复造成的文件名重复(求两次hash两次都与另一个url重复的概率总要比一次重复的概率小吧)。</p>
<p>相关文章：<br><a href="https://kymjs.com/code/2016/03/08/01/" target="_blank" rel="external">面试后的总结</a></p>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历HashMap的最佳方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMap</span><span class="params">(Map mp)</span> </span>&#123;</div><div class="line">    Iterator it = mp.entrySet().iterator();</div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">        Map.Entry pair = (Map.Entry)it.next();</div><div class="line">        System.out.println(pair.getKey() + <span class="string">" = "</span> + pair.getValue());</div><div class="line">        <span class="comment">// it.remove(); // avoids a ConcurrentModificationException</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/TreeMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/TreeMap.html</a></p>
<p>定义：<br>基于红黑树的Map实现。该映射英剧其键的自然顺序进行排序，或者根据创建映射时提供的Comparator进行排序，具体取决于使用的构造方法。</p>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>演示1：<br>每一个学生都有对应的归属地。<br>学生Student，地址String。</p>
<p>学生属性：姓名，年龄。<br>注意：姓名和年龄相同的视为同一个学生（重复元素）<br> 保证学生的唯一性（键不能重复，值可以重复）</p>
<p>1.描述学生。<br>2.定义map容器。将学生作为键，地址作为值。存入。<br>3.获取map集合中的所有元素。</p>
<p>记住，像这种同时创建多个对象需要被用的时候，一共要3个动态（实现Comparable接口，覆盖hashCode方法，覆盖equals方法）<br>如果Comparable和Comparator同时存在，那么最终以比较器为主<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapDemo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 自定义一个容器TreeMap，而且让它具备比较性</span></div><div class="line">    TreeMap&lt;Student,String&gt; hm = <span class="keyword">new</span> TreeMap&lt;Student,String&gt;(<span class="keyword">new</span> StuNameComparator()); </div><div class="line">    </div><div class="line">    hm.put(<span class="keyword">new</span> Student(<span class="string">"alisi"</span>,<span class="number">21</span>),<span class="string">"beijing"</span>);</div><div class="line">    hm.put(<span class="keyword">new</span> Student(<span class="string">"lisi"</span>,<span class="number">23</span>),<span class="string">"nanjing"</span>);</div><div class="line">    hm.put(<span class="keyword">new</span> Student(<span class="string">"blisi"</span>,<span class="number">22</span>),<span class="string">"shanghai"</span>);</div><div class="line">    hm.put(<span class="keyword">new</span> Student(<span class="string">"blisi"</span>,<span class="number">22</span>),<span class="string">"tianjin"</span>);     <span class="comment">// 重复的被去掉了（新的覆盖旧的），因为访回0了（比较器中）</span></div><div class="line">    hm.put(<span class="keyword">new</span> Student(<span class="string">"lisi"</span>,<span class="number">24</span>),<span class="string">"wuhan"</span>);</div><div class="line">    </div><div class="line">    Set&lt;Map.Entry&lt;Student,String&gt;&gt; entrySet = tm.entrySet();</div><div class="line">    Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = entrySet.iterator();</div><div class="line">    <span class="keyword">while</span>(it.hasNext)&#123;</div><div class="line">      Map.Entry&lt;Student, String&gt; me = it.next();</div><div class="line">      Student stu = me.getKey();</div><div class="line">      String addr = me.getValue();</div><div class="line">      System.out.println(stu +<span class="string">"：："</span> +addr);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 自定义姓名比较器</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StuNameComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1,Student s2)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> num = s1.getName().compareTo(s2.getName()); <span class="comment">// 首要条件：姓名排序</span></div><div class="line">    <span class="keyword">if</span>(num == <span class="number">0</span>)  <span class="comment">// 次要条件：如果姓名相同，就按年龄排序</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Integer(s1.getAge()).compareTo(<span class="keyword">new</span> Integer(s2.getAge()));</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">  Student(String name,<span class="keyword">int</span> age) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name;   </div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> name +<span class="string">":"</span>+ age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> name.hashCode()+age*<span class="number">34</span>;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Student))   <span class="comment">// 如果obj不是Student类型才能强转</span></div><div class="line">    <span class="comment">//  return new RuntimeException("类型不匹配");  // RuntimeException：运行时异常的父类</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(<span class="string">"类型不匹配"</span>);   <span class="comment">// RuntimeException子类（类型转换异常）</span></div><div class="line">    Student s = (Student) obj ;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(s.name) &amp;&amp; <span class="keyword">this</span>.age==s.age;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 复写compareTo方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student s)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> num = <span class="keyword">new</span> Integer(<span class="keyword">this</span>.age).compareTo(<span class="keyword">new</span> Integer(s.age));</div><div class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(s.name);</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>演示2：TreeMap练习2-字母出现的次数<br>“sdfgzxcvasdfxcvdf”获取该字符串中的字母出现的次数。<br>希望打印结果：a(1)c(2)…..</p>
<p>通过结果发现，每一个字母都有对应的次数。<br>说明字母和次数之间都有映射关系。</p>
<p>注意，当发现有映射关系时，可以选择map集合。<br>因为map集合中存放就是映射关系。</p>
<p>什么时候使用map集合呢？<br>当数据之间存在这映射关系时，就要先想到map集合。</p>
<p>思路：<br>1.将字符串转换成字符数组。因为要对每一个字母进行操作。<br>2.定义一个map集合，因为打印结果的字母有顺序，所以使用TreeMap集合。<br>3.遍历字符数组。<br>将每一个字母作为键去查map集合。<br>如果返回null，将该字母和1存入到map集合中。<br>如果返回不是null，说明该字母在map集合已经存在并有对应次数。<br>那么就获取该次数并进行自增。然后将该字母和自增后的次数存入到map集合中。<br>覆盖调用原理键所对应的值。<br>4.将map集合中的数据变成指定的字符串形式返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest3</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    String s = charCount(<span class="string">"aabfcdabcdefa"</span>);  <span class="comment">// 结果返回一个字符串</span></div><div class="line">    System.out.println(s);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">charCount</span><span class="params">(String str)</span></span>&#123;</div><div class="line">    <span class="comment">// 将字符串转换成字符数组（因为要对每一个字母进行操作）</span></div><div class="line">    <span class="keyword">char</span>[] chs = str.toCharArray();</div><div class="line">    </div><div class="line">    <span class="comment">// 定义一个map集合，因为打印结果的字母有顺序，所以使用TreeMap集合</span></div><div class="line">    TreeMap&lt;Character,Integer&gt; tm = <span class="keyword">new</span> TreeMap&lt;Character,Integer&gt;();</div><div class="line">    <span class="comment">// 泛型类接收的都是引用数据类型，所以要找到对应的基本数据类型包装类，所以是&lt;Character,Integer&gt;，不能存char和int</span></div><div class="line">    <span class="comment">// Character：字母作为键，Integer：次数作为值</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 定义个变量，拿这个变量去记录value</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;chs.length; x++)&#123;</div><div class="line">      <span class="keyword">if</span>(!(chs[x]&gt;=<span class="string">'a'</span>  &amp;&amp;  chs[x]&lt;=<span class="string">'z'</span>  ||  chs[x] &gt;=<span class="string">'A'</span>  &amp;&amp;  chs[x]&lt;=<span class="string">'Z'</span>))  &#123;</div><div class="line">        <span class="keyword">continue</span>;  <span class="comment">// 不是的继续循环</span></div><div class="line">      &#125; </div><div class="line">      Integer value = tm.get(chs[x]);  <span class="comment">// x这个字母作为键去找这个集合返回来一个值</span></div><div class="line">      <span class="keyword">if</span>(value != <span class="keyword">null</span>)&#123;      <span class="comment">// 如果value不等于空的情况下就用一个变量把你记住，记录完以后就把变量自增一次（0到1的过程）</span></div><div class="line">        count = value;</div><div class="line">      &#125;</div><div class="line">      count++;</div><div class="line">      tm.put(chs[x], count);  <span class="comment">// 直接往集合中存储字符和数字，为什么可以，因为自动装箱。</span></div><div class="line">      count = <span class="number">0</span>;              <span class="comment">// count用完一次要清零（如a自增完了，然后b这个字母进来后用的还是这个count）</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 希望打印结果：a(1)c(2).....</span></div><div class="line">    <span class="comment">// 遍历后存起来，用容器存：缓冲区什么类型都能弄放，而且最终都变成字符串</span></div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; it = ts.entrySet().iterator();  </div><div class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">      Map.Entry&lt;Character, Integer&gt; me = it.next();</div><div class="line">      Character ch = me.getKey();</div><div class="line">      Integer value = me.getValue();</div><div class="line">      sb.append(ch +<span class="string">"("</span>+value+<span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sb.toString();  <span class="comment">// 因为sb是StringBuilder类型，所以必须要写toString</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/Hashtable.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/Hashtable.html</a><br>现状：被HashMap替代</p>
<p><a href="http://www.cnblogs.com/wuqinglong/p/5746473.html" target="_blank" rel="external">HashMap和HashTable的区别</a></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/Properties.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/Properties.html</a></p>
<p>因为继承Hashtable，可以用Map的方法（集合和IO相结合的容器））<br>这个集合的特点是和流相结合</p>
<p>相关文章：<br><a href="http://blog.csdn.net/riskys/article/details/52548739" target="_blank" rel="external">AndroidStudio使用properties资源文件</a></p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/LinkedHashMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/LinkedHashMap.html</a></p>
<p>相关文章：<br><a href="http://mmqzlj.blog.51cto.com/2092359/550631" target="_blank" rel="external">关于HashMap和LinkedHashMap的工作心得</a></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>直接使用HashMap有时候会带来内存溢出的风险，使用WeakHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象</p>
<p>WeakHashMap中元素可在适当时候被系统垃圾回收器自动回收，所以适合在内存紧张型中使用。<br>相关文章：<br><a href="http://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/" target="_blank" rel="external">译文：理解Java中的弱引用</a></p>
<h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/SortedMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/SortedMap.html</a></p>
<p>相关文章：<br><a href="http://blog.csdn.net/lishengbo/article/details/6193509" target="_blank" rel="external">使用SortedMap对HashMap排序</a></p>
<h3 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a>NavigableMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/NavigableMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/NavigableMap.html</a></p>
<p>相关文章：<br><a href="http://blog.csdn.net/xymyeah/article/details/6371448" target="_blank" rel="external">java.util.NavigableSet和NavigableMap</a></p>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/EnumMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/EnumMap.html</a></p>
<p>相关文章：<br><a href="http://blog.csdn.net/cuidiwhere/article/details/21995363" target="_blank" rel="external">EnumMap学习</a></p>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/IdentityHashMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/IdentityHashMap.html</a></p>
<p>相关文章：<br><a href="http://jiangwenfeng762.iteye.com/blog/1621555" target="_blank" rel="external">IdentityHashMap</a><br><a href="http://blog.csdn.net/lee576/article/details/7299897" target="_blank" rel="external">初学Java,IdentityHashMap实现类(三十三)</a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>所属包：java.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/concurrent/ConcurrentHashMap.html</a></p>
<p>ConcurrentHashMap融合了hashtable和hashmap二者的优势。<br>ConcurrentHashMap为细分锁，锁粒度更小，并发性能更优，采用分段加锁的机制来确保安全</p>
<p><a href="http://blog.csdn.net/wisgood/article/details/19338693" target="_blank" rel="external">Hashtable与ConcurrentHashMap区别</a></p>
<hr>
<h1 id="集合——迭代器"><a href="#集合——迭代器" class="headerlink" title="集合——迭代器"></a>集合——迭代器</h1><hr>
<p>什么是迭代器呢？<br>其实就是集合的取出元素的方式（和遍历是一样的（有元素就拿一个，没有就不拿了））<br>如同抓娃娃游戏机中的夹子。</p>
<p>迭代器是取出方式，会直接访问集合中的元素。<br>所以将迭代器通过内部类的形式来进行描述。<br>通过容器的iterator()方法获取该内部类的对象。</p>
<h2 id="迭代器为何单独出来而不集成在集合类中"><a href="#迭代器为何单独出来而不集成在集合类中" class="headerlink" title="迭代器为何单独出来而不集成在集合类中"></a>迭代器为何单独出来而不集成在集合类中</h2><p>就是把取出方式定义在集合的内部，<br>这样取出放啊是就可以直接访问集合内容的元素。<br>那么取出方式就被定义了内部类。</p>
<p>而每一个容器的数据结构不同，<br>所以取出的动作细节也不一样。<br>但是都有共性内容判断和取出。<br>那么可以将这么共性抽取。</p>
<p>那么这些内部类都符合一个规则。<br>该规则是Iterator。<br>如果获取集合的取出对象呢？<br>通过一个对外提供的方法：iteraotr();</p>
<h2 id="Iterator方法"><a href="#Iterator方法" class="headerlink" title="Iterator方法"></a>Iterator方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>：如果仍有元素可以迭代，则返回 <span class="keyword">true</span></span></div><div class="line"><span class="keyword">abstract</span> E <span class="title">next</span><span class="params">()</span>：返回迭代的下一个元素</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span>：从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）</div></pre></td></tr></table></figure>
<h2 id="Iterator示例"><a href="#Iterator示例" class="headerlink" title="Iterator示例"></a>Iterator示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    method_get();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method_get</span><span class="params">()</span></span>&#123;</div><div class="line">    ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line">    al.add(<span class="string">"java01"</span>);</div><div class="line">    al.add(<span class="string">"java02"</span>);</div><div class="line">    al.add(<span class="string">"java03"</span>);</div><div class="line">    al.add(<span class="string">"java04"</span>);</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// 迭代器写法1</span></div><div class="line">    <span class="comment">// 缺点：这种写法结局就是it还在内存中，它在也代表对象也在内存中，但是迭代器用完结束了</span></div><div class="line">    <span class="comment">// 优点：代码短，格式容易阅读</span></div><div class="line">    Iterator it = al.iterator();</div><div class="line">    <span class="comment">// iterator方法返回的是iterator的子类对象（Iteraotr接口）</span></div><div class="line">    <span class="comment">// 接口型引用只能指向自己的子类对象，而这个对象不是new出来的，是通过集合的方法获取出来的</span></div><div class="line">    <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">// 获取迭代器，用于取出集合中的元素。</span></div><div class="line">      sop(it.next());</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 迭代器写法2</span></div><div class="line">    <span class="comment">// 优点：it是for的局部变量，for完it就被释放了，这么写对内存优化一些</span></div><div class="line">    <span class="comment">// 缺点：代码长，阅读性差</span></div><div class="line">    <span class="comment">// 建议：还是写这个比较正规</span></div><div class="line">    <span class="keyword">for</span>( Iterator it = al.iterator();  it.hasNext(); )&#123;</div><div class="line">      sop(it.next());</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Iterator子接口"><a href="#Iterator子接口" class="headerlink" title="Iterator子接口"></a>Iterator子接口</h2><h3 id="ListIterator接口"><a href="#ListIterator接口" class="headerlink" title="ListIterator接口"></a>ListIterator接口</h3><p>列表迭代器，继承迭代器（Iterator是它的父类），里面有指针和角标，所以方法比它父类多的多</p>
<p>List集合特有的迭代器：ListIterator是Iterator的子接口。 </p>
<p>在迭代时，不可以通过集合对象的方法操作集合中的元素。<br>因为会发生ConcurrentModificationException（并发修改异常）</p>
<p>所以，在迭代器时，只能用迭代器的方法操作元素，<br>可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，<br>如果想要其他的操作如添加，修改等，就需要使用其子接口：ListIterator</p>
<p>该接口只能通过List集合的listIterator方法获取。</p>
<p>List集合可以实现遍历过程中的增删改查<br>所以用它是最为方便的，必须要掌握</p>
<p>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></div><div class="line">以正向遍历列表时，如果列表迭代器有多个元素，则返回 <span class="keyword">true</span></div><div class="line">换句话说，如果 next 返回一个元素而不是抛出异常，则返回 <span class="keyword">true</span>。</div><div class="line">判断后面有没有元素</div><div class="line"></div><div class="line">E <span class="title">next</span><span class="params">()</span></div><div class="line">返回列表中的下一个元素</div><div class="line">就是取出</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></div><div class="line">返回对 next 的后续调用所返回元素的索引。 </div><div class="line">获取下一个角标</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></div><div class="line">如果以逆向遍历列表，列表迭代器有多个元素，则返回 <span class="keyword">true</span>。 </div><div class="line">反向遍历，判断前面有没有元素（逆向遍历用的少一些，一般都用正向遍历）</div><div class="line"></div><div class="line">E <span class="title">previous</span><span class="params">()</span></div><div class="line">返回列表中的前一个元素</div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></div><div class="line">将指定的元素插入列表（可选操作）/ 添加</div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></div><div class="line">从列表中移除由 next 或 previous 返回的最后一个元素（可选操作）</div><div class="line">删除</div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></div><div class="line">用指定元素替换 next 或 previous 返回的最后一个元素（可选操作） </div><div class="line">修改</div></pre></td></tr></table></figure></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示ListIterator</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sop</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">    System.out.println(obj);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">    ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line">    al.add(<span class="string">"java01"</span>);</div><div class="line">    al.add(<span class="string">"java02"</span>);</div><div class="line">    al.add(<span class="string">"java03"</span>);   </div><div class="line">    al.add(<span class="number">1</span>,<span class="string">"java09"</span>); </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 演示列表迭代器</span></div><div class="line">    ArrayList al = <span class="keyword">new</span> ArrayList();</div><div class="line">    al.add(<span class="string">"java01"</span>);</div><div class="line">    al.add(<span class="string">"java02"</span>);</div><div class="line">    al.add(<span class="string">"java03"</span>);</div><div class="line"></div><div class="line">    ListIterator li = al.listIterator();</div><div class="line">    </div><div class="line">    <span class="comment">// 正向遍历</span></div><div class="line">    <span class="keyword">while</span>(li.hasNext()) &#123;</div><div class="line">      Object obj = li.next(); </div><div class="line">      <span class="keyword">if</span>(obj.equals(<span class="string">"java02"</span>))</div><div class="line">    <span class="comment">//  li.add("java009");   // 在java02后面添加java09</span></div><div class="line">        li.set(<span class="string">"java06"</span>);    <span class="comment">// 在java02替换成java06</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 所以说ListIterator 既能添加，又能修改，还能删除，还能获取（增删改查全具备，因为List元素集合都带角标）</span></div><div class="line">    <span class="comment">// 只有List集合才具备这个功能</span></div><div class="line">    </div><div class="line">    <span class="comment">// 逆向遍历</span></div><div class="line">    <span class="keyword">while</span>(li.hasPrevious())&#123;</div><div class="line">      sop(li.previous());  <span class="comment">// 倒着取值</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="集合——工具类"><a href="#集合——工具类" class="headerlink" title="集合——工具类"></a>集合——工具类</h1><hr>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>所属包：andriod.util<br>在线API：<a href="http://www.android-doc.com/reference/java/util/Collections.html" target="_blank" rel="external">http://www.android-doc.com/reference/java/util/Collections.html</a></p>
<p>集合框架工具类<br>集合操作的工具方法，里面定义的都是静态方法（都是共享型数据，所以定义静态方便）<br>没有对外提供构造函数，是不需要创建对象的，因为它的对象中并没去封装特有数据</p>
<p>Collections和Collection有什么区别？<br>1.Collection是集合框架中的一个顶层接口，它里面定义了单列集合的共性方法。<br>它有两个常用的子接口，<br>List：对元素都有定义索引。有序的。可以重复元素。<br>Set：不可以重复元素。无序。<br>2.Collections是集合框架中的一个工具类。专门对集合操作，该类中的方法都是静态的<br>提供的方法中有可以对list集合进行排序，二分查找等方法。<br>通常常用的集合都是线程不安全的。因为要提高效率。<br>如果多线程操作这些集合时，可以通过该工具类中的同步方法，将线程不安全的集合，转换成安全的。</p>
<p>Collections方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection&lt;?&gt; c, Object o)</span></span></div><div class="line">可以统计出某个对象在collection中出现的次数 </div><div class="line">如果要对List去重，则可以用 Collection 的 frequency 方法。</div><div class="line">相关资料：http:<span class="comment">//blog.csdn.net/jackyrongvip/article/details/9218669</span></div><div class="line"></div><div class="line">...剩下的方法待写</div></pre></td></tr></table></figure></p>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays它是用于操作数组的工具类。<br>里面都是静态方法。<br>方法里有很多二分搜索法来查找（这类里集合和数组都有二分查找，拿来用就哦了，所以不用在写折半查找）</p>
<h3 id="集合变数组"><a href="#集合变数组" class="headerlink" title="集合变数组"></a>集合变数组</h3><p>Arrays.asList</p>
<p>把数组变成list集合有什么好处？<br>可以使用集合的思想和方法来操作数组中的元素，要不然还得自己封装方法，写for循序，写if（如下面的myContains方法）<br>下面的方法很麻烦，所以说数组变集合，一个方法（list.contains）就搞定了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">myContains</span><span class="params">(String[] arr,String key)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;arr.length; x++)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[x].equals(key))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为数组是一个对象，但是功能很少，而集合的方法很多，但是要注意 ↓<br>将数组变成集合，不可以使用集合的增删方法。因为数组的长度是固定的。<br>这几个都能用（全是list特点）↓<br>contains<br>get<br>indexOf()<br>subList();<br>就是不能增删，如果你增删。那么会发生UnsupportedOperationException（不支持操作异常）  </p>
<p>如果数组中的元素都是对象。那么变成集合时，数组中的元素就直接转成集合中的元素。<br>如果数组中的元素都是基本数据类型，那么会将该数组作为集合中的元素存在。</p>
<p>Arrays方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//待写</span></div></pre></td></tr></table></figure></p>
<h3 id="数组变集合"><a href="#数组变集合" class="headerlink" title="数组变集合"></a>数组变集合</h3><p>Collection.toArray</p>
<p>为什么要将集合变数组？<br>为了限定对元素的操作。不需要进行增删了。<br>详细的说：当我的集合是可变长度的不断的操作过程中，因为不明确元素的个数，操作完了之后把集合返回来是可以的，<br>但是返回集合给对方，那么对方就能对这个集合进行增删，而我还不需要对这个集合进行增删，这时候就转成数组在返回去<br>因为一返回数组就不能增删了，就这么多元素不会变了</p>
<p>指定类型的数组到底要定义多长呢？<br>当指定类型的数组长度小于了集合的size，那么该方法内部会创建一个新的数组。长度为集合的size。<br>当指定类型的数组长度大于了集合的size，就不会新创建了数组。而是使用传递进来的数组。<br>所以创建一个刚刚好的数组最优。</p>
<h3 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h3><p>请使用System.arrayCopy或Arrays.copyOf 实现，且在JAVA中后者基于前者实现。</p>
<hr>
<h1 id="集合——Android中的新型容器"><a href="#集合——Android中的新型容器" class="headerlink" title="集合——Android中的新型容器"></a>集合——Android中的新型容器</h1><hr>
<p>Android API当中提供了一些优化过后的数据集合工具类，如：<br>Sparse系列：SparseArray，SparseBooleanArray，以及LongSparseArray等<br>ArrayMap<br>使用这些API可以让我们的程序更加高效。<br>传统Java API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>
<h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所属包：andriod.util<br>在线API：<a href="http://www.android-doc.com/reference/android/util/SparseArray.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/util/SparseArray.html</a></p>
<p>可替代的API：<br>HashMap</p>
<p>API优势：<br>安卓版hashmap<br>Map的高效优化版本<br>内部实现了一个矩阵压缩算法，很适合存储稀疏矩阵，来节省内存，提高性能</p>
<p>兼容API:<br>support包中还提供了兼容的类SparseArrayCompat,基本和SparseArray是同一个类，只不过第二个类有removeAt方法</p>
<p>使用标准：<br>只能在key为int的时候才能使用（注意是int而不是Integer）</p>
<p>效率提升优势：<br>因为上面的使用标准，所以去掉了装箱的操作</p>
<p>判断对象相等方式：<br>因为key为int也就不需要hash值，只要int值相等，那就是同1个对象</p>
<p>默认容量大小：<br>10，可以根据自己可能的容量设置初始值。</p>
<p>插入和查找原理：<br>基于二分法，原理和Arraymap基本一致</p>
<p>空间上对比：<br>与HashMap，去掉了Hash值的存储空间，没有next的指针占用，还有其他一些小的内存占用，看着节省了不少。</p>
<p>时间上对比：<br>插入和查找的情形和Arraymap基本一致，可能存在大量的数组搬移。<br>但是它避免了装箱的环节，不要小看装箱过程，还是很费时的。<br>所以从源码上来看，效率谁快，就看数据量大小了。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Sparse系列的数据结构是为key为int情况的特殊处理，采用二分查找及简单的数组存储，加上不需要泛型转换的开销，相对Map来说性能更优。</p>
<p>SparseArray意思是稀疏数组(Sparse array),<br>所谓稀疏数组就是数组中大部分的内容值都未被使用（或都为零），在数组中仅有少部分的空间使用。<br>因此造成内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。</p>
<p>SparseArray是android提供的一个工具类，它可以用来替代hashmap进行对象的存储，其内部实现了一个矩阵压缩算法，很适合存储稀疏矩阵的。</p>
<p>推荐文件：<br><a href="http://blog.csdn.net/u010687392/article/details/47809295" target="_blank" rel="external">Android内存优化（使用SparseArray和ArrayMap代替HashMap）</a><br>相关文章：<br><a href="http://blog.csdn.net/fancylovejava/article/details/45148325" target="_blank" rel="external">Android开发中高效的数据结构用SparseArray代替HashMap</a></p>
<h2 id="ArrayMap-amp-SimpleArrayMap"><a href="#ArrayMap-amp-SimpleArrayMap" class="headerlink" title="ArrayMap &amp; SimpleArrayMap"></a>ArrayMap &amp; SimpleArrayMap</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>所属包：<br>andriod.util 和 android.support.v4</p>
<p>ArrayMap在线API：<br><a href="http://www.android-doc.com/reference/android/util/ArrayMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/util/ArrayMap.html</a><br><a href="http://www.android-doc.com/reference/android/support/v4/util/ArrayMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/support/v4/util/ArrayMap.html</a></p>
<p>SimpleArrayMap在线API：<br><a href="http://www.android-doc.com/reference/android/support/v4/util/SimpleArrayMap.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/support/v4/util/SimpleArrayMap.html</a></p>
<p>使用API版本：<br>android.util.ArrayMap需要API&gt;=19<br>V4包无所谓</p>
<p>数据结构：<br>ArrayMap利用两个数组<br>mHashes用来保存每一个key的hash值<br>mArray大小为mHashes的2倍，依次保存key和value。</p>
<p>插入和查询原理：<br>二分查找<br>根据key的hashcode()方法得到hash值，计算出在mArrays的index位置，然后利用二分查找找到对应的位置进行插入，当出现哈希冲突时，会在index的相邻位置插入。</p>
<p>空间效率：<br>ArrayMap每存储一条信息，需要保存一个hash值，一个key值，一个value值。<br>对比下HashMap 粗略的看，只是减少了一个指向下一个entity的指针。还有就是节省了一部分可见空间上的内存节省也不是特别明显。</p>
<p>时间效率：<br>插入和查找的时候因为都用的二分法，查找的时候应该是没有hash查找快，插入的时候呢，如果顺序插入的话效率肯定高，但如果是随机插入，肯定会涉及到大量的数组搬移，数据量大，肯定不行，再想一下，如果是不凑巧，每次插入的hash值都比上一次的小，那就得次次搬移，效率一下就扛不住了</p>
<p>缺点：<br>HashMap实现了Serializable<br>ArrayMap并没有，所以数据传递的时候使用ArrayMap会报错</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SimpleArrayMap<k,v>与ArrayMap<k,v></k,v></k,v></p>
<p>实质上ArrayMap继承自SimpleArrayMap,主要是为了实现像HashMap一样的api方法，让习惯使用HashMap的开发者感觉不到差异，本质上是SimpleArrayMap+Map的再封装。</p>
<p>一般来说使用这2个类主要来代替HashMap，因为他们比HashMap更加高效，对内存也进行了优化。<br>虽然比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。</p>
<p>官方对ArrayMap也有说明：它不是一个适应大数据的数据结构，相比传统的HashMap速度要慢，因为查找方法是二分法，并且当你删除或者添加数据时，会对空间重新调整，在使用大量数据时，效率并不明显，低于50%。</p>
<p>所以ArrayMap是牺牲了时间换空间。在写手机app时，适时的使用ArrayMap，会给内存使用带来可观的提升。</p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2017/02/12/dive-into-arraymap-in-android/" target="_blank" rel="external">深入剖析 Android中的 ArrayMap</a><br><a href="http://blog.csdn.net/bdmh/article/details/49176001" target="_blank" rel="external">Android内存优化：ArrayMap</a></p>
<h3 id="HashMap，ArrayMap，SparseArray的性能对比"><a href="#HashMap，ArrayMap，SparseArray的性能对比" class="headerlink" title="HashMap，ArrayMap，SparseArray的性能对比"></a>HashMap，ArrayMap，SparseArray的性能对比</h3><p>插入性能时间对比：<br>HashMap远超Arraymap和SparseArray。<br>当然数据量小的时候，例如1000以下，这点时间差异也是可以忽略的。</p>
<p>查找性能对比：<br>HashMap才是查询最快的<br>但是我们正常用的时候是不管装不装箱的，所以综合起来还是使用SparseArray效率最高。</p>
<p>空间对比：<br>SparseArray在内存占用方面的确要优于HashMap和ArrayMap不少，通过数据观察，大致节省30%左右<br>而ArrayMap的表现正如前面说的，优化作用有限，几乎和HashMap相同。</p>
<p>总结：<br>1.在数据量小的时候一般认为1000以下，当你的key为int的时候，使用SparseArray确实是一个很不错的选择，内存大概能节省30%，相比用HashMap，因为它key值不需要装箱，所以时间性能平均来看也优于HashMap,建议使用！</p>
<p>2.ArrayMap相对于SparseArray，特点就是key值类型不受限，任何情况下都可以取代HashMap,但是通过研究和测试发现，ArrayMap的内存节省并不明显，也就在10%左右，但是时间性能确是最差的，当然了，1000以内的数据量也无所谓了，加上它只有在API&gt;=19才可以使用，个人建议没必要使用！还不如用HashMap放心。</p>
<p>相关文章：<br><a href="http://www.jianshu.com/p/7b9a1b386265" target="_blank" rel="external">HashMap，ArrayMap，SparseArray源码分析及性能对比</a></p>
<h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>Lru  ( less recently use ) 最近最少使用算法 / 缓存最近使用的 </p>
<p>可以自动控制内存大小, 及时回收不常用的对象, 用法和HashMap类似</p>
<p>它是基于Lru算法的内存缓冲<br>就是说bitmap储存到里面, 就能算的出来用的多还是少<br>用的少就回收<br>它一直在内存里面, 永远能保证内存的使用<br>缓存最近使用的，使用该类可以代替引用级别</p>
<p>它就是一个map ( key和 value )<br>包 : android.util/android.support.v4.util  ( 向下兼容 ) </p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemCache;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheUtils</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();<span class="comment">// 模拟器默认是16M内存</span></div><div class="line">    Logger.d(<span class="string">"最大内存:"</span> + maxMemory);</div><div class="line">    mMemCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;((<span class="keyword">int</span>) (maxMemory / <span class="number">8</span>)) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> value.getRowBytes() * value.getHeight();<span class="comment">//返回图片大小</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从内存中取图片</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> url</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMem</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mMemCache.get(url);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 向内存中存图片</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> url</div><div class="line"> * <span class="doctag">@param</span> bitmap</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBitmapToMem</span><span class="params">(String url, Bitmap bitmap)</span> </span>&#123;</div><div class="line">    mMemCache.put(url, bitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://www.bdqn.cn/news/201307/10432.shtml" target="_blank" rel="external">Android使用 LruCache 缓存图片</a></p>
<h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>磁盘Lru缓存方案</p>
<p>注意：DiskLruCache并不是由Google官方编写的，所以这个类并没有被包含在Android API当中，我们需要将这个类从网上下载下来，然后手动添加到项目当中。<br>DiskLruCache的源码在Google Source上，地址如下：<br>android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/DiskLruCache.java</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="external">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a><br><a href="http://blog.csdn.net/fangzhibin4712/article/details/38823533" target="_blank" rel="external">Android照片墙完整版，完美结合LruCache和DiskLruCache</a><br><a href="http://www.jianshu.com/p/833adadc9eb6" target="_blank" rel="external">Android 缓存策略LruCache和DiskLruCache学习</a></p>
<h2 id="ContentValues"><a href="#ContentValues" class="headerlink" title="ContentValues"></a>ContentValues</h2><p>里面键值对的使用，其实就是Map集合<br>是一种存储的机制，负责存储一些名值对，存储的名值对当中的名是一个String类型，而值是基本数据类型。<br>ContentValues只能存储基本数据类型。常用方法为putXXX(String key,XXX value)的重载函数，用于存储数据。</p>
<h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>所属包：android.util.Pair与android.support.v4.util.Pair。</p>
<p>这个类 可以用来方便的存储一”组”数据。但不是key和value的关系。<br>方便构建类和构造器的方法。</p>
<p>相关文章：<br><a href="http://www.jianshu.com/p/cbec7786d8f1" target="_blank" rel="external">Android 表示一对“组元素”的Pair类</a><br><a href="http://www.jianshu.com/p/5c4f5feeb9d4" target="_blank" rel="external">有序键值的一种：Pair</a></p>
<hr>
<h1 id="集合——线程安全容器类"><a href="#集合——线程安全容器类" class="headerlink" title="集合——线程安全容器类"></a>集合——线程安全容器类</h1><hr>
<p>Vector<br>Stack：因为继承了Vector</p>
<p>Hashtable<br>Property：实现了Map接口，是HashTable的子类，所以是线程安全的</p>
<p>Enumeration</p>
<p>ConcurrentHashMap</p>
<p>BlockingQueue系列：<br>ArrayBlockkingQueue<br>LinkedBlockingQueue</p>
<p>CopyOnWrite容器系列：<br>CopyOnWriteArrayList</p>
<p>Sorted容器系列：</p>
<p>相关文章：<br><a href="https://www.nowcoder.com/questionTerminal/46999f0286644d6d8c44be91c40e664b" target="_blank" rel="external">以下集合对象中哪几个是线程安全的？</a></p>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><hr>
<p>待总结</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_java_collection_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Java" scheme="https://hengxing0080.github.io/categories/IT-Java/"/>
    
    
      <category term="Java" scheme="https://hengxing0080.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>多线程并发异步的总结</title>
    <link href="https://hengxing0080.github.io/2017/09/06/it/1.Java/Multithreading/"/>
    <id>https://hengxing0080.github.io/2017/09/06/it/1.Java/Multithreading/</id>
    <published>2017-09-06T07:54:12.000Z</published>
    <updated>2017-11-10T04:51:05.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_java_thread.jpg" alt="UML图"><br><a id="more"></a><br>注意：此图总结不全用于临时展示，后续待上传最新思维导图</p>
<hr>
<h1 id="进程和线程的理解"><a href="#进程和线程的理解" class="headerlink" title="进程和线程的理解"></a>进程和线程的理解</h1><hr>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是计算机系统中，一个正在进行执行中的程序, 程序运行的实体，也是线程的容器。<br>每一个进程执行都有一个执行顺序,该顺序是一个从头执行到尾的控制单元(控制单元也叫执行情景或执行路径).</p>
<p>进程的作用：<br>如qq或迅雷，它们启动时都在内存中分配一块空间和地址，进程就是来定义和标识空间，用来封装里面的控制单元！</p>
<p>java有2个进程：<br>编译进程：javac(编译器)也是一个进程, javac.exe(编译完就结束了，进程就消失了)<br>运行进程：jvm(虚拟机),启动时会有一个进程java.exe </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>通俗的理解线程就是代码一行行向下执行的线路和流程。<br>线程就是进程中的一个独立的控制单元.<br>线程是进程中实际执行单位，一个线程是程序执行流的最小单元。<br>线程在控制着进程的执行<br>线程是进程中的内容（线程运行在进程里面）<br>每一个应用程序(进程)至少有一个线程<br>Java虚拟机允许应用程序(进程)并发地运行多个执行线程。 </p>
<p>多线程：<br>就是分出另外一个执行线程，同时又多条线路并行运行。<br>一个进程里有多个线程在执行, 就是有多条执行路径就叫多线程 （例如：下载就是多线程）<br>多线程和CPU有关，单核CPU不能开启多线程，只能单线程</p>
<p>主线程：<br>该进程中至少有一个线程负责java程序的执行<br>而且这个线程运行的代码存在于main方法中<br>该线程称为主线程<br>主线程要运行的代码存在main方法，是虚拟机定义的（它的控制单元只认main方法），这就是虚拟机调用main方法的原因，因为是主线程在调用！</p>
<p>垃圾回收机制的线程：<br>其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。</p>
<p>线程类API：<br>java.lang → Thread<br>Java中万物皆对象,线程也被描述成了一个对象就是Thread对象.<br>Java对多线程的支持也是特别完善的,特别是JDK1.5之后.</p>
<p>如未通俗的理解进程和线程，请看下面的文章↓<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">进程与线程的一个简单解释</a></p>
<hr>
<h1 id="创建线程的3种方式"><a href="#创建线程的3种方式" class="headerlink" title="创建线程的3种方式"></a>创建线程的3种方式</h1><hr>
<h2 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h2><p>(1)将类声明为 Thread 的子类。<br>(2)子类覆盖父类中的run方法，将线程运行的代码存放在run方法中。（目的：将自定义代码存储在run方法，让线程运行）<br>(3)建立子类对象的同时线程也被创建。<br>(4)通过调用start方法开启线程。(start方法有2个作用：1.启动线程 2.调用run方法)</p>
<h2 id="2-实现Runnable接口创建线程类"><a href="#2-实现Runnable接口创建线程类" class="headerlink" title="2.实现Runnable接口创建线程类"></a>2.实现Runnable接口创建线程类</h2><p>(1)定义类实现Runnable接口<br>(2)覆盖Runnable接口中的run方法（将线程要运行的代码存放在该run方法中）<br>(3)通过Thread类建立线程对象<br>(4)将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数<br>(5)调用Thread类的start方法开启线程并调用Runnable接口子类的run方法</p>
<p>注意：<br>Runnable只是一个任务，真正干活的还是Thread<br>因为查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run方法。</p>
<h2 id="3-实现Callable接口和通过Future创建线程"><a href="#3-实现Callable接口和通过Future创建线程" class="headerlink" title="3.实现Callable接口和通过Future创建线程"></a>3.实现Callable接口和通过Future创建线程</h2><p>(1)创建Callable接口的实现类，并实现call()方法(相当于run)，该call()方法将作为线程执行体，并且有返回值。<br>(2)创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>(3)使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<h3 id="关于Callable-amp-Future的介绍"><a href="#关于Callable-amp-Future的介绍" class="headerlink" title="关于Callable&amp;Future的介绍"></a>关于Callable&amp;Future的介绍</h3><p>一个程序启动一个线程，这个线程运行完了有一返回结果，这些类可以获得这个结果</p>
<p>Callable是任务来返回结果，然后返回的结果由Future去拿</p>
<p>Future取得的结果类型和Callable返回的结果类型必须一致，这是通过泛型来实现的。</p>
<p>Callable要采用ExecutorSevice的submit方法提交，返回的future对象可以取消任务。</p>
<p>Callable&amp;Future的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</div><div class="line">        Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123; </div><div class="line">            <span class="comment">// Callable任务来返回结果，获取的结果由Future来拿，Callable如果没有结果，Future会一直等</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"等待结果"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"拿到结果："</span> + future.get());</div><div class="line">    <span class="comment">//      System.out.println("拿到结果："+future.get(100,TimeUnit.SECONDS));</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ExecutorService threadPool2 = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="comment">// CompletionService用于提交一组Callable任务，其take方法返回已完成的一个Callable任务对应的Future对象。</span></div><div class="line">        <span class="comment">// 好比我同时种了几块地的麦子，然后就等待收割。收割时，则是哪块先成熟了，则先去收割哪块麦子。</span></div><div class="line">        CompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;Integer&gt;(threadPool2); <span class="comment">// 接口不能直接new，需要new它的子类</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = i;</div><div class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>));</div><div class="line">                    <span class="keyword">return</span> seq;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(completionService.take().get()); <span class="comment">// 按最先运行的线程来获取</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建并开启线程的7种方式"><a href="#创建并开启线程的7种方式" class="headerlink" title="创建并开启线程的7种方式"></a>创建并开启线程的7种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">开发时的线程写法（当然只是示范，不一定非得这么写，只是一种写法）</div><div class="line">什么时候用多线程？当某些代码要被同时执行就用单独的线程封装</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 单独封装线程1（Thread子类对象）</span></div><div class="line">        <span class="comment">// 在主方法里new个对象，这样封装，即使这个对象没运行完，下面的for也能运行</span></div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  /</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"线程1"</span> + x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line"></div><div class="line">        <span class="comment">// 单独封装线程2（技巧写法，用匿名内部类完成）</span></div><div class="line">        Runnable r = <span class="keyword">new</span> Runnable()  &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"线程2"</span> + x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">new</span> Thread(r).start();  </div><div class="line"></div><div class="line">        <span class="comment">// 线程3（主线程）</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"线程3"</span> + x);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 线程4</span></div><div class="line">        <span class="keyword">new</span> Thread2().start(); </div><div class="line"></div><div class="line">        <span class="comment">// 线程5</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable2()).start();</div><div class="line"></div><div class="line">        <span class="comment">// 上面定义5个线程，这么一封装，这样就能同时运行了而且高效了</span></div><div class="line">    </div><div class="line">        <span class="comment">//  new Test1().start();  // 如果放这开启就不是4个同时开始，而是先执行上面3个才执行它</span></div><div class="line"></div><div class="line">        <span class="comment">// 以下还有3种方式</span></div><div class="line">        <span class="comment">// 线程6</span></div><div class="line">        Thread thread6 = <span class="keyword">new</span> Thread()&#123; <span class="comment">// new一个子类，复写run方法</span></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">					<span class="keyword">try</span> &#123;Thread.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</div><div class="line">				    System.out.println(<span class="string">"1："</span>+Thread.currentThread().getName());</div><div class="line">					System.out.println(<span class="string">"2："</span>+<span class="keyword">this</span>.getName()); <span class="comment">// this代表run方法所在的对象（thread对象），但是工作中不建议这么写</span></div><div class="line">                &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		&#125;;</div><div class="line">		thread6.start();</div><div class="line"></div><div class="line">        <span class="comment">// 线程7</span></div><div class="line">        Thread thread7 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 等待</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(ANIMATION_DELAY);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 做页面跳转</span></div><div class="line">                <span class="comment">// doNavgation();</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(isTopActivity(WelcomeActivity.<span class="keyword">this</span>))&#123;</div><div class="line">                    IntentUtil.startActivityAndFinish(MainActivity.class);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        thread7.start();</div><div class="line"></div><div class="line">        <span class="comment">// 线程8</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 等待</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(ANIMATION_DELAY);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 做页面跳转</span></div><div class="line">                <span class="comment">//doNavgation();</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span>(isTopActivity(WelcomeActivity.<span class="keyword">this</span>))&#123;</div><div class="line">                    IntentUtil.startActivityAndFinish(MainActivity.class);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  <span class="comment">// 继承和实现都行</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程4："</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程5："</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.创建线程的三种方式的对比<br>使用继承Thread类的方式创建多线程时<br>优势：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势：线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>采用实现Runnable、Callable接口的方式创见多线程时<br>优势：<br>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>劣势：<br>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>2.实现方式(Runnable)和继承方式(Thread)有什么区别呢？<br>实现方式好处：避免了单继承的局限性</p>
<p>两种方式区别在于存放代码位置不一样： ↓<br>继承Thread：线程代码存放Thread类的子类run方法中<br>实现Runnable，线程代码存在Runnable接口的子类的run方法</p>
<p>在定义线程时，建议使用实现方式（Runnable）<br>当然，自己的类没有父类的时候可以用继承Thread</p>
<p>图解：<br>继承：因为Java只支持单继承，所以Student类继承了Person类后就无法在继承Thread类.<br>实现：Student类继承了Person类还实现了Runnable接口，功能还扩展了.<br><img src="/images/it_java_thread1.png" alt="UML图"></p>
<p>PS:Thread类本身也实现了Runnable</p>
<p>3.为什么要覆盖run方法呢？<br>Thread类用于描述线程。<br>该类就定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。<br>就是说Thread类中的run方法，用于存储线程要运行的代码。<br>结论就是run方法就是初始化代码</p>
<p>4.start方法和run方法的区别？  调用start方法结果是什么？  调用run方法结果又是什么？<br>d.start();<br>开启线程并执行该线程的run方法<br>它调用底层让控制单元去执行的动作，这是start的作用<br>它很重要，只有它才能开启线程</p>
<p>d.run();<br>仅仅是对象调用方法。而线程创建了，并没有运行。<br>run的功能就是封装线程要运行的代码</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://www.cnblogs.com/DreamDrive/p/6180918.html" target="_blank" rel="external">创建线程的三种方式 </a><br><a href="http://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="external">java创建线程的三种方式及其对比</a></p>
<hr>
<h1 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h1><hr>
<h2 id="interrupt-停止线程"><a href="#interrupt-停止线程" class="headerlink" title="interrupt(停止线程)"></a>interrupt(停止线程)</h2><h3 id="先看下终止线程的三种方法"><a href="#先看下终止线程的三种方法" class="headerlink" title="先看下终止线程的三种方法"></a>先看下终止线程的三种方法</h3><p>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>定义循环结束标记,因为线程运行代码一般都是循环，只要控制了循环即可，就可以让run方法结束，也就是线程结束。</p>
<p>不过有种特殊情况：<br>当线程处于了冻结状态<br>就不会读取到标记<br>那么线程就不会结束  </p>
<p>所以推荐下面的interrupt<br>写程序时很常见的问题，只要线程挂着不动，就用interrupt</p>
<p>2.使用interrupt方法中断线程。(推荐)<br>该方法是结束线程的冻结状态，使线程回到运行状态中来。</p>
<p>详细就是当没有指定的方式让冻结的线程恢复到运行状态时，这时就需要对冻结进行清除。<br>强制让线程恢复到运行状态（获取运行资格）中来，这样就可以操作标记让线程结束。</p>
<p>注意这个方法不是停止线程，是强制清洁冻结状态的线程.<br>中断状态就是冻结状态<br>中断状态不是停止线程<br>stop方法才是停止线程<br>stop()，wait()，join() 都能被中断</p>
<p>3.使用stop方法强行终止线程。(不推荐)<br>这个方法已经过时不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的<br>虚拟机不识别不说而且此方法有bug，就是强制停止线程.<br>suspend方法也已过时（发送死锁）</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束线程方法1：加结束标记的情况：只要能让循环结束，那么线程就能结束</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;  <span class="comment">// 定义方法（改变标记）</span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span>&#123;</div><div class="line">        <span class="keyword">while</span>(flag)&#123;   <span class="comment">// 循环结束那么线程就能结束</span></div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread(); <span class="comment">// 主线程</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);       <span class="comment">// 其他线程1</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);       <span class="comment">// 其他线程2</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="comment">// 开始控制线程 </span></div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 无限循环</span></div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                st.changeFlag();  <span class="comment">// 结束标记（改变标记为假，循环和线程结束）</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num);  <span class="comment">// 得到主线程名字和编号</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 证明主线程执行完的提示语</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束线程2：(特殊情况) 加了同步后，线程停不下来，只能用interrupt</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  <span class="comment">// 遇到同步就等于拿到锁</span></div><div class="line">        <span class="keyword">while</span>(flag)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                wait();  <span class="comment">// 线程0和1进来遇到它就冻结等待了（放弃了执行资格）</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"...Exception"</span>); </div><div class="line">                flag = <span class="keyword">false</span>;  <span class="comment">// 只要能发送发生异常就代表在用interrupt，所以定义标记处理成false就能结束线程了</span></div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread(); </div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);      <span class="comment">// 线程0</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);      <span class="comment">// 线程1</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                <span class="comment">//  st.changeFlag(); // 虽然改变了标记，但是这次程序因为同步的原因没有停下来</span></div><div class="line">                t1.interrupt();      <span class="comment">// 冻结状态强制被清除了，中断线程，出中断异常</span></div><div class="line">                t2.interrupt();      <span class="comment">// 同上</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num);  </div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 用了interrupt，主线程正常停下来了</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="setDeamon-守护线程"><a href="#setDeamon-守护线程" class="headerlink" title="setDeamon(守护线程)"></a>setDeamon(守护线程)</h2><p>将该线程标记为守护线程或用户线程。<br>当正在运行的线程都是守护线程时，Java 虚拟机退出。<br>该方法必须在启动线程前调用。</p>
<p>能看到的线程都是前台线程，当把某线程标记成后台线程后，就具备了特殊的含义<br>开启运行时，后台线程和前台线程都一样一起抢夺CPU资源，就结束有区别<br>当所有的前台线程都结束后，后台线程会自动结束（前台不在了，后台也挂了）</p>
<p>主线程是前台线程，主线程一结束就都结束</p>
<p>示例代码2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示：守护线程</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(flag)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread();</div><div class="line">        </div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st); </div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);     </div><div class="line">        </div><div class="line">        <span class="comment">// 给t1和t2标记守护线程（传个真就守护了）</span></div><div class="line">        t1.setDaemon(<span class="keyword">true</span>);         </div><div class="line">        t2.setDaemon(<span class="keyword">true</span>);  </div><div class="line">        <span class="comment">// 主线程结束后，不管t1和t2是什么情况（睡眠，冻结，等待，无限循环等等）都能结束）</span></div><div class="line">        <span class="comment">// 该方法必须在启动线程前调用（开启守护模式当然必须在线程开动前期）     </span></div><div class="line">        <span class="comment">// 所以线程停下来的原因是因为主线程结束了（前台线程）</span></div><div class="line">        <span class="comment">// 而标记t1和t2的守护线程时他们是后台线程所以也跟着结束了，原理是这个方法让虚拟机结束了</span></div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num); </div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="join方法-临时加入线程"><a href="#join方法-临时加入线程" class="headerlink" title="join方法(临时加入线程)"></a>join方法(临时加入线程)</h2><p>Join用途：<br>临时加入线程用的<br>一个线程在运行中要临时加入另外一个线程，让这个线程运算完，然后让另外一个线程在继续运行</p>
<p>Join特点：<br>当A线程执行到了B线程的join()方法时，A就会等待。<br>等B线程都执行完，A才会执行。<br>join可以用来临时加入线程执行<br>join用的频率不高，但是很有技术含量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示：join</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">70</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        </div><div class="line">        t1.join()  <span class="comment">// t1先拥有执行权，主线程就处于冻结状态，等到t1打印完结束了，主线程才恢复到运行状态中来</span></div><div class="line"></div><div class="line">        t2.start();</div><div class="line"></div><div class="line">    <span class="comment">//  t1.join(); // 主线程先执行，执行到t1.join，主线程就冻结然后等待t1，</span></div><div class="line">                   <span class="comment">// 这时t1和t2交替执行，等t1结束了，主线程解冻和t2抢夺执行权</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">80</span>; x++)&#123;</div><div class="line">            System.out.println(<span class="string">"main....."</span>+x);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 证明主函数结束的标语</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息"><a href="#yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息" class="headerlink" title="yield方法(临时停止线程) &amp; setPriority(设置优先级) &amp; toString(返回线程全部信息)"></a>yield方法(临时停止线程) &amp; setPriority(设置优先级) &amp; toString(返回线程全部信息)</h2><ul>
<li><p>yield()<br>临时停止<br>暂停当前正在执行的线程对象，并执行其他线程。<br>用的频率也不高</p>
</li>
<li><p>setPriority()<br>所有的线程包括主线程默认优先级是5，优先级一共10<br>优先级代表抢资源的频率</p>
<p>  因为1，5，10 这3个优先级跨度最大，所以有了3个字段 ↓<br>  static int MAX_PRIORITY   （优先级10,最高优先级）<br>  static int MIN_PRIORITY   （优先级1,最低优先级）<br>  static int NORM_PRIORITY  （优先级5,默认优先级）</p>
</li>
<li><p>toString()<br>返回该线程的字符串表示形式，包括线程名称、线程组和优先级。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *演示：toString &amp; setPriority &amp; yield</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">70</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().toString()+<span class="string">"....."</span>+x);</div><div class="line">            <span class="comment">// 输出：线程组（谁开启就属于哪个组，这里是主线程开启的t1和t2，所以属于main）</span></div><div class="line"></div><div class="line">            Thread.yield(); </div><div class="line">            <span class="comment">// 起到稍微减缓线程执行的频率的运行，能让所有的线程都有机会平均的运行效果（类似你一下，我一下的执行效果）</span></div><div class="line">            <span class="comment">// 强制性的让线程临时释放执行权</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t1.setPriority(Thread.MAX_PRIRITY); <span class="comment">// 不过这方法不严谨，设完了也是互相抢资源，相对就是抢的频率高一些</span></div><div class="line">        t2.start();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">80</span>; x++)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"main....."</span>+x);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="线程的5种生命周期状态"><a href="#线程的5种生命周期状态" class="headerlink" title="线程的5种生命周期状态"></a>线程的5种生命周期状态</h1><hr>
<p><img src="/images/it_java_thread2.jpg" alt="UML图"><br><img src="/images/it_java_thread3.jpg" alt="UML图"><br><img src="/images/it_java_thread4.jpg" alt="UML图"></p>
<p>Java线程的生命周期分为如下几种：<br>新建：创建线程对象<br>就绪：拥有执行资格，但是没有执行权<br>运行：有执行资格且有执行权<br>阻塞：没有执行资格和执行权，但是可以被激活到就绪<br>死亡：线程对象变为垃圾，等待被回收。</p>
<ul>
<li><p>1.新建状态<br>创建线程对象<br>new一个Thread对象就是一个线程，new一个Thread子类也是</p>
</li>
<li><p>2.就绪状态<br>有执行资格的状态<br>特点：具备运行资格，但没有执行权</p>
</li>
<li><p>3.运行状态<br>即有资格又有执行权叫运行状态<br>方法：start()：开始启动线程</p>
</li>
<li><p>4.阻塞/冻结/睡眠/等待状态<br>没有执行资格的状态叫冻结状态(特点：放弃了执行资格，当然更没有执行权了)<br>方法：<br>sleep()：睡眠（需要指定睡眠时间，单位是毫秒）<br>wait()：等待<br>notify()：唤醒</p>
</li>
<li><p>5.消亡/线程死亡/销毁状态<br>方法：<br>stop()：停止<br>run()：run方法也是结束(当线程里内容执行完没有内容了就结束了)</p>
</li>
</ul>
<hr>
<h1 id="多线程同步安全问题与互斥技术"><a href="#多线程同步安全问题与互斥技术" class="headerlink" title="多线程同步安全问题与互斥技术"></a>多线程同步安全问题与互斥技术</h1><hr>
<p>同步：<br>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p>
<p>线程安全：<br>经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码.</p>
<p>多线程的运行出现了安全问题，原因是：<br>1.多个线程访问出现延迟<br>2.线程随机性</p>
<p>多线程安全问题经典案例：银行转账（1个人存，一个人取）</p>
<p>问题的原因：<br>当多条语句在操作同一线程共享数据时，一个线程对多条语句只执行了一部分，<br>还没有执行完，另一个线程参与进行执行。导致共享数据的错误。</p>
<p>解决方法：<br>对多条操作共享数据的语句，只能让一个线程都执行完。<br>在执行过程中，其他线程不可以参与运行。<br>java对于多余线程的安全问题提供了专业的解决方式：同步锁<br>对象如同锁，持有锁的线程可以在同步中执行。<br>没有持有锁的线程即使获取CPU的执行权，也执行不起，因为没有获取锁。</p>
<p>同步的前提：<br>1.必须要有两个或者两个以上的线程。<br>2.必须是多个线程使用同一个锁。<br>3.必须保证同步中能有一个线程运行。</p>
<p>同步的好处：解决了多线程的安全问题<br>同步的弊端：多个线程需要判断锁，较为消耗资源，影响程序效率.</p>
<p>相关名称：<br>互斥：多个线程互相排斥，互不干扰，这样就同步了。<br>互斥锁（Mutual exclusion，缩写 Mutex）：防止多个线程同时读写某一块内存区域。<br>信号量（Semaphore）：用来保证多个线程不会互相冲突。</p>
<p>同步有两种锁机制：<br>乐观锁和悲观锁<br>不懂俩锁的可以看下面文章快速联系<br><a href="http://blog.csdn.net/hongchangfirst/article/details/26004335" target="_blank" rel="external">一分钟教你知道乐观锁和悲观锁的区别</a></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁是一种非独占锁，非阻塞锁。</p>
<p>相关文章：<br><a href="http://www.importnew.com/20472.html" target="_blank" rel="external">乐观锁的一种实现方式——CAS</a><br><a href="http://www.cnblogs.com/gossip/p/6182028.html" target="_blank" rel="external">Java并发_volatile实现可见性但不保证原子性</a><br><a href="http://www.cnblogs.com/yuyutianxia/p/3991869.html" target="_blank" rel="external">锁、volatile、CAS 比较</a></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS(Compare and Swap)比较并交换的无锁算法<br>解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<p>java.util.concurrent包中借助CAS实现了区别于synchronized同步锁的一种乐观锁。<br>AtomicInteger</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>与锁相比，volatile变量是一和更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作</p>
<p>volatile变量也存在一些局限：不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用volatile变量</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁是一种是独占锁，阻塞锁.</p>
<p>悲观锁机制存在以下问题：<br>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>悲观锁种类：<br>有Synchronized和Lock两种方式</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized就是一种阻塞算法.<br>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。<br>独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p>
<p>Synchronized有如下几种表现方式和情况： </p>
<h4 id="1-同步代码块（互斥的代码块上锁，加任意对象锁）"><a href="#1-同步代码块（互斥的代码块上锁，加任意对象锁）" class="headerlink" title="1.同步代码块（互斥的代码块上锁，加任意对象锁）"></a>1.同步代码块（互斥的代码块上锁，加任意对象锁）</h4><p>同步代码块的锁可以创建一个任意类型的对象来用，如Object类型或该类所属字节码文件对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">格式：synchronized ( 对象 )&#123; </div><div class="line">    需要被同步的代码 ;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">Object obj = <span class="keyword">new</span> Object();  <span class="comment">// 新建对象锁，Object现成的基类直接拿来用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(obj)&#123;      <span class="comment">// 同步代码块(在操作共享数据的地方加同步代码块，多了一层代码阶段形状相当于加了一道同步锁(或者是监视器)</span></div><div class="line">        sum = sum + n;</div><div class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</div><div class="line">        System.out.println(<span class="string">"sum"</span> + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-同步函数（互斥非静态方法上锁，加this锁）"><a href="#2-同步函数（互斥非静态方法上锁，加this锁）" class="headerlink" title="2.同步函数（互斥非静态方法上锁，加this锁）"></a>2.同步函数（互斥非静态方法上锁，加this锁）</h4><p>同步函数用的是哪一个锁？<br>函数需要被对象调用，那么函数都有一个所属对象引用：this，所以同步函数使用的锁是this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">格式：在函数上加上synchronized修饰符即可</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 同步函数（让函数具备同步性）  </span></div><div class="line">    sum = sum + n;</div><div class="line">    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</div><div class="line">    System.out.println(<span class="string">"sum"</span> + sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-静态同步函数-互斥静态方法上锁，加类锁"><a href="#3-静态同步函数-互斥静态方法上锁，加类锁" class="headerlink" title="3.静态同步函数(互斥静态方法上锁，加类锁)"></a>3.静态同步函数(互斥静态方法上锁，加类锁)</h4><p>同步函数被静态修饰后，使用的锁是什么呢？<br>通过验证，发现不在是this（因为静态方法中不可以定义this）<br>静态进内存时，内存中还没有本类对象，但是一定有该类对应的字节码文件对象：类名.class，所以该对象的类型是class<br>静态的同步方法，使用的锁是该方法所在类的字节码文件对象：类名.class（这个对象在内存里是唯一的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  演示 静态同步函数的锁是Class对象</div><div class="line"> */ </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tick = <span class="number">100</span>; <span class="comment">// 静态（加静态后是方法区共享数据，不加静态是堆内存共享数据）</span></div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(Ticket.class)&#123;  <span class="comment">// Ticket的字节码</span></div><div class="line">                    <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"同步代码块 : "</span> + tick--);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;  <span class="comment">// 静态同步方法</span></div><div class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"同步函数 : "</span> + tick--);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Ticket ticket = <span class="keyword">new</span> Ticket(); </div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ticket);  </div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ticket); </div><div class="line">        thread1.start(); </div><div class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">        ticket.flag = <span class="keyword">false</span>;</div><div class="line">        thread2.start(); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综合示例演示3种方式的对比<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 线程的互斥：关键字synchronized</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ThreadSynchronized().init();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 内部方法</span></div><div class="line">        <span class="keyword">final</span> Output output = <span class="keyword">new</span> Output();</div><div class="line"></div><div class="line">        <span class="comment">//下面2个线程中的2段代码在线程执行时要互斥</span></div><div class="line">        <span class="comment">//要互斥的代码必须用synchronize代码块包围起来.</span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123; </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</div><div class="line">                    output.output(<span class="string">"cat"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</div><div class="line">                    output.output2(<span class="string">"dog"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span></span>&#123; <span class="comment">// 内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">synchronized</span> (Output.class)&#123;  <span class="comment">// 同步代码块  // this：谁调用我谁就是锁</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                    System.out.print(name.charAt(i));</div><div class="line">                &#125;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 同步函数 （注意：一个方法最好就1个synchronized，如果还有同步代码块就容易产生死锁）</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output2</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                System.out.print(name.charAt(i));</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output3</span><span class="params">(String name)</span></span>&#123; <span class="comment">// 静态同步函数</span></div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                System.out.print(name.charAt(i));</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以必须要用一把锁来挡住冲突的线程，不同的锁是无法挡住这些冲突的线程的.</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock比传统线程模型中的synchronized方法更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。</p>
<p>两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。<br>锁是上在代表要操作的资源的类的内部方法中，而不是线程代码中。</p>
<p>Lock使用lock()、unlock()加锁解锁，比synchronized功能更多，JDK6后性能和synchronized差不多</p>
<p>除此之外Lock接口还有两个非常强大的实现类<br>(1)ReentrantLock重入锁<br>(2)ReentrantReadWriteLock读写锁</p>
<p>相关文章：<br><a href="http://blog.csdn.net/canot/article/details/52050633" target="_blank" rel="external">Java中的锁-Lock接口解析</a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>同步还有个小小的弊端——死锁     </p>
<p>死锁：同步中嵌套同步的锁<br>如你持有一个锁，我也有一个锁，我要到你那里去运行，所以要拿你的锁，<br>而你又要到我这里运行，你跟我也要锁，我不放我的锁我要进你那里去，你也不放你的锁要进我这里来，<br>谁都不放，这种现象就叫死锁，导致程序挂着不动了。</p>
<p>下面看几个死锁示例，面试题也有写出死锁程序，因为，能写出死锁，意味着理解死锁也就能避免死锁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 死锁示例1</div><div class="line"> **/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">1000</span>;</div><div class="line">    Object obj = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  <span class="comment">// 实现Runnable接口后要覆盖run方法 </span></div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(obj)&#123;  <span class="comment">// 同步代码块，锁是obj</span></div><div class="line">                    show();         <span class="comment">// 同步代码块里有同步函数（obj锁里有this锁）</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">// 同步函数，锁是this</span></div><div class="line">        <span class="comment">// 注意：这里放while(true)将会无法死锁</span></div><div class="line">        <span class="keyword">synchronized</span>(obj)&#123; <span class="comment">// 同步函数里有同步代码块，this锁里有obj锁</span></div><div class="line">            <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"同步代码块 : "</span> + tick--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Ticket t = <span class="keyword">new</span> Ticket();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);  </div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);  </div><div class="line">        t1.start();</div><div class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">        t.flag = <span class="keyword">false</span>;</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">死锁示例2</div><div class="line">比上面的简单一些,这个程序要掌握!</div><div class="line">考的是对死锁的理解，能写出来，多线程就差不多了，死锁能理解，就能避免死锁，同步也能很熟了，不熟的话是写不出死锁的.</div><div class="line">用于面试题：请写一个死锁程序</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(<span class="keyword">true</span>));</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(<span class="keyword">false</span>));</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> Object locka = <span class="keyword">new</span> Object();  <span class="comment">// 想要调用locka就得创建对象，麻烦，所以静态（static）方便调用</span></div><div class="line">    <span class="keyword">static</span> Object lockb = <span class="keyword">new</span> Object();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">// 实现Runnable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;       <span class="comment">// 定义一个标记</span></div><div class="line">    Test(<span class="keyword">boolean</span> flag)&#123;</div><div class="line">        <span class="keyword">this</span>.flag = flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   <span class="comment">// 实现Runnable接口后要覆盖run方法 </span></div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 少运行怕锁不上，所以一直循环，为了让它锁上</span></div><div class="line">                <span class="keyword">synchronized</span>(MyLock.locka)&#123;               <span class="comment">// A锁（嵌套B锁）</span></div><div class="line">                    System.out.println(<span class="string">"if locka"</span>);       <span class="comment">// 打印if A锁</span></div><div class="line">                    <span class="keyword">synchronized</span>(MyLock.lockb)&#123;           <span class="comment">// B锁（被A锁嵌套）</span></div><div class="line">                        System.out.println(<span class="string">"if lockb"</span>);   <span class="comment">// 打印if B锁</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(MyLock.lockb)&#123;               <span class="comment">// B锁（嵌套A锁）</span></div><div class="line">                    System.out.println(<span class="string">"else lockb"</span>);     <span class="comment">// 打印else B锁</span></div><div class="line">                    <span class="keyword">synchronized</span>(MyLock.locka)&#123;           <span class="comment">// A锁（被B锁嵌套）</span></div><div class="line">                        System.out.println(<span class="string">"else locka"</span>); <span class="comment">// 打印else A锁</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="多线程间通信问题"><a href="#多线程间通信问题" class="headerlink" title="多线程间通信问题"></a>多线程间通信问题</h1><hr>
<p>线程间通讯其实就是多个线程在操作同一个资源，<br>但是操作的动作不同，一个线程负责存进数据，另一个负责拿走数据<br>所以说得2个run方法存放数据存放在2个类中<br>不过就是因为多个线程在一存一取，一旦发生不同步问题，所以会引发巨大的隐患.</p>
<h2 id="线程间通信机制"><a href="#线程间通信机制" class="headerlink" title="线程间通信机制"></a>线程间通信机制</h2><p>针对上述情况有以下几种解决方案：<br>1.等待唤醒机制<br>2.条件对象Condition:<br>3.BlockingQueue</p>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>等待唤醒机制在开发时非常常见<br>比喻2个人同时做事情，而且做的不一样，等第一个人做完了第二个在做，<br>操作局部数据2个人可以随便<br>操作共享数据时为了避免出现问题会定一个规矩：我完事了叫你动了你在动</p>
<p>3个相关方法：</p>
<ul>
<li><p>wait()<br>等待<br>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。<br>换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。<br>当前线程必须拥有此对象监视器（对象监视器就是同步的锁。什么时候有锁？只有同步才有锁）<br>这个方法需要抓异常<br>特点：放弃了执行资格</p>
</li>
<li><p>notify()<br>唤醒（用在同步里面）（API：java.lang，Object）</p>
</li>
<li><p>notifyAll()<br>集体唤醒线程池中的所有线程（用在同步里面）（API：java.lang，Object）</p>
</li>
</ul>
<p>以上3个方法都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，因为只有同步才具有锁.</p>
<h4 id="等待唤醒机制示例"><a href="#等待唤醒机制示例" class="headerlink" title="等待唤醒机制示例"></a>等待唤醒机制示例</h4><p>需求：子线程循环5次，接着主线程循环10次，接着又回到子线程循环5次，接着再回到主线程又循环10次，如此循环50次，请写出程序。</p>
<p>版本1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ThreadTest().init();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">                            business.SubThread(i);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        ).start();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            business.MainThread(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 经验：要用到共同数据（包括同步锁）或共同算法的的若干个方法应该归在同一个类身上，这种设计正好体现了高类聚和程序的健壮性，易维护。</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> bShouldSub = <span class="keyword">true</span>; <span class="comment">//这里相当于定义了控制该谁执行的一个信号灯</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">MainThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (bShouldSub)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bShouldSub = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">SubThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!bShouldSub)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bShouldSub = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>版本2：优化上一代码<br>不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bShouldMain = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(</div><div class="line">            <span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</div><div class="line">                        <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</div><div class="line">                            <span class="keyword">if</span> (bShouldMain) &#123;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    ThreadTest.class.wait();</div><div class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                    e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">                            &#125;</div><div class="line">                            bShouldMain = <span class="keyword">true</span>;</div><div class="line">                            ThreadTest.class.notify();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ).start();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</div><div class="line">                <span class="keyword">if</span> (!bShouldMain) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        ThreadTest.class.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bShouldMain = <span class="keyword">false</span>;</div><div class="line">                ThreadTest.class.notify();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>版本3：下面使用jdk5中的并发库来实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition subThreadCondition = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bBhouldSubThread = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">                    lock.lock();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (!bBhouldSubThread)</div><div class="line">                            subThreadCondition.await();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">",j="</span> + j);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        bBhouldSubThread = <span class="keyword">false</span>;</div><div class="line">                        subThreadCondition.signal();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        lock.unlock();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        threadPool.shutdown();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            lock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (bBhouldSubThread)</div><div class="line">                    subThreadCondition.await();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">",j="</span> + j);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bBhouldSubThread = <span class="keyword">true</span>;</div><div class="line">                subThreadCondition.signal();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="条件对象Condition"><a href="#条件对象Condition" class="headerlink" title="条件对象Condition"></a>条件对象Condition</h3><p>await/signal/signalAll</p>
<h3 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h3><p><a href="http://blog.csdn.net/suifeng3051/article/details/48807423" target="_blank" rel="external">【Java并发之】BlockingQueue</a></p>
<h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p><a href="http://www.cnblogs.com/linjiqin/p/3217050.html" target="_blank" rel="external">Java多线程-并发协作(生产者消费者模型)</a></p>
<h2 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.wait()，notify()，notify All()，用来操作线程为什么定义在了Object类中？<br>(1)这些方法存在与同步中<br>(2)使用这些方法时必须要标识所属的同步的锁<br>(3)锁可以是任意对象，所以任意对象调用的方法一定定义在Object类中</p>
<p>2.wait()，sleep()有什么区别？<br>(1)wait()：释放资源，释放锁<br>(2)sleep()：释放资源，不释放锁</p>
<p>3.等待的线程在哪呢？<br>线程运行的时候会建立一个线程池，等待线程都临时存在这个线程池当中（线程没挂，但是不能动）<br>notify唤醒的都是线程池中的线程，唤醒的顺序是第一个被等待的，因为是按顺序往里存的</p>
<p>4.为什么定义notifyAll？<br>因为需要唤醒对方线程<br>因为只用notify，容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待！</p>
<p>5.死锁和notifyAll(全部等待)的区别：<br>死锁：我的和你要，你的和我要，谁都不放<br>全部等待：你我都动不了，都不是活的，全冻结了</p>
<p>6.对于多个生产者和消费者，为什么要定义while判断标记？<br>原因：让被唤醒的线程再一次判断标记。</p>
<p>7.生产者和消费者有什么替代方案？<br>JDK1.5之前一个锁对应一个wait notify，如果还想要一组wait notify就得还定义一个锁，<br>在建锁就得在建同步，一同步2个就形成嵌套就容易死锁</p>
<p>JDK1.5现在变成了一个锁有好几组wait notify(可以对应好几个Condition对象)，就是wait notify封装成了Condition对象<br>详细说就是JDK1.5版本中提供了显示的锁机制，以及锁对象身上的等待唤醒操作机制，同时它把等待和唤醒给封装了，一个锁有多个Condition</p>
<p>Lock：替代了Synchronized<br>    lock(); 获取锁（加锁）<br>    unlock(); 释放锁（解锁）<br>    newCondition(); 返回Condition对象</p>
<p>Condition：替代了Object 类的 wait / notify / notifyAll<br>    await();<br>    signal();<br>    signalAll();</p>
<hr>
<h1 id="线程管理类-线程池"><a href="#线程管理类-线程池" class="headerlink" title="线程管理类(线程池)"></a>线程管理类(线程池)</h1><hr>
<h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><p>首先介绍在Tcp服务器编程模型的原理，每一个客户端连接用一个单独的线程为之服务，当与客户端的会话结束时，线程也就结束了，即每来一个客户端连接，服务器端就要创建一个新线程。<br>如果访问服务器的客户端很多，那么服务器要不断的创建和销毁线程，这将严重影响服务器的性能。<br>所以要创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池中。<br>就这样，在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程。</p>
<p>线程池（thread pool）：<br>就是有多个线程</p>
<p>线程池的作用：<br>管理好几个线程，固定几个线程，<br>不然拼命New Thread就浪费资源了，因为如果不对线程的数量进行控制，而不断New Thread（开线程）很浪费资源</p>
<p>线程池就2个东西：<br>几个线程，里面仍了几个任务<br>我们要做的就是把任务扔到池子里让线程池自己办</p>
<p>一个应用程序可能有多个线程池，每个线程池负责一件事，如网络访问有一个线程池，数据库操作有一个线程池，优先级的的操作也有一个池（池就是容器,如List ,Map）</p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。<br>线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。<br>如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。<br>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>下面说下new Thread的弊端及Java四种线程池的使用，对Android同样适用<br>还有但凡和线程池/线程/同步/锁等有关的实践问题，建议尽量不要用Android的解决方案，如AsyncTask，而要用Java中已经历经考验的实践方案 如FutureTask+ThreadPoolExecuters。</p>
<h2 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>执行一个异步任务你还只是如下new Thread吗？<br>那你就out太多了，new Thread的弊端如下：<br>a. 每次new Thread新建对象性能差。<br>b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。<br>c. 缺乏更多功能，如定时执行、定期执行、线程中断。<br>相比new Thread，Java提供的四种线程池的好处在于：<br>a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。<br>b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br>c. 提供定时执行、定期执行、单线程、并发数控制等功能。</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Java5通过Executors提供4种线程池，分别为：</p>
<p>1.newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(index);</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p>
<p>2.newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(index * <span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(index);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 </p>
<p>3.newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</div><div class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"delay 3 seconds"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>表示延迟3秒执行。</p>
<p>定期执行示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。<br>ScheduledExecutorService比Timer类更安全，功能更强大。</p>
<p>4.newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(index);</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果依次输出，相当于顺序执行各个任务。<br>现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p>
<h3 id="相关问题-2"><a href="#相关问题-2" class="headerlink" title="相关问题"></a>相关问题</h3><p>1.如果实现线程死掉后重新启动？<br>创建单一线程池（newSingleThreadExecutor）<br>它里面会创建一个线程，如果这个线程死了就马上在创建一个线程，始终有一个线程活着</p>
<p>2.执行线程的2个方法<br>Executor的execute    （没有返回值）<br>ExecutorService的submit  （有返回值，返回Future&lt;?&gt;）</p>
<p>3.线程池在Android的使用场合：<br>图片缓存的最大线程数：<br>使用线程池，分为核心线程池和普通线程池，下载图片等耗时任务放置在普通线程池，避免耗时任务阻塞线程池后，导致所有异步任务都必须等待</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>自定义线程池<br>查看Executors源码我们知道，Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，也就是上面所说的四种Executors线程池，但是 ThreadPoolExecutor 提供的功能远不止于此。<br>不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池<br>我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。 </p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolProxy</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> ThreadPoolExecutor  mExecutor;          <span class="comment">// 线程池</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 mCorePoolSize;      <span class="comment">// 核心线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 mMaximumPoolSize;   <span class="comment">// 最大线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span>                mKeepAliveTime;     <span class="comment">// 保持存活时间</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolProxy</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mCorePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.mMaximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.mKeepAliveTime = keepAliveTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initThreadPoolExecutor</span><span class="params">(Runnable task)</span></span>&#123; <span class="comment">//+同步一个时间点只能执行一次这个方法，更严谨</span></div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mExecutor == <span class="keyword">null</span> || mExecutor.isShutdown() || mExecutor.isTerminated())&#123;</div><div class="line">            <span class="comment">// keepAliveTime单位</span></div><div class="line">            TimeUnit unit = TimeUnit.MILLISECONDS;</div><div class="line"></div><div class="line">            <span class="comment">// 任务队列/阻塞队列</span></div><div class="line">            BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();                      <span class="comment">// 不固定大小队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(10);                  // 固定大小队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new PriorityBlockingQueue(initialCapacity, comparator);// 优先级队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new SynchronousQueue&lt;Runnable&gt;();                      // 同步队列，FIFO</span></div><div class="line"></div><div class="line">            <span class="comment">// 线程工厂</span></div><div class="line">            ThreadFactory threadFactory = Executors.defaultThreadFactory();</div><div class="line"></div><div class="line">            <span class="comment">// 错误捕获器（下面这种形式类似策略设计模式）</span></div><div class="line">            RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();         <span class="comment">// 如果出现错误，不做处理</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy();        // 如果出现错误，则直接抛出异常</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();   // 如果出现错误，直接执行加入的任务</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardOldestPolicy();// 如果出现错误,移除第一个任务,执行加入的任务</span></div><div class="line"></div><div class="line">            mExecutor = <span class="keyword">new</span> ThreadPoolExecutor(mCorePoolSize,  mMaximumPoolSize,mKeepAliveTime, unit, workQueue, threadFactory,handler);        </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务（方式1）</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> task</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</div><div class="line">        initThreadPoolExecutor(task); <span class="comment">// 初始化线程池</span></div><div class="line">        mExecutor.execute(task);  <span class="comment">// 执行线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务（方式2）</div><div class="line">     * </div><div class="line">     * submit方法和execute的区别是有返回值的（Future），说明被持有了，然后可以做了操作（如停掉）</div><div class="line">	 * future有cancel方法，可以把线程停掉（整个线程杀掉，任务正在运行就是做耗时操作也是被干掉）</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> task</div><div class="line">     * <span class="doctag">@return</span> Future</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task)&#123;</div><div class="line">        initThreadPoolExecutor(task);</div><div class="line">        <span class="keyword">return</span> mExecutor.submit(task); <span class="comment">// 执行线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * remove方法只是移出任务队列，不归我管了，因为队列里已经没有它</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Runnable task)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (mExecutor != <span class="keyword">null</span>)&#123;</div><div class="line">            mExecutor.remove(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/java-android-thread-pool/" target="_blank" rel="external">Java(Android)线程池</a><br><a href="http://blog.csdn.net/l540675759/article/details/62230562" target="_blank" rel="external">深入理解在Android中线程池的使用</a><br><a href="http://blog.csdn.net/xlxxcc/article/details/52108534" target="_blank" rel="external">Java Executors 和 ThreadPoolExecutor 线程池</a></p>
<hr>
<h1 id="线程范围内共享变量"><a href="#线程范围内共享变量" class="headerlink" title="线程范围内共享变量"></a>线程范围内共享变量</h1><hr>
<p>相关文章：<br><a href="http://blog.csdn.net/lufeng20/article/details/24314381" target="_blank" rel="external">彻底理解ThreadLocal</a></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>方便解决多线程并发问题的工具类<br>线程范围内的共享数据<br>JavsEE（底层框架）用的比较多的知识<br>Andriod用的比较少</p>
<p>简单来说，它可以为每一个使用它的线程提供一个独立的副本，而不会被其他线程影响。<br>比如在线程A中调用ThreadLocal的set方法，它会将我们set方法中传递参数对象的引用做一个记录，然后在线程A中，可以通过ThreadLocal的get方法将其取出，但在线程B中就无法获取。</p>
<p>先看下线程范围的共享变量的应用场景<br>示例代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData</span></span>&#123;	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>; <span class="comment">// 定义一个全局变量</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Thread,Integer&gt; threadData = <span class="keyword">new</span> HashMap&lt;Thread,Integer&gt;();</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  <span class="comment">// 循环2遍相当于启动2个线程</span></div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;	</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">					threadData.put(Thread.currentThread(), data);</div><div class="line">					<span class="keyword">new</span> A().get();  <span class="comment">// 调用A模块取数据</span></div><div class="line">					<span class="keyword">new</span> B().get();  <span class="comment">// 调用B模块取数据</span></div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> data = threadData.get(Thread.currentThread());</div><div class="line">			System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> data = threadData.get(Thread.currentThread());</div><div class="line">			System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread-0 has put data : 11</div><div class="line">Thread-1 has put data : 22</div><div class="line">A from Thread-0 get data : 11</div><div class="line">A from Thread-1 get data : 22</div><div class="line">B from Thread-0 get data : 11</div><div class="line">B from Thread-1 get data : 22</div></pre></td></tr></table></figure></p>
<p>结果分析：<br>线程1存进去数值11<br>线程2存进去数值22<br>A对象从线程1拿到的也是11，线程2拿到的是22<br>B同样，从线程1和线程2拿到也是11和22<br>这样就实现了每个线程有各自独立的数据，在这个线程范围内，不管哪个对象拿到的也是正常的相同线程的数量变量</p>
<p>下面开始主题，介绍下ThreadLocal<br>ThreadLocal的作用和目的：用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。</p>
<p>ThreadLocal的原理：<br>内部就是一个map<br>每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。在线程结束时可以调用ThreadLocal.clear()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。</p>
<p>ThreadLocal的应用场景：<br>1.订单处理包含一系列操作：减少库存量、增加一条流水台账、修改总账，这几个操作要在同一个事务中完成，通常也即同一个线程中进行处理，如果累加公司应收款的操作失败了，则应该把前面的操作回滚，否则，提交所有操作，这要求这些操作使用相同的数据库连接对象，而这些操作的代码分别位于不同的模块类中。<br>2.银行转账包含一系列操作： 把转出帐户的余额减少，把转入帐户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，转入和转出操作的代码分别是两个不同的帐户对象的方法。<br>3.例如Strut2的ActionContext，同一段代码被不同的线程调用运行时，该代码操作的数据是每个线程各自的状态和数据，对于不同的线程来说，getContext方法拿到的对象都不相同，对同一个线程来说，不管调用getContext方法多少次和在哪个模块中getContext方法，拿到的都是同一个。</p>
<p>实验案例：<br>定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。</p>
<p>ThreadLocal总结：<br>一个ThreadLocal代表一个变量，故其中里只能放一个数据，你有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象。如果有一个百个变量要线程共享呢？那请先定义一个对象来装这一百个变量，然后在ThreadLocal中存储这一个对象。</p>
<p>示例代码2：<br>上述代码替换成ThreadLocal形式，特别简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建议：<br>实现对ThreadLocal变量的封装，让外界不要直接操作ThreadLocal变量。<br>对基本类型的数据的封装，这种应用相对很少见。<br>对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。<br>示例代码3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    MyThreadScopeData myData = <span class="keyword">new</span> MyThreadScopeData();</div><div class="line">                    myData.setName(<span class="string">"name"</span> + data);</div><div class="line">                    myData.setAge(data);</div><div class="line">                    myThreadScopeData.set(myData);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = myThreadScopeData.get();</div><div class="line">            System.out.println(</div><div class="line">                    <span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更优雅的方式，直接单例模式<br>示例代码4：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    MyThreadScopeData.getThreadInstance().setName(<span class="string">"name"</span> + data);</div><div class="line">                    MyThreadScopeData.getThreadInstance().setAge(data);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; map = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadScopeData</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyThreadScopeData <span class="title">getThreadInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 互斥也不用加了</span></div><div class="line">        MyThreadScopeData instance = map.get();</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> MyThreadScopeData();</div><div class="line">            map.set(instance);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="多个线程访问共享对象和数据的方法"><a href="#多个线程访问共享对象和数据的方法" class="headerlink" title="多个线程访问共享对象和数据的方法"></a>多个线程访问共享对象和数据的方法</h2><hr>
<p>需求：设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</p>
<p>示例代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadShareData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ShareData1 data1 = <span class="keyword">new</span> ShareData1();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ShareData1 data2 = <span class="keyword">new</span> ShareData1();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable1(data2)).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable2(data2)).start();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ShareData1 data1 = <span class="keyword">new</span> ShareData1();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                data1.decrement();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                data1.increment();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ShareData1 data1;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable1</span><span class="params">(ShareData1 data1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data1 = data1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data1.decrement();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ShareData1 data1;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable2</span><span class="params">(ShareData1 data1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data1 = data1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data1.increment();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例代码2：（比较复杂）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line"></div><div class="line">        ThreadTest1 tt = <span class="keyword">new</span> ThreadTest1();</div><div class="line"></div><div class="line">        Inc inc = tt.new Inc();</div><div class="line">        Dec dec = tt.new Dec();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread(inc);</div><div class="line">            t.start();</div><div class="line">            t = <span class="keyword">new</span> Thread(dec);</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-inc:"</span> + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-dec:"</span> + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                inc();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                dec();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例代码2：（更简化的版本）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    JManager j = <span class="keyword">new</span> JManager();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> A().call();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        j.accumulate();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        j.subtract();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtract</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><hr>
<h2 id="AtomicInteger、AtomicBoolean等等"><a href="#AtomicInteger、AtomicBoolean等等" class="headerlink" title="AtomicInteger、AtomicBoolean等等"></a>AtomicInteger、AtomicBoolean等等</h2><p>一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。这个类在AsyncTask中用到了。</p>
<p>多个线程访问同一个整数数据的情况下，一定要用这个类</p>
<h2 id="AtomicFile"><a href="#AtomicFile" class="headerlink" title="AtomicFile"></a>AtomicFile</h2><p>AtomicFile首先不是用来代替File的，而是作为File的辅助类从在， AtomicFile的作用是实现事务性原子操作，即文件读写必须完整，适合多线程中的文件读写操作。</p>
<p>用来实现多线程中的文件读写的安全操作</p>
<p>注意：AtomicFile是android.util包下的API，不是Java并发包的API.</p>
<h2 id="Atomic、volatile、synchronized区别"><a href="#Atomic、volatile、synchronized区别" class="headerlink" title="Atomic、volatile、synchronized区别"></a>Atomic、volatile、synchronized区别</h2><p><a href="https://kymjs.com/code/2016/03/08/01/" target="_blank" rel="external">开源实验室——面试后的总结</a></p>
<hr>
<h1 id="线程安全容器类"><a href="#线程安全容器类" class="headerlink" title="线程安全容器类"></a>线程安全容器类</h1><hr>
<p>详情查看<br><a href="http://www.hengxing.me/2017/09/07/it/1.Java/CollectionsFramework/" target="_blank" rel="external">Java集合框架的总结</a></p>
<hr>
<h1 id="Android中的多线程编程"><a href="#Android中的多线程编程" class="headerlink" title="Android中的多线程编程"></a>Android中的多线程编程</h1><hr>
<h2 id="Android中有哪几种方法可以使得任务并发执行？"><a href="#Android中有哪几种方法可以使得任务并发执行？" class="headerlink" title="Android中有哪几种方法可以使得任务并发执行？"></a>Android中有哪几种方法可以使得任务并发执行？</h2><p>AsyncTask与Loader<br>IntentService<br>Threads与HandlerThread<br>FutureTask<br>ThreadPoolExecutor<br>CountDownTimer 与 Timer<br>JobScheduler 与 GcmNetworkManager<br>相关文章：<br><a href="http://www.cnblogs.com/xlk0101/p/5122432.html" target="_blank" rel="external">Android中8种异步处理与计算的方法</a><br><a href="http://blog.csdn.net/wangjigaoyi/article/details/51911145" target="_blank" rel="external">在Android中使用并发来提高速度和性能</a></p>
<h2 id="Android如何实现多线程之间同步访问共享数据"><a href="#Android如何实现多线程之间同步访问共享数据" class="headerlink" title="Android如何实现多线程之间同步访问共享数据"></a>Android如何实现多线程之间同步访问共享数据</h2><p>相关文章：<br><a href="http://blog.csdn.net/csdn_aiyang/article/details/65442540" target="_blank" rel="external">Android之多线程实现方式及并发与同步</a><br><a href="http://www.cnblogs.com/0616--ataozhijia/p/3649519.html" target="_blank" rel="external">Androidi性能优化之多线程和同步</a></p>
<hr>
<h1 id="相关多线程文章"><a href="#相关多线程文章" class="headerlink" title="相关多线程文章"></a>相关多线程文章</h1><hr>
<p><a href="http://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="external">Java中的多线程你只要看这一篇就够了</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_java_thread.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - Java" scheme="https://hengxing0080.github.io/categories/IT-Java/"/>
    
    
      <category term="Java" scheme="https://hengxing0080.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Session &amp; Cookie &amp; Token的区别</title>
    <link href="https://hengxing0080.github.io/2017/09/04/it/2.NetworkProtocol/Session/"/>
    <id>https://hengxing0080.github.io/2017/09/04/it/2.NetworkProtocol/Session/</id>
    <published>2017-09-04T10:20:01.000Z</published>
    <updated>2017-09-29T16:29:48.823Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_session1.jpg" alt="UML图"><br><a id="more"></a></p>
<hr>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><hr>
<p>中文名：时域 | 会话<br>外文名：Session<br>应用学科：软件 网络通信<br>属性：用户与交互系统通信的时间间隔</p>
<h2 id="Session简介"><a href="#Session简介" class="headerlink" title="Session简介"></a>Session简介</h2><p>简单理解就是存在服务端的缓存</p>
<p>session的中文翻译是“会话”，当用户打开某个web应用时，便与web服务器产生一次session。<br>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。<br>这种用户信息存储方式相对cookie来说更安全<br>比如说你用某个账号登陆某新浪，那么新浪的服务器端就会生成一个session来记录你的登陆状态，一般10分钟或者20分钟就失效了，<br>而cookie是网页指令让浏览器生成本地的记录你的登陆状态的文件。一般对安全性要求不高的话就可以直接在客户端生成cookie来记录登陆状态，否则就需要超时处理用session</p>
<p>session在WEB技术中占有非常重要的份量。<br>由于网页是一种无状态的连接程序，因此你无法得知用户的浏览状态。<br>因此我们必须通过session记录用户的有关信息，以供用户再次以此身份对web服务器提供要求时作确认，<br>例如，我们在某些网站中常常要求用户登录，但我们怎么知道用户已经登录了呢，<br>如果没有session的话，登录信息是无法保留的，那岂不要让用户在每一页网页中都要提供用户名和密码。 </p>
<h2 id="Session和Cookie的生命周期"><a href="#Session和Cookie的生命周期" class="headerlink" title="Session和Cookie的生命周期"></a>Session和Cookie的生命周期</h2><p>session和cookies都是来存储信息的但是他们的寿命不一样：比如你登录一个网站你有自己的帐号。昵称啊什么的这些就保存在session里当网页不关闭，session就存在。但是当你关闭之后session就清空了。<br>而cookies则可以在电脑的缓存文件里添加记录，这样即使当你的程序关闭了，但是记录却被永久保存了下来。存活期较session长。</p>
<h2 id="Session缺陷"><a href="#Session缺陷" class="headerlink" title="Session缺陷"></a>Session缺陷</h2><p>如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>
<h2 id="Session和Cookie的区别比较"><a href="#Session和Cookie的区别比较" class="headerlink" title="Session和Cookie的区别比较"></a>Session和Cookie的区别比较</h2><p><img src="/images/it_network_session2.jpg" alt="UML图"></p>
<p>用处：<br>两者都可以用来跟踪和保存客户端的状态信息</p>
<p>保存地点：<br>Session是在服务器端创建,在服务端保存(所以Session的安全性高于Cookie)<br>Cookie是在服务器端创建,在客户端保存，</p>
<p>保存类型：<br>Session是依赖于Cookie的, Sessionid还是存放在Cookie中并保存在客户端的浏览器中<br>Cookie中只能存放String类型,而session中可以存放Object类型。</p>
<p>安全性：<br>cookie存在客户端的磁盘上对用户透明<br>session存在服务器端而且sessionID是加密的相对来说seesion较安全。<br>用户的会话通过cookie中存储的session id 来和服务器端的session进行关联从而保持正常的会话。</p>
<h2 id="Session都是可以存在哪？"><a href="#Session都是可以存在哪？" class="headerlink" title="Session都是可以存在哪？"></a>Session都是可以存在哪？</h2><p>数据库、缓存、文件</p>
<h2 id="如果把Cookie-禁掉Session还能用吗？"><a href="#如果把Cookie-禁掉Session还能用吗？" class="headerlink" title="如果把Cookie 禁掉Session还能用吗？"></a>如果把Cookie 禁掉Session还能用吗？</h2><p>1.通过url传值，把session id附加到url上（缺点：整个站点中不能有纯静态页面，因为当是纯静态页面session id 将无法继续向后传了）</p>
<p>2.通过隐藏表单，把session id 放到表单的隐藏文本框中同表单一块提交过去（缺点：不适用<a>标签这种直接跳转的非表单的情况）</a></p>
<p>3.直接配置php.ini文件,将php.ini文件里的session.use_trans_sid= 0设为1,</p>
<p>4.用文件、数据库等形式保存Session ID，在跨页过程中手动调用</p>
<hr>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><hr>
<p>中文名：储存在用户本地终端上的数据<br>外文名：Cookie<br>复数形式：Cookies</p>
<h2 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h2><p>网站为了辨别用户身份，而储存在本地设备上的数据，包括用户名和密码</p>
<p>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而储存在用户本地终端上的数据（通常经过加密）。</p>
<p>Cookie是保存在本地终端的数据。<br>Ccokie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</p>
<h2 id="Cookie的组成"><a href="#Cookie的组成" class="headerlink" title="Cookie的组成"></a>Cookie的组成</h2><p>名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”\”)、失效时间、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。</p>
<h2 id="Cookie分两种"><a href="#Cookie分两种" class="headerlink" title="Cookie分两种"></a>Cookie分两种</h2><p>一种叫会话cookie是没有设置过期时间，当关闭浏览器后cookie将消失；<br>另一种是设置了过期时间叫持久cookie，这种cookie存储在磁盘中关闭浏览器后cookie不会消失。</p>
<h2 id="各浏览器Cookie大小、个数限制"><a href="#各浏览器Cookie大小、个数限制" class="headerlink" title="各浏览器Cookie大小、个数限制"></a>各浏览器Cookie大小、个数限制</h2><p>由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。<br>详情查看文章：↓<br><a href="http://www.cnblogs.com/henryhappier/archive/2011/03/03/1969564.html" target="_blank" rel="external">各浏览器Cookie大小、个数限制</a></p>
<hr>
<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><hr>
<p>中文名 令牌，标记<br>外文名 Token </p>
<h2 id="Token简介"><a href="#Token简介" class="headerlink" title="Token简介"></a>Token简介</h2><p>代表执行某些操作的权利的对象,是用户身份的验证方式。</p>
<h2 id="Token组成"><a href="#Token组成" class="headerlink" title="Token组成"></a>Token组成</h2><p>最简单的token组成:<br>　uid(用户唯一的身份标识)<br>　time(当前时间的时间戳)<br>　sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。<br>　还可以把不变的参数也放进token，避免多次查库</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><h3 id="访问令牌（Access-token）"><a href="#访问令牌（Access-token）" class="headerlink" title="访问令牌（Access token）"></a>访问令牌（Access token）</h3><p>表示访问控制操作主体的系统对象</p>
<p>access_token一般作为请求操作时的访问令牌，比如你让用户用QQ登陆后要去拿用户的QQ头像，这时候向腾讯API发送请求时就需要带上access_token。</p>
<p>如果只是单纯的登陆的话，登陆后不做任何请求，理论上是可以不存access_token的，但是还是推荐你按照Oath2.0的标准来做。<br>想象一种情况，我授权了一个应用，它拿到了我的access_token，然后我忘记我授权过了，于是我以后每次发布的内容都被它拿去存起来，或者它利用我的账号偷偷的发消息，我一点都不知道。 这种情况还是很可怕的。</p>
<h3 id="密保令牌（Security-token）"><a href="#密保令牌（Security-token）" class="headerlink" title="密保令牌（Security token）"></a>密保令牌（Security token）</h3><p>或者硬件令牌，例如U盾，或者叫做认证令牌或者加密令牌，一种计算机身份校验的物理设备</p>
<h3 id="会话令牌（Session-token）"><a href="#会话令牌（Session-token）" class="headerlink" title="会话令牌（Session token）"></a>会话令牌（Session token）</h3><p>交互会话中唯一身份标识符</p>
<h3 id="令牌化技术-Tokenization"><a href="#令牌化技术-Tokenization" class="headerlink" title="令牌化技术 (Tokenization)"></a>令牌化技术 (Tokenization)</h3><p>取代敏感信息条目的处理过程</p>
<h3 id="邀请码"><a href="#邀请码" class="headerlink" title="邀请码"></a>邀请码</h3><p>在邀请系统中使用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_session1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IT - 网络 - 相关" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Socket机制</title>
    <link href="https://hengxing0080.github.io/2017/09/03/it/2.NetworkProtocol/Socket/"/>
    <id>https://hengxing0080.github.io/2017/09/03/it/2.NetworkProtocol/Socket/</id>
    <published>2017-09-03T07:19:20.000Z</published>
    <updated>2017-10-06T11:46:50.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_socket1.png" alt="UML图"></p>
<a id="more"></a>
<p>中文名：套接字<br>外文名：Socket<br>英文原义：“孔”或“插座”地方<br>常用类型：流式Socket和数据包式Socket<br>相关模型：对等模型、C/S模型<br>相关应用：C#/C++语言应用, python应用<br>区号：它的网络地址</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>可以理解成码头（港口），2个港口通过船传输货物。所以说想要通讯必须要有港口。<br>或者理解成就是插座。服务器的socket，就是服务器提供插座，等着客户端的插头插进来。一旦插入完成，服务器-客户端的通信就建立了。 ​​</p>
<p>网络编程其实指的就是Socket编程 （Socket编程主要是记住流程，代码是查询文档不是很难）</p>
<p>Socket：套接字，多指传输层网络接口。<br>Socket就是为网络服务提供的一种机制。<br>通信的两端都有Socket。<br>网络通信其实就是Socket间的通信。<br>数据在两个Socket间通过IO传输。</p>
<p>Socket和SocketServer是基于套接字的服务端和客户端实现<br>Socket和SocketServer是服务端和客户端的区别</p>
<p>Socket是为了实现以上的通信过程而建立成来的通信管道，其真实的代表是客户端和服务器端的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。<br>socket只是一种连接模式，不是协议，tcp、udp，简单的说（虽然不准确）是两个最基本的协议,很多其它协议都是基于这两个协议如，http就是基于tcp的，.用socket可以创建tcp连接，也可以创建udp连接，这意味着，用socket可以创建任何协议的连接，因为其它协议都是基于此的。</p>
<h1 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h1><p>根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。<br>（1）服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。<br>（2）客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>（3）连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h1 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h1><p><img src="/images/it_network_socket2.png" alt="UML图"><br><img src="/images/it_network_socket3.png" alt="UML图"></p>
<h1 id="套接字的理解"><a href="#套接字的理解" class="headerlink" title="套接字的理解"></a>套接字的理解</h1><p>中文名 套接字<br>外文名 Socket<br>连接方式 通过传输层进行数据通信<br>流式套接字 双向字节流</p>
<p>源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。<br>其用于标识客户端请求的服务器和服务。<br>它是网络通信过程中端点的抽象表示，<br>包含进行网络通信必需的5种信息：<br>(1)连接使用的协议<br>(2)本地主机的IP地址<br>(3)本地进程的协议端口<br>(4)远地主机的IP地址<br>(5)远地进程的协议端口</p>
<p>TCP/IP的”传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_socket1.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 相关" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>URI &amp; URL &amp; URN 的区别</title>
    <link href="https://hengxing0080.github.io/2017/09/02/it/2.NetworkProtocol/URI/"/>
    <id>https://hengxing0080.github.io/2017/09/02/it/2.NetworkProtocol/URI/</id>
    <published>2017-09-02T02:10:51.000Z</published>
    <updated>2017-09-29T16:29:33.429Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_uri1.jpg" alt="UML图"></p>
<a id="more"></a>
<ul>
<li><p>URI ：Uniform Resource Identifier，统一资源标识符<br>统一资源标识符（URI）提供了一个简单、可扩展的资源标识方式。<br>URI规范中的语义和语法来源于万维网全球信息主动引入的概念，万维网从1990年起使用这种标识符数据，并被描述为“万维网中的统一资源描述符”。</p>
</li>
<li><p>URL：Uniform Resource Locator，统一资源定位符<br>URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置。</p>
</li>
<li><p>URN：Uniform Resource Name，统一资源名称<br>URN是URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。</p>
</li>
</ul>
<p>注意要记住，其中，URL,URN是URI的子集。<br><img src="/images/it_network_uri2.jpg" alt="UML图"></p>
<hr>
<h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><hr>
<p>中文名：统一资源标识符<br>外文名：Uniform Resource Identifier<br>简称：URI<br>应用：万维网</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>比URL范围更广泛, 接收自定义的路径<br>标识、定位任何资源的字符串<br>该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。<br>URI由包括确定语法和相关协议的方案所定义。<br>Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用URI进行定位。</p>
<p>URI  是一个用于标识某一互联网资源名称的字符串。<br>该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。</p>
<h2 id="URI组成"><a href="#URI组成" class="headerlink" title="URI组成"></a>URI组成</h2><p>URI一般由三部分组成：<br>一、主机名<br>二、标志符<br>三、相对URI</p>
<h2 id="URI示例"><a href="#URI示例" class="headerlink" title="URI示例"></a>URI示例</h2><p>电话<br>tel://110</p>
<p>远程图片<br><a href="http://或者https://" target="_blank" rel="external">http://或者https://</a> </p>
<p>本地文件<br>file:// </p>
<p>Content provider  ( 内容提供者 )<br>content://    </p>
<p>asset目录下资源<br>assets:// </p>
<p>res目录下资源<br>res:// </p>
<hr>
<h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><hr>
<p>中文名：统一资源定位符 | 统一资源定位器<br>外文名：Uniform Resource Locator<br>缩写：URL<br>发明者：蒂姆·伯纳斯·李</p>
<h2 id="URL简介"><a href="#URL简介" class="headerlink" title="URL简介"></a>URL简介</h2><p>简单理解：网络路径地址，用于描述一个网络上的资源, 用于定位万维网上的文档（或其他数据）。如网址http, ftp,  rtsp等等</p>
<p>概念理解：URL是统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。<br>互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<h2 id="URL组成"><a href="#URL组成" class="headerlink" title="URL组成"></a>URL组成</h2><p>网址比如：<a href="http://www.w3school.com.cn/html/index.asp，" target="_blank" rel="external">http://www.w3school.com.cn/html/index.asp，</a><br>遵守这样的语法规则：scheme://host.domain:port/path/filename</p>
<p>解释：<br>scheme - 定义因特网服务的类型。最常见的类型是 http<br>host - 定义域主机（http 的默认主机是 www）<br>domain - 定义因特网域名，比如 w3school.com.cn<br>:port - 定义主机上的端口号（http 的默认端口号是 80）<br>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename - 定义文档/资源的名称</p>
<p>基本URL包含：<br>模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如“协议://授权/路径?查询”。</p>
<p>完整的、带有授权部分的普通统一资源标志符语法看上去如下：<br>协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志</p>
<h2 id="URL例子"><a href="#URL例子" class="headerlink" title="URL例子"></a>URL例子</h2><p><a href="http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff" target="_blank" rel="external">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</a><br>　Schema:                 http<br>　host:                   www.mywebsite.com<br>　path:                   /sj/test/test.aspx<br>　Query String:           name=sviergn&amp;x=true<br>　Anchor:                 stuff</p>
<p><a href="http://www.crazyit.org:80/ethos.php" target="_blank" rel="external">http://www.crazyit.org:80/ethos.php</a><br>　这种可分为如下3个部分<br>　<a href="http://：URL的写部分，只要通过HTTP协议来访问网络，这部分是固定的。" target="_blank" rel="external">http://：URL的写部分，只要通过HTTP协议来访问网络，这部分是固定的。</a><br>　www.crazyit.org：域名部分。只要访问制定的网站，这个部分总是固定的。<br>　ethos.php：网站资源部分。当访问者需要访问不同资源时，这部分是动态改变的。</p>
<p>URL是URI的一个子集，告诉我们访问网络位置的方式。在我们的例子中，URL应该如下所示：</p>
<h2 id="Url最长可以有多长"><a href="#Url最长可以有多长" class="headerlink" title="Url最长可以有多长"></a>Url最长可以有多长</h2><p>在http协议中，其实并没有对url长度作出限制，往往url的最大长度和用户浏览器和Web服务器有关，不一样的浏览器，能接受的最大长度往往是不一样的，当然，不一样的Web服务器能够处理的最大长度的URL的能力也是不一样的。</p>
<p>Microsoft Internet Explorer (Browser)<br>IE浏览器对URL的最大限制为2083个字符</p>
<p>Firefox (Browser)<br>对于Firefox浏览器URL的长度限制为65,536个字符，但当我测试时，最大只能处理8182个字符，这是因为url的长度除了浏览器限制外，还会受Web服务器的限制，而我本机使用的是ubuntu apache服务器，最大处理能力为8192个字符(相差10个字符，不知道是什么原因)，一旦超过这个长度，服务器就返回错误信息。</p>
<p>Safari (Browser)<br>URL最大长度限制为 80,000个字符。</p>
<p>Opera (Browser)<br>URL最大长度限制为190,000个字符。</p>
<p>Google (chrome)<br>url长度一旦超过8182个字符时，出现服务器错误</p>
<p>Apache (Server)<br>能接受最大url长度为8,192个字符，但我的测试数据是8,182。</p>
<p>Microsoft Internet Information Server(IIS)<br>能接受最大url的长度为16,384个字符。</p>
<p>通过上面的数据可知，为了让所有的用户都能正常浏览，我们的URL最好不要超过IE的最大长度限制(2083个字符），当然，如果URL不直接提供给用户，而是提供给程序调用，侧这时的长度就只受Web服务器影响了。</p>
<p>注：可能有些朋友会想当然的认为，如果最大长度限制为2083字符，是不是参数差不多可以传递1000个左右的汉字。这样认为其实是不对的，对于中文的传递，最终会为urlencode后的编码形式进行传递，如果浏览器的编码为UTF8的话，一个汉字最终编码后的字符长度为9个字符。</p>
<p>详情文章：<br><a href="http://www.cnblogs.com/henryhappier/archive/2010/10/09/1846554.html" target="_blank" rel="external">URL最大长度问题</a></p>
<hr>
<h1 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h1><hr>
<p>中文名：统一资源名称<br>外文名：URN<br>全称：Uniform Resource Name<br>作用：标识持久性 Internet 资源</p>
<h2 id="URN简介"><a href="#URN简介" class="headerlink" title="URN简介"></a>URN简介</h2><p>唯一标识一个实体的标识符，但是不能给出实体的位置。<br>系统可以先在本地寻找一个实体，在它试着在Web上找到该实体之前。<br>它也允许Web位置改变，然而这个实体却还是能够被找到。</p>
<p>标识持久性 Internet 资源。<br>URN 可以提供一种机制，用于查找和检索定义特定命名空间的架构文件。<br>尽管普通的 URL 可以提供类似的功能，但是在这方面，URN 更加强大并且更容易管理，因为 URN 可以引用多个 URL。</p>
<p>与 URL 不同，URN 与地址无关。<br>URN 和 URL 都属于 URI。<br>URN在web中主要应用是下拉菜单的制作。使用URN时下拉菜单的易扩展性将会得到很大的提高。<br>P2P下载中使用的磁力链接是URN的一种实现，它可以持久化的标识一个BT资源，资源分布式的存储在P2P网络中，无需中心服务器用户即可找到并下载它。</p>
<h2 id="URN示例"><a href="#URN示例" class="headerlink" title="URN示例"></a>URN示例</h2><p>URN是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bitpoetry.io/posts/hello.html#intro</div></pre></td></tr></table></figure></p>
<p>URL也是URI的一个子集，告诉我们访问网络位置的方式。上述URN的URN形式写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://bitpoetry.io/posts/hello.html</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_uri1.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 相关" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议</title>
    <link href="https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/UDP/"/>
    <id>https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/UDP/</id>
    <published>2017-09-01T15:10:05.000Z</published>
    <updated>2017-09-29T08:21:43.696Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_udp.jpg" alt="UML图"></p>
<a id="more"></a>
<p>中文名　用户数据报协议<br>外文名　User Datagram Protocol<br>特点　不可靠快速传输<br>简称　UDP<br>用途　应用程序之间的简单通信</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一个简单的面向数据报的运输层协议。<br>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。<br>由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快<br>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p>
<h1 id="UDP连接和TCP的不同之处"><a href="#UDP连接和TCP的不同之处" class="headerlink" title="UDP连接和TCP的不同之处"></a>UDP连接和TCP的不同之处</h1><p>Tcp：<br>滑动窗口协议. 拥塞控制.<br>面向连接<br>类似InputStream和OutputStream，是个流，流里的数据不会断开，前后顺序也不会混乱<br>画面优先（数据不丢包）</p>
<p>Udp：<br>不关心数据是否达到,是否阻塞<br>面向无连接<br>流畅优先（速度快）</p>
<h1 id="Java中的UDP"><a href="#Java中的UDP" class="headerlink" title="Java中的UDP"></a>Java中的UDP</h1><p>对象：DatagramSocket与DatagramPacket</p>
<p>步骤：<br>建立发送端，接收端。<br>建立数据包。<br>调用Socket的发送接收方法。<br>关闭Socket。</p>
<p>运行顺序：<br>发送端与接收端是两个独立的运行程序。<br>因为是面向无连接，所以先运行哪个都行</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_udp.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>TCP协议</title>
    <link href="https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/TCP/"/>
    <id>https://hengxing0080.github.io/2017/09/01/it/2.NetworkProtocol/TCP/</id>
    <published>2017-09-01T13:11:55.000Z</published>
    <updated>2017-09-29T08:21:38.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_network_tcp0.png" alt="UML图"></p>
<a id="more"></a>
<p>中文名　传输控制协议<br>英文名　Transmission Control Protocol<br>简称　TCP</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TCP 用于应用程序之间通信的一种协议规范,用于从应用程序到网络的数据传输控制。<br>TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p>
<p>提供的是面向连接、可靠的字节流服务。<br>当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。<br>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端</p>
<p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。<br>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>TCP传输数据量大，UDP也能大量数据传输，不过UDP是以小包方式发出.</p>
<hr>
<h1 id="TCP的3次握手（连接建立）"><a href="#TCP的3次握手（连接建立）" class="headerlink" title="TCP的3次握手（连接建立）"></a>TCP的3次握手（连接建立）</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。<br>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK ，并最终对对方的 SYN 执行 ACK 确认。<br>这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>类似打电话效果<br>第一次握手：客户端发送数据包给服务端，等待服务器确认好建立连接（SYN)<br>第二次握手：服务器收到数据包，同时自己给发送个数据包给客户端（SYN+ACK）<br>第三次握手：客户端收到服务器的数据包，向服务器发送确认数据（ACK）<br>此包发送完毕，客户端和服务器进行连接状态，完成三次握手</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/images/it_network_tcp1.png" alt="UML图"></p>
<hr>
<h1 id="TCP的4次挥手（连接终止）"><a href="#TCP的4次挥手（连接终止）" class="headerlink" title="TCP的4次挥手（连接终止）"></a>TCP的4次挥手（连接终止）</h1><hr>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。<br>所谓四次挥手,是指断开一个TCP连接时，客户端和服务端发送4个包。<br>断开连接，双方都是可以主动断开的。客户端和服务端都有可能是主动断开者.<br>断开连接和和建立连接的区别：建立连接主动方永远是客户端，碰不到服务器来连接客户端</p>
<h2 id="挥手流程"><a href="#挥手流程" class="headerlink" title="挥手流程"></a>挥手流程</h2><ol>
<li><code>主动方</code> 发送请求给 <code>被动方</code>，请求断开连接.（FIN）</li>
<li><code>被动方</code> 接收断开请求，对 <code>主动方</code> 发送响应:收到断开请求。（ACK）</li>
<li><code>被动方</code> 送数据包给 <code>主动方</code> 你可以关闭了，并关闭与 <code>主动方</code> 的连接。（FIN）</li>
<li><code>主动方</code> 收到断开信号后，对 <code>被动方</code> 发送数据包:我断了哦。（ACK）</li>
</ol>
<h2 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h2><p><img src="/images/it_network_tcp2.png" alt="UML图"></p>
<h1 id="TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？"><a href="#TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？" class="headerlink" title="TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？"></a>TCP传输连接中的控制位（SYN、ACK、FIN等等）分别是什么意思？</h1><p><img src="/images/it_network_tcp3.jpg" alt="UML图"></p>
<ul>
<li><p>SYN：同步标志<br>同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。</p>
</li>
<li><p>ACK：确认标志<br>确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。</p>
</li>
<li><p>RST：复位标志<br>复位标志有效。用于复位相应的TCP连接。</p>
</li>
<li><p>URG：紧急标志<br>   紧急(The urgent pointer) 标志有效。紧急标志置位，</p>
</li>
<li><p>PSH：推标志<br>   该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。</p>
</li>
<li><p>FIN：结束标志<br>   带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据</p>
</li>
</ul>
<h1 id="Java中的TCP"><a href="#Java中的TCP" class="headerlink" title="Java中的TCP"></a>Java中的TCP</h1><p>TCP分客户端和服务端<br>客户端对应的对象是Socket<br>服务端对应的对象是ServerSocket</p>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="external">TCP 协议简介</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_network_tcp0.png&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - 网络 - 协议" scheme="https://hengxing0080.github.io/categories/IT-%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="https://hengxing0080.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>心理学效应和思维方式的总结</title>
    <link href="https://hengxing0080.github.io/2017/08/27/manager/1.Psychology/"/>
    <id>https://hengxing0080.github.io/2017/08/27/manager/1.Psychology/</id>
    <published>2017-08-27T08:51:55.000Z</published>
    <updated>2017-10-24T16:09:34.663Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_manager_osychology_logo.jpg" alt="UML图"><br><a id="more"></a><br>(图片来源：<a href="https://stock.tuchong.com/image?imageId=57404333863606738&amp;source=baiduimage" target="_blank" rel="external">东方IC</a>)</p>
<p>心理效应，是指大多数人在相同的情况下或对某种相同的刺激，产生相同或相似的心理反应的现象，它具有普遍性，也具有差异性。</p>
<hr>
<h1 id="心理学效应"><a href="#心理学效应" class="headerlink" title="心理学效应"></a>心理学效应</h1><hr>
<h2 id="习惯性无助效应"><a href="#习惯性无助效应" class="headerlink" title="习惯性无助效应"></a>习惯性无助效应</h2><p>习惯性失败</p>
<p>大象小时候被细绳栓在木桩上，拼命用力都无法挣脱，渐渐的，就认命了，即使长大了，依旧被那根细绳所束缚，这就是习得性无助的厉害之处……</p>
<p>习得性无助效应最早有奥弗米尔和西里格曼发现，后来在动物和人类研究中被广泛探讨。简单地说，很多实验表明，经过训练，狗可以越过屏障或从事其他的行为来逃避实验者加于它的电击。但是，如果狗以前受到不可预期（不知道什么时候到来）且不可控制的电击（如电击的中断与否不依赖于狗的行为），当狗后来有机会逃离电击时，他们也变得无力逃离。而且，狗还表现出其他方面的缺陷，如感到沮丧和压抑，主动性降低等等。</p>
<p>狗之所以表现出这种状况，是由于在实验的早期学到了一种无助感。也就是说，它们认识到自己无论做什么都不能控制电击的终止。在每次实验中，电击终止都是在实验者掌控之下的，而狗会认识到自己没有能力改变这种外界的控制，从而学到了一种无助感。</p>
<p>人如果产生了习得性无助，就成为了一种深深的绝望和悲哀。因此，我们在学习和生活中应把自己的眼光在开阔一点，看到事件背后的真正的决定因素，不要使我们自己陷入绝望。</p>
<h2 id="马太效应"><a href="#马太效应" class="headerlink" title="马太效应"></a>马太效应</h2><p>两极分化现象</p>
<p>马太效应（MatthewEffect），是指好的愈好，坏的愈坏，多的愈多，少的愈少的一种现象。名字来自于《圣经·马太福音》中的一则寓言。在《圣经·新约》的“马太福音”第二十五章中有这么说道：“凡有的，还要加给他叫他多余；没有的，连他所有的也要夺过来。”</p>
<p>1968年，美国科学史研究者罗伯特·莫顿（RobertK.Merton）提出这个术语用以概括一种社会心理现象：“相对于那些不知名的研究者，声名显赫的科学家通常得到更多的声望即使他们的成就是相似的，同样地，在同一个项目上，声誉通常给予那些已经出名的研究者，例如，一个奖项几乎总是授予最资深的研究者，即使所有工作都是一个研究生完成的。”</p>
<p>罗伯特·莫顿归纳“马太效应”为：任何个体、群体或地区，一旦在某一个方面（如金钱、名誉、地位等）获得成功和进步，就会产生一种积累优势，就会有更多的机会取得更大的成功和进步。</p>
<p>此术语后为经济学界所借用，反映贫者愈贫，富者愈富，赢家通吃的经济学中收入分配不公的现象。</p>
<h2 id="丛林法则"><a href="#丛林法则" class="headerlink" title="丛林法则"></a>丛林法则</h2><p>生存法则<br>是自然界里生物学方面的物竞天择、适者生存、优胜劣汰、弱肉强食的规律法则</p>
<h2 id="能量守恒定律"><a href="#能量守恒定律" class="headerlink" title="能量守恒定律"></a>能量守恒定律</h2><p>外文名 conservation of energy<br>表达式 能量在转化或转移的过程中，总量保持不变。<br>提出者托马斯·杨<br>提出时间 1801年<br>应用学科 物理<br>适用领域范围 物理的能量学<br>最早研究时间 1475年</p>
<p>源于热力学三大定律的第一定律<br>能量既不会凭空产生，也不会凭空消失，它只会从一种形式转化为另一种形式，或者从一个物体转移到其它物体，而能量的总量保持不变。能量守恒定律是自然界普遍的基本定律之一。</p>
<p>能量守恒定律在生活中照样有道理，你想占多大的便宜，就一定会吃多大的葵。<br>最终结果总是便宜没占着，亏却吃大发了。<br>如传销…</p>
<h2 id="因果定律"><a href="#因果定律" class="headerlink" title="因果定律"></a>因果定律</h2><p>中文名 因果定律<br>又称 因果法则<br>提出者 苏格拉底<br>意思 每件事情的发生都有某个理由</p>
<p>因果报应也是同一个意思<br>它指事物的起因和结果，种什么因，结什么果。</p>
<p>因果定律，任何事情的发生，都有其必然的原因。有因才有果。<br>换句话说，当你看到任何现象的时候，你不用觉得不可理解或者奇怪，因为任何事情的发生都必有其原因。事物如今结果全是过去的原因导致的结果。</p>
<p>它指无论哪一方面的成功或失败都不是偶然的，而是有着一定的因果关系的必然，即每个结果都有特定的原因，这个法则非常深奥且具极大影响力，以致世人将其称之为人类命运的“铁律”，心理学家将其归纳：种瓜得瓜，种豆得豆，种下什么样的因，得到什么样的果。</p>
<h2 id="鸟笼效应"><a href="#鸟笼效应" class="headerlink" title="鸟笼效应"></a>鸟笼效应</h2><p>中文名 鸟笼效应<br>时间 1907年<br>人物 詹姆斯<br>所属 哈佛大学</p>
<p>鸟笼效应是一个著名的心理现象，又称“鸟笼逻辑”，是人类难以摆脱的十大心理之一 ，其发现者是近代杰出的心理学家詹姆斯。</p>
<p>“鸟笼效应”是一个很有意思的规律，人们会在偶然获得一件原本不需要的物品的基础上，继续添加更多与之相关而自己不需要的东西。鸟笼效应：假如一个人买了一只空鸟笼放在家里，那么一段时间后，他一般会为了用这只笼子再买一只鸟回来养而不会把笼子丢掉，也就是这个人反而被笼子给异化掉了，成为笼子的俘虏 。</p>
<p>挂一个漂亮的鸟笼在房间里最显眼的地方，过不了几天，主人一定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里，这就是鸟笼逻辑。<br>过程很简单，设想你是这房间的主人，只要有人走进房间，看到鸟笼，就会忍不住问你：“鸟呢？是不是死了？”当你回答：“我从来都没有养过鸟。”人们会问：“那么，你要一个鸟笼干什么？”最后你不得不在两个选择中二选一，因为这比无休止的解释要容易得多。<br>鸟笼逻辑的原因很简单：人们绝大部分的时候是采取惯性思维，可见在生活和工作中培养逻辑思维是多么重要。</p>
<h2 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h2><p>破窗效应(BreakPaneLaw)所谓“破窗效应”，是关于环境对人们心理造成暗示性或诱导性影响的一种认识。“破窗效应”理论是指：如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些暗示性的纵容去打烂更多的窗户。发现问题就要及时矫正和补救。</p>
<p>美国斯坦福大学心理学家菲利普·辛巴杜(PhilipZimbardo)于1969年进行了一项实验，他找来两辆一模一样的汽车，把其中的一辆停在加州帕洛阿尔托的中产阶级社区，而另一辆停在相对杂乱的纽约布朗克斯区。停在布朗克斯的那辆，他把车牌摘掉，把顶棚打开，结果当天就被偷走了。而放在帕洛阿尔托的那一辆，一个星期也无人理睬。</p>
<p>后来，辛巴杜用锤子把那辆车的玻璃敲了个大洞。结果呢，仅仅过了几个小时，它就不见了。以这项实验为基础，政治学家威尔逊和犯罪学家凯琳提出了一个“破窗效应”理论，认为：如果有人打坏窗户玻璃，而又得不到及时的维修，别人就可能去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉。结果在这种公众麻木不仁的氛围中，犯罪就会滋生、繁荣。</p>
<h2 id="责任分散效应"><a href="#责任分散效应" class="headerlink" title="责任分散效应"></a>责任分散效应</h2><p>1964年3月13日夜3时20 分，在美国纽约郊外某公寓前，一位叫朱诺比白的年轻女子在结束酒巴间工作回家的路上遇刺。当她绝望地喊叫：“有人要杀人啦!救命!救命!”听到喊叫声，附近住户亮起了灯，打开了窗户，凶手吓跑了。当一切恢复平静后，凶手又返回作案。当她又叫喊时，附近的住户又打开了电灯，凶手又逃跑了。当她认为已经无事，回到自己家上楼时，凶手又一次出现在她面前，将她杀死在楼梯上。在这个过程中，尽管她大声呼救，她的邻居中至少有 38位到窗前观看，但无一人来救她，甚至无一人打电话报警。这件事引起纽约社会的轰动，也引起了社会心理学工作者的重视和思考。人们把这种众多的旁观者见死不救的现象称为责任分散效应。</p>
<p>对于责任分散效应形成的原因，心理学家进行了大量的实验和调查，结果发现：这种现象不能仅仅说是众人的冷酷无情，或道德日益沦丧的表现。因为在不同的场合，人们的援助行为确实是不同的。当一个人遇到紧急情境时，如果只有他一个人能提供帮助，他会清醒地意识到自己的责任，对受难者给予帮助。如果他见死不救会产生罪恶感、内疚感，这需要付出很高的心理代价。而如果有许多人在场的话，帮助求助者的责任就由大家来分担，造成责任分散，每个人分担的责任很少，旁观者甚至可能连他自己的那一份责任也意识不到，从而产生一种“我不去救，由别人去救”的心理，造成“集体冷漠”的局面。如何打破这种局面，这是心理学家正在研究的一个重要课题。</p>
<h2 id="帕金森定律"><a href="#帕金森定律" class="headerlink" title="帕金森定律"></a>帕金森定律</h2><p>英国著名历史学家诺斯古德·帕金森通过长期调查研究，写出一本名叫《帕金森定律》的书。他在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。</p>
<p>第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿，人浮于事，相互扯皮，效率低下的领导体系。</p>
<h2 id="晕轮效应-光环效应-成见效应"><a href="#晕轮效应-光环效应-成见效应" class="headerlink" title="晕轮效应/光环效应/成见效应"></a>晕轮效应/光环效应/成见效应</h2><p>晕轮效应，又称“成见效应”，这种强烈知觉的品质或特点，就象月亮形式的光环一样，向周围弥漫、扩散，从而掩盖了其它品质或特点所以就形象地称之为光环效应。<br>有时候晕轮效应会对人际关系产生积极效应，比如你对人诚恳，那么即便你能力较差，别人对你也会非常信任，因为对方只看见你的诚恳。最典型的例子，就是当我们看到某个明星在媒体上爆出一些丑闻时总是很惊讶，而事实上我们心中这个明星的形象根本就是她在银幕或媒体上展现给我们的那圈“月晕”，它真实地人格我们是不得而知的，仅仅是推断的。</p>
<p>俄国著名的大文豪普希金曾因晕轮效应的作用吃了大苦头。他狂热地爱上了被称为“莫斯科第一美人”的娜坦丽，并且和她结了婚。娜坦丽容貌惊人，但与普希金志不同道不合。当普希金每次把写好的诗读给她听时，她总是捂着耳朵说：“不要听！不要听！”相反，她总是要普希金陪她游乐，出席一些豪华的晚会、舞会，普希金为此丢下创作，弄得债台高筑，最后还为她决斗而死，使一颗文学巨星过早地陨落。在普希金看来，一个漂亮的女人也必然有非凡的智慧和高贵的品格，然而事实并非如此，这种现象被称为晕轮效应。</p>
<p>所谓晕轮效应，就是在人际交往中，人身上表现出的某一方面的特征，掩盖了其他特征，从而造成人际认知的障碍。在日常生活中，“晕轮效应”往往在悄悄地影响着我们对别人的认知和评价。比如有的老年人对青年人的个别缺点，或衣着打扮、生活习惯看不顺眼，就认为他们一定没出息；有的青年人由于倾慕朋友的某一可爱之处，就会把他看得处处可爱，真所谓“一俊遮百丑”。</p>
<p>晕轮效应是一种以偏概全的主观心理臆测，其错误在于：第一，它容易抓住事物的个别特征，习惯以个别推及一般，就像盲人摸象一样，以点代面；第二，它把并无内在联系的一些个性或外貌特征联系在一起，断言有这种特征必然会有另一种特征；第三，它说好就全都肯定，说坏就全部否定，这是一种受主观偏见支配的绝对化倾向。总之，晕轮效应是人际交往中对人的心理影响很大的认知障碍，我们在交往中要尽量地避免和克服晕轮效应的副作用。</p>
<h2 id="霍桑效应"><a href="#霍桑效应" class="headerlink" title="霍桑效应"></a>霍桑效应</h2><p>霍桑效应(HawthorneEffect)或称霍索恩效应，起源于1924年至1933年间的一系列实验研究，其后，从1927年到1932年，乔治·埃尔顿·梅奥（GeorgeEltonMayo）教授持续多年对霍桑实验结果进行研究、分析。霍桑一词源于用于实验的工厂，它是美国西部电气公司坐落在芝加哥的一间工厂的名称。实验最开始研究的是工作条件与生产效率之间的关系，包括外部环境影响条件（如照明强度、湿度）以及心理影响因素（如休息间隔、团队压力、工作时间、管理者的领导力）。</p>
<p>由于受到额外的关注而引起绩效或努力上升的情况我们称之为“霍桑效应”。也就是所谓的“宣泄效应”。</p>
<p>霍桑效应的发现来自一次失败的管理研究。美国芝加哥郊外的霍桑工厂，是一个制造电话交换机的工厂。这个工厂具有较完善的娱乐设施，医疗制度和养老金制度等，但员工们仍愤愤不平，生产状况也很不理想。为探求原因，1924年11月，美国国家研究委员会组织了一个由心理学家等各方面专家参加的研究小组，在该工厂开展了一系列的试验研究。这一系列试验研究的中心课题是生产效率与工作物质条件之间的关系。这一系列试验研究中有一个“谈话试验”，即用两年多的时间，专家们找工人个别谈话两万余人次，并规定在谈话过程中，要耐心倾听工人们对厂方的各种意见和不满，并做详细记录，对工人的不满意见不准反驳和训斥。</p>
<p>这一“谈话试验”收到了意想不到的结果：霍桑工厂的产量大幅度提高。这是由于工人长期以来对工厂的各种管理制度和方法有诸多不满，无处发泄，“谈话试验”使他们的这些不满都发泄出来，从而感到心情舒畅，干劲倍增。社会心理学家将这种奇妙的现象称为“霍桑效应”。</p>
<h2 id="证人的记忆效应-虚假记忆"><a href="#证人的记忆效应-虚假记忆" class="headerlink" title="证人的记忆效应/虚假记忆"></a>证人的记忆效应/虚假记忆</h2><p>证人，在我们的认识里，通常都是提供一些客观的证据的人，就是把自己亲眼看到、亲耳听到的东西如实地讲出来的人。然而，心理学研究证明，很多证人提供的证词都不太准确，或者说是具有个人倾向性，带着个人的观点和意识。</p>
<p>虚假记忆（false memory）是大脑记忆的信息之间自动的组合导致不真实的回忆。每个人的大脑都可能产生虚假的记忆，或将事物的真实情况扭曲。人们会对自己的记忆坚信不疑，甚至会对大脑编造的谎言信以为真。这并非一种发病过程。所有人都会产生虚假记忆，特别是关于童年时期亲身经历的场景的记忆。</p>
<p>虚假记忆最早被注意是由于发现犯罪现场的目击证人的证词并不一定可靠，虽然证人自己确实认为他当时看到的情况就是这样，但常常会因为情景信息的混淆，而导致对罪犯的错误指认或情景的错误描述。例如，证人并没有看清罪犯的长相，但在回忆时会把以前看到过的并不熟悉的人脸指认为罪犯；证人对犯罪现场的细节根本没有看清，但在回忆时会根据自己的经验填充，而且确认是当时看到的情景。</p>
<p>相关文章：<br><a href="http://baijiahao.baidu.com/s?id=1565197792104556&amp;wfr=spider&amp;for=pc" target="_blank" rel="external">“证人的记忆”——真是他们记忆出问题了吗？</a></p>
<h2 id="期望效应"><a href="#期望效应" class="headerlink" title="期望效应"></a>期望效应</h2><p>期望效应又叫“皮格马利翁效应”也叫“罗森尔塔效应”。这个效应源于古希腊一个美丽的传说。相传古希腊雕刻家皮格马利翁深深地爱上了自己用象牙雕刻的美丽少女，并希望少女能够变成活生生的真人。他的真挚的爱感动了爱神阿劳芙罗狄特，爱神赋予了少女雕像以生命，最终皮格马利翁与自己钟爱的少女结为伉俪。后来美国哈佛大学教授罗森林塔尔等人为首的许多心理学家进行一系列研究，实验证明，学生的智力发展与老师对其关注程度成正比关系。</p>
<p>罗森塔尔和雅各布森认为，由他们提供的“假信息”最后出了“真效果”的主要原因，是“权威性的预测”引发了教师对这些学生的较高期望，就是这些教师的较高期望在8个月中发挥了神奇的暗示作用。这些学生在接受了教师渗透在教育教学过程中的积极信息之后，会按照教师所刻划的方向和水平来重新塑造自我形象，调整自己的角色意识与角色行为，从而产生了神奇的“期望效应”。</p>
<p>其实，“罗森塔尔效应”是赏识教育的理论基础，其理论价值远远没有得到老师们的普遍重视。我想从这个期望效应中我们可以获得一点启示，那就是老师应给予学生更多的鼓励与期望，还应该把这种效应用于学生身上。老师要告诉学生，他们是世界上最聪明的一群人。让学生对自己增强自信心，对自己的人生前途更充满希望。</p>
<p>在教学实际中，用对待聪明学生的态度方法对待你所有的学生，多给他们一些积极的期待，你的学生将会越来越聪明的。同时也给老师提个建议：凡是学生能自己办到的事，坚决不替代；课堂上能少讲的就少讲，能不讲的就不讲；把课堂时间还给学生，把学习的自由权交还给学生。那么，你还给学生的将是更美好的未来。</p>
<h2 id="虚假同感偏差"><a href="#虚假同感偏差" class="headerlink" title="虚假同感偏差"></a>虚假同感偏差</h2><p>以前，在一个寒冷的冬天，有一个木匠带着孩子在地主家干活，木匠干活干得大汗淋漓，就一件一件把自己的衣服脱掉了。这时他想起了孩子，生怕他热着，也一件一件把孩子的衣服给脱掉了。后来孩子被冻死了。</p>
<p>虚假同感偏差（false consensus bias），又叫虚假一致性偏差，指的是人们常常高估或夸大自己的信念、判断及行为的普遍性，它是人们坚信自己信念、判断正确性的一种方式。</p>
<h2 id="布里丹毛驴效应"><a href="#布里丹毛驴效应" class="headerlink" title="布里丹毛驴效应"></a>布里丹毛驴效应</h2><p>概念 决策过程中这种犹豫不定的现象<br>结果 毛驴最终饿死<br>原因 不懂得如何决策</p>
<p>决策过程中这种犹豫不定、迟疑不决的现象称之为“布里丹毛驴效应”。</p>
<h2 id="宿舍效应"><a href="#宿舍效应" class="headerlink" title="宿舍效应"></a>宿舍效应</h2><p>从众行为的一种现象</p>
<h2 id="偶像效应"><a href="#偶像效应" class="headerlink" title="偶像效应"></a>偶像效应</h2><p>偶像效应指的是某些人在部分领域做的非常优秀，有很多粉丝从而引出的系列反应。偶像效应也指粉丝对喜爱的偶像进行的行为举止的模仿。</p>
<h2 id="品牌效应"><a href="#品牌效应" class="headerlink" title="品牌效应"></a>品牌效应</h2><p>由品牌为企业带来效应，他是商业社会中企业价值延续，在当前品牌先导商业模式中，意味着商品定位、经营模式、消费族群和利润回报。<br>树立企业品牌需要企业有很强的资源统合能力，将企业本质一面通过品牌展示给世人。<br>树立方法：广告、日常行销、售后服务都有直接影响。<br>品牌效应是品牌在产品上使用，为品牌使用者所带来效益和影响。品牌是商品经济发展到一定阶级的产物，最初的品牌使用是为了便于识别产品，品牌迅速发展是在近代和现代商品经济的高度发达的条件下产生，其得以迅速发展即在于品牌使用给商品生产者带来了巨大经济和社会效益。</p>
<h2 id="集群效应"><a href="#集群效应" class="headerlink" title="集群效应"></a>集群效应</h2><p>又名 集聚效应<br>解释 同种生物活在一起产生有利作用<br>集群发展 世界范围的一种重要经济现象</p>
<p>集群效应指的是集中于一定区域内特定产业的众多具有分工合作关系的不同规模等级的企业与其发展有关的各种机构。</p>
<h2 id="垃圾人定律"><a href="#垃圾人定律" class="headerlink" title="垃圾人定律"></a>垃圾人定律</h2><p>垃圾车法则<br>垃圾人定律，来自于范冰冰对于网络媒体人的回应，形容本身存在很多负面垃圾缠身，需要找个地方倾倒垃圾的人。<br>世界上存在很多负面情绪缠身的人，他们需要找个地方倾倒，有时候被人刚好碰上了，垃圾就往人身上丢。</p>
<h2 id="踢猫效应"><a href="#踢猫效应" class="headerlink" title="踢猫效应"></a>踢猫效应</h2><p>外文名 Kick Cat Effect<br>名词释义 是人与人之间的泄愤连锁反应<br>核心理念 不要拿别人的过错来惩罚自己<br>应用领域 社会组织，组织管理<br>应用要诀 有效控制情绪，正确对待错误</p>
<p>踢猫效应是指对弱于自己或者等级低于自己的对象发泄不满情绪，而产生的连锁反应。“踢猫效应”，描绘的是一种典型的坏情绪的传染。人的不满情绪和糟糕心情，一般会沿着等级和强弱组成的社会关系链条依次传递。由金字塔尖一直扩散到最底层，无处发泄的最弱小的那一个元素，则成为最终的受害者。其实，这是一种心理疾病的传染。</p>
<p>原版故事：<br>一父亲在公司受到了老板的批评，回到家就把沙发上跳来跳去的孩子臭骂了一顿。<br>孩子心里窝火，狠狠去踹身边打滚的猫。<br>猫逃到街上，正好一辆卡车开过来，司机赶紧避让，却把路边的孩子撞伤了。<br>这就是心理学上著名的“踢猫效应”，描绘的是一种典型的坏情绪的传染所导致的恶性循环</p>
<p>另一个故事<br>顾客指着面前的杯子，对服务小姐大声喊道：“小姐！你过来！你看看！你们的牛奶是坏的，把我的一杯红茶都糟蹋了！”<br>服务小姐一边陪着不是一边说：“真对不起！我立刻给您换一杯。”<br>新红茶很快就准备好了，碟边放着新鲜的柠檬和牛乳。<br>小姐再把这些轻轻放在顾客面前，又轻声地说：“我能不能建议您，如果放柠檬，就不要加牛奶，因为有时候柠檬酸会造成牛奶结块。”<br>顾客的脸一下子红了，匆匆喝完茶就走了。<br>在旁边的一个顾客看到这一场景，笑问服务小姐：“明明是他的错，你为什么不直说呢？”<br>服务小姐笑着说：“正因为他粗鲁，所以要用婉转的方法去对待，正因为道理一说就明白，所以用不着大声！理不直的人，常用气壮来压人。理直的人，却用和气来交朋友！”<br>生活中，每个人都是“踢猫效应”长长链条上的一个环节，遇到低自己一等地位的人，都有将愤怒转移出去的倾向。当一个人沉溺于负面或不快乐的事情时，就会同时接收到负面和不快乐的事。当他把怒气转移给别人时，就是把焦点放在不如意的事情上，久而久之，就会形成恶性循环。好心情也一样，所以，为什么不将自己的好心情随金字塔延续下去呢？</p>
<h2 id="巴纳姆效应"><a href="#巴纳姆效应" class="headerlink" title="巴纳姆效应"></a>巴纳姆效应</h2><p>巴纳姆效应（Barnum effect）是1948年由心理学家伯特伦·福勒通过试验证明的一种心理学现象，以杂技师巴纳姆的名字命名，认为每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人。</p>
<hr>
<h1 id="思维方式"><a href="#思维方式" class="headerlink" title="思维方式"></a>思维方式</h1><hr>
<p>与其日复一日重复昨天，不如改变一下思维，换个角度重新出发！看看吧，这些思维方式如果擅于运用将比聪明、智慧还要厉害百倍！</p>
<p>首先要改变一个思维↓</p>
<h2 id="习惯性思维-惯性思维-思维定势"><a href="#习惯性思维-惯性思维-思维定势" class="headerlink" title="习惯性思维/惯性思维/思维定势"></a>习惯性思维/惯性思维/思维定势</h2><p>什么叫惯性思维?<br>即指思维定势、习惯性思维，指人们在考虑研究问题时，用固定的模式或思路去进行思考与分析，从而解决问题的倾向。</p>
<p>固有的东西是很难打破的，这也是经过历史证明的。每次改朝换代，无一不是用血的代价换来的。但正所谓“不破不立”，要想突破自己，就一定要打破惯性思维!</p>
<p>否则，连自己的思维都还被禁锢在旧有的陈腐里，如何能挑得起历史赋予我们的责任?如何担得起对社会财富进行重新分配的重任呢?</p>
<p>所以要解放思想，且还要掌握一定的方法惯性思维是固有的，我们往往在不知不觉中就循着旧路走过去了。这时，我们就需要时刻提醒自己，走一阶段后，要停下来思考一下是否又跳入固有思路了。</p>
<h2 id="费米思维"><a href="#费米思维" class="headerlink" title="费米思维"></a>费米思维</h2><p>简单化才是最经济、最优化，费米思维一种最简单、最省力、最准确的思维法则，具有普遍的适用性。<br>任何问题的复杂化，都是因为没有抓住最深刻的本质，没有揭示最基本规律与问题之间最短的联系，只是停留在表层的复杂性上，反而离解决问题越来越远。<br>最简单的往往是最合理的。</p>
<h2 id="奥卡姆思维"><a href="#奥卡姆思维" class="headerlink" title="奥卡姆思维"></a>奥卡姆思维</h2><p>奥卡姆思维，就是舍弃一切复杂的表象，直指问题的本质。这种思维的可贵之处，是因为它直戳现实中的这么一种病态：今天的人们，往往自以为掌握了许多知识，而喜欢将事情往复杂处瞎鼓捣。</p>
<h2 id="拉哥尼亚思维"><a href="#拉哥尼亚思维" class="headerlink" title="拉哥尼亚思维"></a>拉哥尼亚思维</h2><p>简练才是真正的丰富，只有最简单的东西才具有最大孕育性和想象空间，也才最符合“拉哥尼亚”思维法则。</p>
<p><a href="http://www.360doc.com/content/12/0301/21/7970410_190950535.shtml" target="_blank" rel="external">拉 哥 尼 亚 思 维</a></p>
<h2 id="上帝思维"><a href="#上帝思维" class="headerlink" title="上帝思维"></a>上帝思维</h2><p>“关爱别人，受益自己。”上帝说，天堂里的居民，凡事都是这么想的，世人要是拥有爱的思维，那他无论身处何方，都是活在天堂里.</p>
<h2 id="司马光思维"><a href="#司马光思维" class="headerlink" title="司马光思维"></a>司马光思维</h2><p>打破，才能得生机。这，就是司马光思维的精髓所在：只有打破旧思维的桎梏，思路才会见光明。</p>
<h2 id="孙子思维"><a href="#孙子思维" class="headerlink" title="孙子思维"></a>孙子思维</h2><p>孙子曰：“知已知彼，百战不殆。”这句名言，体现了一种十分可贵的思维方式，那就是：要战胜对手，就必须了解对手。</p>
<h2 id="拿破仑思维"><a href="#拿破仑思维" class="headerlink" title="拿破仑思维"></a>拿破仑思维</h2><p>所谓拿破仑思维，就是敢想敢干，不被外界所干扰，在任何情况下，始终保持自己的主见，用自己的目光去审视世界，用自己方法去解决问题。</p>
<h2 id="亚历山大思维"><a href="#亚历山大思维" class="headerlink" title="亚历山大思维"></a>亚历山大思维</h2><p>它蕴涵着一种很霸气的、更值得称道的思维方式，那就是，成大事者，决不被陈规旧习所束缚。</p>
<h2 id="哥伦布思维"><a href="#哥伦布思维" class="headerlink" title="哥伦布思维"></a>哥伦布思维</h2><p>想了就要干———这，才是哥伦布思维的可贵之处，自古成功自有道，这个道，往往就是在众人认为不可能地方闯出来。</p>
<h2 id="洛克菲勒思维"><a href="#洛克菲勒思维" class="headerlink" title="洛克菲勒思维"></a>洛克菲勒思维</h2><p>时时求主动，处处占先机，以最小代价，求得利益最大化。这，就洛克菲勒思维的主旨。</p>
<h2 id="爱迪生思维"><a href="#爱迪生思维" class="headerlink" title="爱迪生思维"></a>爱迪生思维</h2><p>迂者拘泥于形，易被外在束缚；巧者注重本质，因而心明眼亮。爱迪生思维独到之处，就在于其灵动自如直奔目标，而不为人间万象所困惑干扰。</p>
<h2 id="布勃卡思维"><a href="#布勃卡思维" class="headerlink" title="布勃卡思维"></a>布勃卡思维</h2><p>凡事留有余地，力气不必用尽，把握在手的东西，要懂得慢慢享用。这，就是布勃卡思维的精妙之处。</p>
<h2 id="狼性思维"><a href="#狼性思维" class="headerlink" title="狼性思维"></a>狼性思维</h2><p>危险的往往是生机之所在，这种思维，体现了一种物极必反的哲理。拥有如此思维人，同时也得拥有非凡的勇气。</p>
<h2 id="裁缝思维"><a href="#裁缝思维" class="headerlink" title="裁缝思维"></a>裁缝思维</h2><p>眼前的对手，才是真正的对手；现实的问题，才是最有意义的问题。这，就是裁缝思维的主旨。只有认真对待现实中的问题，人们才有可能真正改善自身的处境。</p>
<h2 id="囚徒思维"><a href="#囚徒思维" class="headerlink" title="囚徒思维"></a>囚徒思维</h2><p>囚徒思维传达出这样的信息：人要懂得借势借力，自己要是没有能力去办好某一件事，那就定得想方设法请个能人代劳；要是自己有能力，有时，也得考虑一下是否该让更有能力的人，把一件事情办得更漂亮一些。</p>
<h2 id="浪子思维"><a href="#浪子思维" class="headerlink" title="浪子思维"></a>浪子思维</h2><p>浪子无羁，浪子思维更具有杀伤力！在实战中，浪子思维往往达到出奇制胜的效果。<br>设定一个较低的预期，以便营造更大的发展空间。</p>
<h2 id="多米诺思维"><a href="#多米诺思维" class="headerlink" title="多米诺思维"></a>多米诺思维</h2><p>多米诺思维要说的，就是量变引起质变的道理。在这个世界上，你不可以忽视任何一个微小的事物。往往，一些微小的东西，很可能就是改变大局触发点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_manager_osychology_logo.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="管理学与心理学" scheme="https://hengxing0080.github.io/categories/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    
      <category term="管理学与心理学" scheme="https://hengxing0080.github.io/tags/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B8%8E%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>运算符系列：位运算符</title>
    <link href="https://hengxing0080.github.io/2017/08/25/it/1.Java/OperationBitwise/"/>
    <id>https://hengxing0080.github.io/2017/08/25/it/1.Java/OperationBitwise/</id>
    <published>2017-08-25T03:54:12.000Z</published>
    <updated>2017-10-05T16:06:24.364Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/it_algorithm_bitwise.jpg" alt="UML图"></p>
<a id="more"></a>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>位运算符：位是二进制位的位，也就是说位运算符是直接对二进制进行运算的符号<br> 它是做所有运算中最快的<br> 有局限性，以2的倍数增长<br>（左移右移）</p>
<hr>
<h1 id="各个分析"><a href="#各个分析" class="headerlink" title="各个分析"></a>各个分析</h1><hr>
<h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>越往左移，数越大</p>
<h3 id="运算规律"><a href="#运算规律" class="headerlink" title="运算规律"></a>运算规律</h3><p>就是2的倍数或者2的几次幂 </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>3&lt;&lt;2 = 12<br>　3左移2位 等于12，实际上就是 3<em>4 =12　或者 3</em>22(3<em>(2</em>2)<br>　3的二进制表示形式：0000-0000-0000-0000-0000-0000-0000-0011<br>　12的二进制表示形式：0000-0000-0000-0000-0000-0000-0000-1100<br>　左移2位（舍弃），右边缺2个拿0补<br>3&lt;&lt;1 = 6<br>　实际上就是 3<em>2=6或3</em>21(3<em>(2</em>1)<br>　00000011 3&lt;&lt;1(左移1位) 之后：00000110 就是6<br>3&lt;&lt;3 =24<br>　实际上就是 3<em>8=24或3</em>23（3<em>(2</em>2*2)</p>
<h2 id="有符号右移-gt-gt"><a href="#有符号右移-gt-gt" class="headerlink" title="有符号右移&gt;&gt;"></a>有符号右移&gt;&gt;</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>右移位运算就是将左操作数的比特位向右移动第二个操作数指定的位数，在二进制中，首位是用来表示正负的，若右移运算符的第一个操作数是正数，就填充0，是负数就填充1；</p>
<p>最高位补什么由原有数据的最高位值而定（最高位：如1111-1111）<br>如果最高位0，右移后，用0补空位<br>如果最高位1，右移后，用1补空位</p>
<p>就是将那个数转为2进制然后在前面补0或1<br>如果是正数就补0<br>负数补1</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>越往右移，数越小</p>
<h3 id="运算规律-1"><a href="#运算规律-1" class="headerlink" title="运算规律"></a>运算规律</h3><p>就是除以2的几次幂</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>6&gt;&gt;2 = 1<br>　6右移2位是1，实际上就是 6/2(2)=1 或者 6/(2<em>2)<br>　等于6除以4，都是整数，所以小数点舍弃得1<br>　右移2位（舍弃），左边补2个0<br>6&gt;&gt;1 = 3<br>　实际上就是 6/2 = 3<br>6&gt;&gt;3 = 0<br>　实际上就是 3</em>2 = 6<br>11 &gt;&gt; 2<br>　则是将数字11右移2位<br>　11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011，然后把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。<br>　则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。<br>　转换为十进制是2。
　</p>
<h2 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义</p>
<h3 id="运算规律-2"><a href="#运算规律-2" class="headerlink" title="运算规律"></a>运算规律</h3><p>物理最高位是什么，右移后，都用0补</p>
<h3 id="无符号右移与有符号右移的区别"><a href="#无符号右移与有符号右移的区别" class="headerlink" title="无符号右移与有符号右移的区别"></a>无符号右移与有符号右移的区别</h3><p>无符号始终补0</p>
<h2 id="与运算-amp"><a href="#与运算-amp" class="headerlink" title="与运算&amp;"></a>与运算&amp;</h2><p>概述：&amp;符号也可以做位运算符存在<br>运算技巧：0是假，1是真<br>示例：6 &amp; 3 = 2<br>示例代码： System.out.println(6 &amp; 3);<br><img src="/images/it_algorithm_bitwise2.png" alt="UML图"></p>
<h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算|"></a>或运算|</h2><p>示例：6 | 5 = 7<br><img src="/images/it_algorithm_bitwise3.png" alt="UML图"></p>
<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算^"></a>异或运算^</h2><p>示例：6 ^ 5 = 3<br>示例代码： System.out.println(6 ^ 5);<br><img src="/images/it_algorithm_bitwise4.png" alt="UML图"></p>
<h3 id="异或技巧"><a href="#异或技巧" class="headerlink" title="异或技巧"></a>异或技巧</h3><p>范例：7 ^ 4 = 3<br>范例：7 ^ 4 ^ 4 = 7<br>范例：7 ^ 5 ^ 5 = 7<br>结论：一个数异或同一个数2次，结果还是那个数。  （这个规律要记住）<br><img src="/images/it_algorithm_bitwise5.png" alt="UML图"></p>
<h3 id="异或用途"><a href="#异或用途" class="headerlink" title="异或用途"></a>异或用途</h3><p>用于加密算法，异或一次变反了，在异或一次就变回来了</p>
<p>数据加密（把某个数如4异或一次）<br>数据解密（和4在异或一次）</p>
<p>还有更复杂的加密方式，如又与又或有很多种运算，这就叫加密算法</p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码~"></a>反码~</h2><p>理解：就是取反</p>
<p>示例代码： System.out.println(~7);</p>
<p>范例：<br>~6 = -7  (正6的取反)<br><img src="/images/it_algorithm_bitwise6.png" alt="UML图"></p>
<p>~-6 = -7+1  （负6的取反）<br><img src="/images/it_algorithm_bitwise7.png" alt="UML图"></p>
<hr>
<h1 id="面试题和使用场景"><a href="#面试题和使用场景" class="headerlink" title="面试题和使用场景"></a>面试题和使用场景</h1><hr>
<h2 id="1-最有效率的方式算出2乘以8等于几？"><a href="#1-最有效率的方式算出2乘以8等于几？" class="headerlink" title="1.最有效率的方式算出2乘以8等于几？"></a>1.最有效率的方式算出2乘以8等于几？</h2><p>最有效率的方式不是2*8，它的底层还是二进制运算<br>二进制是10000<br>十进制是16<br><img src="/images/it_algorithm_bitwise8.png" alt="UML图"></p>
<p>最高效的运算是位运算：2&lt;&lt;3<br>2乘以8：8是2的三次方，也就是将2左移3位（这3位去掉），右边补位（3个0），等于16<br><img src="/images/it_algorithm_bitwise9.png" alt="UML图"></p>
<h2 id="2-对两个整数变量的值进行互换"><a href="#2-对两个整数变量的值进行互换" class="headerlink" title="2.对两个整数变量的值进行互换"></a>2.对两个整数变量的值进行互换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperateDemo2</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = <span class="number">3</span>,m = <span class="number">8</span>;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"n="</span>+n+<span class="string">",m="</span>+m);  <span class="comment">// 打印互换之前的变量</span></div><div class="line"></div><div class="line">        <span class="comment">// 1.通过定义第三方变量（推荐这种最简单的方式，开发常用，阅读性强）</span></div><div class="line">        <span class="comment">//  11 = 3 + 8;</span></div><div class="line">        <span class="comment">//  3 = 11 - 8;</span></div><div class="line">        <span class="comment">//  8 = 11 - 3;</span></div><div class="line">        <span class="keyword">int</span> temp;</div><div class="line">        temp = n;</div><div class="line">        n = m;</div><div class="line">        m = temp;</div><div class="line"></div><div class="line">        <span class="comment">// 2.不用第三方变量</span></div><div class="line">        <span class="comment">// 2.1.第一种方式：(但是有局限性，如果n和m的值非常大，容易超出int范围，容易损失精度)</span></div><div class="line">        n = n + m;  <span class="comment">// 3+8=11，此时n=11</span></div><div class="line">        m = n - m;  <span class="comment">// 11-8=3，此时m=3</span></div><div class="line">        n = n - m;  <span class="comment">// 11-3=8，此时n=8</span></div><div class="line"></div><div class="line">        <span class="comment">// 2.2.第二种方式：(技巧型方式，记这个有规则，左边是nmn，右边是nnn和mmm)</span></div><div class="line">        n = n ^ m;</div><div class="line">        m = n ^ m;  <span class="comment">// 过程：(n^m)^m  （m异或一个数2次所以还是n）</span></div><div class="line">        n = n ^ m;  <span class="comment">// 过程：n^(n^m)                                      */</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"n="</span>+n+<span class="string">",m="</span>+m);   <span class="comment">// 打印互换之后的变量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/it_algorithm_bitwise.jpg&quot; alt=&quot;UML图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IT - Java" scheme="https://hengxing0080.github.io/categories/IT-Java/"/>
    
    
      <category term="Java" scheme="https://hengxing0080.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
