<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />





  <link rel="alternate" href="/atom.xml" title="恒星的轨迹" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android —— 性能优化系列总结">
<meta property="og:url" content="https://hengxing0080.github.io/2017/09/28/it/1.Android/Performance/index.html">
<meta property="og:site_name" content="恒星的轨迹">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_android_performance_logo.jpg">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_android_network_gzip1.png">
<meta property="og:updated_time" content="2017-11-15T06:23:27.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android —— 性能优化系列总结">
<meta name="twitter:image" content="https://hengxing0080.github.io/images/it_android_performance_logo.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":120,"offset_float":0,"b2t":true,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hengxing0080.github.io/2017/09/28/it/1.Android/Performance/"/>





  <title>Android —— 性能优化系列总结 | 恒星的轨迹</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  









<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500489903");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>







  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恒星的轨迹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">时间在流逝...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://hengxing0080.github.io/2017/09/28/it/1.Android/Performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="恒星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恒星的轨迹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android —— 性能优化系列总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-28T23:56:13+08:00">
                2017-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-Android/" itemprop="url" rel="index">
                    <span itemprop="name">IT - Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/images/it_android_performance_logo.jpg" alt="UML图"><br><a id="more"></a></p>
<p>(上图临时占位，等后续总结成思维导图待替换…)</p>
<p>优化前言：<br>工作中随着代码体量变得日趋臃肿，视图层级越来越深，工程结构也越来越复杂。<br>相应的，输出的apk包越来越大，界面流畅性大不如前，经常性发生卡顿，甚至不时出现内存溢出崩溃。<br>在这个阶段，Android开发需要掌握以下方面的技术：<br>AndroidStudio的使用(包括调试工具，测试工具，快捷键等)<br>Android资源管理<br>Android视图架构（Activity视图层级、layout inflate）<br>代码优化<br>UI优化<br>内存优化<br>电量优化<br>网络优化<br>数据库优化<br>动画优化<br>NDK JNI开发<br>……</p>
<p>优化的原则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.时间换空间</div><div class="line">    牺牲时间换取空间, 流的读写</div><div class="line">2.空间换时间</div><div class="line">    把文件的路径存放到数据库里面,以后查询效率就高很多</div><div class="line">    Android下的图库应用检索sd卡的图片</div><div class="line">3.空间换空间</div><div class="line">    把内存换成硬盘 或者把硬盘换成内存</div><div class="line">4.时间换时间</div><div class="line">    开启启动速度的优化</div></pre></td></tr></table></figure></p>
<p>性能测试中存在两个概念：<br>(1). 响应时间<br>指从用户操作开始到系统给用户以正确反馈的时间。一般包括逻辑处理时间 + 网络传输时间 + 展现时间。对于非网络类应用不包括网络传输时间。<br>展现时间即网页或 App 界面渲染时间。</p>
<p>响应时间是用户对性能最直接的感受。</p>
<p>(2). TPS(Transaction Per Second)<br>TPS为每秒处理的事务数，是系统吞吐量的指标，在搜索系统中也用QPS(Query Per Second)衡量。TPS一般与响应时间反相关。</p>
<p>通常所说的性能问题就是指响应时间过长、系统吞吐量过低。</p>
<p>对后台开发来说，也常将高并发下内存泄漏归为性能问题。<br>对移动开发来说，性能问题还包括电量、内存使用这两类较特殊情况。</p>
<p>性能调优方式：<br>明白了何为性能问题之后，就能明白性能优化实际就是优化系统的响应时间，提高TPS。优化响应时间，提高TPS。方式不外乎这三大类：<br>(1) 降低执行时间<br>又包括几小类<br>a. 利用多线程并发或分布式提高 TPS<br>b. 缓存(包括对象缓存、IO 缓存、网络缓存等)<br>c. 数据结构和算法优化<br>d. 性能更优的底层接口调用，如 JNI 实现<br>e. 逻辑优化<br>f. 需求优化</p>
<p>(2) 同步改异步，利用多线程提高TPS</p>
<p>充分利用多核Cpu优势，利用线程解决密集型计算、IO、网络等操作。</p>
<p>(3) 提前或延迟操作，错峰提高TPS</p>
<p>对于上面提到的数据库优化、布局优化、代码优化、网络优化等等都可以归纳到上面的几种方式中。</p>
<p>下面开始各个章节的介绍，这是我工作学习中不断自我收集和收集各种技术大牛博客总结的，此文将不断的更新！</p>
<hr>
<h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><hr>
<p>相关文章：<br><a href="http://www.trinea.cn/android/layout-performance/" target="_blank" rel="external">Trinea——性能优化之布局优化</a><br><a href="http://blog.csdn.net/arui319/article/details/8549849" target="_blank" rel="external">[Android] Android开发优化之——对界面UI的优化（1）</a><br><a href="http://blog.csdn.net/arui319/article/details/8554816" target="_blank" rel="external">[Android] Android开发优化之——对界面UI的优化（2）</a><br><a href="http://blog.csdn.net/arui319/article/details/8561757" target="_blank" rel="external">[Android] Android开发优化之——对界面UI的优化（3）</a></p>
<p>UI界面布局也会对应用程序的性能会产生很大的影响，如果布局写得糟糕的话，那么程序加载UI的速度就会非常慢，从而造成不好的用户体验。<br>那么本篇文章就来学习一下，如何通过优化布局来提供应用程序的性能。</p>
<h2 id="复用Android系统资源"><a href="#复用Android系统资源" class="headerlink" title="复用Android系统资源"></a>复用Android系统资源</h2><p>Android系统本身有很多资源在应用中都可以直接使用，具体的，可以进入android-sdk的相应文件夹中去查看。例如：可以进入$android-sdk$\platforms\android-8\data\res，里面的系统资源就一览无余了。<br>开发者需要花一些时间去熟悉这些资源，特别是图片资源和各种Style资源，这样在开发过程中，能够想到有相关资源并且直接拿来使用。</p>
<h3 id="利用系统定义的id"><a href="#利用系统定义的id" class="headerlink" title="利用系统定义的id"></a>利用系统定义的id</h3><p>比如我们有一个定义ListView的xml文件，一般的，我们会写类似下面的代码片段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    android:id=<span class="string">"@+id/mylist"</span></div><div class="line">    android:layout_width=<span class="string">"fill_parent"</span></div><div class="line">    android:layout_height=<span class="string">"fill_parent"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>这里我们定义了一个ListView，定义它的id是”@+id/mylist”。实际上，如果没有特别的需求，就可以利用系统定义的id，类似下面的样子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView</div><div class="line">    android:id=<span class="string">"@android:id/list"</span></div><div class="line">    android:layout_width=<span class="string">"fill_parent"</span></div><div class="line">    android:layout_height=<span class="string">"fill_parent"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>在xml文件中引用系统的id，只需要加上“@android:”前缀即可。如果是在Java代码中使用系统资源，和使用自己的资源基本上是一样的。不同的是，需要使用android.R类来使用系统的资源，而不是使用应用程序指定的R类。这里如果要获取ListView可以使用android.R.id.list来获取。</p>
<h3 id="利用系统的图片资源"><a href="#利用系统的图片资源" class="headerlink" title="利用系统的图片资源"></a>利用系统的图片资源</h3><p> 假设我们在应用程序中定义了一个menu，xml文件如下。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/menu_attachment"</span></div><div class="line">        <span class="attr">android:title</span>=<span class="string">"附件"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@android:drawable/ic_menu_attachment"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中代码片段android:icon=”@android:drawable/ic_menu_attachment”本来是想引用系统中已有的Menu里的“附件”的图标。但是在Build工程以后，发现出现了错误。提示信息如下：<br>error: Error: Resource is not public. (at ‘icon’ with value ‘@android:drawable/ic_menu_attachment’).</p>
<p>从错误的提示信息大概可以看出，由于该资源没有被公开，所以无法在我们的应用中直接引用。既然这样的话，我们就可以在Android SDK中找到相应的图片资源，直接拷贝到我们的工程目录中，然后使用类似android:icon=”@drawable/ic_menu_attachment”的代码片段进行引用。<br>这样做的好处，一个是美工不需要重复的做一份已有的图片了，可以节约不少工时；另一个是能保证我们的应用程序的风格与系统一致。</p>
<p>PS经验分享：<br>Android中没有公开的资源，在xml中直接引用会报错。除了去找到对应资源并拷贝到我们自己的应用目录下使用以外，我们还可以将引用“@android”改成“@<em>android”解决。比如上面引用的附件图标，可以修改成下面的代码。<br>android:icon=”@</em>android:drawable/ic_menu_attachment”<br>修改后，再次Build工程，就不会报错了。</p>
<h3 id="利用系统的字符串资源"><a href="#利用系统的字符串资源" class="headerlink" title="利用系统的字符串资源"></a>利用系统的字符串资源</h3><p>假设我们要实现一个Dialog，Dialog上面有“确定”和“取消”按钮。就可以使用下面的代码直接使用Android系统自带的字符串。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/yes"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.0"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@android:string/yes"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/no"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1.0"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@android:string/no"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果使用系统的字符串，默认就已经支持多语言环境了。<br>如上述代码，直接使用了@android:string/yes和@android:string/no，在简体中文环境下会显示“确定”和“取消”，在英文环境下会显示“OK”和“Cancel”。</p>
<h3 id="利用系统的Style"><a href="#利用系统的Style" class="headerlink" title="利用系统的Style"></a>利用系统的Style</h3><p>假设布局文件中有一个TextView，用来显示窗口的标题，使用中等大小字体。可以使用下面的代码片段来定义TextView的Style。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/title"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:textAppearance</span>=<span class="string">"?android:attr/textAppearanceMedium"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>其中android:textAppearance=”?android:attr/textAppearanceMedium”就是使用系统的style。需要注意的是，使用系统的style，需要在想要使用的资源前面加“?android:”作为前缀，而不是“@android:”。</p>
<h3 id="利用系统的颜色定义"><a href="#利用系统的颜色定义" class="headerlink" title="利用系统的颜色定义"></a>利用系统的颜色定义</h3><p>除了上述的各种系统资源以外，还可以使用系统定义好的颜色。<br>在项目中最常用的，就是透明色的使用。代码片段如下。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:background ="@android:color/transparent"</div></pre></td></tr></table></figure></p>
<p>经验分享：<br>Android系统本身有很多资源在应用中都可以直接使用，具体的，可以进入android-sdk的相应文件夹中去查看。例如：可以进入$android-sdk$\platforms\android-8\data\res，里面的系统资源就一览无余了。<br>开发者需要花一些时间去熟悉这些资源，特别是图片资源和各种Style资源，这样在开发过程中，能够想到有相关资源并且直接拿来使用。</p>
<h3 id="尽量为所有分辨率创建资源"><a href="#尽量为所有分辨率创建资源" class="headerlink" title="尽量为所有分辨率创建资源"></a>尽量为所有分辨率创建资源</h3><p>减少不必要的硬件缩放，这会降低UI的绘制速度，可借助Android asset studio</p>
<h2 id="巧用抽象布局标签-include-viewstub-merge"><a href="#巧用抽象布局标签-include-viewstub-merge" class="headerlink" title="巧用抽象布局标签(include, viewstub, merge)"></a>巧用抽象布局标签(include, viewstub, merge)</h2><p>在布局优化中，Androi的官方提到了这三种布局并介绍了这三种布局各有的优势<br>当你在Application中创建复杂的布局时，页面的渲染过程也变得更加缓慢。<br>此时，我们需要利用include标签(布局重用,避免重复渲染)和ViewStub标签(延迟加载)和merge标签(布局合并)来优化我们的页面。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/43376527" target="_blank" rel="external">Android最佳性能实践(四)——布局优化技巧</a></p>
<h2 id="OverDraw（过度绘制）-amp-渲染绘制的性能优化"><a href="#OverDraw（过度绘制）-amp-渲染绘制的性能优化" class="headerlink" title="OverDraw（过度绘制）&amp; 渲染绘制的性能优化"></a>OverDraw（过度绘制）&amp; 渲染绘制的性能优化</h2><p>相关文章：<br>    <a href="http://blog.csdn.net/lmj623565791/article/details/45556391" target="_blank" rel="external">Android UI性能优化实战 识别绘制中的性能问题</a><br>    <a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a><br>    <a href="http://www.jianshu.com/p/9e095bacf44a" target="_blank" rel="external">实战 Android中的UI过度绘制</a></p>
<p>准备知识：<br>    Android渲染机制</p>
<p>处理方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.移除不必要的background</div><div class="line">    1.1.移除Window默认的Background</div><div class="line">    1.2.移除XML布局文件中非必需的Background</div><div class="line"></div><div class="line">2.onDraw多次重复绘制图案</div><div class="line">    1.1.clipRect的妙用</div><div class="line">    1.2.drawRect等等</div></pre></td></tr></table></figure></p>
<h2 id="去除不必要的层级嵌套和View节点"><a href="#去除不必要的层级嵌套和View节点" class="headerlink" title="去除不必要的层级嵌套和View节点"></a>去除不必要的层级嵌套和View节点</h2><p>4.0及以上Android版本可通过设置-&gt;开发者选项-&gt;显示布局边界打开页面布局显示，看看是否有不必要的节点和嵌套。4.0以下版本可通过hierarchy viewer查看。</p>
<p>(1) 首次不需要使用的节点设置为GONE或使用viewstub<br>很多人在工作中将不常用的元素使用INVISIBLE或者GONE进行隐藏，然后当用户需要使用这些元素的时候再把它们置成VISIBLE显示出来。使用这种方式肯定可以实现功能的，但是性能方面就表现得一般了，因为即使是将元素进行隐藏，它们其实还是在布局当中的，每个元素还拥有着自己的宽、高、背景等等属性，解析布局的时候也会将这些隐藏的元素一一解析出来。</p>
<p>那么我们如何才能让这些不常用的元素仅在需要时才去加载呢？Android为此提供了一种非常轻量级的控件，ViewStub。ViewStub虽说也是View的一种，但是它没有大小，没有绘制功能，也不参与布局，资源消耗非常低，将它放置在布局当中基本可以认为是完全不会影响性能的。</p>
<p>(2) 使用RelativeLayout代替LinearLayout<br>大约在Android4.0之前，新建工程的默认main.xml中顶节点是LinearLayout，而在之后已经改为RelativeLayout，因为RelativeLayout性能更优，且可以简单实现LinearLayout嵌套才能实现的布局。<br>使用RelativeLayout减少视图树的层级，防止过度绘制</p>
<p>某网友关键评论如下：<br>通过测试，相同层级的情况下， RelativeLayout 和LinearLayour之间的效率没<br>有太大差异，但是对于同样的一个布局效果，用RelativeLayout产生的View层级嵌套比<br>LinearLayout的层级要少一些，我们知道，层级嵌套越深，资源消耗是越大的，测量和布局<br>所花费的时间是越长的。所以，相对来说RelativeLayout的效率比LinearLayout要高一些。<br>Google更加推荐咱们在写布局时，使用RelativeLayout，当我们在创建一个新工程时，<br>main_activity.xml的最外层布局是RelativeLayout。</p>
<p>复杂布局推荐使用RelativeLayout</p>
<p><a href="http://www.jianshu.com/p/8a7d059da746" target="_blank" rel="external">Android中RelativeLayout和LinearLayout性能分析</a><br><a href="http://blog.csdn.net/wangjia55/article/details/37772763" target="_blank" rel="external">【Android性能优化】尽可能用RelativeLayout来代替多层嵌套的LinearLayout</a><br><a href="https://www.zhihu.com/question/36762882" target="_blank" rel="external">安卓FrameLayout LinearLayout RelativeLayout 效率高低？</a></p>
<h2 id="减少不必要的infalte"><a href="#减少不必要的infalte" class="headerlink" title="减少不必要的infalte"></a>减少不必要的infalte</h2><p>(1) 对于inflate的布局可以直接缓存，用全部变量代替局部变量，避免下次需再次inflate<br>如上面ViewStub示例中的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</div><div class="line">  networkErrorView.setVisibility(View.VISIBLE);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (networkErrorView != <span class="keyword">null</span>) &#123;</div><div class="line">  networkErrorView.setVisibility(View.VISIBLE);</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2) ListView提供了item缓存，adapter getView的标准写法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">  ImageView appIcon;</div><div class="line">  TextView  appName;</div><div class="line">  TextView  appInfo;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line">  ViewHolder holder;</div><div class="line">  <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</div><div class="line">    convertView = inflater.inflate(R.layout.list_item, <span class="keyword">null</span>);</div><div class="line">    holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">    ……</div><div class="line">    convertView.setTag(holder);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    holder = (ViewHolder)convertView.getTag();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于ListView缓存原理可见Android ListView缓存机制。</p>
<h2 id="View控件优化"><a href="#View控件优化" class="headerlink" title="View控件优化"></a>View控件优化</h2><h3 id="用SurfaceView或TextureView代替普通View"><a href="#用SurfaceView或TextureView代替普通View" class="headerlink" title="用SurfaceView或TextureView代替普通View"></a>用SurfaceView或TextureView代替普通View</h3><p>SurfaceView或TextureView可以通过将绘图操作移动到另一个单独线程上提高性能。<br>普通View的绘制过程都是在主线程(UI线程)中完成，如果某些绘图操作影响性能就不好优化了，这时我们可以考虑使用SurfaceView和TextureView，他们的绘图操作发生在UI线程之外的另一个线程上。<br>因为SurfaceView在常规视图系统之外，所以无法像常规试图一样移动、缩放或旋转一个SurfaceView。<br>TextureView是Android4.0引入的，除了与SurfaceView一样在单独线程绘制外，还可以像常规视图一样被改变。</p>
<h3 id="ViewPager优化"><a href="#ViewPager优化" class="headerlink" title="ViewPager优化"></a>ViewPager优化</h3><h4 id="Activity返回ViewPager-Activity较慢"><a href="#Activity返回ViewPager-Activity较慢" class="headerlink" title="Activity返回ViewPager Activity较慢"></a>Activity返回ViewPager Activity较慢</h4><p>定位：在onStart函数<br>解决：使用延迟策略，具体代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    appUpdateListAdapter.notifyDataSetChanged();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onStart();</div><div class="line">    <span class="comment">// delay send message</span></div><div class="line">    handler.sendMessageDelayed(handler.obtainMessage(MessageConstants.WHAT_NOTIFY_DATA_CHANGED), <span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MessageConstants.WHAT_NOTIFY_DATA_CHANGED:</div><div class="line">                <span class="keyword">if</span> (appUpdateListAdapter != <span class="keyword">null</span>) &#123;</div><div class="line">                    appUpdateListAdapter.notifyDataSetChanged();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><p>相关文章：<br><a href="http://www.cnblogs.com/xiongbo/archive/2011/07/14/2106387.html" target="_blank" rel="external">ListView优化三原则</a></p>
<h4 id="复用convertView"><a href="#复用convertView" class="headerlink" title="复用convertView"></a>复用convertView</h4><p>使用ListView的时候，必须让ConvertView得到复用。</p>
<p>在getItemView中，判断convertView是否为空，如果不为空，可复用。</p>
<p>这个最常用的缓存方法如果不小心写错了造成的内存损失也相当巨大，数据量大手机内存小的情况下只需疯狂滑动几下app即可崩溃.</p>
<p>标准模板也留下一个：<br>在继承BaseAdapter时会让我们重写getView(int position, View   convertView, ViewGroup parent)方法，<br>第二个参数convertView就是我们要用到的重用的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;  </div><div class="line">    ViewHolder vHolder = <span class="keyword">null</span>;  </div><div class="line">    <span class="comment">//如果convertView对象为空则创建新对象，不为空则复用  </span></div><div class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;  </div><div class="line">        convertView = inflater.inflate(..., <span class="keyword">null</span>);  </div><div class="line">        <span class="comment">// 创建 ViewHodler 对象  </span></div><div class="line">        vHolder = <span class="keyword">new</span> ViewHolder();  </div><div class="line">        vHolder.img= (ImageView) convertView.findViewById(...);  </div><div class="line">        vHolder.tv= (TextView) convertView.findViewById(...);  </div><div class="line">        <span class="comment">// 将ViewHodler保存到Tag中  </span></div><div class="line">        convertView.setTag(vHolder);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                       <span class="comment">//当convertView不为空时，通过getTag()得到View  </span></div><div class="line">        vHolder = (ViewHolder) convertView.getTag();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 给对象赋值，修改显示的值  </span></div><div class="line">    vHolder.img.setImageBitmap(...);  </div><div class="line">    vHolder.tv.setText(...);  </div><div class="line">    <span class="keyword">return</span> convertView;  </div><div class="line">&#125;  </div><div class="line">       <span class="comment">//将显示的View 包装成类  </span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;  </div><div class="line">    TextView tv;  </div><div class="line">    ImageView img;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里只讲使用方法，具体性能测试文章请见：<br><a href="http://www.cnblogs.com/xiaowenji/archive/2010/12/08/1900579.html" target="_blank" rel="external">ListView中getView的原理＋如何在ListView中放置多个item</a><br><a href="http://shinfocom.iteye.com/blog/1231511" target="_blank" rel="external">Android开发之ListView适配器（Adapter）优化</a></p>
<p>注意事项：<br>如果convertView中的view需要添加listerner，代码一定要在if(convertView==null){}之外。</p>
<h4 id="Listview判断不滑动才加载数据"><a href="#Listview判断不滑动才加载数据" class="headerlink" title="Listview判断不滑动才加载数据"></a>Listview判断不滑动才加载数据</h4><p>快速滑动时不显示图片<br>当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来</p>
<p>相关文章：<br><a href="http://blog.csdn.net/yy1300326388/article/details/45153813" target="_blank" rel="external">Listview滑动时不加载数据，停下来时加载数据，让App更优</a></p>
<h4 id="异步加载图片和图片缓存和Lru回收"><a href="#异步加载图片和图片缓存和Lru回收" class="headerlink" title="异步加载图片和图片缓存和Lru回收"></a>异步加载图片和图片缓存和Lru回收</h4><p>item中如果包含有webimage，那么最好异步加载</p>
<p>list中异步加载的图片，当不在可视范围内，按照一定的算法及时回收（如在当前可视范围的上下10条item以外的图片进行回收，或者将图片进行缓存，设置一个大小，按照最近最少使用原则超过部分进行回收）</p>
<h4 id="BaseAdapter避免内存溢出"><a href="#BaseAdapter避免内存溢出" class="headerlink" title="BaseAdapter避免内存溢出"></a>BaseAdapter避免内存溢出</h4><p>如果BaseAdapter的实体类有属性非常消耗内存，可以将保存到文件；为提高性能，可以进行缓存，并限制缓存大小。</p>
<h4 id="Adapter封装"><a href="#Adapter封装" class="headerlink" title="Adapter封装"></a>Adapter封装</h4><p><a href="http://blog.csdn.net/lmj623565791/article/details/38902805/" target="_blank" rel="external">Android 快速开发系列 打造万能的ListView GridView 适配器</a><br><a href="http://www.cnblogs.com/lao-liang/p/5122425.html" target="_blank" rel="external">从零开始搭建架构实施Android项目</a></p>
<h3 id="GridView优化"><a href="#GridView优化" class="headerlink" title="GridView优化"></a>GridView优化</h3><h4 id="Gridview的滥用"><a href="#Gridview的滥用" class="headerlink" title="Gridview的滥用"></a>Gridview的滥用</h4><p>Gridview和Listview的实现方式一样，GridVIew的view不是及时创建，而全部保存在内存中，比如Gridview有100项，虽然我们只能看10项，但是其实整个100项都是在内存中</p>
<h3 id="Webview优化"><a href="#Webview优化" class="headerlink" title="Webview优化"></a>Webview优化</h3><p>Webview也能泄漏，如webview对象没有销毁，所以要注意了</p>
<h3 id="TextView优化"><a href="#TextView优化" class="headerlink" title="TextView优化"></a>TextView优化</h3><p>TextView的android:ellipsize=”marquee”跑马灯效果极耗性能，具体原因还在深入源码中</p>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p>FragmentPagerAdapter 和 FragmentStatePagerAdapter</p>
<hr>
<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><hr>
<p>时间和空间的处理<br>处理每一个细节<br>使用的任何资源都记得关闭或者异常处理，保证在最恶劣的情况下也能使资源得到释放。</p>
<p>本文会介绍一些常见的避免创建对象的场景和方法，其中有些属于微优化，有的属于编码技巧，当然也有确实能够起到显著效果的方法。</p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/java-android-performance/" target="_blank" rel="external">Trinea——性能优化之Java(Android)代码优化</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/42318689" target="_blank" rel="external">Android最佳性能实践(三)——高性能编码优化</a><br><a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">如何在Android中避免创建不必要的对象</a><br><a href="http://blog.csdn.net/arui319/article/details/8537588" target="_blank" rel="external">[Android] Android开发优化之——从代码角度进行优化</a></p>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>减少变量创建的次数<br>去掉大量的临时变量和部分全局变量<br>不要在循环当中声明临时变量，不要在循环中捕获异常。<br>但当局部变量不需要时，不需明显的设为null，因为一个方法执行完毕时，这些引用会自动被清理。</p>
<p>我们所要遵守的一个基本原则就是尽可能地少创建临时对象，越少的对象意味着越少的GC操作，同时也就意味着越好的程序性能和用户体验。</p>
<p>避免创建对象的场景：<br>1.在没有特殊原因的情况下，尽量使用基本数据类来代替封装数据类型，int比Integer要更加高效，其它数据类型也是一样。<br>2.正如前面所说，基本数据类型要优于对象数据类型，类似地，基本数据类型的数组也要优于对象数据类型的数组。另外，两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的两个数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效得多。</p>
<h2 id="使用单例"><a href="#使用单例" class="headerlink" title="使用单例"></a>使用单例</h2><p>单例是我们常用的设计模式，使用这种模式，我们可以只提供一个对象供全局调用。因此单例是避免创建不必要的对象的一种方式。</p>
<p>单例模式上手容易，但是需要注意很多问题，最重要的就是多线程并发的情况下保证单例的唯一性。当然方式很多，比如饿汉式，懒汉式double-check等。这里介绍一个很极客的书写单例的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> SingleInstanceHolder.sInstance;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceHolder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> SingleInstance sInstance = <span class="keyword">new</span> SingleInstance();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java中，类的静态初始化会在类被加载时触发，我们利用这个原理，可以实现利用这一特性，结合内部类，可以实现上面的代码，进行懒汉式创建实例。</p>
<p>当然还有其他常见的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object    obj      = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// if already inited, no need to get lock everytime</span></div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单例还有个会造成内存泄漏的问题。<br>别急，详情查看在后面的章节（单例引起的内存泄露）</p>
<h3 id="注意字符串拼接"><a href="#注意字符串拼接" class="headerlink" title="注意字符串拼接"></a>注意字符串拼接</h3><p>字符串这个或许是最不起眼的一项了。这里主要讲的是字符串的拼接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Log.i(LOGTAG, <span class="string">"onCreate bundle="</span> + savedInstanceState);</div></pre></td></tr></table></figure></p>
<p>这应该是我们最常见的打log的方式了，然而字符串的拼接内部实际是生成StringBuilder对象，然后挨个进行append，直至最后调用toString方法的过程。</p>
<p>下面是一段代码循环的代码，这明显是很不好的，因为这其中创建了很多的StringBuilder对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">implicitUseStringBuilder</span><span class="params">(String[] values)</span> </span>&#123;</div><div class="line">  String result = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; values.length; i ++) &#123;</div><div class="line">      result += values[i];</div><div class="line">  &#125;</div><div class="line">  System.out.println(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>降低字符串拼接的方法有<br>1.使用String.format替换<br>2.如果是循环拼接，建议显式在循环外部创建StringBuilder使用</p>
<p>关于字符串拼接的原理考究，可以参考这篇文章：<a href="http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/" target="_blank" rel="external">Java细节：字符串的拼接</a></p>
<h3 id="StringBuffer或StringBuilder替代String"><a href="#StringBuffer或StringBuilder替代String" class="headerlink" title="StringBuffer或StringBuilder替代String"></a>StringBuffer或StringBuilder替代String</h3><p>字符串拼接用StringBuilder代替String（String对象在进程处理时是新建一个对象），在非并发情况下用StringBuilder代替StringBuffer。</p>
<p>场景：<br>1.如果我们有一个需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。</p>
<p>2.当一个方法的返回值是String的时候，通常可以去判断一下这个String的作用是什么，如果我们明确地知道调用方会将这个返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。</p>
<p>3.设置合理的大小<br>如果你对字符串的长度有大致了解，如100字符左右，可以直接new StringBuilder(128)指定初始大小，减少空间不够时的再次分配。</p>
<p>4.用完记得回收对象<br>StringBuilder.sentLength(0) </p>
<h2 id="页面传递对象时Parcelable代替Serializable"><a href="#页面传递对象时Parcelable代替Serializable" class="headerlink" title="页面传递对象时Parcelable代替Serializable"></a>页面传递对象时Parcelable代替Serializable</h2><p>Serializable简洁<br>Parcelable速度(比 Serializable快了10多倍)<br>相关文章：<br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0204/2410.html" target="_blank" rel="external">Android系统中Parcelable和Serializable的区别</a></p>
<h2 id="对象不用了把对象数据成员设为null或者从集合中移除该对象。"><a href="#对象不用了把对象数据成员设为null或者从集合中移除该对象。" class="headerlink" title="对象不用了把对象数据成员设为null或者从集合中移除该对象。"></a>对象不用了把对象数据成员设为null或者从集合中移除该对象。</h2><p>有一些变量的引用没有被释放，导致资源不能被垃圾回收掉</p>
<p>还有一个特殊场景要注意<br>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">100</span>);     </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;      </div><div class="line">    Object o = <span class="keyword">new</span> Object();      　</div><div class="line">    v.add(o);      　</div><div class="line">    o = <span class="keyword">null</span>;      </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 循环执行完之后，此时，所有的Object对象都没有被释放，因为变量v引用这些对象（还在集合里）。</span></div></pre></td></tr></table></figure></p>
<h2 id="优化for循环-使用增强for循环"><a href="#优化for循环-使用增强for循环" class="headerlink" title="优化for循环(使用增强for循环)"></a>优化for循环(使用增强for循环)</h2><p>增强型for循环（也被称为for-each循环）可以用于去遍历实现Iterable接口的集合以及数组，这是jdk 1.5中新增的一种循环模式。当然除了这种新增的循环模式之外，我们仍然还可以使用原有的普通循环模式，只不过它们之间是有效率区别的，我们来看下面一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> mCount;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">Counter[] mArray = ...  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;  </div><div class="line">        sum += mArray[i].mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    Counter[] localArray = mArray;  </div><div class="line">    <span class="keyword">int</span> len = localArray.length;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;  </div><div class="line">        sum += localArray[i].mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (Counter a : mArray) &#123;  </div><div class="line">        sum += a.mCount;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，上述代码当中我们使用了三种不同的循环方式来对mArray中的所有元素进行求和。其中zero()方法是最慢的一种，因为它是把mArray.length写在循环当中的，也就是说每循环一次都需要重新计算一次mArray的长度。而one()方法则相对快得多，因为它使用了一个局部变量len来记录数组的长度，这样就省去了每次循环时字段搜寻的时间。two()方法在没有JIT（Just In Time Compiler）的设备上是运行最快的，而在有JIT的设备上运行效率和one()方法不相上下，唯一需要注意的是这种写法需要JDK 1.5之后才支持。</p>
<p>但是这里要跟大家提一个特殊情况，对于ArrayList这种集合，自己手写的循环要比增强型for循环更快，而其他的集合就没有这种情况。因此，对于我们来说，默认情况下可以都使用增强型for循环，而遍历ArrayList时就还是使用传统的循环方式吧。</p>
<h2 id="巧用静态方法"><a href="#巧用静态方法" class="headerlink" title="巧用静态方法"></a>巧用静态方法</h2><p>如果你并不需要访问一个对象中的某些字段，只是想调用它的某个方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，这会让调用的速度提升15%-20%，同时也不用为了调用这个方法而去专门创建对象了，这样还满足了上面的一条原则。另外这也是一种好的编程习惯，因为我们可以放心地调用静态方法，而不用担心调用这个方法后是否会改变对象的状态（静态方法内无法访问非静态字段）。</p>
<h2 id="对常量使用static-final修饰符"><a href="#对常量使用static-final修饰符" class="headerlink" title="对常量使用static final修饰符"></a>对常量使用static final修饰符</h2><p>final类型存储在常量区中读取效率更高</p>
<p>我们先来看一下在一个类的最顶部定义如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;  </div><div class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>编译器会为上述代码生成一个初始化方法，称为<clinit>方法，该方法会在定义类第一次被使用的时候调用。然后这个方法会将42的值赋值到intVal当中，并从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式来去访问具体的值了。</clinit></p>
<p>但是我们还可以通过final关键字来对上述代码进行优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;  </div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>经过这样修改之后，定义类就不再需要一个<clinit>方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal时会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。</clinit></p>
<p>另外需要大家注意的是，这种优化方式只对基本数据类型以及String类型的常量有效，对于其它数据类型的常量是无效的。不过，对于任何常量都是用static final的关键字来进行声明仍然是一种非常好的习惯。</p>
<h2 id="基本数据类型的选型"><a href="#基本数据类型的选型" class="headerlink" title="基本数据类型的选型"></a>基本数据类型的选型</h2><p>64位类型如long double的处理比32位如int慢</p>
<h2 id="多使用系统封装好的API"><a href="#多使用系统封装好的API" class="headerlink" title="多使用系统封装好的API"></a>多使用系统封装好的API</h2><p>Java语言当中其实给我们提供了非常丰富的API接口，我们在编写程序时如果可以使用系统提供的API就应该尽量使用，系统提供的API完成不了我们需要的功能时才应该自己去写，因为使用系统的API在很多时候比我们自己写的代码要快得多，它们的很多功能都是通过底层的汇编模式执行的。</p>
<p>比如说String类当中提供的好多API都是拥有极高的效率的，像indexOf()方法和一些其它相关的API，虽说我们通过自己编写算法也能够完成同样的功能，但是效率方面会和这些方法差的比较远。这里举个例子，如果我们要实现一个数组拷贝的功能，使用循环的方式来对数组中的每一个元素一一进行赋值当然是可行的，但是如果我们直接使用系统中提供的System.arraycopy()方法将会让执行效率快9倍以上。</p>
<h2 id="避免在内部调用Getters-Setters方法"><a href="#避免在内部调用Getters-Setters方法" class="headerlink" title="避免在内部调用Getters/Setters方法"></a>避免在内部调用Getters/Setters方法</h2><p>我们平时写代码时都被告知，一定要使用面向对象的思维去写代码，而面向对象的三大特性我们都知道，封装、多态和继承。其中封装的基本思想就是不要把类内部的字段暴漏给外部，而是提供特定的方法来允许外部操作相应类的内部字段，从而在Java语言当中就出现了Getters/Setters这种封装技巧。</p>
<p>然而在Android上这个技巧就不再是那么的受推崇了，因为字段搜寻要比方法调用效率高得多，我们直接访问某个字段可能要比通过getters方法来去访问这个字段快3到7倍。不过我们肯定不能仅仅因为效率的原因就将封装这个技巧给抛弃了，编写代码还是要按照面向对象思维的，但是我们可以在能优化的地方进行优化，比如说避免在内部调用getters/setters方法。</p>
<p>那什么叫做在内部调用getters/setters方法呢？这里我举一个非常简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one = <span class="number">1</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two = <span class="number">2</span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOne</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> one;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTwo</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> two;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> getOne() + getTwo();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，上面是一个Calculate类，这个类的功能非常简单，先将one和two这两个字段进行了封装，然后提供了getOne()方法获取one字段的值，提供了getTwo()方法获取two字段的值，还提供了一个getSum()方法用于获取总和的值。</p>
<p>这里我们注意到，getSum()方法当中的算法就是将one和two的值相加进行返回，但是它获取one和two的值的方式也是通过getters方法进行获取的，其实这是一种完全没有必要的方式，因为getSum()方法本身就是Calculate类内部的方法，它是可以直接访问到Calculate类中的封装字段的，因此这种写法在Android上是不推崇的，我们可以进行如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> one = <span class="number">1</span>;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> two = <span class="number">2</span>;  </div><div class="line">  </div><div class="line">    ......  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> one + two;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改成这种写法之后，我们就避免了在内部调用getters/setters方法，而对于外部而言Calculate类仍然是具有很好的封装性的。</p>
<h2 id="避免进行隐式装箱"><a href="#避免进行隐式装箱" class="headerlink" title="避免进行隐式装箱"></a>避免进行隐式装箱</h2><p>自动装箱是Java 5 引入的一个特性，即自动将原始类型的数据转换成对应的引用类型，比如将int转为Integer等。</p>
<p>这种特性，极大的减少了编码时的琐碎工作，但是稍有不注意就可能创建了不必要的对象了。比如下面的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;</div><div class="line">   sum+=i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码sum+=i可以看成sum = sum + i，但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成Integer对象。其内部变化如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> result = sum.intValue() + i;</div><div class="line">Integer sum = <span class="keyword">new</span> Integer(result);</div></pre></td></tr></table></figure></p>
<p>由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p>
<p>另外，当将原始数据类型的值加入集合中时，也会发生自动装箱，所以这个过程中也是有对象创建的。如有需要避免这种情况，可以选择SparseArray,SparseBooleanArray,SparseLongArray等容器。</p>
<p>关于Java中的自动装箱与拆箱，参考文章：<a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">Java中的自动装箱与拆箱</a></p>
<h2 id="用好LaunchMode"><a href="#用好LaunchMode" class="headerlink" title="用好LaunchMode"></a>用好LaunchMode</h2><p>复用、回收Activity对象</p>
<p>提到LaunchMode必然和Activity有关系。正常情况下我们在manifest中声明Activity，如果不设置LaunchMode就使用默认的standard模式。</p>
<p>一旦设置成standard，每当有一次Intent请求，就会创建一个新的Activity实例。举个例子，如果有10个撰写邮件的Intent，那么就会创建10个ComposeMailActivity的实例来处理这些Intent。结果很明显，这种模式会创建某个Activity的多个实例。</p>
<p>如果对于一个搜索功能的Activity，实际上保持一个Activity示例就可以了，使用standard模式会造成Activity实例的过多创建，因而不好。</p>
<p>确保符合常理的情况下，合理的使用LaunchMode，减少Activity的创建。</p>
<p>推荐用法：<br>主界面设置为singleTask<br>一般界面设置为singleTop<br>临时的activity及时finish</p>
<p>详细了解LaunchMode，阅读文章：<a href="http://droidyue.com/blog/2016/08/01/avoid-creating-unnecesssary-objects-in-android/" target="_blank" rel="external">深入讲解Android中Activity launchMode</a></p>
<h2 id="Activity处理onConfigurationChanged"><a href="#Activity处理onConfigurationChanged" class="headerlink" title="Activity处理onConfigurationChanged"></a>Activity处理onConfigurationChanged</h2><p>这又是一个关于Activity对象创建相关的，因为Activity创建的成本相对其他对象要高很多。</p>
<p>默认情况下，当我们进行屏幕旋转时，原Activity会销毁，一个新的Activity被创建，之所以这样做是为了处理布局适应。当然这是系统默认的做法，在我们开发可控的情况下，我们可以避免重新创建Activity。</p>
<p>以屏幕切换为例，在Activity声明时，加上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">".MainActivity"</span></div><div class="line">    android:label=<span class="string">"@string/app_name"</span></div><div class="line">    android:theme=<span class="string">"@style/AppTheme.NoActionBar"</span></div><div class="line">    android:configChanges=<span class="string">"orientation"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>然后重写Activity的onConfigurationChanged方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onConfigurationChanged(newConfig);</div><div class="line">    <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</div><div class="line">        setContentView(R.layout.portrait_layout);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</div><div class="line">        setContentView(R.layout.landscape_layout);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="提前检查，减少不必要的异常"><a href="#提前检查，减少不必要的异常" class="headerlink" title="提前检查，减少不必要的异常"></a>提前检查，减少不必要的异常</h2><p>异常对于程序来说，在平常不过了，然后其实异常的代码很高的，因为它需要收集现场数据stacktrace。但是还是有一些避免异常抛出的措施的，那就是做一些提前检查。</p>
<p>比如，我们想要打印一个文件的每一行字符串，没做检查的代码如下，是存在FileNotFoundException抛出可能的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printFileByLine</span><span class="params">(String filePath)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"textfile.txt"</span>);</div><div class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</div><div class="line">        String strLine;</div><div class="line">        <span class="comment">//Read File Line By Line</span></div><div class="line">        <span class="keyword">while</span> ((strLine = br.readLine()) != <span class="keyword">null</span>)   &#123;</div><div class="line">            <span class="comment">// Print the content on the console</span></div><div class="line">            System.out.println (strLine);</div><div class="line">        &#125;</div><div class="line">        br.close();</div><div class="line">    &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们进行文件是否存在的检查，抛出FileNotFoundException的概率会减少很多，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printFileByLine</span><span class="params">(String filePath)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span> File(filePath).exists()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"textfile.txt"</span>);</div><div class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</div><div class="line">        String strLine;</div><div class="line">        <span class="comment">//Read File Line By Line</span></div><div class="line">        <span class="keyword">while</span> ((strLine = br.readLine()) != <span class="keyword">null</span>)   &#123;</div><div class="line">            <span class="comment">// Print the content on the console</span></div><div class="line">            System.out.println (strLine);</div><div class="line">        &#125;</div><div class="line">        br.close();</div><div class="line">    &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述的检查是一个不错的编码技巧，建议采纳。</p>
<p>还有一点<br>慎用异常，使用异常会导致性能降低</p>
<h2 id="选用对象池"><a href="#选用对象池" class="headerlink" title="选用对象池"></a>选用对象池</h2><p>在Android中有很多池的概念，如线程池，连接池。包括我们很长用的Handler.Message就是使用了池的技术。</p>
<p>比如，我们想要使用Handler发送消息，可以使用Message msg = new Message()，也可以使用Message msg = handler.obtainMessage()。使用池并不会每一次都创建新的对象，而是优先从池中取对象。</p>
<p>使用对象池需要需要注意几点</p>
<p>将对象放回池中，注意初始化对象的数据，防止存在脏数据<br>合理控制池的增长，避免过大，导致很多对象处于闲置状态</p>
<h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p>对于很多耗时逻辑没必要立即执行，这时候我们可以将其延迟执行。</p>
<p>线程延迟执行：<br>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);</p>
<p>消息延迟发送：<br>handler.sendMessageDelayed(handler.obtainMessage(0), 1000);<br>handler.postDelayed<br>handler.postAtTime</p>
<p>视图延迟：<br>View.postDelayed</p>
<p>警告器定时：<br>AlarmManager</p>
<p>不推荐使用：<br>Timer.schedule;</p>
<h2 id="提前操作"><a href="#提前操作" class="headerlink" title="提前操作"></a>提前操作</h2><p>对于第一次调用较耗时操作，可统一放到初始化中，将耗时提前。如得到壁纸wallpaperManager.getDrawable();</p>
<h2 id="简化代码规范"><a href="#简化代码规范" class="headerlink" title="简化代码规范"></a>简化代码规范</h2><p>这是一个不可以忽略的问题。与那些连基本的Android开发编码规范都不遵守的人一起工作是很困难的。</p>
<p>这不是什么困难的事情，要不了几个小时的时间就可以学习基本的Java 和 Android 编码规范。而且这不是一次性买卖，作为一个开发者终生受益。</p>
<p>提示：这里 有一个开始学习标准编码规范的极佳资源。<br><a href="https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md" target="_blank" rel="external">https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md</a><br>其他：<br><a href="http://www.cnblogs.com/xiongbo/archive/2011/08/15/2098130.html" target="_blank" rel="external">Android开发规范</a></p>
<h2 id="重构App"><a href="#重构App" class="headerlink" title="重构App"></a>重构App</h2><p>就是重新架构app</p>
<p>大多数时候我们都笼统的把代码放到Activity和Fragment中（在这个问题上你也可以责怪我），导致它们变成庞大的“上帝对象”，这几乎不可维护和测试。</p>
<p>为app采用一个好的架构是非常重要的，比如MVP, MVVM, Redux等。考虑把app的业务逻辑，视图交互，数据交换分为不同的层，让它们更易管理和测试。</p>
<p>提示：看一看谷歌的 这些 模版可以让你在架构app的时候更容易。<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">https://github.com/googlesamples/android-architecture</a></p>
<hr>
<h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><hr>
<p>相关文章收集：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a></p>
<p>学习之前要知道这2个至关重要的概念，所有的内存优化方式都是避免下面这俩种情况发生.</p>
<h2 id="内存泄露-amp-内存溢出"><a href="#内存泄露-amp-内存溢出" class="headerlink" title="内存泄露&amp;内存溢出"></a>内存泄露&amp;内存溢出</h2><h3 id="内存泄露-a-memory-leak"><a href="#内存泄露-a-memory-leak" class="headerlink" title="内存泄露(a memory leak)"></a>内存泄露(a memory leak)</h3><p>定义：<br>内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕由于错误或漏洞造成的内存占用过多没释放，或占用内存后无法释放</p>
<p>简单理解：<br>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，<br>结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），<br>而系统也不能再次将它分配给需要的程序。</p>
<p>详细的说：<br>就说是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，<br>但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。</p>
<p>形象比喻：<br>操作系统可提供给所有进程的存储空间正在被某个进程榨干”，<br>最终结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。<br>所以“内存泄漏”是从操作系统的角度来看的。<br>这里的存储空间并不是指物理内存，而是指虚拟内存大小，<br>这个虚拟内存大小取决于磁盘交换区设定的大小。<br>由程序申请的一块内存，如果没有任何一个指针指向它，那么这块内存就泄漏了。</p>
<p>Java中有内存泄露吗？为什么？<br>有！<br>所谓内存泄露就是对象再也不用了程序一直运行还一直占用内存空间没有被释放掉，<br>程序还在一直运行，导致浪费内存，最后导致内存溢出，就叫内存泄露！</p>
<p>Android系统中GC什么情况下会出现内存泄露呢？<br>有Java带垃圾回收的机制,为什么还会内存泄露呢?<br>导致内存泄漏主要的原因是，先前申请了内存空间而忘记了释放。<br>如果程序中存在对无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器GC验证这些对象是否不再需要。<br>如果存在对象的引用，这个对象就被定义为”有效的活动”，同时不会被释放。<br>要确定对象所占内存将被回收，我们就要务必确认该对象不再会被使用。<br>安卓的内存泄露不明显：如电池不扛用没电了关机重启下就恢复了，因为内存不足在后台，被系统给回收掉了重启一下<br>也因为安卓应用内存泄露不明显，很多公司不去处理这个问题</p>
<h3 id="内存溢出-OOM-Out-of-Memory"><a href="#内存溢出-OOM-Out-of-Memory" class="headerlink" title="内存溢出(OOM:Out of Memory)"></a>内存溢出(OOM:Out of Memory)</h3><p>形象比喻：<br>一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！</p>
<p>通俗理解：<br>就是内存不够了<br>你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出</p>
<p>详细理解：<br>内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，即使已有的数据超过了其获得到的内存所能存储的范围，所以出现out of memory；<br>比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。<br>比如用一个字节存放1000这个数字也属于内存溢出</p>
<p>通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，此时软件或游戏就运行不了，系统会提示内存溢出，<br>有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件或游戏一段时间。</p>
<p>Android里出现的OOM：<br>OOM异常是Android中经常遇到的一个问题，程序员稍微不注意可能就导致其产生。<br>因为Android的每一个应用都是一个Davlik虚拟机，该虚拟机的默认堆内存只有16M，远远无法跟我们的PC机比较，因此和容易导致OOM异常的产生。<br>最常见的OOM主要是加载图片导致的。因为不良代码是可以通过约束程序员的编码规范来进行预防，或者使用性能分析工具来检查。</p>
<p>Android出现OOM只有2种可能：<br>Bitmap<br>线程</p>
<h2 id="内存泄露：资源对象引用没释放"><a href="#内存泄露：资源对象引用没释放" class="headerlink" title="内存泄露：资源对象引用没释放"></a>内存泄露：资源对象引用没释放</h2><h3 id="Handler内存泄漏"><a href="#Handler内存泄漏" class="headerlink" title="Handler内存泄漏"></a>Handler内存泄漏</h3><p>已单独整合成一篇文章，请跳转查看↓<br><a href="http://localhost:4000/2017/10/09/it/1.Android/Handler/" target="_blank" rel="external">Android —— 异步任务机制 &amp; 消息通知机制</a></p>
<h3 id="Context内存泄漏"><a href="#Context内存泄漏" class="headerlink" title="Context内存泄漏"></a>Context内存泄漏</h3><p>已单独整理成一篇文章，请跳转查看↓<br><a href="http://www.hengxing.me/2017/10/10/it/1.Android/Context/" target="_blank" rel="external">Android —— Context的几种环境和区别</a></p>
<h4 id="Drawable引起的内存泄露"><a href="#Drawable引起的内存泄露" class="headerlink" title="Drawable引起的内存泄露"></a>Drawable引起的内存泄露</h4><p>这是一个很隐晦的OutOfMemoryError的情况。先看一个Android官网提供的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;  </div><div class="line"></div><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);  </div><div class="line">  </div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);  </div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;  </div><div class="line">      sBackground = getDrawable(R.drawable.large_bitmap);  </div><div class="line">    &#125;  </div><div class="line">    label.setBackgroundDrawable(sBackground);  </div><div class="line">  </div><div class="line">    setContentView(label);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码效率很快，但同时又是极其错误的；<br>在第一次屏幕方向切换时它泄露了一开始创建的Activity。当一个Drawable附加到一个 View上时，<br>View会将其作为一个callback设定到Drawable上。上述的代码片段，意味着Drawable拥有一个TextView的引用，<br>而TextView又拥有Activity（Context类型）的引用，换句话说，Drawable拥有了更多的对象引用。即使Activity被 销毁，内存仍然不会被释放。<br>另外，对Context的引用超过它本身的生命周期，也会导致Context泄漏。所以尽量使用Application这种Context类型。<br>这种Context拥有和应用程序一样长的生命周期，并且不依赖Activity的生命周期。如果你打算保存一个长时间的对象，<br>并且其需要一个 Context，记得使用Application对象。你可以通过调用Context.getApplicationContext()或 Activity.getApplication()轻松得到Application对象。 </p>
<p>关于Drawable的其他解决方案：<br>2.3.7及以下版本Drawable的setCallback方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback cb)</span> </span>&#123;</div><div class="line">    mCallback = cb;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好在从4.0.1开始，引入了弱引用处理这个问题，弱引用在GC回收时，不会阻止GC回收其指向的对象，避免了内存泄露问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(Callback cb)</span> </span>&#123;</div><div class="line">    mCallback = <span class="keyword">new</span> WeakReference&lt;Callback&gt;(cb);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="单例引起的内存泄露"><a href="#单例引起的内存泄露" class="headerlink" title="单例引起的内存泄露"></a>单例引起的内存泄露</h4><p>单例是我们比较简单常用的一种设计模式,然而如果单例使用不当也会导致内存泄露。 比如这样一个例子,我们使用饿汉式初始化单例，AppSettings我们需要持有一个Context作为成员变量，如果我们按照下面的实现其实是有问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSettings</span> </span>&#123;    </div><div class="line">    <span class="keyword">private</span> Context mAppContext;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppSettings sInstance = <span class="keyword">new</span> AppSettings();</div><div class="line"></div><div class="line">    <span class="comment">//some other codes</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppSettings <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        mAppContext = context;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sInstance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，当我们进行屏幕旋转，默认情况下，系统会销毁当前Activity，然后当前的Activity被一个单例持有，导致垃圾回收器无法进行回收，进而产生了内存泄露。</p>
<p>解决的方法就是不持有Activity的引用，而是持有Application的Context引用。代码如下修改<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    mAppContext = context.getApplicationContext(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://blog.csdn.net/syc434432458/article/details/51612747" target="_blank" rel="external">单例造成的内存泄漏</a></p>
<h4 id="getSystemService内存泄漏"><a href="#getSystemService内存泄漏" class="headerlink" title="getSystemService内存泄漏"></a>getSystemService内存泄漏</h4><p>相关文章：<br><a href="http://droidyue.com/blog/2016/11/14/be-careful-using-getsystemservice/" target="_blank" rel="external">技术小黑屋——Android内存泄漏：谨慎使用getSystemService</a></p>
<h4 id="线程引起的内存泄漏"><a href="#线程引起的内存泄漏" class="headerlink" title="线程引起的内存泄漏"></a>线程引起的内存泄漏</h4><p>最近遇到一种情况引起了Context泄漏，就是在Activity销毁时，里面有其他线程没有停。<br>详细看下面关于多线程的踪迹</p>
<h3 id="AsyncTask内存泄漏"><a href="#AsyncTask内存泄漏" class="headerlink" title="AsyncTask内存泄漏"></a>AsyncTask内存泄漏</h3><h3 id="Listener内存泄露"><a href="#Listener内存泄露" class="headerlink" title="Listener内存泄露"></a>Listener内存泄露</h3><p>下面各类监听器注册后，没有在对应的位置写取消（反注册）的代码：<br>广播接受者(BroadcastReceiver)<br>观察者(Observer)<br>传感器(Sensor)</p>
<h3 id="Timer内存泄漏"><a href="#Timer内存泄漏" class="headerlink" title="Timer内存泄漏"></a>Timer内存泄漏</h3><p>下面是一个使用Java Timer的例子，功能是在5秒后做一些工作。它们两个类可以被用于调度一些运行于后台的线程。在Android中还有一些类似的处理方法，你可以使用带有postDelayed的Handler或者是Handler 结合调用sendMessageDelayed（）方法，这样handler就会运行在后台正如上面展示的一样。同样，你要清楚这两个API对于Android的生命周期不清楚，很难在Activity、Fragment或者是View中引用它们，因为这样可能会导致内存泄露。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">timer.schedule(<span class="keyword">new</span> TimerTask()&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// time ran out.</span></div><div class="line">    timer.cancel(); </div><div class="line">  &#125;</div><div class="line">&#125;, <span class="number">5000</span>);</div></pre></td></tr></table></figure></p>
<h3 id="属性动画导致内存泄露"><a href="#属性动画导致内存泄露" class="headerlink" title="属性动画导致内存泄露"></a>属性动画导致内存泄露</h3><p>例如代码中设置了属性动画（ObjectAnimator），在Activity中启动了动画，但是在销毁的时候，没有调用cancle方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。</p>
<h3 id="NotificationManager内存泄漏"><a href="#NotificationManager内存泄漏" class="headerlink" title="NotificationManager内存泄漏"></a>NotificationManager内存泄漏</h3><p>android 直到4.1.3 之前的版本，通知栏API 都存在内存泄露BUG，反复调用 NotificationManager.notify 方法会造成手机死机重启。<br>绕过此BUG 的方法是每次调用notify 时都必须 new 一个新的RemoteViews。</p>
<h3 id="new-Message内存泄露"><a href="#new-Message内存泄露" class="headerlink" title="new Message内存泄露"></a>new Message内存泄露</h3><p>尽量采用Message.obtain();</p>
<h3 id="关于OnSharedPreferenceChangeListener的设计"><a href="#关于OnSharedPreferenceChangeListener的设计" class="headerlink" title="关于OnSharedPreferenceChangeListener的设计"></a>关于OnSharedPreferenceChangeListener的设计</h3><p>它的设计用弱引用的方式不和Activity纠缠在一起，的确避免了内存泄漏<br>但是还时有些问题需要额外处理下.<br>详情查看文章：<br><a href="http://droidyue.com/blog/2014/11/29/why-onsharedpreferencechangelistener-was-not-called/" target="_blank" rel="external">技术小黑屋——Google为何这样设计OnSharedPreferenceChangeListener</a></p>
<h3 id="静态变量（static关键字）引起内存泄露"><a href="#静态变量（static关键字）引起内存泄露" class="headerlink" title="静态变量（static关键字）引起内存泄露"></a>静态变量（static关键字）引起内存泄露</h3><p>小心静态变量引用了activity<br>代码有静态变量引用了activity，随着代码的运行导致内存越来越大导致内存泄漏</p>
<p>要谨慎的对象：<br>Bitmap<br>Animation </p>
<p>原因：<br>因为有静态关键字，字节码被装载进来了，static对应的空间就被申请进来了<br>即使MainActivity被回收掉了，如静态bitmap空间还被占用着</p>
<p>解决方案：<br>就是把静态的引用去掉</p>
<p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Resources mResources; </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>.onCreate(state);</div><div class="line"><span class="keyword">if</span> (mResources == <span class="keyword">null</span>) &#123;</div><div class="line">    mResources = <span class="keyword">this</span>.getResources();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码中有一个静态的Resources对象。代码片段mResources = this.getResources()对Resources对象进行了初始化。这时Resources对象拥有了当前Activity对象的引用，Activity又引用了整个页面中所有的对象。<br>如果当前的Activity被重新创建（比如横竖屏切换，默认情况下整个Activity会被重新创建），由于Resources引用了第一次创建的Activity，就会导致第一次创建的Activity不能被垃圾回收器回收，从而导致第一次创建的Activity中的所有对象都不能被回收。这个时候，一部分内存就浪费掉了。</p>
<p>解决方案：<br>使用Application的Context<br>在Android中，Application Context的生命周期和应用的生命周期一样长，而不是取决于某个Activity的生命周期。如果想保持一个长期生命的对象，并且这个对象需要一个Context，就可以使用Application对象。<br>可以通过调用Context.getApplicationContext()方法或者Activity.getApplication()方法来获得Application对象。<br>依然拿上面的代码作为例子。可以将代码修改成下面的样子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Resources mResources; </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>.onCreate(state);</div><div class="line"><span class="keyword">if</span> (mResources == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">// mResources = this.getResources();</span></div><div class="line">    mResources = <span class="keyword">this</span>.getApplication().getResources();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里将this.getResources()修改为this.getApplication().getResources()。<br>修改以后，Resources对象拥有的是Application对象的引用。<br>如果Activity被重新创建，第一次创建的Activity就可以被回收了。</p>
<p>经验分享：<br>在实际项目中，我们经常会把一些对象的引用加入到集合中，如果这个集合是静态的话，就需要特别注意了。当不需要某对象时，务必及时把它的引用从集合中清理掉。或者可以为集合提供一种更新策略，及时更新整个集合，这样可以保证集合的大小不超过某值，避免内存空间的浪费。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/wuchuy/article/details/51242738" target="_blank" rel="external">android中不小心使用静态变量会导致内存泄露</a></p>
<h3 id="非static的内部类"><a href="#非static的内部类" class="headerlink" title="非static的内部类"></a>非static的内部类</h3><p>如果你不想控制内部类的生命周期，应该避免在activity中使用非静态的内部类，而应该是静态的内部类</p>
<p>典型案例：<br>Handler</p>
<h3 id="使用WeakReference代替强引用"><a href="#使用WeakReference代替强引用" class="headerlink" title="使用WeakReference代替强引用"></a>使用WeakReference代替强引用</h3><p>弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。</p>
<p>使用SoftReference、WeakReference相对正常的强应用来说更有利于系统垃圾回收</p>
<p>相关文章：<br><a href="http://blog.csdn.net/arui319/article/details/8489451" target="_blank" rel="external">[Android] Android开发优化之——使用软引用和弱引用</a></p>
<h2 id="内存泄露：资源对象没有关闭"><a href="#内存泄露：资源对象没有关闭" class="headerlink" title="内存泄露：资源对象没有关闭"></a>内存泄露：资源对象没有关闭</h2><h3 id="数据库的Cursor-未及时关闭"><a href="#数据库的Cursor-未及时关闭" class="headerlink" title="数据库的Cursor 未及时关闭"></a>数据库的Cursor 未及时关闭</h3><p>操作Sqlite数据库时，Cursor是数据库表中每一行的集合，是Android查询数据后得到的一个管理数据集合的类，Cursor提供了很多方法，可以很方便的读取数据库中的值，<br>可以根据索引，列名等获取数据库中的值，通过游标的方式可以调用moveToNext()移到下一行<br>当我们操作完数据库后，一定要记得调用Cursor对象的close()来关闭游标，释放资源。<br>正常情况下，如果我们没有关闭它，系统会在回收它时进行关闭，但是这样的效率特别低。如果查询得到的数据量较小时还好，如果Cursor的数据量非常大，特别是如果里面有Blob信息时，就可能出现内存问题。<br>所以一定要及时关闭Cursor。<br>这样保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。<br>并且Android明显是倾向于编程者手动的将Cursor close掉</p>
<p>下面给出一个通用的使用Cursor的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Cursor cursor = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    cursor = mContext.getContentResolver().query(uri,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</div><div class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</div><div class="line">        cursor.moveToFirst();</div><div class="line">        <span class="comment">// 处理数据</span></div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">    e.printStatckTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>)&#123;</div><div class="line">        cursor.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即对异常进行捕获，并且在finally中将cursor关闭。<br>同样的，在使用文件的时候，也要及时关闭。</p>
<h3 id="网络资源-连接Socket-、IO流资源没有及时关闭（InputStream-OutputStream），File"><a href="#网络资源-连接Socket-、IO流资源没有及时关闭（InputStream-OutputStream），File" class="headerlink" title="网络资源(连接Socket)、IO流资源没有及时关闭（InputStream/OutputStream），File"></a>网络资源(连接Socket)、IO流资源没有及时关闭（InputStream/OutputStream），File</h3><p>这个就不多说了，我们操作完输入输出流都要关闭流 </p>
<h2 id="内存泄漏：资源对象没有回收"><a href="#内存泄漏：资源对象没有回收" class="headerlink" title="内存泄漏：资源对象没有回收"></a>内存泄漏：资源对象没有回收</h2><p>1.Bitmap recycle<br>在不使用Bitmap对象时，需要调用recycle()释放内存，然后将它设置为null。虽然调用recycle()并不能保证立即释放占用的内存，但是可以加速Bitmap的内存的释放。<br>在代码优化的过程中，如果发现某个Activity用到了Bitmap对象，却没有显式的调用recycle()释放内存，则需要分析代码逻辑，增加相关代码，在不再使用Bitmap以后调用recycle()释放内存。</p>
<p>2.TypedArray recycle</p>
<h2 id="释放内存：当界面不可见"><a href="#释放内存：当界面不可见" class="headerlink" title="释放内存：当界面不可见"></a>释放内存：当界面不可见</h2><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop"></a>onStop</h3><p>取消网络连接<br>注销广播接收器</p>
<h3 id="onTrimMemory"><a href="#onTrimMemory" class="headerlink" title="onTrimMemory"></a>onTrimMemory</h3><p>在适当的生命周期中创建释放对象<br>onTrimMemory回调：应用响应此回调释放非必须内存，如图片的内存占用</p>
<p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。</p>
<p>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onTrimMemory(level);  </div><div class="line">    <span class="keyword">switch</span> (level) &#123;  </div><div class="line">    <span class="keyword">case</span> TRIM_MEMORY_UI_HIDDEN:  </div><div class="line">        <span class="comment">// 进行资源释放操作  </span></div><div class="line">        <span class="keyword">break</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>
<h2 id="释放内存：当内存紧张时"><a href="#释放内存：当内存紧张时" class="headerlink" title="释放内存：当内存紧张时"></a>释放内存：当内存紧张时</h2><p>详情查看里面的部分段落<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="external">Android最佳性能实践(一)——合理管理内存</a></p>
<h2 id="释放内存：知晓内存的开支情况"><a href="#释放内存：知晓内存的开支情况" class="headerlink" title="释放内存：知晓内存的开支情况"></a>释放内存：知晓内存的开支情况</h2><p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：</p>
<p>任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。<br>任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。<br>在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</p>
<h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>重复使用的资源可以考虑使用缓存池技术</p>
<p>Java的对象创建需要分配资源较耗费时间，加上创建的对象越多会造成越频繁的gc影响系统响应。</p>
<p>在内存、文件、数据库、网络的读写速度中，内存都是最优的，且速度数量级差别，所以尽量将需要频繁访问或访问一次消耗较大的数据存储在缓存中。</p>
<p>(1). 单例模式<br>对于创建开销较大的类可使用此方法，保证全局一个实例，在程序运行过程中该类不会因新建额外对象产生开销。</p>
<p>(2). 缓存<br>程序中用到了对象缓存，图片缓存、线程池、View缓存、IO缓存、消网络缓存，DB缓存，消息缓存、通知栏notification缓存)及其他方式减少对象创建。</p>
<p>对象缓存能减少内存的分配，IO缓存减少磁盘的读写次数，网络缓存减少网络传输，DB缓存较少Database的访问次数。</p>
<p>a. 图片缓存：<br><a href="http://www.trinea.cn/android/android-imagecache/" target="_blank" rel="external">ImageCache</a><br><a href="http://www.trinea.cn/android/android-imagesdcardcache/" target="_blank" rel="external">ImageSdCache</a><br><a href="http://www.trinea.cn/android/preloaddatacache/" target="_blank" rel="external">数据预取缓存</a></p>
<p>b. 线程池：使用Java的Executors类，通过newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor、newScheduledThreadPool提供四种不同类型的线程池</p>
<p>c. View缓存：<br>可见<a href="Android ListView滑动过程中图片显示重复错位闪烁问题解决">ListView缓存机制</a><br>listView的getView缓存<br>通过convertView是否为null减少layout inflate次数，通过静态的ViewHolder减少findViewById的次数，这两个函数尤其是inflate是相当费时间的</p>
<p>d. IO缓存：<br>使用具有缓存策略的输入流<br>BufferedInputStream替代InputStream<br>BufferedReader替代Reader<br>BufferedReader替代BufferedInputStream.<br>对文件、网络IO皆适用。</p>
<p>e. 网络缓存<br><a href="http://www.trinea.cn/android/android-http-cache/" target="_blank" rel="external">Android网络缓存</a></p>
<p>http response，根据http头信息中的Cache-Control域确定缓存过期时间。</p>
<p>f. 消息缓存：<br>1.通过 Handler 的 obtainMessage 来从消息池中回收 Message 对象，减少 Message 对象的创建开销<br>handler.sendMessage(handler.obtainMessage(1));</p>
<p>2.如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</p>
<p>g. 通知栏notification缓存：<br>下载中需要不断改变通知栏进度条状态，如果不断新建Notification会导致通知栏很卡。这里我们可以使用最简单的缓存<br>Map<string, notification=""> notificationMap = new HashMap<string, notification="">();如果notificationMap中不存在，则新建notification并且put into map.</string,></string,></p>
<p>h.Layout缓存<br><a href="http://www.trinea.cn/android/layout-performance/" target="_blank" rel="external">性能优化之布局优化</a></p>
<h2 id="4大组件优化"><a href="#4大组件优化" class="headerlink" title="4大组件优化"></a>4大组件优化</h2><h3 id="Activity优化"><a href="#Activity优化" class="headerlink" title="Activity优化"></a>Activity优化</h3><p>如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可</p>
<h3 id="Service优化"><a href="#Service优化" class="headerlink" title="Service优化"></a>Service优化</h3><h4 id="节制使用Service"><a href="#节制使用Service" class="headerlink" title="节制使用Service"></a>节制使用Service</h4><p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>
<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。关于IntentService更加详细的用法讲解，可以参考《第一行代码——Android》的9.5.2节。</p>
<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载（我个人就会这么做）。</p>
<h4 id="推荐使用IntentService"><a href="#推荐使用IntentService" class="headerlink" title="推荐使用IntentService"></a>推荐使用IntentService</h4><p>简介：<br>一个可以干完活后自己去死且不需要我们去管理子线程的Service。</p>
<p>注意：<br>最后，别忘了配置Service，因为它继承于Service，所以，它还是一个Service，一定要配置，否则是不起作用的，开始我就是忘了，结果半天没反应。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=".IntentServiceDemo"&gt;</div><div class="line">      &lt;intent-filter &gt;</div><div class="line">          &lt;action android:name="com.test.intentservice"/&gt;</div><div class="line">      &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure></p>
<p>参考文章：<br><a href="http://www.tuicool.com/articles/zeMFFvB" target="_blank" rel="external">Android中IntentService详解</a><br><a href="https://www.2cto.com/kf/201409/331983.html" target="_blank" rel="external">Android面试，IntentService的原理及使用</a><br><a href="https://zhidao.baidu.com/question/617440918557008172.html" target="_blank" rel="external">Service和IntentService中显示Toast的区别</a></p>
<p>参考书籍：<br>《第一行代码——Android》的9.5.2节。</p>
<h3 id="BroadcastReceiver优化"><a href="#BroadcastReceiver优化" class="headerlink" title="BroadcastReceiver优化"></a>BroadcastReceiver优化</h3><h4 id="广播接受者的内存泄漏"><a href="#广播接受者的内存泄漏" class="headerlink" title="广播接受者的内存泄漏"></a>广播接受者的内存泄漏</h4><p>广播接收者（BroadcastReceiver）经常在应用中用到，可以在多线程任务完成后发送广播通知UI更新，也可以接收系统广播实现一些功能 </p>
<p>泄漏关键就是调用registerReceiver()后未调用unregisterReceiver(). </p>
<p>流程如下：<br>可以通过代码的方式注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntentFilter postFilter = <span class="keyword">new</span> IntentFilter(); </div><div class="line">postFilter.addAction(getPackageName() + <span class="string">".background.job"</span>); </div><div class="line"><span class="keyword">this</span>.registerReceiver(receiver, postFilter);</div></pre></td></tr></table></figure></p>
<p>当我们Activity中使用了registerReceiver()方法注册了BroadcastReceiver，<br>一定要在Activity的生命周期内调用unregisterReceiver()方法取消注册<br>也就是说registerReceiver()和unregisterReceiver()方法一定要成对出现，通常我们可以重写Activity的onDestory()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">this</span>.unregisterReceiver(receiver);  </div><div class="line">      <span class="keyword">super</span>.onDestroy();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="LocalBroadcastManager"><a href="#LocalBroadcastManager" class="headerlink" title="LocalBroadcastManager"></a>LocalBroadcastManager</h2><p>LocalBroadcastManager代替BroadcastReceiver，效率和安全性都更高</p>
<h3 id="ContentProvider优化"><a href="#ContentProvider优化" class="headerlink" title="ContentProvider优化"></a>ContentProvider优化</h3><h2 id="异步任务优化"><a href="#异步任务优化" class="headerlink" title="异步任务优化"></a>异步任务优化</h2><p>异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态<br><a href="http://blog.csdn.net/sfshine/article/details/8144387" target="_blank" rel="external">判断一个Activity在当前激活状态</a></p>
<h2 id="Bitmap图片优化"><a href="#Bitmap图片优化" class="headerlink" title="Bitmap图片优化"></a>Bitmap图片优化</h2><p>因内容庞大，已单独总结分割成一篇文章，请查看以下链接↓<br><a href="http://www.hengxing.me/2017/09/09/it/1.Android/Bitmap/" target="_blank" rel="external">Android —— Bitmap图片的总结</a></p>
<h2 id="集合容器优化-amp-数据结构和算法优化"><a href="#集合容器优化-amp-数据结构和算法优化" class="headerlink" title="集合容器优化 &amp; 数据结构和算法优化"></a>集合容器优化 &amp; 数据结构和算法优化</h2><h3 id="HashMap代替arrayList"><a href="#HashMap代替arrayList" class="headerlink" title="HashMap代替arrayList"></a>HashMap代替arrayList</h3><p>使用hashMap代替arrayList，时间复杂度降低一个数量级</p>
<h3 id="新型集合替代Hash系列集合"><a href="#新型集合替代Hash系列集合" class="headerlink" title="新型集合替代Hash系列集合"></a>新型集合替代Hash系列集合</h3><p>关于Sparse系列和ArrayMap清查看以下文章：<br><a href="http://www.hengxing.me/2017/09/07/it/1.Java/CollectionsFramework/" target="_blank" rel="external">集合框架和其他容器类的总结</a></p>
<h3 id="谨慎选用容器和集合容器扩容优化"><a href="#谨慎选用容器和集合容器扩容优化" class="headerlink" title="谨慎选用容器和集合容器扩容优化"></a>谨慎选用容器和集合容器扩容优化</h3><p>Java和Android提供了很多编辑的容器集合来组织对象。比如ArrayList,ContentValues,HashMap等。</p>
<p>然而，这样容器虽然使用起来方便，但也存在一些问题，就是他们会自动扩容，这其中不是创建新的对象，而是创建一个更大的容器对象。这就意味这将占用更大的内存空间。</p>
<p>以HashMap为例，当我们put key和value时，会检测是否需要扩容，如需要则双倍扩容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> putValueForNullKey(value);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//some code here</span></div><div class="line"></div><div class="line">    <span class="comment">// No entry for (non-null) key is present; create one</span></div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> (size++ &gt; threshold) &#123;</div><div class="line">        tab = doubleCapacity();</div><div class="line">        index = hash &amp; (tab.length - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    addNewEntry(key, value, hash, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于扩容的问题，通常有如下几种方法<br>1.预估一个较大的容量值，避免多次扩容<br>2.寻找替代的数据结构，确保做到时间和空间的平衡</p>
<p>优化的小细节：<br>使用集合对象，如果事先知道其大小，则可以在构造方法中设置初始大小。</p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2017/03/05/java-performance-tuning-collection-size-growth/" target="_blank" rel="external">Java性能调优之容器扩容问题</a></p>
<h3 id="集合的循环遍历方式性能分析"><a href="#集合的循环遍历方式性能分析" class="headerlink" title="集合的循环遍历方式性能分析"></a>集合的循环遍历方式性能分析</h3><p>List<br>(1) 无论ArrayList还是LinkedList，遍历建议使用foreach，尤其是数据量较大时LinkedList避免使用get遍历。<br>(2) List使用首选ArrayList。对于个别插入删除非常多的可以使用LinkedList。<br>(3) 可能在遍历List循环内部需要使用到下标，这时综合考虑下是使用foreach和自增count还是get方式。<br>(4) 用临时遍历变量size取代list.size()性能更优<br><a href="http://www.trinea.cn/android/arraylist-linkedlist-loop-performance/" target="_blank" rel="external">ArrayList和LinkedList的几种循环遍历方式及性能对比分析</a></p>
<p>Map<br>(1) HashMap的循环，如果既需要key也需要value，直接用<br>Map<string, string=""> map = new HashMap<string, string="">();<br>for (Entry<string, string=""> entry : map.entrySet()) {<br>    entry.getKey();<br>    entry.getValue();<br>}<br>即可，foreach简洁易懂。<br>(2) 如果只是遍历key而无需value的话，可以直接用<br>Map<string, string=""> map = new HashMap<string, string="">();<br>for (String key : map.keySet()) {<br>    // key process<br>}<br><a href="http://www.trinea.cn/android/hashmap-loop-performance/" target="_blank" rel="external">HashMap循环遍历方式及其性能对比</a></string,></string,></string,></string,></string,></p>
<h3 id="集合容器对象没有清理造成的内存泄露"><a href="#集合容器对象没有清理造成的内存泄露" class="headerlink" title="集合容器对象没有清理造成的内存泄露"></a>集合容器对象没有清理造成的内存泄露</h3><p>记得不用了就赋予null</p>
<h3 id="数据结构选择"><a href="#数据结构选择" class="headerlink" title="数据结构选择"></a>数据结构选择</h3><p>常见的数据结构选择如：<br>ArrayList和LinkedList的选择：<br>ArrayList根据index取值更快，LinkedList更占内存、随机插入删除更快速、扩容效率更高。一般推荐ArrayList。</p>
<p>ArrayList、HashMap、LinkedHashMap、HashSet的选择：<br>hash系列数据结构查询速度更优，ArrayList存储有序元素，HashMap为键值对数据结构，LinkedHashMap可以记住加入次序的hashMap，HashSet不允许重复元素。</p>
<p>HashMap、WeakHashMap选择：<br>WeakHashMap中元素可在适当时候被系统垃圾回收器自动回收，所以适合在内存紧张型中使用。</p>
<p>Collections.synchronizedMap和ConcurrentHashMap的选择：<br>ConcurrentHashMap为细分锁，锁粒度更小，并发性能更优。<br>Collections.synchronizedMap为对象锁，自己添加函数进行锁控制更方便。</p>
<p>Android也提供了一些性能更优的数据类型：<br>SparseArray、SparseBooleanArray、SparseIntArray、Pair。</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>尽量不用O(n*n)时间复杂度以上的算法，必要时候可用空间换时间。<br>查询考虑hash和二分，尽量不用递归。</p>
<h2 id="多线程优化和多进程优化"><a href="#多线程优化和多进程优化" class="headerlink" title="多线程优化和多进程优化"></a>多线程优化和多进程优化</h2><p>已单独整合成一篇文章，请点击以下文章阅读：↓<br><a href="http://www.hengxing.me/2017/10/09/it/1.Android/Process/" target="_blank" rel="external">Android —— 进程和线程</a></p>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="谨慎使用抽象编程"><a href="#谨慎使用抽象编程" class="headerlink" title="谨慎使用抽象编程"></a>谨慎使用抽象编程</h3><p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>
<h3 id="不建议使用枚举用注解"><a href="#不建议使用枚举用注解" class="headerlink" title="不建议使用枚举用注解"></a>不建议使用枚举用注解</h3><p>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。<br>如括Enum，EnumSet，EnumMap等。<br>枚举也是单例，所以也可能会带来内存泄露</p>
<p>一、枚举常量的优势<br>1）枚举常量会更简单<br>2）枚举常量会更安全<br>3）枚举可以有内置方法和自己的方法<br>4）可以用EnumSet代替位标志<br>二、使用枚举带来的问题<br>1）枚举会增加dex文件大小<br>2）枚举会增加dex文件方法数量<br>3）枚举会增加内存的使用<br>4）枚举会增加字符串常量<br>5）枚举会增加函数调用时间</p>
<p>相关文章：<a href="http://blog.csdn.net/warden032/article/details/52452035" target="_blank" rel="external">android开发之避免使用枚举</a></p>
<p>使用注解替代枚举</p>
<p>枚举是我们经常使用的一种用作值限定的手段，使用枚举比单纯的常量约定要靠谱。然后枚举的实质还是创建对象。好在Android提供了相关的注解，使得值限定在编译时进行，进而减少了运行时的压力。相关的注解为IntDef和StringDef。</p>
<p>如下以IntDef为例，介绍如何使用</p>
<p>在一个文件中如下声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConstants</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_OPEN = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_CLOSE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_BROKEN = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="meta">@IntDef</span>(&#123;STATE_OPEN, STATE_CLOSE, STATE_BROKEN&#125;)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span>  DoorState &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后设置书写这样的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setDoorState</span><span class="params">(@AppConstants.DoorState <span class="keyword">int</span> state)</span> </span>&#123;</div><div class="line">    <span class="comment">//some code</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用方法时只能使用STATE_OPEN，STATE_CLOSE和STATE_BROKEN。使用其他值会导致编译提醒和警告。</p>
<p>想要深入了解注解，可以阅读：<a href="http://droidyue.com/blog/2016/04/24/look-into-java-annotation/" target="_blank" rel="external">详解Java中的注解</a></p>
<h3 id="尽量避免使用依赖注入框架"><a href="#尽量避免使用依赖注入框架" class="headerlink" title="尽量避免使用依赖注入框架"></a>尽量避免使用依赖注入框架</h3><p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidWay</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;   </div><div class="line">    TextView name;   </div><div class="line">    ImageView thumbnail;   </div><div class="line">    LocationManager loc;   </div><div class="line">    Drawable icon;   </div><div class="line">    String myName;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">        name      = (TextView) findViewById(R.id.name);   </div><div class="line">        thumbnail = (ImageView) findViewById(R.id.thumbnail);   </div><div class="line">        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE);   </div><div class="line">        icon      = getResources().getDrawable(R.drawable.icon);   </div><div class="line">        myName    = getString(R.string.app_name);   </div><div class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简化成这样的一种写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ContentView</span>(R.layout.main)  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoboWay</span> <span class="keyword">extends</span> <span class="title">RoboActivity</span> </span>&#123;   </div><div class="line">    <span class="meta">@InjectView</span>(R.id.name)             TextView name;   </div><div class="line">    <span class="meta">@InjectView</span>(R.id.thumbnail)        ImageView thumbnail;   </div><div class="line">    <span class="meta">@InjectResource</span>(R.drawable.icon)   Drawable icon;   </div><div class="line">    <span class="meta">@InjectResource</span>(R.string.app_name) String myName;   </div><div class="line">    <span class="meta">@Inject</span>                            LocationManager loc;   </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </div><div class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>
<h3 id="判断app是否已安装的状态的优化"><a href="#判断app是否已安装的状态的优化" class="headerlink" title="判断app是否已安装的状态的优化"></a>判断app是否已安装的状态的优化</h3><p>修改设置app是否已安装的状态，具体代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;PackageInfo&gt; installedPackageList = getPackageManager().getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);</div><div class="line">List&lt;App&gt; installedAppList = function(installedAppList)</div><div class="line"><span class="keyword">for</span> (App app : appList) &#123;</div><div class="line">	<span class="keyword">for</span> (App installedApp : installedAppList) &#123;</div><div class="line"> </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (App app : appList) &#123;</div><div class="line">	Pair&lt;Integer, String&gt; versionInfo = INSTALLED_APP_MAP.get(app.getPackageName());</div><div class="line">	<span class="keyword">if</span> (versionInfo != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从每次获取List<packageinfo> installedAppList = getPackageManager().getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);修改为只在有应用安装或卸载广播时获取应用列表，并且用hashMap代替installedAppList减少查询时间。<br>将平均执行时间从201ms降低到1ms。</packageinfo></p>
<hr>
<h1 id="工具优化"><a href="#工具优化" class="headerlink" title="工具优化"></a>工具优化</h1><hr>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238633" target="_blank" rel="external">Android最佳性能实践(二)——分析内存的使用情况</a></p>
<h2 id="性能优化分析工具"><a href="#性能优化分析工具" class="headerlink" title="性能优化分析工具"></a>性能优化分析工具</h2><p>用途：性能分析优化监视/查看UI/调试Bug/检测内存泄露工具 </p>
<h3 id="简单有用的发现性能问题的方法"><a href="#简单有用的发现性能问题的方法" class="headerlink" title="简单有用的发现性能问题的方法"></a>简单有用的发现性能问题的方法</h3><p><a href="http://droidyue.com/blog/2017/03/13/a-small-trick-to-detect-time-consuming-task/" target="_blank" rel="external">Android中一个简单有用的发现性能问题的方法</a></p>
<h3 id="手机-设置-开发者选项"><a href="#手机-设置-开发者选项" class="headerlink" title="手机/设置/开发者选项"></a>手机/设置/开发者选项</h3><p>1.查看UI过度绘制<br>手机 / 设置 / 开发者选项 / 显示布局边界（Show GPU Overdraw）<br><a href="http://jingyan.baidu.com/article/1e5468f97c4772484961b72a.html" target="_blank" rel="external">手机怎么设置调试GPU过度绘制</a></p>
<h3 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h3><p>减少不必要的层次：巧用Hierarchy Viewer<br>hierarchy viewer可以方便的查看Activity的布局，各个View的属性、measure、layout、draw的时间，如果耗时较多会用红色标记，否则显示绿色。<br>hierarchy viewer.bat位于<sdk>/tools/目录下</sdk></p>
<h3 id="ViewServer"><a href="#ViewServer" class="headerlink" title="ViewServer"></a>ViewServer</h3><p>下载地址：<br><a href="https://github.com/romainguy/ViewServer" target="_blank" rel="external">https://github.com/romainguy/ViewServer</a></p>
<p>相关文章：<br><a href="http://blog.csdn.net/wanglu198506/article/details/43106133" target="_blank" rel="external">使用ViewServer让Android真机可用HierarchyView视图检测工具</a></p>
<p>参考书籍：<br>Android群英传-10.1.5</p>
<h3 id="无线uiviewer"><a href="#无线uiviewer" class="headerlink" title="无线uiviewer"></a>无线uiviewer</h3><p>安卓UI集成调试必备利器！<br>在android手机端实现Hierarchyviewer里的uiautomatorviewer功能，查看UI布局、控件位置不再需要通过数据线连接到电脑查看，在手机上随时随地可以查看任意界面！<br>有了此工具，安卓测试人员可以底气十足的告诉开发人员，开发出来的界面控件位置、大小哪些是错的，哪些是对的！<br>有了此工具，安卓开发人员可以信心百倍的告诉测试人员，我开发出来的界面与UI标注图是一模一样的！不信你用“无线uiviewer”量一量！</p>
<p>PS：手机需要root</p>
<p>下载地址：<br><a href="http://download.csdn.net/download/duantihi/9448886" target="_blank" rel="external">http://download.csdn.net/download/duantihi/9448886</a></p>
<h3 id="开发助手"><a href="#开发助手" class="headerlink" title="开发助手"></a>开发助手</h3><p><a href="http://www.trinea.cn/android/android-develop-and-debug-tools/" target="_blank" rel="external">Android应用开发调试利器——开发助手，数十倍效率提升</a></p>
<h3 id="ddms-bat"><a href="#ddms-bat" class="headerlink" title="ddms.bat"></a>ddms.bat</h3><p>DDMS 全称是Dalvik Debug Monitor Service，是 Android 开发环境中的Dalvik虚拟机调试监控服务。<br>adt插件的功能, 提供一个调试的视图</p>
<p>具体功能：<br>设备列表,进程列表<br>文件管理<br>模拟器控制 打入电话 发入短信 定位信息<br>查看模拟器资源信息</p>
<h4 id="dump-View-Hierarchy-for-UI-automator"><a href="#dump-View-Hierarchy-for-UI-automator" class="headerlink" title="dump View Hierarchy for UI automator"></a>dump View Hierarchy for UI automator</h4><p><a href="http://blog.csdn.net/caiwenfeng_for_23/article/details/38498337" target="_blank" rel="external">android 开发UI好工具—–dump View Hierarchy for UI automator</a></p>
<h3 id="Monkey-amp-MonkeyRunner"><a href="#Monkey-amp-MonkeyRunner" class="headerlink" title="Monkey &amp; MonkeyRunner"></a>Monkey &amp; MonkeyRunner</h3><p><a href="http://blog.csdn.net/mad1989/article/details/38087737" target="_blank" rel="external">Monkey和MonkeyRunner</a></p>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>Java程序性能分析工具</p>
<h3 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h3><p>程序性能分析器<br>Android自带的TraceView堪比java的性能调优工具visualvm线程视图，可以方便的查看线程的执行情况，某个方法执行时间、调用次数、在总体中的占比等，从而定位性能点。</p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/android-traceview/" target="_blank" rel="external">Android性能调优工具TraceView介绍</a></p>
<h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>Eclipse下的Memory Analyzer Tool（MAT）内存泄漏分析工具 </p>
<h3 id="Monitor-Memory"><a href="#Monitor-Memory" class="headerlink" title="Monitor Memory"></a>Monitor Memory</h3><p>AndroidStudio自带的内存检测工具，可以用于查找内存溢出<br>Android Memory Monitor内置于Android Studio中，用于展示应用内存的使用和释放情况。<br>当你的App占用的内存持续增加，而且你同时出发GC，也没有进行释放，那么你的App很有可能发生了内存泄漏问题。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/u012760183/article/details/52068490" target="_blank" rel="external">Android Studio +MAT 分析内存泄漏实战</a><br><a href="http://www.jianshu.com/p/216b03c22bb8" target="_blank" rel="external">使用新版Android Studio检测内存泄露和性能</a></p>
<h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h3><p>内存泄露目前在项目中一般用LeakCanary（square出品）基本就能搞定，配置起来也相当简单</p>
<p><a href="http://droidyue.com/blog/2016/03/28/android-leakcanary/" target="_blank" rel="external">Android内存泄漏检测利器：LeakCanary</a></p>
<h3 id="StrictMode"><a href="#StrictMode" class="headerlink" title="StrictMode"></a>StrictMode</h3><p>Android性能调优利器StrictMode<br><a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/" target="_blank" rel="external">分析Android app的内存使用</a></p>
<h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><p>函数流程调试工具</p>
<h3 id="Method-Trace"><a href="#Method-Trace" class="headerlink" title="Method Trace"></a>Method Trace</h3><p>函数流程调试工具</p>
<h3 id="draw9patch-bat"><a href="#draw9patch-bat" class="headerlink" title="draw9patch.bat"></a>draw9patch.bat</h3><p>做点九图的工具</p>
<h3 id="emulator-exe"><a href="#emulator-exe" class="headerlink" title="emulator.exe"></a>emulator.exe</h3><p>模拟器</p>
<h3 id="mksdcard-exe"><a href="#mksdcard-exe" class="headerlink" title="mksdcard.exe"></a>mksdcard.exe</h3><p>创建sd卡的工具</p>
<h2 id="代码分析扫描工具"><a href="#代码分析扫描工具" class="headerlink" title="代码分析扫描工具"></a>代码分析扫描工具</h2><p>用途：静态代码扫描/程序分析/代码提示/代码检查</p>
<h3 id="Android-Lint工具"><a href="#Android-Lint工具" class="headerlink" title="Android Lint工具"></a>Android Lint工具</h3><p>先说下layoutopt<br>layoutopt是一个可以提供layout及其层级优化提示的命令行，在sdk16以后已经被lint取代，在Windows-&gt;Show View-&gt;Other-&gt;Android-&gt;Lint Warnings查看lint优化提示，lint具体介绍可见Improving Your Code with lint。</p>
<p>Android lint是在ADT 16提供的新工具，它是一个代码扫描工具，能够帮助我们识别代码结构存在的问题</p>
<p>lint检查：通过Android Studio中的 Analyze-&gt;Inspect Code 对工程代码做静态扫描；找出潜在的问题代码并修改，去掉无用的图片</p>
<p>相关文章：<br><a href="http://blog.csdn.net/xyz_lmn/article/details/14222939" target="_blank" rel="external">Android代码优化——使用Android lint工具</a><br><a href="http://www.bubuko.com/infodetail-1055648.html" target="_blank" rel="external">Android Studio使用Lint进行代码检查</a></p>
<p>相关书籍：<br>Android群英传-10.3 Lint工具</p>
<h3 id="Tools-Attributes"><a href="#Tools-Attributes" class="headerlink" title="Tools Attributes"></a>Tools Attributes</h3><p>官方文档：<br><a href="http://tools.android.com/tech-docs/tools-attributes" target="_blank" rel="external">http://tools.android.com/tech-docs/tools-attributes</a></p>
<p>相关文章：<br><a href="http://www.bubuko.com/infodetail-916616.html" target="_blank" rel="external">android中xml tools属性详解（转）</a><br><a href="http://blog.csdn.net/u011277123/article/details/52814521" target="_blank" rel="external">Android Tools Attributes，让布局设计所见即所得</a></p>
<p>看似Android开发人员只有一种方法来检查成品布局——在设备上运行它。但是，你还可以使用内置于开发框架的Tools Attributes，在我们的例子中所使用的框架是Android Studio。</p>
<p>开发人员在设计Android Layout布局时，总会伴随着一些乱七八槽的困扰。比如，为了更加逼真的真实数据预览效果，我们在开发时会将TextView的text属性写上一些假数据，而当运行到模拟器或真机上时这些假数据就成了造成体验上甚至测试BUG的脏数据，又需要一一清除。再比如，我们想在XML的预览界面上就看到ListView的Item内容，而不是只有通过编译运行时才能查看。等等，诸如这些存在于开发Layout内容阶段的困扰，都可以通过Tools Attributes得以解决，不妨了解一下。</p>
<p>Tools Attributes可以使用额外的命名空间来帮助管理Android Studio，这样开发框架就不会传输运行时版本的属性到最终构建。</p>
<h3 id="Support-Annotations"><a href="#Support-Annotations" class="headerlink" title="Support Annotations"></a>Support Annotations</h3><p>官方文档<br><a href="http://tools.android.com/tech-docs/support-annotations" target="_blank" rel="external">http://tools.android.com/tech-docs/support-annotations</a></p>
<p>学习文章<br><a href="http://www.cnblogs.com/punkisnotdead/p/4705258.html" target="_blank" rel="external">Android 注解的一些应用以及原理</a><br><a href="http://www.codeceo.com/article/android-support-annotations-2.html" target="_blank" rel="external">Android Support Annotations 使用详解</a><br><a href="http://www.mincoder.com/article/6375.shtml" target="_blank" rel="external">使用Android Support Annotations优化你的代码</a></p>
<p>如果你还没有听说过Android Support Annotations 函数库，你将错过一个整洁的新软件包，它有助于你捕获程序中的bugs。该函数库包含了许多的Java注解，用于帮助Android Studio检测代码中可能存在的错误，并报告给开发者。注解类型有很多种</p>
<h3 id="Error-prone"><a href="#Error-prone" class="headerlink" title="Error-prone"></a>Error-prone</h3><p><a href="http://droidyue.com/blog/2017/04/09/error-prone-tool-for-java-and-android/" target="_blank" rel="external">Error-prone,Google出品的Java和Android Bug分析利器</a></p>
<h3 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h3><p>代码检查工具能帮我们检查一些隐藏的bug，代码检查工具中sonar是比较好的一个</p>
<p><a href="http://blog.csdn.net/rain_butterfly/article/details/42170601" target="_blank" rel="external">Android 代码检查工具SonarQube</a></p>
<h3 id="DroidJitChecker"><a href="#DroidJitChecker" class="headerlink" title="DroidJitChecker"></a>DroidJitChecker</h3><p>JIT：JIT全称Just-in-time compilation。意思为实时编译，是JVM中一种优化技术，对频繁调用并且符合条件的方法进行优化将字节码翻译成机器代码，提升执行效率。</p>
<p><a href="http://droidyue.com/blog/2016/04/10/jit-friendly-checker-for-android/" target="_blank" rel="external">一个Android代码JIT友好度检测工具</a></p>
<h3 id="UCDetector"><a href="#UCDetector" class="headerlink" title="UCDetector"></a>UCDetector</h3><p>UCDetector是 eclipse 工具 可以审查出程序中  未被使用的、 冗余的、 变量不规范 的代码 </p>
<p><a href="http://blog.csdn.net/aaawqqq/article/details/46684441" target="_blank" rel="external">android优化 清除无效代码 UCDetector</a></p>
<h3 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h3><p>静态分析工具承诺无需开发人员费劲就能找出代码中已有的缺陷。当然，如果有多年的编写经验，就会知道这些承诺并不是一定能兑现。</p>
<h2 id="高效工具-自动化及格式化"><a href="#高效工具-自动化及格式化" class="headerlink" title="高效工具(自动化及格式化)"></a>高效工具(自动化及格式化)</h2><p>相关文章<br><a href="https://github.com/jiang111/awesome-androidstudio-plugins" target="_blank" rel="external">收集Android studio 常用的插件</a><br><a href="https://www.2cto.com/kf/201504/389231.html" target="_blank" rel="external">打造你的开发神器——介绍Android Studio上的几个插件</a></p>
<h3 id="layoutformatter"><a href="#layoutformatter" class="headerlink" title="layoutformatter"></a>layoutformatter</h3><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0424/4176.html" target="_blank" rel="external">XML 布局文件代码的优雅性</a><br><a href="https://github.com/drakeet/LayoutFormatter" target="_blank" rel="external">https://github.com/drakeet/LayoutFormatter</a></p>
<h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p>根据Gson库使用的要求,将JSONObject格式的String 解析成实体<br>写在前头:本插件只适用 android studio和 Intellij IDEA 工具,eclipse 的少年无视我吧!!!<br>这是一个根据JSONObject格式的字符串,自动生成实体类参数.<br><a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="external">https://github.com/zzz40500/GsonFormat</a></p>
<h3 id="android-layout-id-converter"><a href="#android-layout-id-converter" class="headerlink" title="android layout id converter"></a>android layout id converter</h3><p>Android Studio的一个插件<br>简而言之，可以一秒定义控件并且找到<br>相关文章:<br><a href="http://blog.csdn.net/poison_h/article/details/46722649" target="_blank" rel="external">Android Studio插件之Android Layout ID Converter教程</a></p>
<h3 id="AndroidCodeGenerator"><a href="#AndroidCodeGenerator" class="headerlink" title="AndroidCodeGenerator"></a>AndroidCodeGenerator</h3><p>Android studio 插件<br>可以自动生成findViewById方法和ViewHolder</p>
<p>下载地址：<br><a href="https://github.com/fuxiuyuan/AndroidCodeGenerator" target="_blank" rel="external">https://github.com/fuxiuyuan/AndroidCodeGenerator</a></p>
<h3 id="Android-Toolbox-Plugin"><a href="#Android-Toolbox-Plugin" class="headerlink" title="Android Toolbox Plugin"></a>Android Toolbox Plugin</h3><p>生成viewholder</p>
<h3 id="Android-Studio-Prettify"><a href="#Android-Studio-Prettify" class="headerlink" title="Android Studio Prettify"></a>Android Studio Prettify</h3><p>Studio1.5以上的版本鼠标放在<a href="http://R.layout.xxx右键－Generator可以看到View" target="_blank" rel="external">http://R.layout.xxx右键－Generator可以看到View</a> Variables和View Fields，可以帮你初始化资源文件中有id的view，可以再也不用findViewById了（没有的话请安装JetBrains Plugin Repository :: Android Studio Prettify，2.0以上默认没有<br><a href="http://plugins.jetbrains.com/plugin/7405?pr=androidstudio" target="_blank" rel="external">http://plugins.jetbrains.com/plugin/7405?pr=androidstudio</a></p>
<h3 id="Android-Parcelable-code-generator"><a href="#Android-Parcelable-code-generator" class="headerlink" title="Android Parcelable code generator"></a>Android Parcelable code generator</h3><p>生成实现了Parcelable接口的代码的插件.<br><a href="https://www.2cto.com/kf/201603/493780.html" target="_blank" rel="external">Android Studio添加Parcelable序列化小工具（快速提高开发效率）</a></p>
<h3 id="SelectorChapek-for-Android"><a href="#SelectorChapek-for-Android" class="headerlink" title="SelectorChapek for Android"></a>SelectorChapek for Android</h3><p>这是用于生成Selector的插件</p>
<h3 id="Sexy-Editor"><a href="#Sexy-Editor" class="headerlink" title="Sexy Editor"></a>Sexy Editor</h3><p>设置AS背景插件<br><a href="http://www.jianshu.com/p/6a176c87ef29" target="_blank" rel="external">让你的Android Studio性感起来–Sexy Editor</a></p>
<h3 id="Strings-xml-tools"><a href="#Strings-xml-tools" class="headerlink" title="Strings-xml-tools"></a>Strings-xml-tools</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="jimu-Mirror"><a href="#jimu-Mirror" class="headerlink" title="jimu Mirror"></a>jimu Mirror</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="Android-Holo-Colors-Generator"><a href="#Android-Holo-Colors-Generator" class="headerlink" title="Android Holo Colors Generator"></a>Android Holo Colors Generator</h3><p><a href="http://www.codeceo.com/article/8-android-studio-plugins.html" target="_blank" rel="external">http://www.codeceo.com/article/8-android-studio-plugins.html</a></p>
<h3 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h3><h3 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a>Android Drawable Importer</h3><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="Genymotion-虚拟机"><a href="#Genymotion-虚拟机" class="headerlink" title="Genymotion 虚拟机"></a>Genymotion 虚拟机</h3><p>刚开始做开发的时候，每次使用官方的虚拟机，都想吐槽一下，但是发现了Genymotion 之后，这一切都变化了，它的速度几乎可以和真机媲美了，当然如果有真机，当然还是推荐使用真机测试。</p>
<h3 id="ES-Explorer"><a href="#ES-Explorer" class="headerlink" title="ES Explorer"></a>ES Explorer</h3><p>ES Explorer 是一款文件管理器，但实际它又不仅仅是一款文件管理器，在获得Root 之后，它的功能更强大了，它可以浏览受限制的文件目录；而且提供了一系列小工具，比如下载器；还有集成了众多云储存服务。</p>
<h3 id="WiFi-ADB"><a href="#WiFi-ADB" class="headerlink" title="WiFi ADB"></a>WiFi ADB</h3><p>WiFi ADB 是一个通过无线网络来使电脑和手机连接，当我们做测试的时候，只需在手机上打开，只需在命令行输入 adb connect xxx.xxx.xxx.xxx:5555，电脑可以连接手机，就可以通过无线网络来调试开发的应用。</p>
<hr>
<h1 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h1><hr>
<p>大部分的电都消耗在了网络连接、GPS、传感器上了。<br>简单的说也就是主要在以下情况下耗电比较多：<br>1、大数据量的传输。<br>2、不停的在网络间切换。<br>3、解析大量的文本数据。</p>
<p>相关文章：<br><a href="http://kb.cnblogs.com/page/77741/" target="_blank" rel="external">有效控制Android应用程序的耗电量</a></p>
<h2 id="检查电量"><a href="#检查电量" class="headerlink" title="检查电量"></a>检查电量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">在运行你的程序前先检查电量，电量太低，那么就提示用户充电之类的，使用方法：</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123; </div><div class="line">     <span class="comment">// Register for sticky broadcast and send default     </span></div><div class="line">     registerReceiver(mReceiver, mFilter);    </div><div class="line">     mHandler.sendEmptyMessageDelayed(MSG_BATT, <span class="number">1000</span>);    </div><div class="line"> &#125;   </div><div class="line"> IntentFilter mFilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);    </div><div class="line"> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;   </div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">         <span class="comment">// Found sticky broadcast, so trigger update     </span></div><div class="line">         unregisterReceiver(mReceiver);    </div><div class="line">         mHandler.removeMessages(MSG_BATT);    </div><div class="line">         mHandler.obtainMessage(MSG_BATT, intent).sendToTarget();    </div><div class="line">     &#125;   </div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<h2 id="定时启动服务"><a href="#定时启动服务" class="headerlink" title="定时启动服务"></a>定时启动服务</h2><p>很多人开发的程序后台都会一个service不停的去服务器上更新数据，在不更新数据的时候就让它sleep，这种方式是非常耗电的，通常情况下，我们可以使用AlarmManager来定时启动服务。如下所示，第30分钟执行一次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AlarmManager am = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);    </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(context, MyService.class);    </div><div class="line">PendingIntent pendingIntent = PendingIntent.getService(context, <span class="number">0</span>, intent, <span class="number">0</span>);    </div><div class="line"><span class="keyword">long</span> interval = DateUtils.MINUTE_IN_MILLIS * <span class="number">30</span>;    </div><div class="line"><span class="keyword">long</span> firstWake = System.currentTimeMillis() + interval;    </div><div class="line">am.setRepeating(AlarmManager.RTC,firstWake, interval, pendingIntent);</div></pre></td></tr></table></figure></p>
<h2 id="检查网络连接"><a href="#检查网络连接" class="headerlink" title="检查网络连接"></a>检查网络连接</h2><p>在需要网络连接的程序中，首先检查网络连接是否正常，如果没有网络连接，那么就不需要执行相应的程序。<br>检查网络连接的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ConnectivityManager mConnectivity;    </div><div class="line">TelephonyManager mTelephony;    </div><div class="line"></div><div class="line"><span class="comment">// 检查网络连接，如果无网络可用，就不需要进行连网操作等    </span></div><div class="line">NetworkInfo info = mConnectivity.getActiveNetworkInfo();    </div><div class="line"><span class="keyword">if</span> (info == <span class="keyword">null</span> ||   </div><div class="line">        !mConnectivity.getBackgroundDataSetting()) &#123;   </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </div><div class="line">&#125;   </div><div class="line"><span class="comment">// 判断网络连接类型，只有在3G或wifi里进行一些数据更新。    </span></div><div class="line"><span class="keyword">int</span> netType = info.getType();    </div><div class="line"><span class="keyword">int</span> netSubtype = info.getSubtype();    </div><div class="line"><span class="keyword">if</span> (netType == ConnectivityManager.TYPE_WIFI) &#123;   </div><div class="line">    <span class="keyword">return</span> info.isConnected();    </div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (netType == ConnectivityManager.TYPE_MOBILE    </div><div class="line">        &amp;&amp; netSubtype == TelephonyManager.NETWORK_TYPE_UMTS    </div><div class="line">        &amp;&amp; !mTelephony.isNetworkRoaming()) &#123;   </div><div class="line">    <span class="keyword">return</span> info.isConnected();    </div><div class="line">&#125; <span class="keyword">else</span> &#123;   </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用高效的数据格式和解析方法"><a href="#使用高效的数据格式和解析方法" class="headerlink" title="使用高效的数据格式和解析方法"></a>使用高效的数据格式和解析方法</h2><p>目前主流的数据格式，使用树形解析（如DOM）和流的方式解析（SAX）</p>
<p>使用流的方式解析效率要高一些，因为DOM解析是在对整个文档读取完后，再根据节点层次等再组织起来。而流的方式是边读取数据边解析，数据读取完后，解析也就完毕了。</p>
<p>在数据格式方面，JSON和Protobuf效率明显比XML好很多，XML和JSON大家都很熟悉，Protobuf是Google提出的，一种语言无关、平台无关、扩展性好的用于通信协议、数据存储的结构化数据串行化方法。有兴趣的可以到官方去看看更多的信息。</p>
<p>所以可以得出结论就是尽量使用SAX等边读取边解析的方式来解析数据<br>针对移动设备，最好能使用JSON之类的轻量级数据格式为佳。</p>
<h2 id="GZIP压缩"><a href="#GZIP压缩" class="headerlink" title="GZIP压缩"></a>GZIP压缩</h2><p>http使用GZIP压缩方式下载数据，能减少网络流量<br>目前大部门网站都支持GZIP压缩，所以在进行大数据量下载时，尽量使用GZIP方式下载。</p>
<p>使用方法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.zip.GZIPInputStream;    </div><div class="line">HttpGet request = <span class="keyword">new</span> HttpGet(<span class="string">"http://example.com/gzipcontent"</span>);  </div><div class="line">HttpResponse resp = <span class="keyword">new</span> DefaultHttpClient().execute(request);   </div><div class="line">HttpEntity entity = response.getEntity();  </div><div class="line">InputStream compressed = entity.getContent();  </div><div class="line">InputStream rawData = <span class="keyword">new</span> GZIPInputStream(compressed);</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>获取用户的地理位置信息时，在需要获取数据的时候打开GPS，之后及时关闭掉<br>对定位要求不是太高的话尽量不要使用GPS定位，可能使用wifi和移动网络cell定位即可。<br>GPS定位消耗的电量远远高于移动网络定位。</p>
<p>获取屏幕尺寸等信息可以使用缓存技术，不需要进行多次请求。</p>
<p>尽量不要使用浮点运算。</p>
<hr>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><hr>
<p>一个网络请求可以简单分为连接服务器 -&gt; 获取数据两个部分。<br>其中连接服务器前还包括 DNS 解析的过程；获取数据后可能会对数据进行缓存。</p>
<p>以下是网络优化中一些客户端和服务器端需要尽量遵守的准则：<br>a. 图片必须缓存，最好根据机型做图片做图片适配<br>b. 所有http请求必须添加httptimeout<br>c. 开启gzip压缩<br>d. api接口数据以json格式返回，而不是xml或html<br>e. 根据http头信息中的Cache-Control及expires域确定是否缓存请求结果。<br>f. 确定网络请求的connection是否keep-alive<br>g. 减少网络请求次数，服务器端适当做请求合并。<br>h. 减少重定向次数<br>i. api接口服务器端响应时间不超过100ms<br>google正在做将移动端网页速度降至1秒的项目，关注中<a href="https://developers.google.com/speed/docs/insights/mobile" target="_blank" rel="external">https://developers.google.com/speed/docs/insights/mobile</a></p>
<h2 id="连接服务器优化策略"><a href="#连接服务器优化策略" class="headerlink" title="连接服务器优化策略"></a>连接服务器优化策略</h2><h3 id="1-不用域名，用-IP-直连"><a href="#1-不用域名，用-IP-直连" class="headerlink" title="1.不用域名，用 IP 直连"></a>1.不用域名，用 IP 直连</h3><p>省去 DNS 解析过程，DNS 全名 Domain Name System，解析意指根据域名得到其对应的 IP 地址。 如 <a href="http://www.codekk.com" target="_blank" rel="external">http://www.codekk.com</a> 的域名解析结果就是 104.236.147.76。</p>
<p>首次域名解析一般需要几百毫秒，可通过直接向 IP 而非域名请求，节省掉这部分时间，同时可以预防域名劫持等带来的风险。</p>
<p>当然为了安全和扩展考虑，这个 IP 可能是一个动态更新的 IP 列表，并在 IP 不可用情况下通过域名访问。</p>
<h3 id="2-服务器合理部署"><a href="#2-服务器合理部署" class="headerlink" title="2.服务器合理部署"></a>2.服务器合理部署</h3><p>服务器多运营商多地部署，一般至少含三大运营商、南中北三地部署。</p>
<p>配合上面说到的动态 IP 列表，支持优先级，每次根据地域、网络类型等选择最优的服务器 IP 进行连接。</p>
<p>对于服务器端还可以调优服务器的 TCP 拥塞窗口大小、重传超时时间(RTO)、最大传输单元(MTU)等。</p>
<h2 id="获取数据优化策略"><a href="#获取数据优化策略" class="headerlink" title="获取数据优化策略"></a>获取数据优化策略</h2><h3 id="1-连接复用"><a href="#1-连接复用" class="headerlink" title="1.连接复用"></a>1.连接复用</h3><p>节省连接建立时间，如开启 keep-alive。</p>
<p>Http 1.1 默认启动了 keep-alive。对于 Android 来说默认情况下 HttpURLConnection 和 HttpClient 都开启了 keep-alive。只是 2.2 之前 HttpURLConnection 存在影响连接池的 Bug，具体可见：Android HttpURLConnection 及 HttpClient 选择</p>
<h3 id="2-网络请求增加超时时间"><a href="#2-网络请求增加超时时间" class="headerlink" title="2.网络请求增加超时时间"></a>2.网络请求增加超时时间</h3><p>对于http请求设置连接超时时间和响应超时时间</p>
<h3 id="3-请求合并"><a href="#3-请求合并" class="headerlink" title="3.请求合并"></a>3.请求合并</h3><p>即将多个请求合并为一个进行请求，比较常见的就是网页中的 CSS Image Sprites。 如果某个页面内请求过多，也可以考虑做一定的请求合并。</p>
<h3 id="4-减小请求数据大小"><a href="#4-减小请求数据大小" class="headerlink" title="4.减小请求数据大小"></a>4.减小请求数据大小</h3><p>(1) 对于 POST 请求，Body 可以做 Gzip 压缩，如日志。</p>
<p>(2) 对请求头进行压缩<br>这个 Http 1.1 不支持，SPDY 及 Http 2.0 支持。 Http 1.1 可以通过服务端对前一个请求的请求头进行缓存，后面相同请求头用 md5 之类的 id 来表示即可。</p>
<h3 id="5-CDN-缓存静态资源"><a href="#5-CDN-缓存静态资源" class="headerlink" title="5.CDN 缓存静态资源"></a>5.CDN 缓存静态资源</h3><p>缓存常见的图片、JS、CSS 等静态资源。</p>
<h3 id="6-用压缩减小返回数据大小"><a href="#6-用压缩减小返回数据大小" class="headerlink" title="6.用压缩减小返回数据大小"></a>6.用压缩减小返回数据大小</h3><p>(1) 压缩<br>一般 API 数据使用 Gzip 压缩和ZIP压缩</p>
<p>GZIP压缩下载：<br>使用GZIP压缩方式下载数据，能减少网络流量<br>目前大部门网站都支持GZIP压缩，所以在进行大数据量下载时，尽量使用GZIP方式下载<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.zip.GZIPInputStream;</div><div class="line"></div><div class="line">HttpGet request = <span class="keyword">new</span> HttpGet(<span class="string">"http://example.com/gzipcontent"</span>);</div><div class="line">HttpResponse resp = <span class="keyword">new</span> DefaultHttpClient().execute(request);</div><div class="line">HttpEntity entity = response.getEntity();</div><div class="line">InputStream compressed = entity.getContent();</div><div class="line">InputStream rawData = newGZIPInputStream(compressed);</div></pre></td></tr></table></figure></p>
<p>下图为使用GZIP方式获取包含1800个主题的RSS对比情况。<br><img src="/images/it_android_network_gzip1.png" alt="UML图"></p>
<p>相关文章：<br><a href="http://www.cnblogs.com/whoislcj/p/5473806.html" target="_blank" rel="external">Android总结之Gzip/Zip压缩</a></p>
<p>关于压缩算法的术语：</p>
<ul>
<li>压缩比<br>就是通过编码器压缩后的图象数字大小和原图象数字大小的压缩比。这句话表述刚好相反！<br>正确的表述是： 压缩比= （原图象数字大小）/（压缩后的图象数字大小）</li>
</ul>
<p>(2) 精简数据格式<br>传数据用json格式代替XML，解析方便而且省流量<br>WebP 代替其他图片格式</p>
<p>(3) 对于不同的设备不同网络返回不同的内容 如不同分辨率图片大小。</p>
<p>(4) 增量更新<br>需要数据更新时，可考虑增量更新。如常见的服务端进行 bsdiff，客户端进行 bspatch。</p>
<p>(5) 大文件下载<br>支持断点续传，并缓存 Http Resonse 的 ETag 标识，下次请求时带上，从而确定是否数据改变过，未改变则直接返回 304。</p>
<h2 id="网络数据缓存"><a href="#网络数据缓存" class="headerlink" title="网络数据缓存"></a>网络数据缓存</h2><p>利用缓存减少访问网络的次数</p>
<p>http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读。</p>
<h2 id="其他优化手段"><a href="#其他优化手段" class="headerlink" title="其他优化手段"></a>其他优化手段</h2><h3 id="网络获取到展现速度较慢的优化"><a href="#网络获取到展现速度较慢的优化" class="headerlink" title="网络获取到展现速度较慢的优化"></a>网络获取到展现速度较慢的优化</h3><p>定位：在HttpURLConnection.getInputStream()之后的处理<br>解决：使用BufferedReader替代BufferedInputStream获取时间从100ms降低到3ms，具体代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HttpURLConnection con = (HttpURLConnection)url.openConnection();</div><div class="line">InputStream input = con.getInputStream();</div><div class="line"><span class="keyword">while</span> (input.read(buffer, <span class="number">0</span>, <span class="number">1024</span>) != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HttpURLConnection con = (HttpURLConnection)url.openConnection();</div><div class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(con.getInputStream()));</div><div class="line">String s;</div><div class="line"><span class="keyword">while</span> ((s = input.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="预加载和懒加载"><a href="#预加载和懒加载" class="headerlink" title="预加载和懒加载"></a>预加载和懒加载</h3><p>预加载包括预连接、预取数据。<br>懒加载体现于ViewPager默认加载3页，如果为了节省流量，就修改常量值就变成了只加载1页</p>
<h3 id="分优先级、延迟部分请求"><a href="#分优先级、延迟部分请求" class="headerlink" title="分优先级、延迟部分请求"></a>分优先级、延迟部分请求</h3><p>将不重要的请求延迟，这样既可以削峰减少并发、又可以和后面类似的请求做合并。</p>
<h3 id="多连接"><a href="#多连接" class="headerlink" title="多连接"></a>多连接</h3><p>对于较大文件，如大图片、文件下载可考虑多连接。 需要控制请求的最大并发量，毕竟移动端网络受限。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>优化需要通过数据对比才能看出效果，所以监控系统必不可少，通过前后端的数据监控确定调优效果。</p>
<hr>
<h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><hr>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>简单的说，索引就像书本的目录，目录可以快速找到所在页数，数据库中索引可以帮助快速找到数据，而不用全表扫描，合适的索引可以大大提高数据库查询的效率。</p>
<h2 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h2><p>使用事务的两大好处是原子提交和更优性能。</p>
<p>(1) 原子提交<br>原则提交意味着同一事务内的所有修改要么都完成要么都不做，如果某个修改失败，会自动回滚使得所有修改不生效。</p>
<p>(2) 更优性能<br>Sqlite默认会为每个插入、更新操作创建一个事务，并且在每次插入、更新后立即提交。<br>这样如果连续插入100次数据实际是创建事务-&gt;执行语句-&gt;提交这个过程被重复执行了100次。如果我们显示的创建事务-&gt;执行100条语句-&gt;提交会使得这个创建事务和提交这个过程只做一次，通过这种一次性事务可以使得性能大幅提升。<br>尤其当数据库位于sd卡时，时间上能节省两个数量级左右。<br>Sqlte显示使用事务，示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertWithOneTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">    SQLiteDatabase db = sqliteOpenHelper.getWritableDatabase();</div><div class="line">    <span class="comment">// Begins a transaction</span></div><div class="line">    db.beginTransaction();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// your sqls</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            db.insert(yourTableName, <span class="keyword">null</span>, value);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// marks the current transaction as successful</span></div><div class="line">        db.setTransactionSuccessful();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">// process it</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// end a transaction</span></div><div class="line">        db.endTransaction();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertWithOneTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">    SQLiteDatabase db = sqliteOpenHelper.getWritableDatabase();</div><div class="line">    <span class="comment">// Begins a transaction</span></div><div class="line">    db.beginTransaction();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// your sqls</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            db.insert(yourTableName, <span class="keyword">null</span>, value);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// marks the current transaction as successful</span></div><div class="line">        db.setTransactionSuccessful();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        <span class="comment">// process it</span></div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// end a transaction</span></div><div class="line">        db.endTransaction();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中sqliteOpenHelper.getWritableDatabase()表示得到写表权限。</p>
<h2 id="查询时返回更少的结果集及更少的字段"><a href="#查询时返回更少的结果集及更少的字段" class="headerlink" title="查询时返回更少的结果集及更少的字段"></a>查询时返回更少的结果集及更少的字段</h2><p>查询时只取需要的字段和结果集，更多的结果集会消耗更多的时间及内存，更多的字段会导致更多的内存消耗。</p>
<h2 id="少用cursor-getColumnIndex"><a href="#少用cursor-getColumnIndex" class="headerlink" title="少用cursor.getColumnIndex"></a>少用cursor.getColumnIndex</h2><p>根据性能调优过程中的观察cursor.getColumnIndex的时间消耗跟cursor.getInt相差无几。<br>可以在建表的时候用static变量记住某列的index，直接调用相应index而不是每次查询。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_RESPONSE_TABLE_ID = android.provider.BaseColumns._ID;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_RESPONSE_TABLE_RESPONSE = <span class="string">"response"</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">	……</div><div class="line">	cursor.getString(cursor.getColumnIndex(HTTP_RESPONSE_TABLE_RESPONSE));</div><div class="line">	……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优化为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_RESPONSE_TABLE_ID = android.provider.BaseColumns._ID;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTP_RESPONSE_TABLE_RESPONSE = <span class="string">"response"</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_RESPONSE_TABLE_ID_INDEX = <span class="number">0</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_RESPONSE_TABLE_URL_INDEX = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">	……</div><div class="line">	cursor.getString(HTTP_RESPONSE_TABLE_RESPONSE_INDEX);</div><div class="line">	……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="异步线程"><a href="#异步线程" class="headerlink" title="异步线程"></a>异步线程</h2><p>Sqlite是常用于嵌入式开发中的关系型数据库，完全开源。<br>与Web常用的数据库Mysql、Oracle db、sql server不同，Sqlite是一个内嵌式的数据库，数据库服务器就在你的程序中，无需网络配置和管理，数据库服务器端和客户端运行在同一进程内，减少了网络访问的消耗，简化了数据库管理。不过Sqlite在并发、数据库大小、网络方面存在局限性，并且为表级锁，所以也没必要多线程操作。</p>
<p>Android中数据不多时表查询可能耗时不多，不会导致anr，不过大于100ms时同样会让用户感觉到延时和卡顿，可以放在线程中运行，但sqlite在并发方面存在局限，多线程控制较麻烦，这时候可使用单线程池，在任务中执行db操作，通过handler返回结果和ui线程交互，既不会影响UI线程，同时也能防止并发带来的异常。<br>解决方法：可使用Android提供的 AsyncQueryHandler 或 类似如下代码完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</div><div class="line">singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// db operetions, u can use handler to send message after</span></div><div class="line">		db.insert(yourTableName, <span class="keyword">null</span>, value);</div><div class="line">		handler.sendEmptyMessage(xx);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="避免数据库频繁的打开和关闭"><a href="#避免数据库频繁的打开和关闭" class="headerlink" title="避免数据库频繁的打开和关闭"></a>避免数据库频繁的打开和关闭</h2><p>进去Activity如果有频繁的查询数据库的操作，就在onCreate方法里打开数据库，onDestroy里关闭数据库就可，这样就不用每次点击条目打开一次数据库，避免频繁的打开和关闭</p>
<h2 id="看情景可用ContentProvider代替"><a href="#看情景可用ContentProvider代替" class="headerlink" title="看情景可用ContentProvider代替"></a>看情景可用ContentProvider代替</h2><p>情况符合时处理数据库的时候可采用ContentProvider的方式<br>有2个优点：<br>采用URI的方式访问，更加符合我们的使用习惯<br>随时可以提供给其它应用访问数据库；</p>
<h2 id="语句的拼接使用StringBuilder代替String"><a href="#语句的拼接使用StringBuilder代替String" class="headerlink" title="语句的拼接使用StringBuilder代替String"></a>语句的拼接使用StringBuilder代替String</h2><p>这个就不多说了，简单的string相加会导致创建多个临时对象消耗性能。StringBuilder的空间预分配性能好得多。如果你对字符串的长度有大致了解，如100字符左右，可以直接new StringBuilder(128)指定初始大小，减少空间不够时的再次分配。</p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/database-performance/" target="_blank" rel="external">Trinea——性能优化之数据库优化</a></p>
<hr>
<h1 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h1><hr>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>硬件加速(Hardware Acceleration)<br>有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，<br>在API16之后确实有很多方法不支持硬件加速，<br>通常我们关闭硬件加速都是在清单文件中通过，<br>其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。</p>
<p>相关文章：<br><a href="http://www.cnblogs.com/frydsh/archive/2012/10/23/2733581.html" target="_blank" rel="external">Android的硬件加速</a> </p>
<hr>
<h1 id="JNI优化"><a href="#JNI优化" class="headerlink" title="JNI优化"></a>JNI优化</h1><hr>
<p>Android应用程序大都通过Java开发，需要Dalvik的JIT编译器将Java字节码转换成本地代码运行，而本地代码可以直接由设备管理器直接执行，节省了中间步骤，所以执行速度更快。不过需要注意从Java空间切换到本地空间需要开销，同时JIT编译器也能生成优化的本地代码，所以糟糕的本地代码不一定性能更优。</p>
<p>这个优化点会在后面待补充。</p>
<hr>
<h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1><hr>
<h2 id="各种细节缩减包大小"><a href="#各种细节缩减包大小" class="headerlink" title="各种细节缩减包大小"></a>各种细节缩减包大小</h2><p>图片尽量分拆成多个可重用的图片</p>
<p>服务端可以实现的，就不要放在客户端</p>
<p>引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大</p>
<h2 id="ProGuard优化"><a href="#ProGuard优化" class="headerlink" title="ProGuard优化"></a>ProGuard优化</h2><h3 id="使用ProGuard简化代码"><a href="#使用ProGuard简化代码" class="headerlink" title="使用ProGuard简化代码"></a>使用ProGuard简化代码</h3><p>ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。ProGuard会对我们的代码进行检索，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。</p>
<h2 id="Dex优化"><a href="#Dex优化" class="headerlink" title="Dex优化"></a>Dex优化</h2><p>dex是Android平台上(Dalvik虚拟机)的可执行文件, 相当于Windows平台中的exe文件, 每个Apk安装包中都有dex文件, 里面包含了该app的所有源码, 通过反编译工具可以获取到相应的java源码。</p>
<p>所以dex是一个很重要的东西，当然也可以优化。</p>
<p>查看相关文章：<br><a href="http://www.trinea.cn/android/facebook%E5%BC%80%E6%BA%90%E7%9A%84android%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7redex-%E5%87%8F%E5%B0%8F%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F-%E5%90%8C%E6%97%B6%E6%8F%90%E9%AB%98%E8%BF%90/" target="_blank" rel="external">Facebook App 优化工具 ReDex 优化的 6 点及未优化的一大方面</a><br><!-- 为什么需要学习dex文件格式? 最主要的一个原因: 由于通过反编译dex文件可以直接看到java源码, 越来越多的app(包括恶意病毒app)都使用了加固技术以防止app被轻易反编译, 当需要对一个加固的恶意病毒app进行分析或对一个app进行破解时, 就需要了解dex文件格式, 将加固的dex文件还原后(脱壳)再进行反编译获取java源码, 所以要做Android安全方面的深入, dex文件格式是基础中的基础。 --></p>
<hr>
<h1 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h1><hr>
<h2 id="逻辑优化"><a href="#逻辑优化" class="headerlink" title="逻辑优化"></a>逻辑优化</h2><p>这个不同于算法，主要是理清程序逻辑，减少不必要的操作。</p>
<h2 id="需求优化"><a href="#需求优化" class="headerlink" title="需求优化"></a>需求优化</h2><p>这个就不说了，对于sb的需求可能带来的性能问题，只能说做为一个合格的程序员不能只是执行者，要学会说NO。不过不能拿这种借口敷衍产品经理哦。</p>
<hr>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><hr>
<p>书籍：<br>Andorid开发艺术探索——第15章Android性能优化<br>Android群英传——第10章Android性能优化</p>
<p>文章：<br><a href="http://www.trinea.cn/android/performance/" target="_blank" rel="external">Trinea——性能优化系列总篇</a><br><a href="http://www.trinea.cn/android/android-performance-demo/" target="_blank" rel="external">Trinea——性能优化实例</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持收集实用资料和原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/upload/wechatpay20170716225849.jpg" alt="恒星 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/upload/alipay_20170716225901.jpg" alt="恒星 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/27/manager/1.Rule/" rel="next" title="高效学习工作管理的实用法则">
                <i class="fa fa-chevron-left"></i> 高效学习工作管理的实用法则
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/02/it/1.Android/OpenProject/" rel="prev" title="Android —— 开源框架：工具库篇总结">
                Android —— 开源框架：工具库篇总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="恒星" />
          <p class="site-author-name" itemprop="name">恒星</p>
           
              <p class="site-description motion-element" itemprop="description">披星戴月,日月为鉴! 蛰伏蛰伏,厚积方能薄发!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">94</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hengxing0080" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:skystar0079@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://raw.githubusercontent.com/hengxing0080/hengxing0080.github.io/master/images/WeChat.jpg" target="_blank" title="WeChat">
                  
                    <i class="fa fa-fw fa-wechat"></i>
                  
                  WeChat
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="tencent://message/?uin=348269714&Site=&Menu=yes" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://heneryyang.github.io/" title="老杨博客" target="_blank">老杨博客</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#布局优化"><span class="nav-number">1.</span> <span class="nav-text">布局优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复用Android系统资源"><span class="nav-number">1.1.</span> <span class="nav-text">复用Android系统资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用系统定义的id"><span class="nav-number">1.1.1.</span> <span class="nav-text">利用系统定义的id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用系统的图片资源"><span class="nav-number">1.1.2.</span> <span class="nav-text">利用系统的图片资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用系统的字符串资源"><span class="nav-number">1.1.3.</span> <span class="nav-text">利用系统的字符串资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用系统的Style"><span class="nav-number">1.1.4.</span> <span class="nav-text">利用系统的Style</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用系统的颜色定义"><span class="nav-number">1.1.5.</span> <span class="nav-text">利用系统的颜色定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尽量为所有分辨率创建资源"><span class="nav-number">1.1.6.</span> <span class="nav-text">尽量为所有分辨率创建资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#巧用抽象布局标签-include-viewstub-merge"><span class="nav-number">1.2.</span> <span class="nav-text">巧用抽象布局标签(include, viewstub, merge)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OverDraw（过度绘制）-amp-渲染绘制的性能优化"><span class="nav-number">1.3.</span> <span class="nav-text">OverDraw（过度绘制）& 渲染绘制的性能优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#去除不必要的层级嵌套和View节点"><span class="nav-number">1.4.</span> <span class="nav-text">去除不必要的层级嵌套和View节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#减少不必要的infalte"><span class="nav-number">1.5.</span> <span class="nav-text">减少不必要的infalte</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View控件优化"><span class="nav-number">1.6.</span> <span class="nav-text">View控件优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用SurfaceView或TextureView代替普通View"><span class="nav-number">1.6.1.</span> <span class="nav-text">用SurfaceView或TextureView代替普通View</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewPager优化"><span class="nav-number">1.6.2.</span> <span class="nav-text">ViewPager优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity返回ViewPager-Activity较慢"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">Activity返回ViewPager Activity较慢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ListView优化"><span class="nav-number">1.6.3.</span> <span class="nav-text">ListView优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复用convertView"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">复用convertView</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listview判断不滑动才加载数据"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">Listview判断不滑动才加载数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步加载图片和图片缓存和Lru回收"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">异步加载图片和图片缓存和Lru回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BaseAdapter避免内存溢出"><span class="nav-number">1.6.3.4.</span> <span class="nav-text">BaseAdapter避免内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adapter封装"><span class="nav-number">1.6.3.5.</span> <span class="nav-text">Adapter封装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GridView优化"><span class="nav-number">1.6.4.</span> <span class="nav-text">GridView优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Gridview的滥用"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">Gridview的滥用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Webview优化"><span class="nav-number">1.6.5.</span> <span class="nav-text">Webview优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TextView优化"><span class="nav-number">1.6.6.</span> <span class="nav-text">TextView优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fragment"><span class="nav-number">1.6.7.</span> <span class="nav-text">Fragment</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码优化"><span class="nav-number">2.</span> <span class="nav-text">代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#避免创建不必要的对象"><span class="nav-number">2.1.</span> <span class="nav-text">避免创建不必要的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用单例"><span class="nav-number">2.2.</span> <span class="nav-text">使用单例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意字符串拼接"><span class="nav-number">2.2.1.</span> <span class="nav-text">注意字符串拼接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer或StringBuilder替代String"><span class="nav-number">2.2.2.</span> <span class="nav-text">StringBuffer或StringBuilder替代String</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面传递对象时Parcelable代替Serializable"><span class="nav-number">2.3.</span> <span class="nav-text">页面传递对象时Parcelable代替Serializable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象不用了把对象数据成员设为null或者从集合中移除该对象。"><span class="nav-number">2.4.</span> <span class="nav-text">对象不用了把对象数据成员设为null或者从集合中移除该对象。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化for循环-使用增强for循环"><span class="nav-number">2.5.</span> <span class="nav-text">优化for循环(使用增强for循环)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#巧用静态方法"><span class="nav-number">2.6.</span> <span class="nav-text">巧用静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对常量使用static-final修饰符"><span class="nav-number">2.7.</span> <span class="nav-text">对常量使用static final修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型的选型"><span class="nav-number">2.8.</span> <span class="nav-text">基本数据类型的选型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多使用系统封装好的API"><span class="nav-number">2.9.</span> <span class="nav-text">多使用系统封装好的API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免在内部调用Getters-Setters方法"><span class="nav-number">2.10.</span> <span class="nav-text">避免在内部调用Getters/Setters方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免进行隐式装箱"><span class="nav-number">2.11.</span> <span class="nav-text">避免进行隐式装箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用好LaunchMode"><span class="nav-number">2.12.</span> <span class="nav-text">用好LaunchMode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity处理onConfigurationChanged"><span class="nav-number">2.13.</span> <span class="nav-text">Activity处理onConfigurationChanged</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提前检查，减少不必要的异常"><span class="nav-number">2.14.</span> <span class="nav-text">提前检查，减少不必要的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选用对象池"><span class="nav-number">2.15.</span> <span class="nav-text">选用对象池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟执行"><span class="nav-number">2.16.</span> <span class="nav-text">延迟执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提前操作"><span class="nav-number">2.17.</span> <span class="nav-text">提前操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简化代码规范"><span class="nav-number">2.18.</span> <span class="nav-text">简化代码规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重构App"><span class="nav-number">2.19.</span> <span class="nav-text">重构App</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存优化"><span class="nav-number">3.</span> <span class="nav-text">内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露-amp-内存溢出"><span class="nav-number">3.1.</span> <span class="nav-text">内存泄露&内存溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露-a-memory-leak"><span class="nav-number">3.1.1.</span> <span class="nav-text">内存泄露(a memory leak)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存溢出-OOM-Out-of-Memory"><span class="nav-number">3.1.2.</span> <span class="nav-text">内存溢出(OOM:Out of Memory)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露：资源对象引用没释放"><span class="nav-number">3.2.</span> <span class="nav-text">内存泄露：资源对象引用没释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler内存泄漏"><span class="nav-number">3.2.1.</span> <span class="nav-text">Handler内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context内存泄漏"><span class="nav-number">3.2.2.</span> <span class="nav-text">Context内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Drawable引起的内存泄露"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">Drawable引起的内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单例引起的内存泄露"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">单例引起的内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getSystemService内存泄漏"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">getSystemService内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程引起的内存泄漏"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">线程引起的内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask内存泄漏"><span class="nav-number">3.2.3.</span> <span class="nav-text">AsyncTask内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listener内存泄露"><span class="nav-number">3.2.4.</span> <span class="nav-text">Listener内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer内存泄漏"><span class="nav-number">3.2.5.</span> <span class="nav-text">Timer内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性动画导致内存泄露"><span class="nav-number">3.2.6.</span> <span class="nav-text">属性动画导致内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NotificationManager内存泄漏"><span class="nav-number">3.2.7.</span> <span class="nav-text">NotificationManager内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-Message内存泄露"><span class="nav-number">3.2.8.</span> <span class="nav-text">new Message内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于OnSharedPreferenceChangeListener的设计"><span class="nav-number">3.2.9.</span> <span class="nav-text">关于OnSharedPreferenceChangeListener的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态变量（static关键字）引起内存泄露"><span class="nav-number">3.2.10.</span> <span class="nav-text">静态变量（static关键字）引起内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非static的内部类"><span class="nav-number">3.2.11.</span> <span class="nav-text">非static的内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用WeakReference代替强引用"><span class="nav-number">3.2.12.</span> <span class="nav-text">使用WeakReference代替强引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露：资源对象没有关闭"><span class="nav-number">3.3.</span> <span class="nav-text">内存泄露：资源对象没有关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库的Cursor-未及时关闭"><span class="nav-number">3.3.1.</span> <span class="nav-text">数据库的Cursor 未及时关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络资源-连接Socket-、IO流资源没有及时关闭（InputStream-OutputStream），File"><span class="nav-number">3.3.2.</span> <span class="nav-text">网络资源(连接Socket)、IO流资源没有及时关闭（InputStream/OutputStream），File</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏：资源对象没有回收"><span class="nav-number">3.4.</span> <span class="nav-text">内存泄漏：资源对象没有回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放内存：当界面不可见"><span class="nav-number">3.5.</span> <span class="nav-text">释放内存：当界面不可见</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#onStop"><span class="nav-number">3.5.1.</span> <span class="nav-text">onStop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#onTrimMemory"><span class="nav-number">3.5.2.</span> <span class="nav-text">onTrimMemory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放内存：当内存紧张时"><span class="nav-number">3.6.</span> <span class="nav-text">释放内存：当内存紧张时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#释放内存：知晓内存的开支情况"><span class="nav-number">3.7.</span> <span class="nav-text">释放内存：知晓内存的开支情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存优化"><span class="nav-number">3.8.</span> <span class="nav-text">缓存优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4大组件优化"><span class="nav-number">3.9.</span> <span class="nav-text">4大组件优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity优化"><span class="nav-number">3.9.1.</span> <span class="nav-text">Activity优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Service优化"><span class="nav-number">3.9.2.</span> <span class="nav-text">Service优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#节制使用Service"><span class="nav-number">3.9.2.1.</span> <span class="nav-text">节制使用Service</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#推荐使用IntentService"><span class="nav-number">3.9.2.2.</span> <span class="nav-text">推荐使用IntentService</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BroadcastReceiver优化"><span class="nav-number">3.9.3.</span> <span class="nav-text">BroadcastReceiver优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#广播接受者的内存泄漏"><span class="nav-number">3.9.3.1.</span> <span class="nav-text">广播接受者的内存泄漏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LocalBroadcastManager"><span class="nav-number">3.10.</span> <span class="nav-text">LocalBroadcastManager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ContentProvider优化"><span class="nav-number">3.10.1.</span> <span class="nav-text">ContentProvider优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步任务优化"><span class="nav-number">3.11.</span> <span class="nav-text">异步任务优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bitmap图片优化"><span class="nav-number">3.12.</span> <span class="nav-text">Bitmap图片优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合容器优化-amp-数据结构和算法优化"><span class="nav-number">3.13.</span> <span class="nav-text">集合容器优化 & 数据结构和算法优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap代替arrayList"><span class="nav-number">3.13.1.</span> <span class="nav-text">HashMap代替arrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新型集合替代Hash系列集合"><span class="nav-number">3.13.2.</span> <span class="nav-text">新型集合替代Hash系列集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谨慎选用容器和集合容器扩容优化"><span class="nav-number">3.13.3.</span> <span class="nav-text">谨慎选用容器和集合容器扩容优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合的循环遍历方式性能分析"><span class="nav-number">3.13.4.</span> <span class="nav-text">集合的循环遍历方式性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合容器对象没有清理造成的内存泄露"><span class="nav-number">3.13.5.</span> <span class="nav-text">集合容器对象没有清理造成的内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构选择"><span class="nav-number">3.13.6.</span> <span class="nav-text">数据结构选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法优化"><span class="nav-number">3.13.7.</span> <span class="nav-text">算法优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程优化和多进程优化"><span class="nav-number">3.14.</span> <span class="nav-text">多线程优化和多进程优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他优化"><span class="nav-number">3.15.</span> <span class="nav-text">其他优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#谨慎使用抽象编程"><span class="nav-number">3.15.1.</span> <span class="nav-text">谨慎使用抽象编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不建议使用枚举用注解"><span class="nav-number">3.15.2.</span> <span class="nav-text">不建议使用枚举用注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尽量避免使用依赖注入框架"><span class="nav-number">3.15.3.</span> <span class="nav-text">尽量避免使用依赖注入框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断app是否已安装的状态的优化"><span class="nav-number">3.15.4.</span> <span class="nav-text">判断app是否已安装的状态的优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#工具优化"><span class="nav-number">4.</span> <span class="nav-text">工具优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#性能优化分析工具"><span class="nav-number">4.1.</span> <span class="nav-text">性能优化分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单有用的发现性能问题的方法"><span class="nav-number">4.1.1.</span> <span class="nav-text">简单有用的发现性能问题的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手机-设置-开发者选项"><span class="nav-number">4.1.2.</span> <span class="nav-text">手机/设置/开发者选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hierarchy-Viewer"><span class="nav-number">4.1.3.</span> <span class="nav-text">Hierarchy Viewer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewServer"><span class="nav-number">4.1.4.</span> <span class="nav-text">ViewServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无线uiviewer"><span class="nav-number">4.1.5.</span> <span class="nav-text">无线uiviewer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发助手"><span class="nav-number">4.1.6.</span> <span class="nav-text">开发助手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ddms-bat"><span class="nav-number">4.1.7.</span> <span class="nav-text">ddms.bat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dump-View-Hierarchy-for-UI-automator"><span class="nav-number">4.1.7.1.</span> <span class="nav-text">dump View Hierarchy for UI automator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monkey-amp-MonkeyRunner"><span class="nav-number">4.1.8.</span> <span class="nav-text">Monkey & MonkeyRunner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM"><span class="nav-number">4.1.9.</span> <span class="nav-text">VisualVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TraceView"><span class="nav-number">4.1.10.</span> <span class="nav-text">TraceView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAT"><span class="nav-number">4.1.11.</span> <span class="nav-text">MAT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monitor-Memory"><span class="nav-number">4.1.12.</span> <span class="nav-text">Monitor Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LeakCanary"><span class="nav-number">4.1.13.</span> <span class="nav-text">LeakCanary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StrictMode"><span class="nav-number">4.1.14.</span> <span class="nav-text">StrictMode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Systrace"><span class="nav-number">4.1.15.</span> <span class="nav-text">Systrace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method-Trace"><span class="nav-number">4.1.16.</span> <span class="nav-text">Method Trace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#draw9patch-bat"><span class="nav-number">4.1.17.</span> <span class="nav-text">draw9patch.bat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emulator-exe"><span class="nav-number">4.1.18.</span> <span class="nav-text">emulator.exe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mksdcard-exe"><span class="nav-number">4.1.19.</span> <span class="nav-text">mksdcard.exe</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码分析扫描工具"><span class="nav-number">4.2.</span> <span class="nav-text">代码分析扫描工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Lint工具"><span class="nav-number">4.2.1.</span> <span class="nav-text">Android Lint工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tools-Attributes"><span class="nav-number">4.2.2.</span> <span class="nav-text">Tools Attributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Support-Annotations"><span class="nav-number">4.2.3.</span> <span class="nav-text">Support Annotations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Error-prone"><span class="nav-number">4.2.4.</span> <span class="nav-text">Error-prone</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SonarQube"><span class="nav-number">4.2.5.</span> <span class="nav-text">SonarQube</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DroidJitChecker"><span class="nav-number">4.2.6.</span> <span class="nav-text">DroidJitChecker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UCDetector"><span class="nav-number">4.2.7.</span> <span class="nav-text">UCDetector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FindBugs"><span class="nav-number">4.2.8.</span> <span class="nav-text">FindBugs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效工具-自动化及格式化"><span class="nav-number">4.3.</span> <span class="nav-text">高效工具(自动化及格式化)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#layoutformatter"><span class="nav-number">4.3.1.</span> <span class="nav-text">layoutformatter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GsonFormat"><span class="nav-number">4.3.2.</span> <span class="nav-text">GsonFormat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android-layout-id-converter"><span class="nav-number">4.3.3.</span> <span class="nav-text">android layout id converter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AndroidCodeGenerator"><span class="nav-number">4.3.4.</span> <span class="nav-text">AndroidCodeGenerator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Toolbox-Plugin"><span class="nav-number">4.3.5.</span> <span class="nav-text">Android Toolbox Plugin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Studio-Prettify"><span class="nav-number">4.3.6.</span> <span class="nav-text">Android Studio Prettify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Parcelable-code-generator"><span class="nav-number">4.3.7.</span> <span class="nav-text">Android Parcelable code generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SelectorChapek-for-Android"><span class="nav-number">4.3.8.</span> <span class="nav-text">SelectorChapek for Android</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sexy-Editor"><span class="nav-number">4.3.9.</span> <span class="nav-text">Sexy Editor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Strings-xml-tools"><span class="nav-number">4.3.10.</span> <span class="nav-text">Strings-xml-tools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jimu-Mirror"><span class="nav-number">4.3.11.</span> <span class="nav-text">jimu Mirror</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Holo-Colors-Generator"><span class="nav-number">4.3.12.</span> <span class="nav-text">Android Holo Colors Generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-ButterKnife-Zelezny"><span class="nav-number">4.3.13.</span> <span class="nav-text">Android ButterKnife Zelezny</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Drawable-Importer"><span class="nav-number">4.3.14.</span> <span class="nav-text">Android Drawable Importer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他工具"><span class="nav-number">4.4.</span> <span class="nav-text">其他工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Genymotion-虚拟机"><span class="nav-number">4.4.1.</span> <span class="nav-text">Genymotion 虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES-Explorer"><span class="nav-number">4.4.2.</span> <span class="nav-text">ES Explorer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WiFi-ADB"><span class="nav-number">4.4.3.</span> <span class="nav-text">WiFi ADB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#耗电优化"><span class="nav-number">5.</span> <span class="nav-text">耗电优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#检查电量"><span class="nav-number">5.1.</span> <span class="nav-text">检查电量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时启动服务"><span class="nav-number">5.2.</span> <span class="nav-text">定时启动服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检查网络连接"><span class="nav-number">5.3.</span> <span class="nav-text">检查网络连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用高效的数据格式和解析方法"><span class="nav-number">5.4.</span> <span class="nav-text">使用高效的数据格式和解析方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GZIP压缩"><span class="nav-number">5.5.</span> <span class="nav-text">GZIP压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">5.6.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络优化"><span class="nav-number">6.</span> <span class="nav-text">网络优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#连接服务器优化策略"><span class="nav-number">6.1.</span> <span class="nav-text">连接服务器优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-不用域名，用-IP-直连"><span class="nav-number">6.1.1.</span> <span class="nav-text">1.不用域名，用 IP 直连</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-服务器合理部署"><span class="nav-number">6.1.2.</span> <span class="nav-text">2.服务器合理部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取数据优化策略"><span class="nav-number">6.2.</span> <span class="nav-text">获取数据优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-连接复用"><span class="nav-number">6.2.1.</span> <span class="nav-text">1.连接复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-网络请求增加超时时间"><span class="nav-number">6.2.2.</span> <span class="nav-text">2.网络请求增加超时时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-请求合并"><span class="nav-number">6.2.3.</span> <span class="nav-text">3.请求合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-减小请求数据大小"><span class="nav-number">6.2.4.</span> <span class="nav-text">4.减小请求数据大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-CDN-缓存静态资源"><span class="nav-number">6.2.5.</span> <span class="nav-text">5.CDN 缓存静态资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-用压缩减小返回数据大小"><span class="nav-number">6.2.6.</span> <span class="nav-text">6.用压缩减小返回数据大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络数据缓存"><span class="nav-number">6.3.</span> <span class="nav-text">网络数据缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他优化手段"><span class="nav-number">6.4.</span> <span class="nav-text">其他优化手段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络获取到展现速度较慢的优化"><span class="nav-number">6.4.1.</span> <span class="nav-text">网络获取到展现速度较慢的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预加载和懒加载"><span class="nav-number">6.4.2.</span> <span class="nav-text">预加载和懒加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分优先级、延迟部分请求"><span class="nav-number">6.4.3.</span> <span class="nav-text">分优先级、延迟部分请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多连接"><span class="nav-number">6.4.4.</span> <span class="nav-text">多连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监控"><span class="nav-number">6.4.5.</span> <span class="nav-text">监控</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库优化"><span class="nav-number">7.</span> <span class="nav-text">数据库优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#索引优化"><span class="nav-number">7.1.</span> <span class="nav-text">索引优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用事务"><span class="nav-number">7.2.</span> <span class="nav-text">使用事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询时返回更少的结果集及更少的字段"><span class="nav-number">7.3.</span> <span class="nav-text">查询时返回更少的结果集及更少的字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#少用cursor-getColumnIndex"><span class="nav-number">7.4.</span> <span class="nav-text">少用cursor.getColumnIndex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步线程"><span class="nav-number">7.5.</span> <span class="nav-text">异步线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免数据库频繁的打开和关闭"><span class="nav-number">7.6.</span> <span class="nav-text">避免数据库频繁的打开和关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#看情景可用ContentProvider代替"><span class="nav-number">7.7.</span> <span class="nav-text">看情景可用ContentProvider代替</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#语句的拼接使用StringBuilder代替String"><span class="nav-number">7.8.</span> <span class="nav-text">语句的拼接使用StringBuilder代替String</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动画优化"><span class="nav-number">8.</span> <span class="nav-text">动画优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件加速"><span class="nav-number">8.1.</span> <span class="nav-text">硬件加速</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JNI优化"><span class="nav-number">9.</span> <span class="nav-text">JNI优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#打包优化"><span class="nav-number">10.</span> <span class="nav-text">打包优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#各种细节缩减包大小"><span class="nav-number">10.1.</span> <span class="nav-text">各种细节缩减包大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProGuard优化"><span class="nav-number">10.2.</span> <span class="nav-text">ProGuard优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用ProGuard简化代码"><span class="nav-number">10.2.1.</span> <span class="nav-text">使用ProGuard简化代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dex优化"><span class="nav-number">10.3.</span> <span class="nav-text">Dex优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#业务优化"><span class="nav-number">11.</span> <span class="nav-text">业务优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑优化"><span class="nav-number">11.1.</span> <span class="nav-text">逻辑优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求优化"><span class="nav-number">11.2.</span> <span class="nav-text">需求优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#相关资料"><span class="nav-number">12.</span> <span class="nav-text">相关资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恒星</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
