<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/atom.xml" title="恒星的轨迹空间" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Bitmap图片的总结">
<meta property="og:url" content="https://hengxing0080.github.io/2017/09/06/it/1.Java/Bitmap/index.html">
<meta property="og:site_name" content="恒星的轨迹空间">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_java_thread.jpg">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_java_thread1.png">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_java_thread2.jpg">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_java_thread3.jpg">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_java_thread4.jpg">
<meta property="og:updated_time" content="2017-10-10T15:52:31.235Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bitmap图片的总结">
<meta name="twitter:image" content="https://hengxing0080.github.io/images/it_java_thread.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":120,"offset_float":0,"b2t":true,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hengxing0080.github.io/2017/09/06/it/1.Java/Bitmap/"/>





  <title>Bitmap图片的总结 | 恒星的轨迹空间</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  









<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500489903");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>







  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恒星的轨迹空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">时间在流逝...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://hengxing0080.github.io/2017/09/06/it/1.Java/Bitmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="恒星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恒星的轨迹空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Bitmap图片的总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-06T15:54:12+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-Java/" itemprop="url" rel="index">
                    <span itemprop="name">IT - Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/images/it_java_thread.jpg" alt="UML图"><br><a id="more"></a><br>注意：此图总结不全用于临时展示，后续待上传最新思维导图</p>
<hr>
<h1 id="进程和线程的理解"><a href="#进程和线程的理解" class="headerlink" title="进程和线程的理解"></a>进程和线程的理解</h1><hr>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是计算机系统中，一个正在进行执行中的程序, 程序运行的实体，也是线程的容器。<br>每一个进程执行都有一个执行顺序,该顺序是一个从头执行到尾的控制单元(控制单元也叫执行情景或执行路径).</p>
<p>进程的作用：<br>如qq或迅雷，它们启动时都在内存中分配一块空间和地址，进程就是来定义和标识空间，用来封装里面的控制单元！</p>
<p>java有2个进程：<br>编译进程：javac(编译器)也是一个进程, javac.exe(编译完就结束了，进程就消失了)<br>运行进程：jvm(虚拟机),启动时会有一个进程java.exe </p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>通俗的理解线程就是代码一行行向下执行的线路和流程。<br>线程就是进程中的一个独立的控制单元.<br>线程是进程中实际执行单位，一个线程是程序执行流的最小单元。<br>线程在控制着进程的执行<br>线程是进程中的内容（线程运行在进程里面）<br>每一个应用程序(进程)至少有一个线程<br>Java虚拟机允许应用程序(进程)并发地运行多个执行线程。 </p>
<p>多线程：<br>就是分出另外一个执行线程，同时又多条线路并行运行。<br>一个进程里有多个线程在执行, 就是有多条执行路径就叫多线程 （例如：下载就是多线程）<br>多线程和CPU有关，单核CPU不能开启多线程，只能单线程</p>
<p>主线程：<br>该进程中至少有一个线程负责java程序的执行<br>而且这个线程运行的代码存在于main方法中<br>该线程称为主线程<br>主线程要运行的代码存在main方法，是虚拟机定义的（它的控制单元只认main方法），这就是虚拟机调用main方法的原因，因为是主线程在调用！</p>
<p>垃圾回收机制的线程：<br>其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。</p>
<p>线程类API：<br>java.lang → Thread<br>Java中万物皆对象,线程也被描述成了一个对象就是Thread对象.<br>Java对多线程的支持也是特别完善的,特别是JDK1.5之后.</p>
<p>如未通俗的理解进程和线程，请看下面的文章↓<br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">进程与线程的一个简单解释</a></p>
<hr>
<h1 id="创建线程的3种方式"><a href="#创建线程的3种方式" class="headerlink" title="创建线程的3种方式"></a>创建线程的3种方式</h1><hr>
<h2 id="1-继承Thread类创建线程类"><a href="#1-继承Thread类创建线程类" class="headerlink" title="1.继承Thread类创建线程类"></a>1.继承Thread类创建线程类</h2><p>(1)将类声明为 Thread 的子类。<br>(2)子类覆盖父类中的run方法，将线程运行的代码存放在run方法中。（目的：将自定义代码存储在run方法，让线程运行）<br>(3)建立子类对象的同时线程也被创建。<br>(4)通过调用start方法开启线程。(start方法有2个作用：1.启动线程 2.调用run方法)</p>
<h2 id="2-实现Runnable接口创建线程类"><a href="#2-实现Runnable接口创建线程类" class="headerlink" title="2.实现Runnable接口创建线程类"></a>2.实现Runnable接口创建线程类</h2><p>(1)定义类实现Runnable接口<br>(2)覆盖Runnable接口中的run方法（将线程要运行的代码存放在该run方法中）<br>(3)通过Thread类建立线程对象<br>(4)将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数<br>(5)调用Thread类的start方法开启线程并调用Runnable接口子类的run方法</p>
<p>注意：<br>Runnable只是一个任务，真正干活的还是Thread<br>因为查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run方法，如果Thread类的run方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run方法。</p>
<h2 id="3-实现Callable接口和通过Future创建线程"><a href="#3-实现Callable接口和通过Future创建线程" class="headerlink" title="3.实现Callable接口和通过Future创建线程"></a>3.实现Callable接口和通过Future创建线程</h2><p>(1)创建Callable接口的实现类，并实现call()方法(相当于run)，该call()方法将作为线程执行体，并且有返回值。<br>(2)创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>(3)使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<h3 id="关于Callable-amp-Future的介绍"><a href="#关于Callable-amp-Future的介绍" class="headerlink" title="关于Callable&amp;Future的介绍"></a>关于Callable&amp;Future的介绍</h3><p>一个程序启动一个线程，这个线程运行完了有一返回结果，这些类可以获得这个结果</p>
<p>Callable是任务来返回结果，然后返回的结果由Future去拿</p>
<p>Future取得的结果类型和Callable返回的结果类型必须一致，这是通过泛型来实现的。</p>
<p>Callable要采用ExecutorSevice的submit方法提交，返回的future对象可以取消任务。</p>
<p>Callable&amp;Future的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableAndFuture</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();</div><div class="line">        Future&lt;String&gt; future = threadPool.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123; </div><div class="line">            <span class="comment">// Callable任务来返回结果，获取的结果由Future来拿，Callable如果没有结果，Future会一直等</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                <span class="keyword">return</span> <span class="string">"hello"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"等待结果"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"拿到结果："</span> + future.get());</div><div class="line">    <span class="comment">//      System.out.println("拿到结果："+future.get(100,TimeUnit.SECONDS));</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ExecutorService threadPool2 = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="comment">// CompletionService用于提交一组Callable任务，其take方法返回已完成的一个Callable任务对应的Future对象。</span></div><div class="line">        <span class="comment">// 好比我同时种了几块地的麦子，然后就等待收割。收割时，则是哪块先成熟了，则先去收割哪块麦子。</span></div><div class="line">        CompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;Integer&gt;(threadPool2); <span class="comment">// 接口不能直接new，需要new它的子类</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = i;</div><div class="line">            completionService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>));</div><div class="line">                    <span class="keyword">return</span> seq;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(completionService.take().get()); <span class="comment">// 按最先运行的线程来获取</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="创建并开启线程的7种方式"><a href="#创建并开启线程的7种方式" class="headerlink" title="创建并开启线程的7种方式"></a>创建并开启线程的7种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">开发时的线程写法（当然只是示范，不一定非得这么写，只是一种写法）</div><div class="line">什么时候用多线程？当某些代码要被同时执行就用单独的线程封装</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 单独封装线程1（Thread子类对象）</span></div><div class="line">        <span class="comment">// 在主方法里new个对象，这样封装，即使这个对象没运行完，下面的for也能运行</span></div><div class="line">        <span class="keyword">new</span> Thread()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  /</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"线程1"</span> + x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line"></div><div class="line">        <span class="comment">// 单独封装线程2（技巧写法，用匿名内部类完成）</span></div><div class="line">        Runnable r = <span class="keyword">new</span> Runnable()  &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"线程2"</span> + x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">new</span> Thread(r).start();  </div><div class="line"></div><div class="line">        <span class="comment">// 线程3（主线程）</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">100</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"线程3"</span> + x);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 线程4</span></div><div class="line">        <span class="keyword">new</span> Thread2().start(); </div><div class="line"></div><div class="line">        <span class="comment">// 线程5</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable2()).start();</div><div class="line"></div><div class="line">        <span class="comment">// 上面定义5个线程，这么一封装，这样就能同时运行了而且高效了</span></div><div class="line">    </div><div class="line">        <span class="comment">//  new Test1().start();  // 如果放这开启就不是4个同时开始，而是先执行上面3个才执行它</span></div><div class="line"></div><div class="line">        <span class="comment">// 以下还有3种方式</span></div><div class="line">        <span class="comment">// 线程6</span></div><div class="line">        Thread thread6 = <span class="keyword">new</span> Thread()&#123; <span class="comment">// new一个子类，复写run方法</span></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">				<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">					<span class="keyword">try</span> &#123;Thread.sleep(<span class="number">500</span>);&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</div><div class="line">				    System.out.println(<span class="string">"1："</span>+Thread.currentThread().getName());</div><div class="line">					System.out.println(<span class="string">"2："</span>+<span class="keyword">this</span>.getName()); <span class="comment">// this代表run方法所在的对象（thread对象），但是工作中不建议这么写</span></div><div class="line">                &#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		&#125;;</div><div class="line">		thread6.start();</div><div class="line"></div><div class="line">        <span class="comment">// 线程7</span></div><div class="line">        Thread thread7 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 等待</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(ANIMATION_DELAY);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 做页面跳转</span></div><div class="line">                <span class="comment">// doNavgation();</span></div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(isTopActivity(WelcomeActivity.<span class="keyword">this</span>))&#123;</div><div class="line">                    IntentUtil.startActivityAndFinish(MainActivity.class);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        thread7.start();</div><div class="line"></div><div class="line">        <span class="comment">// 线程8</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 等待</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(ANIMATION_DELAY);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 做页面跳转</span></div><div class="line">                <span class="comment">//doNavgation();</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span>(isTopActivity(WelcomeActivity.<span class="keyword">this</span>))&#123;</div><div class="line">                    IntentUtil.startActivityAndFinish(MainActivity.class);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  <span class="comment">// 继承和实现都行</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程4："</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;<span class="number">100</span>;x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程5："</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.创建线程的三种方式的对比<br>使用继承Thread类的方式创建多线程时<br>优势：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势：线程类已经继承了Thread类，所以不能再继承其他父类。</p>
<p>采用实现Runnable、Callable接口的方式创见多线程时<br>优势：<br>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br>劣势：<br>编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。</p>
<p>2.实现方式(Runnable)和继承方式(Thread)有什么区别呢？<br>实现方式好处：避免了单继承的局限性</p>
<p>两种方式区别在于存放代码位置不一样： ↓<br>继承Thread：线程代码存放Thread类的子类run方法中<br>实现Runnable，线程代码存在Runnable接口的子类的run方法</p>
<p>在定义线程时，建议使用实现方式（Runnable）<br>当然，自己的类没有父类的时候可以用继承Thread</p>
<p>图解：<br>继承：因为Java只支持单继承，所以Student类继承了Person类后就无法在继承Thread类.<br>实现：Student类继承了Person类还实现了Runnable接口，功能还扩展了.<br><img src="/images/it_java_thread1.png" alt="UML图"></p>
<p>PS:Thread类本身也实现了Runnable</p>
<p>3.为什么要覆盖run方法呢？<br>Thread类用于描述线程。<br>该类就定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。<br>就是说Thread类中的run方法，用于存储线程要运行的代码。<br>结论就是run方法就是初始化代码</p>
<p>4.start方法和run方法的区别？  调用start方法结果是什么？  调用run方法结果又是什么？<br>d.start();<br>开启线程并执行该线程的run方法<br>它调用底层让控制单元去执行的动作，这是start的作用<br>它很重要，只有它才能开启线程</p>
<p>d.run();<br>仅仅是对象调用方法。而线程创建了，并没有运行。<br>run的功能就是封装线程要运行的代码</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://www.cnblogs.com/DreamDrive/p/6180918.html" target="_blank" rel="external">创建线程的三种方式 </a><br><a href="http://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="external">java创建线程的三种方式及其对比</a></p>
<hr>
<h1 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h1><hr>
<h2 id="interrupt-停止线程"><a href="#interrupt-停止线程" class="headerlink" title="interrupt(停止线程)"></a>interrupt(停止线程)</h2><h3 id="先看下终止线程的三种方法"><a href="#先看下终止线程的三种方法" class="headerlink" title="先看下终止线程的三种方法"></a>先看下终止线程的三种方法</h3><p>1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br>定义循环结束标记,因为线程运行代码一般都是循环，只要控制了循环即可，就可以让run方法结束，也就是线程结束。</p>
<p>不过有种特殊情况：<br>当线程处于了冻结状态<br>就不会读取到标记<br>那么线程就不会结束  </p>
<p>所以推荐下面的interrupt<br>写程序时很常见的问题，只要线程挂着不动，就用interrupt</p>
<p>2.使用interrupt方法中断线程。(推荐)<br>该方法是结束线程的冻结状态，使线程回到运行状态中来。</p>
<p>详细就是当没有指定的方式让冻结的线程恢复到运行状态时，这时就需要对冻结进行清除。<br>强制让线程恢复到运行状态（获取运行资格）中来，这样就可以操作标记让线程结束。</p>
<p>注意这个方法不是停止线程，是强制清洁冻结状态的线程.<br>中断状态就是冻结状态<br>中断状态不是停止线程<br>stop方法才是停止线程<br>stop()，wait()，join() 都能被中断</p>
<p>3.使用stop方法强行终止线程。(不推荐)<br>这个方法已经过时不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的<br>虚拟机不识别不说而且此方法有bug，就是强制停止线程.<br>suspend方法也已过时（发送死锁）</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束线程方法1：加结束标记的情况：只要能让循环结束，那么线程就能结束</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;  <span class="comment">// 定义方法（改变标记）</span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span>&#123;</div><div class="line">        <span class="keyword">while</span>(flag)&#123;   <span class="comment">// 循环结束那么线程就能结束</span></div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread(); <span class="comment">// 主线程</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);       <span class="comment">// 其他线程1</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);       <span class="comment">// 其他线程2</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="comment">// 开始控制线程 </span></div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 无限循环</span></div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                st.changeFlag();  <span class="comment">// 结束标记（改变标记为假，循环和线程结束）</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num);  <span class="comment">// 得到主线程名字和编号</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 证明主线程执行完的提示语</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 结束线程2：(特殊情况) 加了同步后，线程停不下来，只能用interrupt</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  <span class="comment">// 遇到同步就等于拿到锁</span></div><div class="line">        <span class="keyword">while</span>(flag)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                wait();  <span class="comment">// 线程0和1进来遇到它就冻结等待了（放弃了执行资格）</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"...Exception"</span>); </div><div class="line">                flag = <span class="keyword">false</span>;  <span class="comment">// 只要能发送发生异常就代表在用interrupt，所以定义标记处理成false就能结束线程了</span></div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread(); </div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st);      <span class="comment">// 线程0</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);      <span class="comment">// 线程1</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                <span class="comment">//  st.changeFlag(); // 虽然改变了标记，但是这次程序因为同步的原因没有停下来</span></div><div class="line">                t1.interrupt();      <span class="comment">// 冻结状态强制被清除了，中断线程，出中断异常</span></div><div class="line">                t2.interrupt();      <span class="comment">// 同上</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num);  </div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 用了interrupt，主线程正常停下来了</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="setDeamon-守护线程"><a href="#setDeamon-守护线程" class="headerlink" title="setDeamon(守护线程)"></a>setDeamon(守护线程)</h2><p>将该线程标记为守护线程或用户线程。<br>当正在运行的线程都是守护线程时，Java 虚拟机退出。<br>该方法必须在启动线程前调用。</p>
<p>能看到的线程都是前台线程，当把某线程标记成后台线程后，就具备了特殊的含义<br>开启运行时，后台线程和前台线程都一样一起抢夺CPU资源，就结束有区别<br>当所有的前台线程都结束后，后台线程会自动结束（前台不在了，后台也挂了）</p>
<p>主线程是前台线程，主线程一结束就都结束</p>
<p>示例代码2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示：守护线程</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span><span class="params">()</span></span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(flag)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...run"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StopThread st = <span class="keyword">new</span> StopThread();</div><div class="line">        </div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(st); </div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(st);     </div><div class="line">        </div><div class="line">        <span class="comment">// 给t1和t2标记守护线程（传个真就守护了）</span></div><div class="line">        t1.setDaemon(<span class="keyword">true</span>);         </div><div class="line">        t2.setDaemon(<span class="keyword">true</span>);  </div><div class="line">        <span class="comment">// 主线程结束后，不管t1和t2是什么情况（睡眠，冻结，等待，无限循环等等）都能结束）</span></div><div class="line">        <span class="comment">// 该方法必须在启动线程前调用（开启守护模式当然必须在线程开动前期）     </span></div><div class="line">        <span class="comment">// 所以线程停下来的原因是因为主线程结束了（前台线程）</span></div><div class="line">        <span class="comment">// 而标记t1和t2的守护线程时他们是后台线程所以也跟着结束了，原理是这个方法让虚拟机结束了</span></div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(num++ == <span class="number">60</span>)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span> + num); </div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="join方法-临时加入线程"><a href="#join方法-临时加入线程" class="headerlink" title="join方法(临时加入线程)"></a>join方法(临时加入线程)</h2><p>Join用途：<br>临时加入线程用的<br>一个线程在运行中要临时加入另外一个线程，让这个线程运算完，然后让另外一个线程在继续运行</p>
<p>Join特点：<br>当A线程执行到了B线程的join()方法时，A就会等待。<br>等B线程都执行完，A才会执行。<br>join可以用来临时加入线程执行<br>join用的频率不高，但是很有技术含量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 演示：join</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">70</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"....."</span>+x);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        </div><div class="line">        t1.join()  <span class="comment">// t1先拥有执行权，主线程就处于冻结状态，等到t1打印完结束了，主线程才恢复到运行状态中来</span></div><div class="line"></div><div class="line">        t2.start();</div><div class="line"></div><div class="line">    <span class="comment">//  t1.join(); // 主线程先执行，执行到t1.join，主线程就冻结然后等待t1，</span></div><div class="line">                   <span class="comment">// 这时t1和t2交替执行，等t1结束了，主线程解冻和t2抢夺执行权</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">80</span>; x++)&#123;</div><div class="line">            System.out.println(<span class="string">"main....."</span>+x);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  <span class="comment">// 证明主函数结束的标语</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息"><a href="#yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息" class="headerlink" title="yield方法(临时停止线程) &amp; setPriority(设置优先级) &amp; toString(返回线程全部信息)"></a>yield方法(临时停止线程) &amp; setPriority(设置优先级) &amp; toString(返回线程全部信息)</h2><ul>
<li><p>yield()<br>临时停止<br>暂停当前正在执行的线程对象，并执行其他线程。<br>用的频率也不高</p>
</li>
<li><p>setPriority()<br>所有的线程包括主线程默认优先级是5，优先级一共10<br>优先级代表抢资源的频率</p>
<p>  因为1，5，10 这3个优先级跨度最大，所以有了3个字段 ↓<br>  static int MAX_PRIORITY   （优先级10,最高优先级）<br>  static int MIN_PRIORITY   （优先级1,最低优先级）<br>  static int NORM_PRIORITY  （优先级5,默认优先级）</p>
</li>
<li><p>toString()<br>返回该线程的字符串表示形式，包括线程名称、线程组和优先级。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *演示：toString &amp; setPriority &amp; yield</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">70</span>; x++)&#123;</div><div class="line">            System.out.println(Thread.currentThread().toString()+<span class="string">"....."</span>+x);</div><div class="line">            <span class="comment">// 输出：线程组（谁开启就属于哪个组，这里是主线程开启的t1和t2，所以属于main）</span></div><div class="line"></div><div class="line">            Thread.yield(); </div><div class="line">            <span class="comment">// 起到稍微减缓线程执行的频率的运行，能让所有的线程都有机会平均的运行效果（类似你一下，我一下的执行效果）</span></div><div class="line">            <span class="comment">// 强制性的让线程临时释放执行权</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Demo d = <span class="keyword">new</span> Demo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(d);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(d);</div><div class="line"></div><div class="line">        t1.start();</div><div class="line">        t1.setPriority(Thread.MAX_PRIRITY); <span class="comment">// 不过这方法不严谨，设完了也是互相抢资源，相对就是抢的频率高一些</span></div><div class="line">        t2.start();</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">80</span>; x++)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"main....."</span>+x);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"over"</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="线程的5种生命周期状态"><a href="#线程的5种生命周期状态" class="headerlink" title="线程的5种生命周期状态"></a>线程的5种生命周期状态</h1><hr>
<p><img src="/images/it_java_thread2.jpg" alt="UML图"><br><img src="/images/it_java_thread3.jpg" alt="UML图"><br><img src="/images/it_java_thread4.jpg" alt="UML图"></p>
<p>Java线程的生命周期分为如下几种：<br>新建：创建线程对象<br>就绪：拥有执行资格，但是没有执行权<br>运行：有执行资格且有执行权<br>阻塞：没有执行资格和执行权，但是可以被激活到就绪<br>死亡：线程对象变为垃圾，等待被回收。</p>
<ul>
<li><p>1.新建状态<br>创建线程对象<br>new一个Thread对象就是一个线程，new一个Thread子类也是</p>
</li>
<li><p>2.就绪状态<br>有执行资格的状态<br>特点：具备运行资格，但没有执行权</p>
</li>
<li><p>3.运行状态<br>即有资格又有执行权叫运行状态<br>方法：start()：开始启动线程</p>
</li>
<li><p>4.阻塞/冻结/睡眠/等待状态<br>没有执行资格的状态叫冻结状态(特点：放弃了执行资格，当然更没有执行权了)<br>方法：<br>sleep()：睡眠（需要指定睡眠时间，单位是毫秒）<br>wait()：等待<br>notify()：唤醒</p>
</li>
<li><p>5.消亡/线程死亡/销毁状态<br>方法：<br>stop()：停止<br>run()：run方法也是结束(当线程里内容执行完没有内容了就结束了)</p>
</li>
</ul>
<hr>
<h1 id="多线程同步安全问题与互斥技术"><a href="#多线程同步安全问题与互斥技术" class="headerlink" title="多线程同步安全问题与互斥技术"></a>多线程同步安全问题与互斥技术</h1><hr>
<p>}<br>同步：<br>Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</p>
<p>线程安全：<br>经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码.</p>
<p>多线程的运行出现了安全问题，原因是：<br>1.多个线程访问出现延迟<br>2.线程随机性</p>
<p>多线程安全问题经典案例：银行转账（1个人存，一个人取）</p>
<p>问题的原因：<br>当多条语句在操作同一线程共享数据时，一个线程对多条语句只执行了一部分，<br>还没有执行完，另一个线程参与进行执行。导致共享数据的错误。</p>
<p>解决方法：<br>对多条操作共享数据的语句，只能让一个线程都执行完。<br>在执行过程中，其他线程不可以参与运行。<br>java对于多余线程的安全问题提供了专业的解决方式：同步锁<br>对象如同锁，持有锁的线程可以在同步中执行。<br>没有持有锁的线程即使获取CPU的执行权，也执行不起，因为没有获取锁。</p>
<p>同步的前提：<br>1.必须要有两个或者两个以上的线程。<br>2.必须是多个线程使用同一个锁。<br>3.必须保证同步中能有一个线程运行。</p>
<p>同步的好处：解决了多线程的安全问题</p>
<p>同步的弊端：多个线程需要判断锁，较为消耗资源，影响程序效率.</p>
<p>相关名称：<br>互斥：多个线程互相排斥，互不干扰，这样就同步了。<br>互斥锁（Mutual exclusion，缩写 Mutex）：防止多个线程同时读写某一块内存区域。<br>信号量（Semaphore）：用来保证多个线程不会互相冲突。</p>
<p>同步有两种锁机制：<br>乐观锁和悲观锁<br>不懂俩锁的可以看下面文章快速联系<br><a href="http://blog.csdn.net/hongchangfirst/article/details/26004335" target="_blank" rel="external">一分钟教你知道乐观锁和悲观锁的区别</a></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁是一种非独占锁，非阻塞锁。</p>
<p>相关文章：<br><a href="http://www.importnew.com/20472.html" target="_blank" rel="external">乐观锁的一种实现方式——CAS</a><br><a href="http://www.cnblogs.com/gossip/p/6182028.html" target="_blank" rel="external">Java并发_volatile实现可见性但不保证原子性</a><br><a href="http://www.cnblogs.com/yuyutianxia/p/3991869.html" target="_blank" rel="external">锁、volatile、CAS 比较</a></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS(Compare and Swap)比较并交换的无锁算法<br>解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</p>
<p>java.util.concurrent包中借助CAS实现了区别于synchronized同步锁的一种乐观锁。<br>AtomicInteger</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>与锁相比，volatile变量是一和更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作</p>
<p>volatile变量也存在一些局限：不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用volatile变量</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁是一种是独占锁，阻塞锁.</p>
<p>悲观锁机制存在以下问题：<br>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。<br>一个线程持有锁会导致其它所有需要此锁的线程挂起。<br>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p>
<p>悲观锁种类：<br>有Synchronized和Lock两种方式</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>synchronized就是一种阻塞算法.<br>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。<br>独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p>
<p>Synchronized有如下几种表现方式和情况： </p>
<h4 id="1-同步代码块（互斥的代码块上锁，加任意对象锁）"><a href="#1-同步代码块（互斥的代码块上锁，加任意对象锁）" class="headerlink" title="1.同步代码块（互斥的代码块上锁，加任意对象锁）"></a>1.同步代码块（互斥的代码块上锁，加任意对象锁）</h4><p>同步代码块的锁可以创建一个任意类型的对象来用，如Object类型或该类所属字节码文件对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">格式：synchronized ( 对象 )&#123; </div><div class="line">    需要被同步的代码 ;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">Object obj = <span class="keyword">new</span> Object();  <span class="comment">// 新建对象锁，Object现成的基类直接拿来用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(obj)&#123;      <span class="comment">// 同步代码块(在操作共享数据的地方加同步代码块，多了一层代码阶段形状相当于加了一道同步锁(或者是监视器)</span></div><div class="line">        sum = sum + n;</div><div class="line">        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</div><div class="line">        System.out.println(<span class="string">"sum"</span> + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-同步函数（互斥非静态方法上锁，加this锁）"><a href="#2-同步函数（互斥非静态方法上锁，加this锁）" class="headerlink" title="2.同步函数（互斥非静态方法上锁，加this锁）"></a>2.同步函数（互斥非静态方法上锁，加this锁）</h4><p>同步函数用的是哪一个锁？<br>函数需要被对象调用，那么函数都有一个所属对象引用：this，所以同步函数使用的锁是this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">格式：在函数上加上synchronized修饰符即可</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 同步函数（让函数具备同步性）  </span></div><div class="line">    sum = sum + n;</div><div class="line">    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</div><div class="line">    System.out.println(<span class="string">"sum"</span> + sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-静态同步函数-互斥静态方法上锁，加类锁"><a href="#3-静态同步函数-互斥静态方法上锁，加类锁" class="headerlink" title="3.静态同步函数(互斥静态方法上锁，加类锁)"></a>3.静态同步函数(互斥静态方法上锁，加类锁)</h4><p>同步函数被静态修饰后，使用的锁是什么呢？<br>通过验证，发现不在是this（因为静态方法中不可以定义this）<br>静态进内存时，内存中还没有本类对象，但是一定有该类对应的字节码文件对象：类名.class，所以该对象的类型是class<br>静态的同步方法，使用的锁是该方法所在类的字节码文件对象：类名.class（这个对象在内存里是唯一的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  演示 静态同步函数的锁是Class对象</div><div class="line"> */ </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tick = <span class="number">100</span>; <span class="comment">// 静态（加静态后是方法区共享数据，不加静态是堆内存共享数据）</span></div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(Ticket.class)&#123;  <span class="comment">// Ticket的字节码</span></div><div class="line">                    <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"同步代码块 : "</span> + tick--);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;  <span class="comment">// 静态同步方法</span></div><div class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"同步函数 : "</span> + tick--);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Ticket ticket = <span class="keyword">new</span> Ticket(); </div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(ticket);  </div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ticket); </div><div class="line">        thread1.start(); </div><div class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">        ticket.flag = <span class="keyword">false</span>;</div><div class="line">        thread2.start(); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综合示例演示3种方式的对比<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 线程的互斥：关键字synchronized</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSynchronized</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ThreadSynchronized().init();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 内部方法</span></div><div class="line">        <span class="keyword">final</span> Output output = <span class="keyword">new</span> Output();</div><div class="line"></div><div class="line">        <span class="comment">//下面2个线程中的2段代码在线程执行时要互斥</span></div><div class="line">        <span class="comment">//要互斥的代码必须用synchronize代码块包围起来.</span></div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123; </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</div><div class="line">                    output.output(<span class="string">"cat"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</div><div class="line">                    output.output2(<span class="string">"dog"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Output</span></span>&#123; <span class="comment">// 内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span></span>&#123;</div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">synchronized</span> (Output.class)&#123;  <span class="comment">// 同步代码块  // this：谁调用我谁就是锁</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                    System.out.print(name.charAt(i));</div><div class="line">                &#125;</div><div class="line">                System.out.println();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 同步函数 （注意：一个方法最好就1个synchronized，如果还有同步代码块就容易产生死锁）</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output2</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                System.out.print(name.charAt(i));</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output3</span><span class="params">(String name)</span></span>&#123; <span class="comment">// 静态同步函数</span></div><div class="line">            <span class="keyword">int</span> len = name.length();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">                System.out.print(name.charAt(i));</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以必须要用一把锁来挡住冲突的线程，不同的锁是无法挡住这些冲突的线程的.</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>Lock比传统线程模型中的synchronized方法更加面向对象，与生活中的锁类似，锁本身也应该是一个对象。</p>
<p>两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。<br>锁是上在代表要操作的资源的类的内部方法中，而不是线程代码中。</p>
<p>Lock使用lock()、unlock()加锁解锁，比synchronized功能更多，JDK6后性能和synchronized差不多</p>
<p>除此之外Lock接口还有两个非常强大的实现类<br>(1)ReentrantLock重入锁<br>(2)ReentrantReadWriteLock读写锁</p>
<p>相关文章：<br><a href="http://blog.csdn.net/canot/article/details/52050633" target="_blank" rel="external">Java中的锁-Lock接口解析</a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>同步还有个小小的弊端——死锁     </p>
<p>死锁：同步中嵌套同步的锁<br>如你持有一个锁，我也有一个锁，我要到你那里去运行，所以要拿你的锁，<br>而你又要到我这里运行，你跟我也要锁，我不放我的锁我要进你那里去，你也不放你的锁要进我这里来，<br>谁都不放，这种现象就叫死锁，导致程序挂着不动了。</p>
<p>下面看几个死锁示例，面试题也有写出死锁程序，因为，能写出死锁，意味着理解死锁也就能避免死锁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 死锁示例1</div><div class="line"> **/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">1000</span>;</div><div class="line">    Object obj = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  <span class="comment">// 实现Runnable接口后要覆盖run方法 </span></div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(obj)&#123;  <span class="comment">// 同步代码块，锁是obj</span></div><div class="line">                    show();         <span class="comment">// 同步代码块里有同步函数（obj锁里有this锁）</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">// 同步函数，锁是this</span></div><div class="line">        <span class="comment">// 注意：这里放while(true)将会无法死锁</span></div><div class="line">        <span class="keyword">synchronized</span>(obj)&#123; <span class="comment">// 同步函数里有同步代码块，this锁里有obj锁</span></div><div class="line">            <span class="keyword">if</span> (tick &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;Thread.sleep(<span class="number">10</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"同步代码块 : "</span> + tick--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Ticket t = <span class="keyword">new</span> Ticket();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);  </div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);  </div><div class="line">        t1.start();</div><div class="line">        <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">        t.flag = <span class="keyword">false</span>;</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">死锁示例2</div><div class="line">比上面的简单一些,这个程序要掌握!</div><div class="line">考的是对死锁的理解，能写出来，多线程就差不多了，死锁能理解，就能避免死锁，同步也能很熟了，不熟的话是写不出死锁的.</div><div class="line">用于面试题：请写一个死锁程序</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(<span class="keyword">true</span>));</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(<span class="keyword">false</span>));</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> Object locka = <span class="keyword">new</span> Object();  <span class="comment">// 想要调用locka就得创建对象，麻烦，所以静态（static）方便调用</span></div><div class="line">    <span class="keyword">static</span> Object lockb = <span class="keyword">new</span> Object();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="comment">// 实现Runnable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;       <span class="comment">// 定义一个标记</span></div><div class="line">    Test(<span class="keyword">boolean</span> flag)&#123;</div><div class="line">        <span class="keyword">this</span>.flag = flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   <span class="comment">// 实现Runnable接口后要覆盖run方法 </span></div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// 少运行怕锁不上，所以一直循环，为了让它锁上</span></div><div class="line">                <span class="keyword">synchronized</span>(MyLock.locka)&#123;               <span class="comment">// A锁（嵌套B锁）</span></div><div class="line">                    System.out.println(<span class="string">"if locka"</span>);       <span class="comment">// 打印if A锁</span></div><div class="line">                    <span class="keyword">synchronized</span>(MyLock.lockb)&#123;           <span class="comment">// B锁（被A锁嵌套）</span></div><div class="line">                        System.out.println(<span class="string">"if lockb"</span>);   <span class="comment">// 打印if B锁</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(MyLock.lockb)&#123;               <span class="comment">// B锁（嵌套A锁）</span></div><div class="line">                    System.out.println(<span class="string">"else lockb"</span>);     <span class="comment">// 打印else B锁</span></div><div class="line">                    <span class="keyword">synchronized</span>(MyLock.locka)&#123;           <span class="comment">// A锁（被B锁嵌套）</span></div><div class="line">                        System.out.println(<span class="string">"else locka"</span>); <span class="comment">// 打印else A锁</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="多线程间通信问题"><a href="#多线程间通信问题" class="headerlink" title="多线程间通信问题"></a>多线程间通信问题</h1><hr>
<p>线程间通讯其实就是多个线程在操作同一个资源，<br>但是操作的动作不同，一个线程负责存进数据，另一个负责拿走数据<br>所以说得2个run方法存放数据存放在2个类中<br>不过就是因为多个线程在一存一取，一旦发生不同步问题，所以会引发巨大的隐患.</p>
<h2 id="线程间通信机制"><a href="#线程间通信机制" class="headerlink" title="线程间通信机制"></a>线程间通信机制</h2><p>针对上述情况有以下几种解决方案：<br>1.等待唤醒机制<br>2.条件对象Condition:<br>3.BlockingQueue</p>
<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>等待唤醒机制在开发时非常常见<br>比喻2个人同时做事情，而且做的不一样，等第一个人做完了第二个在做，<br>操作局部数据2个人可以随便<br>操作共享数据时为了避免出现问题会定一个规矩：我完事了叫你动了你在动</p>
<p>3个相关方法：</p>
<ul>
<li><p>wait()<br>等待<br>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。<br>换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。<br>当前线程必须拥有此对象监视器（对象监视器就是同步的锁。什么时候有锁？只有同步才有锁）<br>这个方法需要抓异常<br>特点：放弃了执行资格</p>
</li>
<li><p>notify()<br>唤醒（用在同步里面）（API：java.lang，Object）</p>
</li>
<li><p>notifyAll()<br>集体唤醒线程池中的所有线程（用在同步里面）（API：java.lang，Object）</p>
</li>
</ul>
<p>以上3个方法都使用在同步中，因为要对持有监视器（锁）的线程操作。所以要使用在同步中，因为只有同步才具有锁.</p>
<h4 id="等待唤醒机制示例"><a href="#等待唤醒机制示例" class="headerlink" title="等待唤醒机制示例"></a>等待唤醒机制示例</h4><p>需求：子线程循环5次，接着主线程循环10次，接着又回到子线程循环5次，接着再回到主线程又循环10次，如此循环50次，请写出程序。</p>
<p>版本1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> ThreadTest().init();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">                            business.SubThread(i);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        ).start();</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            business.MainThread(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 经验：要用到共同数据（包括同步锁）或共同算法的的若干个方法应该归在同一个类身上，这种设计正好体现了高类聚和程序的健壮性，易维护。</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> bShouldSub = <span class="keyword">true</span>; <span class="comment">//这里相当于定义了控制该谁执行的一个信号灯</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">MainThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (bShouldSub)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bShouldSub = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">SubThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (!bShouldSub)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bShouldSub = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">this</span>.notify();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>版本2：优化上一代码<br>不可能一上来就写出上面的完整代码，最初写出来的代码如下，问题在于两个线程的代码要参照同一个变量，即这两个线程的代码要共享数据，所以，把这两个线程的执行代码搬到同一个类中去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bShouldMain = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(</div><div class="line">            <span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</div><div class="line">                        <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</div><div class="line">                            <span class="keyword">if</span> (bShouldMain) &#123;</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    ThreadTest.class.wait();</div><div class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                    e.printStackTrace();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">                            &#125;</div><div class="line">                            bShouldMain = <span class="keyword">true</span>;</div><div class="line">                            ThreadTest.class.notify();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ).start();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</div><div class="line">                <span class="keyword">if</span> (!bShouldMain) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        ThreadTest.class.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bShouldMain = <span class="keyword">false</span>;</div><div class="line">                ThreadTest.class.notify();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>版本3：下面使用jdk5中的并发库来实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Condition subThreadCondition = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> bBhouldSubThread = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">                    lock.lock();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (!bBhouldSubThread)</div><div class="line">                            subThreadCondition.await();</div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">",j="</span> + j);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        bBhouldSubThread = <span class="keyword">false</span>;</div><div class="line">                        subThreadCondition.signal();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        lock.unlock();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        threadPool.shutdown();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</div><div class="line">            lock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (bBhouldSubThread)</div><div class="line">                    subThreadCondition.await();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">",j="</span> + j);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                bBhouldSubThread = <span class="keyword">true</span>;</div><div class="line">                subThreadCondition.signal();</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="条件对象Condition"><a href="#条件对象Condition" class="headerlink" title="条件对象Condition"></a>条件对象Condition</h3><p>await/signal/signalAll</p>
<h3 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h3><p><a href="http://blog.csdn.net/suifeng3051/article/details/48807423" target="_blank" rel="external">【Java并发之】BlockingQueue</a></p>
<h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p><a href="http://www.cnblogs.com/linjiqin/p/3217050.html" target="_blank" rel="external">Java多线程-并发协作(生产者消费者模型)</a></p>
<h2 id="相关问题-1"><a href="#相关问题-1" class="headerlink" title="相关问题"></a>相关问题</h2><p>1.wait()，notify()，notify All()，用来操作线程为什么定义在了Object类中？<br>(1)这些方法存在与同步中<br>(2)使用这些方法时必须要标识所属的同步的锁<br>(3)锁可以是任意对象，所以任意对象调用的方法一定定义在Object类中</p>
<p>2.wait()，sleep()有什么区别？<br>(1)wait()：释放资源，释放锁<br>(2)sleep()：释放资源，不释放锁</p>
<p>3.等待的线程在哪呢？<br>线程运行的时候会建立一个线程池，等待线程都临时存在这个线程池当中（线程没挂，但是不能动）<br>notify唤醒的都是线程池中的线程，唤醒的顺序是第一个被等待的，因为是按顺序往里存的</p>
<p>4.为什么定义notifyAll？<br>因为需要唤醒对方线程<br>因为只用notify，容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待！</p>
<p>5.死锁和notifyAll(全部等待)的区别：<br>死锁：我的和你要，你的和我要，谁都不放<br>全部等待：你我都动不了，都不是活的，全冻结了</p>
<p>6.对于多个生产者和消费者，为什么要定义while判断标记？<br>原因：让被唤醒的线程再一次判断标记。</p>
<p>7.生产者和消费者有什么替代方案？<br>JDK1.5之前一个锁对应一个wait notify，如果还想要一组wait notify就得还定义一个锁，<br>在建锁就得在建同步，一同步2个就形成嵌套就容易死锁</p>
<p>JDK1.5现在变成了一个锁有好几组wait notify(可以对应好几个Condition对象)，就是wait notify封装成了Condition对象<br>详细说就是JDK1.5版本中提供了显示的锁机制，以及锁对象身上的等待唤醒操作机制，同时它把等待和唤醒给封装了，一个锁有多个Condition</p>
<p>Lock：替代了Synchronized<br>    lock(); 获取锁（加锁）<br>    unlock(); 释放锁（解锁）<br>    newCondition(); 返回Condition对象</p>
<p>Condition：替代了Object 类的 wait / notify / notifyAll<br>    await();<br>    signal();<br>    signalAll();</p>
<hr>
<h1 id="线程管理类-线程池"><a href="#线程管理类-线程池" class="headerlink" title="线程管理类(线程池)"></a>线程管理类(线程池)</h1><hr>
<h2 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h2><p>首先介绍在Tcp服务器编程模型的原理，每一个客户端连接用一个单独的线程为之服务，当与客户端的会话结束时，线程也就结束了，即每来一个客户端连接，服务器端就要创建一个新线程。<br>如果访问服务器的客户端很多，那么服务器要不断的创建和销毁线程，这将严重影响服务器的性能。<br>所以要创建一些线程，它们的集合称为线程池，当服务器接受到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完后不关闭该线程，而是将该线程还回到线程池中。<br>就这样，在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程。</p>
<p>线程池（thread pool）：<br>就是有多个线程</p>
<p>线程池的作用：<br>管理好几个线程，固定几个线程，<br>不然拼命New Thread就浪费资源了，因为如果不对线程的数量进行控制，而不断New Thread（开线程）很浪费资源</p>
<p>线程池就2个东西：<br>几个线程，里面仍了几个任务<br>我们要做的就是把任务扔到池子里让线程池自己办</p>
<p>一个应用程序可能有多个线程池，每个线程池负责一件事，如网络访问有一个线程池，数据库操作有一个线程池，优先级的的操作也有一个池（池就是容器,如List ,Map）</p>
<p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。<br>线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。<br>如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。<br>如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p>
<p>下面说下new Thread的弊端及Java四种线程池的使用，对Android同样适用<br>还有但凡和线程池/线程/同步/锁等有关的实践问题，建议尽量不要用Android的解决方案，如AsyncTask，而要用Java中已经历经考验的实践方案 如FutureTask+ThreadPoolExecuters。</p>
<h2 id="new-Thread的弊端"><a href="#new-Thread的弊端" class="headerlink" title="new Thread的弊端"></a>new Thread的弊端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>执行一个异步任务你还只是如下new Thread吗？<br>那你就out太多了，new Thread的弊端如下：<br>a. 每次new Thread新建对象性能差。<br>b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。<br>c. 缺乏更多功能，如定时执行、定期执行、线程中断。<br>相比new Thread，Java提供的四种线程池的好处在于：<br>a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。<br>b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。<br>c. 提供定时执行、定期执行、单线程、并发数控制等功能。</p>
<h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Java5通过Executors提供4种线程池，分别为：</p>
<p>1.newFixedThreadPool<br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(index);</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p>
<p>2.newCachedThreadPool<br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(index * <span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(index);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 </p>
<p>3.newScheduledThreadPool<br>创建一个定长线程池，支持定时及周期性任务执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</div><div class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"delay 3 seconds"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>表示延迟3秒执行。</p>
<p>定期执行示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"delay 1 seconds, and excute every 3 seconds"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>表示延迟1秒后每3秒执行一次。<br>ScheduledExecutorService比Timer类更安全，功能更强大。</p>
<p>4.newSingleThreadExecutor<br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> index = i;</div><div class="line">    singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(index);</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果依次输出，相当于顺序执行各个任务。<br>现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p>
<h3 id="相关问题-2"><a href="#相关问题-2" class="headerlink" title="相关问题"></a>相关问题</h3><p>1.如果实现线程死掉后重新启动？<br>创建单一线程池（newSingleThreadExecutor）<br>它里面会创建一个线程，如果这个线程死了就马上在创建一个线程，始终有一个线程活着</p>
<p>2.执行线程的2个方法<br>Executor的execute    （没有返回值）<br>ExecutorService的submit  （有返回值，返回Future&lt;?&gt;）</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>自定义线程池<br>查看Executors源码我们知道，Executors 类提供了使用了 ThreadPoolExecutor 的简单的 ExecutorService 实现，也就是上面所说的四种Executors线程池，但是 ThreadPoolExecutor 提供的功能远不止于此。<br>不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池<br>我们可以在创建 ThreadPoolExecutor 实例时指定活动线程的数量，我们也可以限制线程池的大小并且创建我们自己的 RejectedExecutionHandler 实现来处理不能适应工作队列的工作。 </p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolProxy</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> ThreadPoolExecutor  mExecutor;          <span class="comment">// 线程池</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 mCorePoolSize;      <span class="comment">// 核心线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 mMaximumPoolSize;   <span class="comment">// 最大线程数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span>                mKeepAliveTime;     <span class="comment">// 保持存活时间</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolProxy</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mCorePoolSize = corePoolSize;</div><div class="line">        <span class="keyword">this</span>.mMaximumPoolSize = maximumPoolSize;</div><div class="line">        <span class="keyword">this</span>.mKeepAliveTime = keepAliveTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initThreadPoolExecutor</span><span class="params">(Runnable task)</span></span>&#123; <span class="comment">//+同步一个时间点只能执行一次这个方法，更严谨</span></div><div class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mExecutor == <span class="keyword">null</span> || mExecutor.isShutdown() || mExecutor.isTerminated())&#123;</div><div class="line">            <span class="comment">// keepAliveTime单位</span></div><div class="line">            TimeUnit unit = TimeUnit.MILLISECONDS;</div><div class="line"></div><div class="line">            <span class="comment">// 任务队列/阻塞队列</span></div><div class="line">            BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();                      <span class="comment">// 不固定大小队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(10);                  // 固定大小队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new PriorityBlockingQueue(initialCapacity, comparator);// 优先级队列，FIFO</span></div><div class="line">            <span class="comment">// BlockingQueue&lt;Runnable&gt; workQueue = new SynchronousQueue&lt;Runnable&gt;();                      // 同步队列，FIFO</span></div><div class="line"></div><div class="line">            <span class="comment">// 线程工厂</span></div><div class="line">            ThreadFactory threadFactory = Executors.defaultThreadFactory();</div><div class="line"></div><div class="line">            <span class="comment">// 错误捕获器（下面这种形式类似策略设计模式）</span></div><div class="line">            RejectedExecutionHandler handler = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();         <span class="comment">// 如果出现错误，不做处理</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy();        // 如果出现错误，则直接抛出异常</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();   // 如果出现错误，直接执行加入的任务</span></div><div class="line">            <span class="comment">// RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardOldestPolicy();// 如果出现错误,移除第一个任务,执行加入的任务</span></div><div class="line"></div><div class="line">            mExecutor = <span class="keyword">new</span> ThreadPoolExecutor(mCorePoolSize,  mMaximumPoolSize,mKeepAliveTime, unit, workQueue, threadFactory,handler);        </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务（方式1）</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> task</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span></span>&#123;</div><div class="line">        initThreadPoolExecutor(task); <span class="comment">// 初始化线程池</span></div><div class="line">        mExecutor.execute(task);  <span class="comment">// 执行线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务（方式2）</div><div class="line">     * </div><div class="line">     * submit方法和execute的区别是有返回值的（Future），说明被持有了，然后可以做了操作（如停掉）</div><div class="line">	 * future有cancel方法，可以把线程停掉（整个线程杀掉，任务正在运行就是做耗时操作也是被干掉）</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> task</div><div class="line">     * <span class="doctag">@return</span> Future</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task)&#123;</div><div class="line">        initThreadPoolExecutor(task);</div><div class="line">        <span class="keyword">return</span> mExecutor.submit(task); <span class="comment">// 执行线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * remove方法只是移出任务队列，不归我管了，因为队列里已经没有它</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Runnable task)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (mExecutor != <span class="keyword">null</span>)&#123;</div><div class="line">            mExecutor.remove(task);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://www.trinea.cn/android/java-android-thread-pool/" target="_blank" rel="external">Java(Android)线程池</a><br><a href="http://blog.csdn.net/l540675759/article/details/62230562" target="_blank" rel="external">深入理解在Android中线程池的使用</a><br><a href="http://blog.csdn.net/xlxxcc/article/details/52108534" target="_blank" rel="external">Java Executors 和 ThreadPoolExecutor 线程池</a></p>
<hr>
<h1 id="线程范围内共享变量"><a href="#线程范围内共享变量" class="headerlink" title="线程范围内共享变量"></a>线程范围内共享变量</h1><hr>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>线程范围内的共享数据<br>JavsEE（底层框架）用的比较多的知识<br>Andriod用的比较少</p>
<p>先看下线程范围的共享变量的应用场景<br>示例代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData</span></span>&#123;	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>; <span class="comment">// 定义一个全局变量</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Thread,Integer&gt; threadData = <span class="keyword">new</span> HashMap&lt;Thread,Integer&gt;();</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  <span class="comment">// 循环2遍相当于启动2个线程</span></div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;	</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">					threadData.put(Thread.currentThread(), data);</div><div class="line">					<span class="keyword">new</span> A().get();  <span class="comment">// 调用A模块取数据</span></div><div class="line">					<span class="keyword">new</span> B().get();  <span class="comment">// 调用B模块取数据</span></div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> data = threadData.get(Thread.currentThread());</div><div class="line">			System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> data = threadData.get(Thread.currentThread());</div><div class="line">			System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread-0 has put data : 11</div><div class="line">Thread-1 has put data : 22</div><div class="line">A from Thread-0 get data : 11</div><div class="line">A from Thread-1 get data : 22</div><div class="line">B from Thread-0 get data : 11</div><div class="line">B from Thread-1 get data : 22</div></pre></td></tr></table></figure></p>
<p>结果分析：<br>线程1存进去数值11<br>线程2存进去数值22<br>A对象从线程1拿到的也是11，线程2拿到的是22<br>B同样，从线程1和线程2拿到也是11和22<br>这样就实现了每个线程有各自独立的数据，在这个线程范围内，不管哪个对象拿到的也是正常的相同线程的数量变量</p>
<p>下面开始主题，介绍下ThreadLocal<br>ThreadLocal的作用和目的：用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。</p>
<p>ThreadLocal的原理：<br>内部就是一个map<br>每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。在线程结束时可以调用ThreadLocal.clear()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。</p>
<p>ThreadLocal的应用场景：<br>1.订单处理包含一系列操作：减少库存量、增加一条流水台账、修改总账，这几个操作要在同一个事务中完成，通常也即同一个线程中进行处理，如果累加公司应收款的操作失败了，则应该把前面的操作回滚，否则，提交所有操作，这要求这些操作使用相同的数据库连接对象，而这些操作的代码分别位于不同的模块类中。<br>2.银行转账包含一系列操作： 把转出帐户的余额减少，把转入帐户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，转入和转出操作的代码分别是两个不同的帐户对象的方法。<br>3.例如Strut2的ActionContext，同一段代码被不同的线程调用运行时，该代码操作的数据是每个线程各自的状态和数据，对于不同的线程来说，getContext方法拿到的对象都不相同，对同一个线程来说，不管调用getContext方法多少次和在哪个模块中getContext方法，拿到的都是同一个。</p>
<p>实验案例：<br>定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。</p>
<p>ThreadLocal总结：<br>一个ThreadLocal代表一个变量，故其中里只能放一个数据，你有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象。如果有一个百个变量要线程共享呢？那请先定义一个对象来装这一百个变量，然后在ThreadLocal中存储这一个对象。</p>
<p>示例代码2：<br>上述代码替换成ThreadLocal形式，特别简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建议：<br>实现对ThreadLocal变量的封装，让外界不要直接操作ThreadLocal变量。<br>对基本类型的数据的封装，这种应用相对很少见。<br>对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。<br>示例代码3：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    MyThreadScopeData myData = <span class="keyword">new</span> MyThreadScopeData();</div><div class="line">                    myData.setName(<span class="string">"name"</span> + data);</div><div class="line">                    myData.setAge(data);</div><div class="line">                    myThreadScopeData.set(myData);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = myThreadScopeData.get();</div><div class="line">            System.out.println(</div><div class="line">                    <span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更优雅的方式，直接单例模式<br>示例代码4：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" has put data:"</span> + data);</div><div class="line">                    x.set(data);</div><div class="line">                    MyThreadScopeData.getThreadInstance().setName(<span class="string">"name"</span> + data);</div><div class="line">                    MyThreadScopeData.getThreadInstance().setAge(data);</div><div class="line">                    <span class="keyword">new</span> A().get();</div><div class="line">                    <span class="keyword">new</span> B().get();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</div><div class="line">            System.out.println(<span class="string">"A from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> data = x.get();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"get data:"</span> + data);</div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();</div><div class="line">            System.out.println(<span class="string">"B from"</span> + Thread.currentThread().getName() + <span class="string">"getMyData:"</span> + myData.getName() + <span class="string">","</span> + myData.getAge());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; map = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadScopeData</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyThreadScopeData <span class="title">getThreadInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 互斥也不用加了</span></div><div class="line">        MyThreadScopeData instance = map.get();</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> MyThreadScopeData();</div><div class="line">            map.set(instance);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="多个线程访问共享对象和数据的方法"><a href="#多个线程访问共享对象和数据的方法" class="headerlink" title="多个线程访问共享对象和数据的方法"></a>多个线程访问共享对象和数据的方法</h2><hr>
<p>需求：设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</p>
<p>示例代码1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadShareData</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ShareData1 data1 = <span class="keyword">new</span> ShareData1();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ShareData1 data2 = <span class="keyword">new</span> ShareData1();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable1(data2)).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable2(data2)).start();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> ShareData1 data1 = <span class="keyword">new</span> ShareData1();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                data1.decrement();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                data1.increment();</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ShareData1 data1;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable1</span><span class="params">(ShareData1 data1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data1 = data1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data1.decrement();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ShareData1 data1;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable2</span><span class="params">(ShareData1 data1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data1 = data1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data1.increment();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">100</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            count--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例代码2：（比较复杂）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line"></div><div class="line">        ThreadTest1 tt = <span class="keyword">new</span> ThreadTest1();</div><div class="line"></div><div class="line">        Inc inc = tt.new Inc();</div><div class="line">        Dec dec = tt.new Dec();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">            Thread t = <span class="keyword">new</span> Thread(inc);</div><div class="line">            t.start();</div><div class="line">            t = <span class="keyword">new</span> Thread(dec);</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-inc:"</span> + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-dec:"</span> + j);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                inc();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">                dec();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例代码2：（更简化的版本）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    JManager j = <span class="keyword">new</span> JManager();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> A().call();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        j.accumulate();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line"></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        j.subtract();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JManager</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtract</span><span class="params">()</span> </span>&#123;</div><div class="line">        j--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">()</span> </span>&#123;</div><div class="line">        j++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><hr>
<h2 id="AtomicInteger、AtomicBoolean等等"><a href="#AtomicInteger、AtomicBoolean等等" class="headerlink" title="AtomicInteger、AtomicBoolean等等"></a>AtomicInteger、AtomicBoolean等等</h2><p>一个提供原子操作的Integer的类。在Java语言中，++i和i++操作并不是线程安全的，在使用的时候，不可避免的会用到synchronized关键字。而AtomicInteger则通过一种线程安全的加减操作接口。这个类在AsyncTask中用到了。</p>
<p>多个线程访问同一个整数数据的情况下，一定要用这个类</p>
<h2 id="AtomicFile"><a href="#AtomicFile" class="headerlink" title="AtomicFile"></a>AtomicFile</h2><p>AtomicFile首先不是用来代替File的，而是作为File的辅助类从在， AtomicFile的作用是实现事务性原子操作，即文件读写必须完整，适合多线程中的文件读写操作。</p>
<p>用来实现多线程中的文件读写的安全操作</p>
<p>注意：AtomicFile是android.util包下的API，不是Java并发包的API.</p>
<hr>
<h1 id="线程安全容器类"><a href="#线程安全容器类" class="headerlink" title="线程安全容器类"></a>线程安全容器类</h1><hr>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>详情查看<br><a href="http://www.hengxing.me/2017/09/07/it/1.Java/CollectionsFramework/" target="_blank" rel="external">Java集合框架的总结</a></p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><h2 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h2><h2 id="Sorted容器"><a href="#Sorted容器" class="headerlink" title="Sorted容器"></a>Sorted容器</h2><hr>
<h1 id="相关多线程文章"><a href="#相关多线程文章" class="headerlink" title="相关多线程文章"></a>相关多线程文章</h1><hr>
<p><a href="http://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="external">Java中的多线程你只要看这一篇就够了</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持收集实用资料和原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/upload/wechatpay20170716225849.jpg" alt="恒星 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/upload/alipay_20170716225901.jpg" alt="恒星 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/04/it/2.NetworkProtocol/Session/" rel="next" title="Session & Cookie & Token的区别">
                <i class="fa fa-chevron-left"></i> Session & Cookie & Token的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/06/it/1.Java/Multithreading/" rel="prev" title="多线程并发异步的总结">
                多线程并发异步的总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="恒星" />
          <p class="site-author-name" itemprop="name">恒星</p>
           
              <p class="site-description motion-element" itemprop="description">披星戴月,日月为鉴! 蛰伏蛰伏,厚积方能薄发!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">77</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hengxing0080" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:skystar0079@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://raw.githubusercontent.com/hengxing0080/hengxing0080.github.io/master/images/WeChat.jpg" target="_blank" title="WeChat">
                  
                    <i class="fa fa-fw fa-wechat"></i>
                  
                  WeChat
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="tencent://message/?uin=348269714&Site=&Menu=yes" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://heneryyang.github.io/" title="老杨博客" target="_blank">老杨博客</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程和线程的理解"><span class="nav-number">1.</span> <span class="nav-text">进程和线程的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程"><span class="nav-number">1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">1.2.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建线程的3种方式"><span class="nav-number">2.</span> <span class="nav-text">创建线程的3种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-继承Thread类创建线程类"><span class="nav-number">2.1.</span> <span class="nav-text">1.继承Thread类创建线程类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现Runnable接口创建线程类"><span class="nav-number">2.2.</span> <span class="nav-text">2.实现Runnable接口创建线程类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-实现Callable接口和通过Future创建线程"><span class="nav-number">2.3.</span> <span class="nav-text">3.实现Callable接口和通过Future创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于Callable-amp-Future的介绍"><span class="nav-number">2.3.1.</span> <span class="nav-text">关于Callable&Future的介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建并开启线程的7种方式"><span class="nav-number">2.4.</span> <span class="nav-text">创建并开启线程的7种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关问题"><span class="nav-number">2.5.</span> <span class="nav-text">相关问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关文章"><span class="nav-number">2.6.</span> <span class="nav-text">相关文章</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程的常用方法"><span class="nav-number">3.</span> <span class="nav-text">线程的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt-停止线程"><span class="nav-number">3.1.</span> <span class="nav-text">interrupt(停止线程)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先看下终止线程的三种方法"><span class="nav-number">3.1.1.</span> <span class="nav-text">先看下终止线程的三种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例代码"><span class="nav-number">3.1.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setDeamon-守护线程"><span class="nav-number">3.2.</span> <span class="nav-text">setDeamon(守护线程)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join方法-临时加入线程"><span class="nav-number">3.3.</span> <span class="nav-text">join方法(临时加入线程)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield方法-临时停止线程-amp-setPriority-设置优先级-amp-toString-返回线程全部信息"><span class="nav-number">3.4.</span> <span class="nav-text">yield方法(临时停止线程) & setPriority(设置优先级) & toString(返回线程全部信息)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程的5种生命周期状态"><span class="nav-number">4.</span> <span class="nav-text">线程的5种生命周期状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程同步安全问题与互斥技术"><span class="nav-number">5.</span> <span class="nav-text">多线程同步安全问题与互斥技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观锁"><span class="nav-number">5.1.</span> <span class="nav-text">乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">5.1.1.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">5.1.2.</span> <span class="nav-text">volatile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#悲观锁"><span class="nav-number">5.2.</span> <span class="nav-text">悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-number">5.2.1.</span> <span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-同步代码块（互斥的代码块上锁，加任意对象锁）"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">1.同步代码块（互斥的代码块上锁，加任意对象锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-同步函数（互斥非静态方法上锁，加this锁）"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">2.同步函数（互斥非静态方法上锁，加this锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-静态同步函数-互斥静态方法上锁，加类锁"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">3.静态同步函数(互斥静态方法上锁，加类锁)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock"><span class="nav-number">5.2.2.</span> <span class="nav-text">Lock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">5.3.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程间通信问题"><span class="nav-number">6.</span> <span class="nav-text">多线程间通信问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间通信机制"><span class="nav-number">6.1.</span> <span class="nav-text">线程间通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等待唤醒机制"><span class="nav-number">6.1.1.</span> <span class="nav-text">等待唤醒机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等待唤醒机制示例"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">等待唤醒机制示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件对象Condition"><span class="nav-number">6.1.2.</span> <span class="nav-text">条件对象Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列BlockingQueue"><span class="nav-number">6.1.3.</span> <span class="nav-text">阻塞队列BlockingQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者模型"><span class="nav-number">6.2.</span> <span class="nav-text">生产者消费者模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关问题-1"><span class="nav-number">6.3.</span> <span class="nav-text">相关问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程管理类-线程池"><span class="nav-number">7.</span> <span class="nav-text">线程管理类(线程池)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池介绍"><span class="nav-number">7.1.</span> <span class="nav-text">线程池介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-Thread的弊端"><span class="nav-number">7.2.</span> <span class="nav-text">new Thread的弊端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executors"><span class="nav-number">7.3.</span> <span class="nav-text">Executors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关问题-2"><span class="nav-number">7.3.1.</span> <span class="nav-text">相关问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">7.4.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程范围内共享变量"><span class="nav-number">8.</span> <span class="nav-text">线程范围内共享变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">8.1.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个线程访问共享对象和数据的方法"><span class="nav-number">8.2.</span> <span class="nav-text">多个线程访问共享对象和数据的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原子类"><span class="nav-number">9.</span> <span class="nav-text">原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicInteger、AtomicBoolean等等"><span class="nav-number">9.1.</span> <span class="nav-text">AtomicInteger、AtomicBoolean等等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AtomicFile"><span class="nav-number">9.2.</span> <span class="nav-text">AtomicFile</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程安全容器类"><span class="nav-number">10.</span> <span class="nav-text">线程安全容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">10.1.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">10.2.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWrite容器"><span class="nav-number">10.3.</span> <span class="nav-text">CopyOnWrite容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发Queue"><span class="nav-number">10.4.</span> <span class="nav-text">并发Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sorted容器"><span class="nav-number">10.5.</span> <span class="nav-text">Sorted容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#相关多线程文章"><span class="nav-number">11.</span> <span class="nav-text">相关多线程文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恒星</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
