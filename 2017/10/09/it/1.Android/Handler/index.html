<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />





  <link rel="alternate" href="/atom.xml" title="恒星的轨迹" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android —— 异步任务机制 &amp; 消息通知机制">
<meta property="og:url" content="https://hengxing0080.github.io/2017/10/09/it/1.Android/Handler/index.html">
<meta property="og:site_name" content="恒星的轨迹">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_android_handler_logo.gif">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_android_handler.jpg">
<meta property="og:image" content="https://hengxing0080.github.io/images/it_android_handler_loop1.png">
<meta property="og:updated_time" content="2017-11-14T15:32:54.568Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android —— 异步任务机制 &amp; 消息通知机制">
<meta name="twitter:image" content="https://hengxing0080.github.io/images/it_android_handler_logo.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":120,"offset_float":0,"b2t":true,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hengxing0080.github.io/2017/10/09/it/1.Android/Handler/"/>





  <title>Android —— 异步任务机制 & 消息通知机制 | 恒星的轨迹</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  









<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500489903");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>







  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">恒星的轨迹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">时间在流逝...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://hengxing0080.github.io/2017/10/09/it/1.Android/Handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="恒星">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="恒星的轨迹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android —— 异步任务机制 & 消息通知机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-09T18:08:33+08:00">
                2017-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IT-Android/" itemprop="url" rel="index">
                    <span itemprop="name">IT - Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/images/it_android_handler_logo.gif" alt="UML图"><br><a id="more"></a></p>
<p>在Android中实现异步任务机制有两种方式：Handler和AsyncTask</p>
<p>Handler模式需要为每一个任务创建一个新的线程，任务完成后通过Handler实例向UI线程发送消息，完成界面的更新，这种方式对于整个过程的控制比较精细，但也是有缺点的，例如代码相对臃肿，在多个任务同时执行时，不易对线程进行精确的控制。</p>
<p>AsyncTask任务由计算运行在后台线程上，其结果发表在UI线程上。<br>它有三种参数类型：Params, Progress and Result 和四个步骤：onPreExecute, doInBackground, onProgressUpdate 和 onPostExecute。</p>
<hr>
<h1 id="Handler消息处理模型"><a href="#Handler消息处理模型" class="headerlink" title="Handler消息处理模型"></a>Handler消息处理模型</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主线程和子线程的各种名称：<br>主线程/UI线程/UI Thread/Main Thread/Activity Thread/Single Thread<br>子线程/工作线程/工作者线程/异步线程/Work Thread</p>
<p>主线程简介：<br>它管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)<br>并根据AMS的要求（通过IApplicationThread接口，AMS为Client、ActivityThread.ApplicationThread为Server）负责调度和执行activities、broadcasts和其它操作。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前提知识：<br>所有使用UI界面的操作系统，后台都在运行着一个死循环。<br>它在不停地监听和接收用户发出的指令，一旦接收到指令就马上执行。</p>
<p>当前应用程序一启动的时候，系统就会给应用程序提供Looper(轮询器)。<br>子线程在需要修改UI界面的时候，给handler发送一个消息（Message），handler接收到消息后会把消息放到Looper内部维护的消息队列中，Looper内部维护的死循环会不停的从消息队列中取消息，一旦取到消息就会发送给handler，然后handler再去修改UI界面。</p>
<p>Handler是android给我们提供用来更新UI的一套机制，也是一套消息处理的机制，我们可以通过它发送消息，也可以通过它处理消息。</p>
<p>Android在设计的时候，就封装了一套创建，传递，处理机制，如果不遵循这样的机制的话就没有办法更新UI信息的，就会抛出异常信息。</p>
<p>当应用程序启动时，android首先会开启一个主线程（UI线程），主线程为管理界面中的UI控件，进行事件分发。<br>如果此时需要一个耗时的操作，例如：联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象，如果5秒钟还没有完成的话，会收到Android系统的一个错误提示“强制关闭”</p>
<p>只有创建视图（创建UI界面的那个线程）的那个线程才能修改视图。<br>只有主线程（UI线程）才能修改UI界面。<br>子线程不能直接修改UI界面，所以有了Handler消息处理机制。</p>
<h2 id="消息模型图示"><a href="#消息模型图示" class="headerlink" title="消息模型图示"></a>消息模型图示</h2><p><img src="/images/it_android_handler.jpg" alt="UML图"></p>
<h2 id="消息模型组成"><a href="#消息模型组成" class="headerlink" title="消息模型组成"></a>消息模型组成</h2><p>1.Handler<br>消息处理器(运行在主线程, 生成，发送，处理消息)<br>常用方法:<br>handleMessage(Message)<br>覆盖此方法，做UI的处理消息结果( 运行在主线程里, 去更新UI)</p>
<p>2.Message 和 Message Queue<br>Message：消息(数据载体)<br>Message Queue：存储消息的队列(FIFO)，容器，单链表，会按时间排序，它被封装到Looper里面。</p>
<p>4.Looper<br>信息的轮询器，轮询取消息，linux底层管道通讯<br>运行在主线程（主线程一启动就有默认的Looper，如果在子线程肯定没有轮询器，得需要额外new）<br>用来轮询MessageQueue，调用Message中的数据<br>里面写死循环<br>它有start方法，开始轮询</p>
<p>细节:<br>在主线程new handler，就自动有了轮询器和消息队列<br>在子线程new handler，就得手动new轮询器</p>
<p>总结：<br>handler负责发送消息<br>MessageQueue就是一个存储消息的容器<br>Looper负责接收handler发送的消息，并直接将消息回传给Handler自己</p>
<p>他们三者的关系是：<br>MessageQueue和Looper是一一对应的<br>一个Looper可以对应多个Handler<br>同时这里还有一个角色就是线程Thread.当然Thread和Looper的关系也是一一对应的。</p>
<p>他们三者配合的最大好处：<br>Looper Handler Message 基本上可以应付多线程编程</p>
<h2 id="消息模型目地"><a href="#消息模型目地" class="headerlink" title="消息模型目地"></a>消息模型目地</h2><p>负责Android系统的主线程安全，别的线程不可以修改ui线程的界面。<br>如果子线程里面想去更新ui，必须采用消息机制处理子线程更新ui的步骤  </p>
<h2 id="子线程更新UI的几种方式"><a href="#子线程更新UI的几种方式" class="headerlink" title="子线程更新UI的几种方式"></a>子线程更新UI的几种方式</h2><p>–不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的</p>
<p>1.消息机制(Handler)<br>（1）.Handler.post(Runnable r), Handler.postAtTime(Runnable, long), Handler.postDelayed(Runnable, long)<br>（2）.handler.sendMessage(Meaaage msg) </p>
<p>2: Activity的runOnUiThread方法  </p>
<p>3.View<br>View.post(Runnable)<br>View.postDelayed(Runnable, long)</p>
<h2 id="自定义子线程更新UI"><a href="#自定义子线程更新UI" class="headerlink" title="自定义子线程更新UI"></a>自定义子线程更新UI</h2><p><a href="http://blog.csdn.net/jiangwei0910410003/article/details/17021809" target="_blank" rel="external">http://blog.csdn.net/jiangwei0910410003/article/details/17021809</a></p>
<h3 id="使用Handle的sendMessage修改UI界面"><a href="#使用Handle的sendMessage修改UI界面" class="headerlink" title="使用Handle的sendMessage修改UI界面"></a>使用Handle的sendMessage修改UI界面</h3><p>步骤：<br>1.在主线程里面声明handler，并重写handler的方法处理消息<br>private Handler handler = new Handler(){} ;<br>    public void handleMessage(Message msg) {<br>        // 运行在主线程，更新ui</p>
<pre><code>};
</code></pre><p>2.子线程想去更新ui，利用消息机制,系统内部有消息队列和looper，轮询到消息，交给handler去处理<br>Message msg = new Message();<br>msg.what 消息类型<br>msg.obj 具体消息携带的数据<br>handler.sendMessage(msg); // 给主线程发送一个消息，表示我要修改UI界面了</p>
<p>3.线程授权handler，hanlder的修改UI界面（handleMessage方法执行具体逻辑）</p>
<p>Handler sendMessage的代码模板：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">	main thread&#123;</div><div class="line">	TextView tv=(TextView) findViewById(.....);</div><div class="line">	<span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">			<span class="keyword">switch</span>(msg.what)&#123;</div><div class="line">				<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">					String text = (String)msg.obj;</div><div class="line">					tv.setText(text);</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">			String s = <span class="string">"haha"</span>;</div><div class="line">			<span class="comment">// 只想刷新UI</span></div><div class="line">			Message msg = Message.obtain();</div><div class="line">			msg.what=<span class="number">0</span>;</div><div class="line">			msg.obj = s；</div><div class="line">			handler.sendMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;)	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Handler的handleMessage方法可以在子线程执行吗？<br>可以，取决于looper，默认的时候用的是系统的looper，默认在主函数，就是主线程执行</p>
<h3 id="使用Handler的post-方法修改UI界面"><a href="#使用Handler的post-方法修改UI界面" class="headerlink" title="使用Handler的post()方法修改UI界面"></a>使用Handler的post()方法修改UI界面</h3><p>如果常见Handler对象时，没有覆盖handleMessage(Message mg)方法时，只能通过post（）方法发送Runable对象传递消息，当调用post方法时，自动调用Runnable对象的run（）方法，Runnable对象只是作为一个封装了操作的对象被传递，并未产生新线程。</p>
<p>关于handler.post方法和handler.sendmessage方法的区别：<br>相关文章：<br><a href="http://blog.csdn.net/u012534831/article/details/52212239" target="_blank" rel="external">handler.post方法的终极最直观的理解与解释</a></p>
<p>Handler post的代码模板：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">main thread&#123;</div><div class="line">	TextView tv=(TextView) findViewById(.....);</div><div class="line">	<span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;&#125;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">				String s = <span class="string">"haha"</span>;</div><div class="line">				handler.post(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">					<span class="comment">//只想刷新UI</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">						<span class="comment">//这段代码就是在主线程中执行的</span></div><div class="line">						tv.setText(s);</div><div class="line">					&#125;					</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">		&#125;)	</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然写法上相差很多，但是原理是完全一样的，我们在Runnable对象的run()方法里更新UI，效果完全等同于在handleMessage()方法中更新UI。</p>
<h3 id="使用Activity-runOnUiThread方法修改UI界面"><a href="#使用Activity-runOnUiThread方法修改UI界面" class="headerlink" title="使用Activity.runOnUiThread方法修改UI界面"></a>使用Activity.runOnUiThread方法修改UI界面</h3><p>运行在主线程，内部使用线程合并技术Join</p>
<p>用法示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		tv_result.setText(result); <span class="comment">// 修改界面</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;  </div><div class="line">        mHandler.post(action);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        action.run();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果当前的线程不等于UI线程(主线程)，<br>就去调用Handler的post()方法，<br>否则就直接调用Runnable对象的run()方法。</p>
<p>注意：<br>主线程里注意别写runOnUiThread，而且里面还写了耗时操作<br>看源码得知它的内部实现原理是handler发消息给主线程，主线程得到消息就把runnable逻辑又给主线程<br>这么写就白给了，还是在主线程执行耗时的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 耗时操作</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="使用View-post方法修改UI界面"><a href="#使用View-post方法修改UI界面" class="headerlink" title="使用View.post方法修改UI界面"></a>使用View.post方法修改UI界面</h3><p>post源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;  </div><div class="line">    Handler handler;  </div><div class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;  </div><div class="line">        handler = mAttachInfo.mHandler;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        ViewRoot.getRunQueue().post(action);  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> handler.post(action);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实就是调用了Handler中的post()方法</p>
<h2 id="Handler对象传递的几种方式"><a href="#Handler对象传递的几种方式" class="headerlink" title="Handler对象传递的几种方式"></a>Handler对象传递的几种方式</h2><p>android多个Activity可以共用一个handler进行发送消息吗？</p>
<p>1.整个主UI ，只创建一个handler,即全局的handler.然后多个activity共享这一个handler,发送消息。<br>优点： 只用一个消息循环，比较能提高性能。<br>缺点： 发送消息时，传递数据不方便。需要将activity的 各变量值打包 传递给这个全局的handler. </p>
<p>2.每一个Activity创建一个handler,当前Activity就用它自己的handler变量来发送消息。<br>优点：发送消息时，传递数据很方便，因为就利用当前activity类里的变量值。<br>缺点：创建了多个消息队列，容易忘掉释放，影响性能。 </p>
<h3 id="1-创建一个HandlerManager管理工具类"><a href="#1-创建一个HandlerManager管理工具类" class="headerlink" title="1.创建一个HandlerManager管理工具类"></a>1.创建一个HandlerManager管理工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">在不同的类中实现同一个Handler处理，可以通过Handler对象传递的方式来解决，</div><div class="line">实现原理：通过ThreadLocal来存储Handler对象，通过线程id来查找指定线程上的变量。</div><div class="line">创建一个HandlerManager管理工具类，将要传递的Handler对象保存到该类下进行管理，然后在其他类中获得Handler对象即可传递消息。</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerManager</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Handler&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Handler&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> threadLocal.get();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putHandler</span><span class="params">(Handler value)</span> </span>&#123;</div><div class="line">		threadLocal.set(value);<span class="comment">// UiThread  id</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-Application全局共享和利用广播机制"><a href="#2-Application全局共享和利用广播机制" class="headerlink" title="2.Application全局共享和利用广播机制"></a>2.Application全局共享和利用广播机制</h3><p>相关文章：<br><a href="http://blog.csdn.net/jason0539/article/details/18055259" target="_blank" rel="external">android之在activity中控制另一个activity的UI更新_如何在activity之间传递handler</a><br><a href="http://blog.csdn.net/jason0539/article/details/18075293" target="_blank" rel="external">android之如何在两个activity之间传递handler_利用broadcast广播机制</a></p>
<h2 id="Handler用法注意"><a href="#Handler用法注意" class="headerlink" title="Handler用法注意"></a>Handler用法注意</h2><p>1.在 Activity 中尽可能少的创建 Handler 对象，创建一个主线程 Handler，一个后台 HandlerThread 就可以了。</p>
<p>2.Handler机制有一个特点是不会随着Activity、Service的生命周期结束而结束。<br>也就是说，如果你Post了一个Delay的Runnable，然后在Runnable执行之前退出了Activity，Runnable到时间之后还是要执行的。如果Runnable里面包含更新View的操作，程序崩溃了。</p>
<p>3.不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突</p>
<p>4.Handler 发两个消息导致主线程阻塞<br>注意，Handler发2个消息会挂<br>Message msg = Message.obtain();<br>hanlder.sendMessage(msg);<br>looper轮询器处理消息，msg处理完，销毁（把msg所有属性重置为默认值，并不是回收对象）</p>
<h2 id="Handler其他面试题"><a href="#Handler其他面试题" class="headerlink" title="Handler其他面试题"></a>Handler其他面试题</h2><p>1.请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系</p>
<p>谷歌为防止多个子线程更新UI混乱，把安卓的界面显示做成了单线程模型</p>
<p>子线程委托主线程的handler调用它的handlemessage来更新UI，类似代理设计模式</p>
<p>Activity是一个UI线程，运行于主线程中，Android系统在启动的时候会为Activity创建一个消息队列和消息循环（Looper）。</p>
<p>UI线程（主线程）定义了一个集合（Message queue）消息队列<br>主线程里有一个Looper，一旦它调用了loop方法，loop内部是死循环，它会不停的获取message queue里的消息<br>这个死循环是个阻塞式死循环，类似socket监听端口就停在这了，并不是停止，而是等待，一旦有消息到来，就接消息就处理下<br>Loop执行的方式和socket很像，没消息就停留等待，有消息就取消息执行<br>举例：Thread A和ThreadB拿到主线程里面的handler（它把消息放在message queue里）一放进来，looper就发现有消息到来了，就执行loop方法获取消息，就调用handlemessage方法来更新UI（因为looper和message queue都在主线程，所以能更新UI）</p>
<p>2.对android主线程的运用和理解</p>
<p>只要与图像相关的，主线程都是死循环（阻塞式死循环，有消息接收，没消息等待）<br>4大组件都是通过消息机制操作的</p>
<p>主ui线程不能执行耗时的操作,<br>主线程也不能阻塞太长时间会导致内容提供者r和广播接受者处理不了<br>主线程不仅负责UI的更新，还有系统事件，所以必须要保留一个较高的优先级，<br>假设有事件到来就得立刻处理，所以尽量不要再主线程执行耗时的操作<br>只是觉得代码执行时间多就放在子线程里</p>
<p>3.一个线程怎样把消息放入主线程的消息队列呢？<br>答案是通过Handle对象，只要Handler对象以主线程的Looper创建，那么调用Handler的sendMessage等接口，将会把消息放入队列都将是放入主线程的消息队列。并且将会在Handler主线程中调用该handler的handleMessage接口来处理消息。</p>
<p>4.Handler的作用<br>是把消息加入特定的（Looper）消息队列中，并分发和处理该消息队列中的消息。<br>构造Handler的时候可以指定一个Looper对象，如果不指定则利用当前线程的Looper创建。</p>
<p>5.直接在子线程中创建Handler为什么会报错</p>
<p>在子线程中创建handler时会报以下错误<br>Can’t create handler inside thread that has not called Looper.prepare()</p>
<p>总结一下就是在主线程中可以直接创建Handler对象<br>而在子线程中需要先调用Looper.prepare()才能创建Handler对象。</p>
<p>相关文章：<br><a href="http://blog.csdn.net/jay1on/article/details/52988689" target="_blank" rel="external">Android 直接在子线程中创建Handler为什么会报错</a></p>
<p>6.Android子线程真的不能更新UI么<br><a href="http://www.cnblogs.com/lao-liang/p/5108745.html" target="_blank" rel="external">http://www.cnblogs.com/lao-liang/p/5108745.html</a></p>
<h2 id="Handler其他使用场景"><a href="#Handler其他使用场景" class="headerlink" title="Handler其他使用场景"></a>Handler其他使用场景</h2><p>handler能与Looper配合实现经典的Pipeline Thread(流水线线程)模式。<br><a href="http://blog.csdn.net/runninglion/article/details/40627381" target="_blank" rel="external">Android Guts: Intro to Loopers and Handlers</a></p>
<h2 id="Handler内存泄露"><a href="#Handler内存泄露" class="headerlink" title="Handler内存泄露"></a>Handler内存泄露</h2><p>注意：<br>避免使用非静态内部类</p>
<p>解决方案：<br>1.使用显形的引用<br>1.1.静态内部类<br>1.2.放在外部类(单独的类文件)</p>
<p>2.使用弱引用 WeakReference<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * Handler：静态内部类的方式避免内存泄漏</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_2 = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_3 = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mHandler.sendMessageDelayed(Message.obtain(), <span class="number">60000</span>);</div><div class="line">        finish();<span class="comment">// just finish this activity</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;HandlerActivity2&gt; mActivity;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</div><div class="line">            mActivity = <span class="keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            System.out.println(msg);</div><div class="line">            <span class="keyword">if</span> (mActivity.get() == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mActivity.get().todo();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span> </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>还没完，上面这样就可以了吗？No</p>
<p>3.Activity onStop或者onDestroy,取消掉该Handler对象的Message和Runnable。 通过查看Handler的API，它有几个方法：<br>removeCallbacks(Runnable r)和removeMessages(int what)等。<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一切都是为了不要让mHandler拖泥带水</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    mHandler.removeMessages(MESSAGE_1);</div><div class="line">    mHandler.removeMessages(MESSAGE_2);</div><div class="line">    mHandler.removeMessages(MESSAGE_3);</div><div class="line">    <span class="comment">// ... ...</span></div><div class="line">    mHandler.removeCallbacks(mRunnable);</div><div class="line">    <span class="comment">// ... ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果上面觉的麻烦，也可以如下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//  If null, all callbacks and messages will be removed.</span></div><div class="line">    mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="http://droidyue.com/blog/2014/12/28/in-android-handler-classes-should-be-static-or-leaks-might-occur/" target="_blank" rel="external">Android中Handler引起的内存泄露</a><br><a href="http://www.open-open.com/lib/view/open1455981510995.html" target="_blank" rel="external">Android内存泄露之Handler</a></p>
<h2 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h2><p>Handler的上层源码分析：<br><a href="http://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="external">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a><br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/17021809" target="_blank" rel="external">Android中的Handler,Looper,Message机制</a></p>
<p>Handler工作机制的底层原理：<br>Handler发消息的时候会往管道里写字符串“W”来唤醒主线程<br><a href="http://blog.csdn.net/jiangwei0910410003/article/details/39692607" target="_blank" rel="external">Android中对消息机制(Handler)的再次解读</a></p>
<h2 id="关于Message"><a href="#关于Message" class="headerlink" title="关于Message"></a>关于Message</h2><p>在线API：<br><a href="https://developer.android.google.cn/reference/android/os/Message.html" target="_blank" rel="external">https://developer.android.google.cn/reference/android/os/Message.html</a></p>
<p>概述：<br>Message被放在MessageQueue中<br>一个MessageQueue中可以包含多个Message对象<br>每个Message对象可以通过Message.Obtain()或Handler.ObtainMessage()方法获得。</p>
<p>注意：<br>1)使用Message类的属性可以携带int数据，如果要携带其他类型的数据，可以先将要携带的数据保存到Bundle对象中，然后通过Message类的setData方法将添加到Message中。<br>2)尽管Message有public的默认构造函数，但是通常情况下需要使用Message.obtain()或Handler.obainMessage()方法来从消息池中获得空消息对象，以节省资源<br>3)尽可能使用Message.what来表示信息，以使用不同处理Message</p>
<h3 id="获取Message的三种方式"><a href="#获取Message的三种方式" class="headerlink" title="获取Message的三种方式"></a>获取Message的三种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.Message msg = <span class="keyword">new</span> Message();    </div><div class="line"><span class="comment">// 不推荐</span></div><div class="line"></div><div class="line"><span class="number">2</span>.Message msg = Message.obtain();  </div><div class="line"><span class="comment">// 复用Message对象，去池子里取，节省创建和销毁事件，节省资hanlder.sendMessage(msg);</span></div><div class="line"></div><div class="line"><span class="number">3</span>.Message msg = handler.obtainMessage(); </div><div class="line"><span class="comment">// 和上面的区别就是这个msg已经和handler绑定</span></div><div class="line"><span class="comment">// msg.sendToTarget();	搭配这个方法使用可以连续调用，如</span></div><div class="line"><span class="comment">// handler.obtainMessage(GET_USERS_DATA_OK, users).sendToTarget();</span></div><div class="line"><span class="comment">// 在给Handler发送消息的时候没必要每次都new Message()，而是使用handler.obtainMessage()，它会先看看消息队列里面有没有没用的消息，如果有可以复用消息对象。</span></div></pre></td></tr></table></figure>
<h2 id="关于Looper"><a href="#关于Looper" class="headerlink" title="关于Looper"></a>关于Looper</h2><p>在线API：<br><a href="https://developer.android.google.cn/reference/android/os/Looper.html" target="_blank" rel="external">https://developer.android.google.cn/reference/android/os/Looper.html</a></p>
<h3 id="Looper的开启和关闭"><a href="#Looper的开启和关闭" class="headerlink" title="Looper的开启和关闭"></a>Looper的开启和关闭</h3><p>在写Looper.loop()之后代码不会执行，该方法内部是一个循环<br>当调用Handler.getLooper().quit()方法后，loop（）等等才会终止，之后的代码才能运行。</p>
<h3 id="一个线程中，能有几个Looper和Handler"><a href="#一个线程中，能有几个Looper和Handler" class="headerlink" title="一个线程中，能有几个Looper和Handler?"></a>一个线程中，能有几个Looper和Handler?</h3><p>在一个线程中<br>只能有一个Looper和MessageQueue<br>但是可以有多个Handler，而且这些Handler可以共享同一个Looper和MessageQueue。<br><img src="/images/it_android_handler_loop1.png" alt="UML图"></p>
<h3 id="Loop能不能在子线程中定义"><a href="#Loop能不能在子线程中定义" class="headerlink" title="Loop能不能在子线程中定义"></a>Loop能不能在子线程中定义</h3><p>loop不是共享的，可以在子线程中定义.</p>
<h3 id="在非主线程中创建Handler对象，需要手动New-Looper吗？"><a href="#在非主线程中创建Handler对象，需要手动New-Looper吗？" class="headerlink" title="在非主线程中创建Handler对象，需要手动New Looper吗？"></a>在非主线程中创建Handler对象，需要手动New Looper吗？</h3><p>在android中，一个线程对应一个Looper对象，而一个Looper对象又对应一个MessageQueue（消息队列），<br>MessageQueue用于存放Message（消息），在MessageQueue中存放的消息按照FIFO（先进先出）原则执行，<br>由于MessageQueue被封装到Looper（轮询器）里面。<br>Looper对象用来为一个线程开启一个消息循环，从而操作MessageQueue。<br>默认情况下，android中新创建线程是没有开启消息循环的，但是主线程除外，系统自动为主线程创建Looper对象，开启消息循环，所以，当在主线程中创建Handler对象时不会产生异常。<br>如果要在非主线程中创建Handler对象，首先需要使用Looper类的prepare（）方法来初始化一个Looper对象，然后创建该Handler对象，使用Looper类的loop（）方法启动Looper，从消息队列中获取和处理消息。</p>
<hr>
<h1 id="HandlerThread消息处理器线程"><a href="#HandlerThread消息处理器线程" class="headerlink" title="HandlerThread消息处理器线程"></a>HandlerThread消息处理器线程</h1><hr>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>在线API：<a href="http://www.android-doc.com/reference/android/os/HandlerThread.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/os/HandlerThread.html</a></p>
<p>名称：消息处理器线程 类</p>
<p>作用：代替不停new Thread开子线程的重复体力写法</p>
<p>概述：<br>Android提供了一个封装好的带有looper的线程类，即为HandlerThread</p>
<p>从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。</p>
<p>单一线程 + 任务队列 处理轻量的异步任务 </p>
<p>确实比较适合单线程+异步队列的场景，比如应用刚进入时的数据初始化操作，如果开启多个线程同时执行，有可能争夺UI线程的CPU执行时间，造成卡顿，这个使用单线程+一异步队列模型，设置优先级之后，就可以将同步工作顺序执行，而又不影响UI的初始化</p>
<p>Handler会关联一个单独的线程和消息队列。Handler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。如果要在其他线程执行，可以使用HandlerThread。<br>HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>封装一个轻量级的任务处理器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightTaskManager</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Handler mHandler;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LightTaskManager</span><span class="params">()</span> </span>&#123;</div><div class="line">        HandlerThread workerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"LightTaskThread"</span>);</div><div class="line">        <span class="comment">// 设置优先级(后台线程建议设置这个优先级，值为10)</span></div><div class="line">        <span class="comment">// HandlerThread workerThread = new HandlerThread("LightTaskThread", Process.THREAD_PRIORITY_BACKGROUND);</span></div><div class="line"></div><div class="line">        workerThread.start();</div><div class="line">        mHandler = <span class="keyword">new</span> Handler(workerThread.getLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable run)</span> </span>&#123;</div><div class="line">        mHandler.post(run);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable runnable)</span> </span>&#123;</div><div class="line">        mHandler.postAtFrontOfQueue(runnable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable runnable, <span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        mHandler.postDelayed(runnable, delay);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postAtTime</span><span class="params">(Runnable runnable, <span class="keyword">long</span> time)</span> </span>&#123;</div><div class="line">        mHandler.postAtTime(runnable, time);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="http://blog.csdn.net/double2hao/article/details/58598171" target="_blank" rel="external">HandlerThread的使用以及原理</a><br><a href="http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/" target="_blank" rel="external">详解 Android 中的 HandlerThread</a></p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://www.infoq.com/cn/articles/android-worker-thread" target="_blank" rel="external">关于Android中工作者线程的思考</a><br><a href="http://www.3lian.com/edu/2012/11-19/44762.html" target="_blank" rel="external">详解 Android 中的 HandlerThread</a><br><a href="http://www.3lian.com/edu/2012/11-19/44762.html" target="_blank" rel="external">HandlerThread，Handler，Thread使用方法</a></p>
<hr>
<h1 id="AsyncQueryHandler异步查询框架"><a href="#AsyncQueryHandler异步查询框架" class="headerlink" title="AsyncQueryHandler异步查询框架"></a>AsyncQueryHandler异步查询框架</h1><hr>
<p>如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的<br>需要注意的是，这玩意儿吃异常..</p>
<p>相关文章：<br><a href="https://www.cnblogs.com/yejiurui/archive/2012/12/28/2837760.html" target="_blank" rel="external">Android异步查询框架AsyncQueryHandler使用简介</a></p>
<hr>
<h1 id="AsyncTask异步任务"><a href="#AsyncTask异步任务" class="headerlink" title="AsyncTask异步任务"></a>AsyncTask异步任务</h1><hr>
<h2 id="AsyncTask简介"><a href="#AsyncTask简介" class="headerlink" title="AsyncTask简介"></a>AsyncTask简介</h2><p>所属包：android.os<br>在线API：<a href="http://www.android-doc.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/os/AsyncTask.html</a></p>
<p>Protected Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">onPreExecute()</div><div class="line">onPostExecute(Bitmap result)</div><div class="line">onProgressUpdate(Progress...params)</div><div class="line">doInBackground(Void... params) </div><div class="line">publishProgress(Progress... values)</div><div class="line">onCancelled(Result result) </div><div class="line">onCancelled()</div></pre></td></tr></table></figure></p>
<p>Public Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span>	<span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span>	<span class="title">execute</span><span class="params">(Runnable runnable)</span></div><div class="line"><span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt;	<span class="title">execute</span><span class="params">(Params... params)</span></div><div class="line"><span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt;	<span class="title">executeOnExecutor</span><span class="params">(Executor exec, Params... params)</span></div><div class="line"><span class="keyword">final</span> Result	<span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></div><div class="line"><span class="keyword">final</span> Result	<span class="title">get</span><span class="params">()</span></div><div class="line"><span class="keyword">final</span> AsyncTask.Status	<span class="title">getStatus</span><span class="params">()</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span>	<span class="title">isCancelled</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>AsyncTask三个参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">AsyncTask&lt;Params, Progress, Result&gt;</div><div class="line"><span class="number">1</span>.Params 启动任务执行的传输的参数，比如HTTP请求的URL</div><div class="line"><span class="number">2</span>.Progress 下载相关的，进度提示（Integer，Float）</div><div class="line"><span class="number">3</span>.Result 后台执行任务最终返回的结果，比如String,Integer</div></pre></td></tr></table></figure></p>
<p>AsyncTask执行的四个步骤：<br>每一步都对应一个回调方法，开发者需要实现这些方法：<br>1)继承AsyncTask<br>2)实现AsyncTask中定义的下面一个或几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">onPreExecute()</div><div class="line">该方法将在执行实际的后台操作前被UI 线程调用。</div><div class="line">可以在该方法中做一些准备工作，如在界面上显示一个进度条，或者一些控件的实例化，这个方法可以不用实现。</div><div class="line"></div><div class="line">doInBackground(Params... params)</div><div class="line">将在onPreExecute 方法执行后马上执行，该方法运行在后台线程中。</div><div class="line">这里将主要负责执行那些很耗时的后台处理工作。</div><div class="line">可以调用 publishProgress方法来更新实时的任务进度。</div><div class="line">该方法是抽象方法，子类必须实现。</div><div class="line"></div><div class="line">onPostExecute(Result)</div><div class="line">在doInBackground 执行完成后，onPostExecute 方法将被UI 线程调用，</div><div class="line">后台的计算结果将通过该方法传递到UI 线程，并且在界面上展示给用户.</div><div class="line"></div><div class="line">onProgressUpdate(Progress...params)</div><div class="line">在publishProgress方法被调用后，</div><div class="line">UI 线程将调用这个方法从而在界面上展示任务的进展情况，例如通过一个进度条进行展示。</div><div class="line"></div><div class="line">onCancelled()</div><div class="line">在用户取消线程操作的时候调用，运行在UI线程中。</div><div class="line">在主线程中调用onCancelled()的时候回调该方法。</div></pre></td></tr></table></figure></p>
<p>历史：<br>Android API 3（1.5 Cupcake）开始，AsyncTask被引入用来帮助开发者更简单地管理线程。<br>实际上在Android 1.0和1.1也是有类似的实现，那就是UserTask。UserTask和AsyncTask有着相同的API及实现，但是由于由于1.0和1.1的设备份额微乎其微，这里的概念就不会涉及到UserTask。</p>
<p>使用场景：<br>1.handler能用的地方也是他使用的地方（UI更新）<br>2.做耗时操作时，需要开线程去执行，执行完成后，ui更新<br>3.和ui打交道</p>
<p>使用关键点：<br>使用AsyncTask需要确保AsyncTask正确地取消</p>
<p>注意：<br>不同API版本的AsyncTask实现不一样，有的是可以同时执行多个任务，有的API中只能同时执行一个线程，所以在程序中同时执行多个AsyncTask时有可能遇到一个AsyncTask的excute方法后很久都没有执行。</p>
<p>为了正确的使用AsyncTask类，以下是几条必须遵守的准则：<br>1) Task的实例必须在UI 线程中创建<br>2) execute方法必须在UI 线程中调用<br>3) 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法，需要在UI线程中实例化的task来调用。<br>4) 该task只能被执行一次，否则多次调用时将会出现异常<br>5）executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)，如果操作的线程过多，会出现线程等待现象，可以使用该方法来避免。</p>
<p>AsyncTask和Handler区别<br>这俩类都是用来实现异步的，其中AsyncTask的集成度较高，使用简单，Handler则需要手动写Runnable或者Thread的代码；另外，由于AsyncTask内部实现了一个非常简单的线程池，实际上是只适用于轻量级的异步操作的，AsyncTask 通过重写的方式是可以用于长耗时操作的.</p>
<p>常见问题：<br>调用AsyncTask的excute方法不能立即执行程序的原因分析及改善方案：<br><a href="http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html" target="_blank" rel="external">http://zmywly8866.github.io/2015/09/29/android-call-asynctask-excute-not-run.html</a></p>
<p>推荐替换方案：<br>Loaders</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Android中的线程池技术</p>
<p>用于异步任务处理</p>
<p>异步任务是一个简单的异常调用的框架，把需求抽象成了模板，<br>做操作之前更新一下UI（onPreExecute）<br>后台有一个耗时的任务（doInBackGroup），<br>耗时的任务做完了就要更新界面了（onPostExecute）<br>这些方法定义成模板，留一些抽象的代码让人去实现，这就是框架</p>
<p>Android消息机制的UI线程时不安全的，如果想要在子线程里进行UI操作，就需要借助android的异步消息处理机制。<br>为了更加方便在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它可以非常灵活方便地从子线程切换到UI线程</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TextView    tv;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        tv = (TextView) findViewById(R.id.tv);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.HONEYCOMB)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clickStart</span><span class="params">(View view)</span></span>&#123;</div><div class="line">        <span class="comment">// 异步任务</span></div><div class="line">        <span class="comment">// 执行顺序 onPreExecute --》 doInBackground --》 onPostExecute</span></div><div class="line">        <span class="comment">// 参数：</span></div><div class="line">        <span class="comment">// 1: 执行任务传人的参数,doInBackground的参数</span></div><div class="line">        <span class="comment">// 2: 执行的进度 onProgressUpdated的参数</span></div><div class="line">        <span class="comment">// 3: 执行结果参数，是doInBackground的返回值，是onPostExecute的参数</span></div><div class="line">        AsyncTask&lt;String, Integer, Long&gt; task = <span class="keyword">new</span> AsyncTask&lt;String, Integer, Long&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="comment">// 主线程中执行，准备执行耗时操作前（用于在执行后台任务前做一些UI操作)</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span></span>&#123; </div><div class="line">                <span class="keyword">super</span>.onPreExecute();</div><div class="line">                tv.setText(<span class="string">"开始加载"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 是在子线程（线程池）中执行的，执行耗时的操作（异步任务）,不可在此方法内修改UI  </span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(String... params)</span></span>&#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</div><div class="line">                    <span class="keyword">try</span>&#123;</div><div class="line">                        Thread.sleep(<span class="number">100</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    publishProgress(i); <span class="comment">// 公布进度,最后onProgressUpdate方法将被执行   </span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="number">1000l</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 主线程中执行,用于更新进度信息，如果想触发他，需要调用publishProgress()</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span></span>&#123; </div><div class="line">                <span class="keyword">super</span>.onProgressUpdate(values)</div><div class="line">                tv.setText(values[<span class="number">0</span>] + <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 主线程中执行，耗时操作完成后的回调，用于在执行完后台任务后更新UI,显示结果 </span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span></span>&#123;   </div><div class="line">                <span class="keyword">super</span>.onPostExecute(result);</div><div class="line">                tv.setText(<span class="string">""</span> + result);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//用于在取消执行中的任务时更改UI  </span></div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;  </div><div class="line">                Log.i(TAG, <span class="string">"onCancelled()"</span>);  </div><div class="line">                tv.setText(<span class="string">"cancelled"</span>);  </div><div class="line">            &#125;  </div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 版本适配</span></div><div class="line">        <span class="comment">// 2.3和3.0以后的异步任务有什么区别？</span></div><div class="line">        <span class="comment">// android3.0之前是多线程的（new 多少个AsyncTask就开启多少个线程）</span></div><div class="line">        <span class="comment">// android3.0之后是单线程队列的(new多个AsyncTask时，一个接一个的开启线程，有先后顺序，需要排列，就是队列)</span></div><div class="line">        <span class="comment">// 当实际开发中需要多个AsyncTask的同时开启时，就需要版本控制来解决</span></div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.HONEYCOMB)&#123; 		</div><div class="line">        <span class="comment">// Build.VERSION.SDK_INT返回当前手机内的版本号</span></div><div class="line">		<span class="comment">// Build.VERSION_CODES.HONEYCOMB  android3.0版本</span></div><div class="line">            task.executeOnExecutor(Executors.newFixedThreadPool(<span class="number">3</span>));<span class="comment">// 3.0以上是单线程队列的</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            task.execute(); <span class="comment">// 3.0之前是多线程的</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不同版本出现的各种问题"><a href="#不同版本出现的各种问题" class="headerlink" title="不同版本出现的各种问题"></a>不同版本出现的各种问题</h2><p>参考文章：<br><a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/" target="_blank" rel="external">技术小黑屋——Android中糟糕的AsyncTask</a></p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>还有一种常见的情况就是，在Activity中使用非静态匿名内部AsyncTask类，由于Java内部类的特点，AsyncTask内部类会持有外部类的隐式引用。由于AsyncTask的生命周期可能比Activity的长，当Activity进行销毁AsyncTask还在执行时，由于AsyncTask持有Activity的引用，导致Activity对象无法回收，进而产生内存泄露。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>关于AsyncTask存在一个这样广泛的误解，很多人认为一个在Activity中的AsyncTask会随着Activity的销毁而销毁。然后事实并非如此。AsyncTask会一直执行doInBackground()方法直到方法执行结束。一旦上述方法结束，会依据情况进行不同的操作。</p>
<p>如果cancel(boolean)调用了，则执行onCancelled(Result)方法<br>如果cancel(boolean)没有调用，则执行onPostExecute(Result)方法<br>AsyncTask的cancel方法需要一个布尔值的参数，参数名为mayInterruptIfRunning,意思是如果正在执行是否可以打断,如果这个值设置为true，表示这个任务可以被打断，否则，正在执行的程序会继续执行直到完成。如果在doInBackground()方法中有一个循环操作，我们应该在循环中使用isCancelled()来判断，如果返回为true，我们应该避免执行后续无用的循环操作。</p>
<p>总之，我们使用AsyncTask需要确保AsyncTask正确地取消。</p>
<h3 id="不好好工作的cancel"><a href="#不好好工作的cancel" class="headerlink" title="不好好工作的cancel()"></a>不好好工作的cancel()</h3><p>简而言之的答案，有时候起作用。</p>
<p>如果你调用了AsyncTask的cancel(false)，doInBackground()仍然会执行到方法结束，只是不会去调用onPostExecute()方法。但是实际上这是让应用程序执行了没有意义的操作。那么是不是我们调用cancel(true)前面的问题就能解决呢？并非如此。如果mayInterruptIfRunning设置为true，会使任务尽早结束，但是如果的doInBackground()有不可打断的方法会失效，比如这个BitmapFactory.decodeStream() IO操作。但是你可以提前关闭IO流并捕获这样操作抛出的异常。但是这样会使得cancel()方法没有任何意义。</p>
<h3 id="结果丢失"><a href="#结果丢失" class="headerlink" title="结果丢失"></a>结果丢失</h3><p>另一个问题就是在屏幕旋转等造成Activity重新创建时AsyncTask数据丢失的问题。当Activity销毁并创新创建后，还在运行的AsyncTask会持有一个Activity的非法引用即之前的Activity实例。导致onPostExecute()没有任何作用。</p>
<h3 id="串行还是并行"><a href="#串行还是并行" class="headerlink" title="串行还是并行"></a>串行还是并行</h3><p>关于AsyncTask时串行还是并行有很多疑问，这很正常，因为它经过多次的修改。如果你并不明白什么时串行还是并行，可以通过接下来的例子了解，假设我们在一个方法体里面有如下两行代码</p>
<p>new AsyncTask1().execute();<br>new AsyncTask2().execute();</p>
<p>上面的两个任务时同时执行呢，还是AsyncTask1执行结束之后，AsyncTask2才能执行呢？实际上是结果依据API不同而不同。</p>
<p>在1.6(Donut)之前:<br>在第一版的AsyncTask，任务是串行调度。一个任务执行完成另一个才能执行。由于串行执行任务，使用多个AsyncTask可能会带来有些问题。所以这并不是一个很好的处理异步（尤其是需要将结果作用于UI试图）操作的方法。</p>
<p>从1.6到2.3(Gingerbread):<br>后来Android团队决定让AsyncTask并行来解决1.6之前引起的问题，这个问题是解决了，新的问题又出现了。很多开发者实际上依赖于顺序执行的行为。于是很多并发的问题蜂拥而至。</p>
<p>3.0（Honeycomb）到现在:<br>好吧，开发者可能并不喜欢让AsyncTask并行，于是Android团队又把AsyncTask改成了串行。当然这一次的修改并没有完全禁止AsyncTask并行。你可以通过设置executeOnExecutor(Executor)来实现多个AsyncTask并行。</p>
<p>看下源码看看AsyncTask的执行原理：<br>AsyncTask默认自己维护一个静态的线程池，而该线程池只允许同时执行一个线程，也就是说，不管多少个AsyncTask,只要是调用execute()方法，都是共享这个默认进程池的，你的任务必须在之前的任务执行完以后，才能执行。可以理解为，默认情况下，所有的AsyncTask在一个独立于UI线程的线程中执行，任务需要排队，先execute的先执行，后面的只能等。<br>当然，这是串行的源码，后期变成并行，乃至可串可并..不过核心还是线程池.</p>
<h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><p>核心底层原理：<br>里面封装了线程池和handle（但是不完全代替handler，handler可创建在子线程，asyncTask只能在主线程）<br>核心线程数5个<br>最大线程池128个</p>
<p>相关文章：<br><a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="external">Android AsyncTask完全解析，带你从源码的角度彻底理解</a></p>
<hr>
<h1 id="Loader加载器机制"><a href="#Loader加载器机制" class="headerlink" title="Loader加载器机制"></a>Loader加载器机制</h1><hr>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>相关文章：<br><a href="http://www.jianshu.com/p/385327e35711" target="_blank" rel="external">Android 深入理解Loader机制 让APP轻装上阵</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2014/0325/1602.html" target="_blank" rel="external">android 加载器loader详解</a></p>
<p>中文名：<br>加载器，装载机</p>
<p>历史：<br>android 3.0之后才被引入，它简化了在activity和fragment中异步加载数据的步骤，优雅的实现了异步加载</p>
<p>特点：<br>适用于每个activity和fragment异步加载数据，无需重新启动一个线程来执行数据加载.<br>提供异步加载的实现方法<br>实时更新数据，监听数据源的一举一动，在数据发生变更时自动返回新的结果<br>当由于配置改变而被重新创建后，它们自动重连到上一个加载器的游标，所以不必重新查询数据<br>异步加载也可以用asyncTask, 但是loader自带数据结果监听机制，可以方便优雅的进行UI更新<br>在Activity配置发生变化（如横竖屏切换）时不避免数据重复加载</p>
<p>作用：<br>主要完成单线程耗时数据异步装载功能，并在数据有更新自动通知UI刷新的作用</p>
<p>使用前提：<br>overLoad一般是由于开发者在主线程操作耗时操作，导致程序变慢 甚至出现的anr的现象<br>那么android早已为这种现象提供完美的解决方案：Loader机制</p>
<p>使用情景：<br>普通展现某个android手机有多少应用程序，加载已安装app时候，其实loader就能排上用场。</p>
<h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><p>使用loader的过程中可能会遇到这些类和接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.LoaderManager</div><div class="line">一个与activity和fragment相关联的抽象类，它管理一个或多个loader实例，</div><div class="line">帮助一个应用管理那些与Activity或Fragment的生命周期相关的长时间运行的的操作。</div><div class="line">最常见的方式是与一个CursorLoader一起使用，然而应用也可以自己写一个加载其他数据类型或者数据源的loader。</div><div class="line">每个activity或fragment只有一个LoaderManager。但是一个LoaderManager可以拥有多个加载器。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/app/LoaderManager.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/app/LoaderManager.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">2</span>.LoaderManager.LoaderCallbacks	</div><div class="line">一个用于客户端与LoaderManager交互的回调接口。</div><div class="line">例如，你使用回调方法onCreateLoader()来创建一个新的加载器。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/app/LoaderManager.LoaderCallbacks.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">3</span>.Loader	</div><div class="line">一个执行异步数据加载的抽象类。它是加载器的基类。</div><div class="line">你可以使用典型的CursorLoader，但是你也可以实现你自己的子类。</div><div class="line">一旦加载器被激活，它们将监视它们的数据源并且在数据改变时发送新的结果。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/content/Loader.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/content/Loader.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">4</span>.AsyncTaskLoader	</div><div class="line">提供一个AsyncTask来执行异步加载工作的抽象类。</div><div class="line">可用来所有异步加载</div><div class="line">AsyncTaskLoader继承了Loader,</div><div class="line">除了拥有loader的功能，还有executePendingTask()， dispatchOnCancelled（），onLoadInBackground()等方法</div><div class="line">最神奇的是他拥有AsyncTask的实例，并且实现Runnable,这是他能进行异步的原因所在。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/content/AsyncTaskLoader.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/content/AsyncTaskLoader.html</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="number">5</span>.CursorLoader	</div><div class="line">AsyncTaskLoader的子类，主要负责数据库查询的异步加载</div><div class="line">它查询ContentResolver然后返回一个Cursor。</div><div class="line">这个类为查询cursor以标准的方式实现了加载器的协议，</div><div class="line">它的游标查询是通过AsyncTaskLoader在后台线程中执行，从而不会阻塞界面。</div><div class="line">使用这个加载器是从一个ContentProvider异步加载数据的最好方式。</div><div class="line">相比之下，通过fragment或activity的API来执行一个被管理的查询就不行了。</div><div class="line"></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/content/CursorLoader.html</span></div><div class="line">http:<span class="comment">//www.android-doc.com/reference/android/support/v4/content/CursorLoader.html</span></div></pre></td></tr></table></figure></p>
<p>上面所列的类和接口们是你在你的应用中要实现加载器时的核心组件。<br>你的每个加载器并不一定需要所有的组件，但是你总是需要引用LoaderManager来初始化一个加载器。</p>
<h2 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h2><p>底层原理：<br>当然自身轮询和通信是离不开Handler的<br>因为整个android的通讯就是建立在Handler（底层binder）基础上</p>
<p>相关文章：<br><a href="http://blog.csdn.net/yanbober/article/details/48861457" target="_blank" rel="external">Android应用Loaders全面详解及源码浅析</a></p>
<hr>
<h1 id="IntentService-异步意图服务"><a href="#IntentService-异步意图服务" class="headerlink" title="IntentService 异步意图服务"></a>IntentService 异步意图服务</h1><hr>
<h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>所属包：android.app<br>在线API：<a href="http://www.android-doc.com/reference/android/app/IntentService.html" target="_blank" rel="external">http://www.android-doc.com/reference/android/app/IntentService.html</a></p>
<p>一句话描述：<br>一个可以干完活后自己去死且不需要我们去管理子线程的Service。</p>
<p>Public Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span></div><div class="line"><span class="keyword">void</span>    <span class="title">onCreate</span><span class="params">()</span></div><div class="line"><span class="keyword">void</span>    <span class="title">onDestroy</span><span class="params">()</span></div><div class="line"><span class="keyword">void</span>    <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span></div><div class="line"><span class="keyword">int</span>     <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></div><div class="line"><span class="keyword">void</span>    <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></div></pre></td></tr></table></figure></p>
<p>Protected Methods：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span>	<span class="title">onHandleIntent</span><span class="params">(Intent intent)</span></span></div></pre></td></tr></table></figure></p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>框架包装好的服务<br>一个方便我们处理业务流程的类，它是一个Service，但是比Service更智能。</p>
<p>普通的service, 默认运行在主线程<br>Sdk给我们提供的方便的,带有异步处理的Service类,<br>OnHandleIntent() 处理耗时的操作，内部开了子线程</p>
<p>几个常用生命周期方法（开启完就自动销毁了）<br>onCreate<br>onHandleIntent<br>onDestroy</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>IntentService是继承于Service并处理异步请求的一个类<br>有一个工作线程来处理耗时操作<br>启动IntentService的方式和启动传统Service一样<br>同时，当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。<br>可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。</p>
<p>生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。<br>在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。</p>
<p>该服务提供了一个onBind()方法的默认实现，它返回null</p>
<p>提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>我们省去了在Service中手动开线程的麻烦<br>当操作完成时，我们不用手动停止Service。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>IntentService不能并行处理多个job，只能依次处理，一个接一个</p>
<h2 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h2><p>1.非阻塞式的聊天软件，后台有耗时操作，取消息的时候可能会用到它</p>
<p>2.用于天气预报的应用，获取天气信息<br>开一个服务，在服务的方法onHandleIntent获取天气<br>服务获取完天气就自动onDestroy，销毁掉</p>
<h2 id="Service与IntentService耗时操作的区别"><a href="#Service与IntentService耗时操作的区别" class="headerlink" title="Service与IntentService耗时操作的区别"></a>Service与IntentService耗时操作的区别</h2><p>Service中如果有耗时的操作，要开启一个Thread来做。<br>IntentService是在独立的线程中，所以可以进行一些耗时操作。</p>
<h2 id="AsyncTask与Service的使用区别"><a href="#AsyncTask与Service的使用区别" class="headerlink" title="AsyncTask与Service的使用区别"></a>AsyncTask与Service的使用区别</h2><p>如果是全后台的工作，使用Service，结果的提示可以使用Notification。<br>如果是异步工作，工作结束后需要更新UI，那么最好使用Thread或者AsyncTask。</p>
<h2 id="IntentService中显示Toast"><a href="#IntentService中显示Toast" class="headerlink" title="IntentService中显示Toast"></a>IntentService中显示Toast</h2><p><a href="https://zhidao.baidu.com/question/617440918557008172.html" target="_blank" rel="external">Service和IntentService中显示Toast的区别</a></p>
<h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestService</span><span class="params">()</span></span>&#123; <span class="comment">// 必须要有空参数构造函数，不然运行时异常</span></div><div class="line">        <span class="keyword">super</span>(<span class="string">"haha"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onBind"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onBind(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"oncreate"</span>);</div><div class="line">        System.out.println(<span class="string">"服务线程name:"</span>+Thread.currentThread().getName());</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onStart"</span>);</div><div class="line">        <span class="keyword">super</span>.onStart(intent, startId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onStartCommand"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"setIntentRedelivery"</span>);</div><div class="line">        <span class="keyword">super</span>.setIntentRedelivery(enabled);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123; <span class="comment">// Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务</span></div><div class="line">        System.out.println(<span class="string">"onHandleIntent"</span>);</div><div class="line">        System.out.println(<span class="string">"服务线程onHandleIntent name:"</span>+Thread.currentThread().getName());</div><div class="line"></div><div class="line">        String action = intent.getExtras().getString(<span class="string">"param"</span>);</div><div class="line">        <span class="keyword">if</span> (action.equals(<span class="string">"oper1"</span>)) &#123;</div><div class="line">            System.out.println(<span class="string">"Operation1"</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">"oper2"</span>)) &#123;</div><div class="line">            System.out.println(<span class="string">"Operation2"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 面试题：</span></div><div class="line">        <span class="comment">// 如天气app，onHandleIntent里放网络请求去查是否最新气象信息，</span></div><div class="line">        <span class="comment">// 但是onHandleIntent执行完就要onDestroy，但是请求的是异步任务，服务都销毁了如何回调呢？</span></div><div class="line">        <span class="comment">// 解决方案：睡眠定时，时间可比网络请求的超时时间长一些，然后回调函数通知页面刷新</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"-----"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onDestroy"</span>);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，别忘了配置Service，因为它继承于Service，所以，它还是一个Service，一定要配置，否则是不起作用的，开始我就是忘了，结果半天没反应。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;service android:name=".IntentServiceDemo"&gt;</div><div class="line">      &lt;intent-filter &gt;</div><div class="line">          &lt;action android:name="com.test.intentservice"/&gt;</div><div class="line">      &lt;/intent-filter&gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure></p>
<h2 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h2><p><a href="http://www.jb51.net/article/76490.htm" target="_blank" rel="external">IntentService工作原理及源码解析</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IntentService可以在工作线程中完成工作而不阻塞主线程，<br>但是IntentService不能并行处理多个job，只能依次处理，一个接一个，<br>当所有的job完成后，会自动执行onDestroy方法而无需我们自己调用stopSelf()或stopSelf(startId)方法。<br>IntentService并不神秘，只是Android对一种常见开发方式的封装，便于开发人员减少开发工作量。<br>IntentService是个助手类，如果Android没有提供该类也没什么，我们自己也可以写一个类似的。<br>IntentService之余Service，类似于HandlerThread之于Handler。</p>
<h2 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.tuicool.com/articles/zeMFFvB" target="_blank" rel="external">Android中IntentService详解</a></p>
<hr>
<h1 id="接口回调机制"><a href="#接口回调机制" class="headerlink" title="接口回调机制"></a>接口回调机制</h1><hr>
<h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>监听器接口的回调函数（CallBack）</p>
<p>回调就是一件事件产生后给我们返回来的通知<br>回调就是我不想干，让别人去干这件事，就定义接口<br>方法带on….都是回调</p>
<p>如果写业务逻辑的时候，如果不关心它内部的是如何实现的，留下一个模板，就写一个接口，方法定义成抽象，然后把参数暴露出去<br>这种写法就叫回调函数（CallBack）</p>
<p>抽取接口定义回调函数（重要）<br>通过接口定义回调函数<br>回调函数就是不是我们的代码实现，而是由别的代码去实现。</p>
<p>对数据的异步处理的几个方法,他们都是通知机制<br>Handler机制<br>AsyncTask<br>IntentService<br>接口回调</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>1.单纯的通知<br>2.通知+传值</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.定义接口,以及接口方法<br>2.定义接口对象<br>3.在某一个地方.接口对象调用接口方法<br>4.暴露接口对象(构造方法,setter方法)</p>
<h2 id="接口回调实例"><a href="#接口回调实例" class="headerlink" title="接口回调实例"></a>接口回调实例</h2><h3 id="备份短信的进度条"><a href="#备份短信的进度条" class="headerlink" title="备份短信的进度条"></a>备份短信的进度条</h3><p>1.暴露接口<br>所谓接口无非就是一方在使用接口一方实现接口<br>这里以手机短信备份来讲<br>怎么在备份的工具类中得到短信的总条数和已经备份过的条数来供自己的程序使用呢(如设置<code>progressBar</code>显示备份进度等)    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsUtils</span> </span>&#123;</div><div class="line">    <span class="comment">// 在自己的程序中定义一个接口，并提供相应方法</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackUpStatusListener</span></span>&#123; <span class="comment">//在类中定义一个接口</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 在备份短信之前 max 总的进度</div><div class="line">        * <span class="doctag">@param</span> max</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">beforeBackup</span><span class="params">(<span class="keyword">int</span> max)</span></span>; </div><div class="line">        <span class="comment">/**</span></div><div class="line">        * 正在备份的进度.</div><div class="line">        * <span class="doctag">@param</span> process</div><div class="line">        */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onBackUpProcess</span><span class="params">(<span class="keyword">int</span> process)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 备份短信的工具方法</div><div class="line">     * <span class="doctag">@param</span> context 上下文</div><div class="line">     * <span class="doctag">@param</span> fos 备份到哪个文件输出流里面.</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backUp</span><span class="params">(Context context,FileOutputStream fos,BackUpStatusListener listener)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//在自己的方法中使用接口</span></div><div class="line">        ContentResolver resolver = context.getContentResolver();</div><div class="line">        Uri uri = Uri.parse(<span class="string">"content://sms/"</span>);</div><div class="line">        XmlSerializer serializer = Xml.newSerializer();</div><div class="line">        serializer.setOutput(fos, <span class="string">"utf-8"</span>);</div><div class="line">        serializer.startDocument(<span class="string">"utf-8"</span>, <span class="keyword">true</span>);</div><div class="line">        serializer.startTag(<span class="keyword">null</span>, <span class="string">"smss"</span>);</div><div class="line">        Cursor cursor = resolver.query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">"address"</span>,<span class="string">"date"</span>,<span class="string">"type"</span>,<span class="string">"body"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// pd.setMax(cursor.getCount());//设置初始化的总长度</span></div><div class="line">        listener.beforeBackup(cursor.getCount()); <span class="comment">// 调用接口中的方法，将短信的总条数传给接口的参数</span></div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(cursor.moveToNext())&#123;</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"sms"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"address"</span>);</div><div class="line">            String address = cursor.getString(<span class="number">0</span>);</div><div class="line">            serializer.text(address);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"address"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"date"</span>);</div><div class="line">            String date = cursor.getString(<span class="number">1</span>);</div><div class="line">            serializer.text(date);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"date"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"type"</span>);</div><div class="line">            String type = cursor.getString(<span class="number">2</span>);</div><div class="line">            serializer.text(type);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"type"</span>);</div><div class="line">            serializer.startTag(<span class="keyword">null</span>, <span class="string">"body"</span>);</div><div class="line">            String body = cursor.getString(<span class="number">3</span>);</div><div class="line">            serializer.text(body);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"body"</span>);</div><div class="line">            serializer.endTag(<span class="keyword">null</span>, <span class="string">"sms"</span>);</div><div class="line">            fos.flush();</div><div class="line">            total++;</div><div class="line">            <span class="comment">//pd.setProgress(total);</span></div><div class="line">            listener.onBackUpProcess(total);</div><div class="line">            <span class="comment">// 调用接口中的方法将已经备份了的短信数传递给相应方法的参数</span></div><div class="line">            <span class="comment">// 由于这个接口的实现类是由调用者实现的，这里是多态，真正执行的接口的方法是调用者实现的方法</span></div><div class="line">            <span class="comment">// 这里讲短信的数量传递给方法的参数，所以调用者就能再实现类的方法中通过参数得到短信数</span></div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125;</div><div class="line">        serializer.endTag(<span class="keyword">null</span>, <span class="string">"smss"</span>);</div><div class="line">        serializer.endDocument();</div><div class="line">        fos.flush();</div><div class="line">        fos.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.实现接口并实现相应的方法，直接就通过回调方法中的参数得到相应的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">SmsUtils.backUp(getApplicationContext(), fos, <span class="keyword">new</span> BackUpStatusListener() &#123;</div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackUpProgress</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;</div><div class="line">        pd.setProgress(process);<span class="comment">//通过方法中的参数我们就能得到数据</span></div><div class="line">    &#125;</div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeBackUp</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</div><div class="line">        pd.setMax(max);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义控件的点击事件"><a href="#自定义控件的点击事件" class="headerlink" title="自定义控件的点击事件"></a>自定义控件的点击事件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public interface OnYouKuItemClickedListener&#123;</div><div class="line">    public void onItemClicked(int viewid);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class MenuView&#123;</div><div class="line">    // 声明接口传递进来的实现类</div><div class="line">    private OnYouKuItemClickedListener mOnYouKuItemClickedListener;</div><div class="line"></div><div class="line">    // 暴露一个方法设置接口实现类</div><div class="line">    public void setOnYouKuItenClickedListener(OnYouKuItemClickedListener mOnYouKuItemClickedListener)&#123;</div><div class="line">        this.mOnYouKuItemClickedListener = mOnYouKuItenClickedListener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void OnClick(View v)&#123;</div><div class="line">        if(mOnYouKuItemClickedListener != null)&#123; // 做判断，如果没初始化会空指针</div><div class="line">            mOnYouKuItemClickedListener.onItemClicked(v.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">public class MainActivity extends Activity&#123;</div><div class="line">    private MenuView mMenuView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protexted void onCreate(Bundle savedInstanceState)&#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.ativity_main);</div><div class="line">        mMenuView = (Menu)findVieById(R.id.menuview);</div><div class="line">        mMenuView.setOnYouKuItemClickedListener(new OnYoukuItemClickedListener())&#123;</div><div class="line">            @Override</div><div class="line">            public void onItemClicked(int viewid)&#123;</div><div class="line">                switch(viewid)&#123;</div><div class="line">                    case R.id.iv_channel1:</div><div class="line">                        Toast.makeText(getApplicationContext(),"频道1被点击了”，0).show();</div><div class="line">                        break;</div><div class="line">                    case R.id.iv_channel2:</div><div class="line">                        Toast.makeText(getApplicationContext(),"频道2被点击了”，0).show();</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="用接口实现广播通知"><a href="#用接口实现广播通知" class="headerlink" title="用接口实现广播通知"></a>用接口实现广播通知</h3><p><a href="http://download.csdn.net/download/csm_qz/8797507" target="_blank" rel="external">用接口实现广播通知</a></p>
<h1 id="总结：各种界面不同的刷新UI方式和其它通知方式"><a href="#总结：各种界面不同的刷新UI方式和其它通知方式" class="headerlink" title="总结：各种界面不同的刷新UI方式和其它通知方式"></a>总结：各种界面不同的刷新UI方式和其它通知方式</h1><p>子线程不能直接更新UI, 要更新UI有2种方式<br>1.消息机制(Handler)<br>　HandlerThread<br>　AsyncTask<br>　IntentService<br>2: Activity的runOnUiThread方法 (更简单) </p>
<p>接口回调函数<br>广播通知<br>SharedPreferences的OnSharedPreferenceChangeListener</p>
<p>View：<br>　1.invalidate<br>　　主线程（UI线程）<br>　　旗下子类都继承此方法<br>　　如：<br>　　TextView<br>　　ViewDragHelper<br>　2.postInvalidate<br>　　子线程（非UI线程）</p>
<p>BaseAdapter：<br>　notifyDataSetChanged</p>
<p>PagerSlidingTabStrip：<br>　notifyDataSetChanged<br>　updateTabStyles</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持收集实用资料和原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/upload/wechatpay20170716225849.jpg" alt="恒星 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/upload/alipay_20170716225901.jpg" alt="恒星 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/05/it/1.Android/Touch/" rel="next" title="Android —— Touch事件分发传递机制的总结">
                <i class="fa fa-chevron-left"></i> Android —— Touch事件分发传递机制的总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="恒星" />
          <p class="site-author-name" itemprop="name">恒星</p>
           
              <p class="site-description motion-element" itemprop="description">披星戴月,日月为鉴! 蛰伏蛰伏,厚积方能薄发!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">93</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hengxing0080" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:skystar0079@gmail.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                  Email
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://raw.githubusercontent.com/hengxing0080/hengxing0080.github.io/master/images/WeChat.jpg" target="_blank" title="WeChat">
                  
                    <i class="fa fa-fw fa-wechat"></i>
                  
                  WeChat
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="tencent://message/?uin=348269714&Site=&Menu=yes" target="_blank" title="QQ">
                  
                    <i class="fa fa-fw fa-qq"></i>
                  
                  QQ
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://heneryyang.github.io/" title="老杨博客" target="_blank">老杨博客</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Handler消息处理模型"><span class="nav-number">1.</span> <span class="nav-text">Handler消息处理模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息模型图示"><span class="nav-number">1.3.</span> <span class="nav-text">消息模型图示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息模型组成"><span class="nav-number">1.4.</span> <span class="nav-text">消息模型组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息模型目地"><span class="nav-number">1.5.</span> <span class="nav-text">消息模型目地</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子线程更新UI的几种方式"><span class="nav-number">1.6.</span> <span class="nav-text">子线程更新UI的几种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义子线程更新UI"><span class="nav-number">1.7.</span> <span class="nav-text">自定义子线程更新UI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Handle的sendMessage修改UI界面"><span class="nav-number">1.7.1.</span> <span class="nav-text">使用Handle的sendMessage修改UI界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Handler的post-方法修改UI界面"><span class="nav-number">1.7.2.</span> <span class="nav-text">使用Handler的post()方法修改UI界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Activity-runOnUiThread方法修改UI界面"><span class="nav-number">1.7.3.</span> <span class="nav-text">使用Activity.runOnUiThread方法修改UI界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用View-post方法修改UI界面"><span class="nav-number">1.7.4.</span> <span class="nav-text">使用View.post方法修改UI界面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler对象传递的几种方式"><span class="nav-number">1.8.</span> <span class="nav-text">Handler对象传递的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建一个HandlerManager管理工具类"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.创建一个HandlerManager管理工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Application全局共享和利用广播机制"><span class="nav-number">1.8.2.</span> <span class="nav-text">2.Application全局共享和利用广播机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler用法注意"><span class="nav-number">1.9.</span> <span class="nav-text">Handler用法注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler其他面试题"><span class="nav-number">1.10.</span> <span class="nav-text">Handler其他面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler其他使用场景"><span class="nav-number">1.11.</span> <span class="nav-text">Handler其他使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler内存泄露"><span class="nav-number">1.12.</span> <span class="nav-text">Handler内存泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler源码分析"><span class="nav-number">1.13.</span> <span class="nav-text">Handler源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Message"><span class="nav-number">1.14.</span> <span class="nav-text">关于Message</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取Message的三种方式"><span class="nav-number">1.14.1.</span> <span class="nav-text">获取Message的三种方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Looper"><span class="nav-number">1.15.</span> <span class="nav-text">关于Looper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Looper的开启和关闭"><span class="nav-number">1.15.1.</span> <span class="nav-text">Looper的开启和关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个线程中，能有几个Looper和Handler"><span class="nav-number">1.15.2.</span> <span class="nav-text">一个线程中，能有几个Looper和Handler?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loop能不能在子线程中定义"><span class="nav-number">1.15.3.</span> <span class="nav-text">Loop能不能在子线程中定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在非主线程中创建Handler对象，需要手动New-Looper吗？"><span class="nav-number">1.15.4.</span> <span class="nav-text">在非主线程中创建Handler对象，需要手动New Looper吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HandlerThread消息处理器线程"><span class="nav-number">2.</span> <span class="nav-text">HandlerThread消息处理器线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介-1"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例代码"><span class="nav-number">2.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">2.3.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关文章"><span class="nav-number">2.4.</span> <span class="nav-text">相关文章</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AsyncQueryHandler异步查询框架"><span class="nav-number">3.</span> <span class="nav-text">AsyncQueryHandler异步查询框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AsyncTask异步任务"><span class="nav-number">4.</span> <span class="nav-text">AsyncTask异步任务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncTask简介"><span class="nav-number">4.1.</span> <span class="nav-text">AsyncTask简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">4.2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板"><span class="nav-number">4.3.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同版本出现的各种问题"><span class="nav-number">4.4.</span> <span class="nav-text">不同版本出现的各种问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露"><span class="nav-number">4.4.1.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期"><span class="nav-number">4.4.2.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不好好工作的cancel"><span class="nav-number">4.4.3.</span> <span class="nav-text">不好好工作的cancel()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果丢失"><span class="nav-number">4.4.4.</span> <span class="nav-text">结果丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行还是并行"><span class="nav-number">4.4.5.</span> <span class="nav-text">串行还是并行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析-1"><span class="nav-number">4.5.</span> <span class="nav-text">源码分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Loader加载器机制"><span class="nav-number">5.</span> <span class="nav-text">Loader加载器机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介-2"><span class="nav-number">5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关API"><span class="nav-number">5.2.</span> <span class="nav-text">相关API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析-2"><span class="nav-number">5.3.</span> <span class="nav-text">源码分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IntentService-异步意图服务"><span class="nav-number">6.</span> <span class="nav-text">IntentService 异步意图服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介-3"><span class="nav-number">6.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">6.2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特点"><span class="nav-number">6.3.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用"><span class="nav-number">6.4.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#好处"><span class="nav-number">6.5.</span> <span class="nav-text">好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缺点"><span class="nav-number">6.6.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用情景"><span class="nav-number">6.7.</span> <span class="nav-text">使用情景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service与IntentService耗时操作的区别"><span class="nav-number">6.8.</span> <span class="nav-text">Service与IntentService耗时操作的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncTask与Service的使用区别"><span class="nav-number">6.9.</span> <span class="nav-text">AsyncTask与Service的使用区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IntentService中显示Toast"><span class="nav-number">6.10.</span> <span class="nav-text">IntentService中显示Toast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板代码"><span class="nav-number">6.11.</span> <span class="nav-text">模板代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析-3"><span class="nav-number">6.12.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.13.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关文章-1"><span class="nav-number">6.14.</span> <span class="nav-text">相关文章</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口回调机制"><span class="nav-number">7.</span> <span class="nav-text">接口回调机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-3"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用-1"><span class="nav-number">7.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#步骤"><span class="nav-number">7.3.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口回调实例"><span class="nav-number">7.4.</span> <span class="nav-text">接口回调实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#备份短信的进度条"><span class="nav-number">7.4.1.</span> <span class="nav-text">备份短信的进度条</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义控件的点击事件"><span class="nav-number">7.4.2.</span> <span class="nav-text">自定义控件的点击事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用接口实现广播通知"><span class="nav-number">7.4.3.</span> <span class="nav-text">用接口实现广播通知</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结：各种界面不同的刷新UI方式和其它通知方式"><span class="nav-number">8.</span> <span class="nav-text">总结：各种界面不同的刷新UI方式和其它通知方式</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恒星</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
